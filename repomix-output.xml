This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
.cursor/
  rules/
    api-standards.mdc
    backend.mdc
    components.mdc
    database.mdc
    frontend.mdc
    general.mdc
    performance.mdc
    security.mdc
    styling.mdc
.github/
  workflows/
    backup-supabase.yml
    claude.yml
    export-feature-to-md.yml
    test.yml
app/
  [slug]/
    [flow]/
      edit/
        components/
          blocks/
            BasicBlock.tsx
            BeginBlock.tsx
            CustomBlock.module.css
            CustomBlock.tsx
            EndBlock.tsx
            EventDelayBlock.tsx
            FixedDelayBlock.tsx
            InvisibleBlock.tsx
            LastBlock.tsx
            MergeBlock.tsx
            PathBlock.tsx
          edges/
            BasicEdge.tsx
            CustomSmoothStepEdge.tsx
            SmoothStepCustomParent.tsx
            StrokeEdge.module.css
            StrokeEdge.tsx
          modals/
            ConnectNodeModal.tsx
            CreateParallelPathModal.tsx
            DelayTypeModal.tsx
            DeleteBlocksModal.tsx
            DeletePathModal.tsx
            DeleteStrokeEdgeModal.tsx
            EditLinksModal.tsx
            EventDelayModal.tsx
            FixedDelayModal.tsx
            UpdatePathModal.tsx
          AddBlockDropdownMenu.tsx
          BlockDetailsSidebar.tsx
          BlockMediaVisualizer.tsx
          DocumentationModal.tsx
          Flow.tsx
          IconModifier.tsx
          IconSelector.tsx
          ImageEditor.tsx
          MediaUploader.tsx
          PathContainer.tsx
          PathSelectionBox.tsx
          PreviewEdgePortal.tsx
          ReactFlowPageClient.tsx
          ScreenSizeOverlay.tsx
          SettingsModal.tsx
          Sidebar.tsx
          TextEditor.tsx
          UpdatePathSelectionBox.tsx
          WorkflowHeader.tsx
          ZoomBar.tsx
          ZoomBarDropdownMenu.tsx
        store/
          clipboardStore.ts
          connectModeStore.ts
          editModeStore.ts
          loadingStore.ts
          modalStore.ts
          pathSelectionStore.ts
          pathsStore.ts
          strokeLinesStore.ts
          updateModeStore.ts
        test/
          page.tsx
        utils/
          collectAllPathIds.ts
          createChildPaths.ts
          createParallelPaths.ts
          debounce.ts
          elkLayout.ts
          getBlocksAfterPosition.ts
          getChildPaths.ts
          getChildPathsIds.ts
          mergePaths.ts
          processPath.ts
          stroke-lines.ts
          toggleEndpoint.ts
        page.tsx
        styles.css
      read/
        components/
          steps/
            BaseStep.ts
            HorizontalDelay.tsx
            HorizontalLastStep.tsx
            HorizontalStep.tsx
            VerticalDelay.tsx
            VerticalLastStep.tsx
            VerticalStep.tsx
          BreadCrumbs.tsx
          FeedbackSlideout.tsx
          Header.tsx
          ProcessCanvas.tsx
          ProcessCard.tsx
          ReadPageClient.tsx
          Sidebar.tsx
          StepsContainer.tsx
          ViewModeSwitch.tsx
        store/
          pathsStore.ts
        utils/
          timeUtils.ts
        page.tsx
      utils/
        createLinks.ts
        pathUtils.ts
      types.ts
    page.tsx
  api/
    auth/
      check-onboarding/
        route.ts
      clear-reset-cookies/
        route.ts
      confirm/
        route.ts
      perform-password-reset/
        route.ts
      reset-password/
        route.ts
    auth-status/
      route.ts
    batch-signed-urls/
      route.ts
    billing-info/
      route.ts
    blocks/
      [id]/
        duplicate/
          route.ts
        image/
          route.ts
        toggle-endpoint/
          route.ts
        route.ts
      delete-multiple/
        route.ts
      move/
        route.ts
      route.ts
    check-email/
      route.ts
    clear-password-reset-cookie/
      route.ts
    cron/
      send-scheduled-emails/
        route.ts
    deleteUser/
      route.ts
    docs/
      route.ts
    email/
      send-subscription-email/
        route.ts
      subscription-activated/
        route.ts
      route.ts
    get-signed-url/
      route.ts
    get-subscription/
      route.ts
    hello/
      route.ts
    invoices/
      route.ts
    join/
      route.ts
    logo-search/
      route.ts
    onboarding/
      create-default-workflow/
        route.ts
      email/
        route.ts
      force-complete/
        route.ts
    paths/
      [id]/
        route.ts
      connect/
        route.ts
      merge/
        [id]/
          route.ts
        route.ts
      minimal/
        route.ts
      route.ts
    step-icons/
      route.ts
    stripe/
      customer-portal/
        route.ts
      webhook.ts
    stroke-lines/
      route.ts
    subscription/
      cancel/
        route.ts
      update/
        route.ts
      route.ts
    test/
      cleanup-user/
        route.ts
      cleanup-workspace/
        route.ts
      get-user-by-email/
        route.ts
      get-workspace-by-name/
        route.ts
      seed-user/
        route.ts
      seed-workspace/
        route.ts
      send-feature-update/
        route.ts
      send-feature-update-test/
        route.ts
    upload/
      avatar/
        route.ts
      workspace-brand-logo/
        route.ts
      workspace-brand-name/
        route.ts
      workspace-logo/
        route.ts
      route.ts
    upload-icon/
      route.ts
    user/
      onboarding-complete/
        route.ts
      switch-workspace/
        route.ts
      tutorial-status/
        [userId]/
          route.ts
      update/
        route.ts
      generate-token.ts
      route.ts
    user_workspace/
      [user_id]/
        route.ts
      route.ts
    utils/
      blocks/
        addOne.ts
        deleteOne.ts
        editOne.ts
      paths/
        addOne.ts
        deleteMany.ts
        deleteOne.ts
        editOne.ts
        Pathutils.ts
      workflows/
        addOne.ts
        deleteOne.ts
        editOne.ts
      workspaces/
        addOne.ts
        deleteOne.ts
        editOne.ts
      create-default-workflow.ts
      deleteFile.ts
      formatTitle.ts
      generatePublicUrl.ts
      generateUserUrl.ts
      generateWorkspaceURL.ts
      isVercel.ts
    webhooks/
      stripe/
        route.ts
    workflow/
      [workflow_id]/
        title/
          route.ts
        route.ts
      public/
        route.ts
      updateLastOpened/
        route.ts
      route.ts
      utils.ts
    workspace/
      [id]/
        access/
          route.ts
        blocks/
          route.ts
        invite/
          route.ts
        paths/
          [path_id]/
            route.ts
          route.ts
        workflows/
          [workflowId]/
            route.ts
          route.ts
        route.ts
      check-slug/
        route.ts
      create/
        route.ts
      folders/
        [id]/
          route.ts
        update-position/
          route.ts
        route.ts
      subfolders/
        route.ts
      workflows/
        route.ts
  auth/
    callback/
      route.ts
    confirm/
      route.ts
  checkout/
    cancel/
      page.tsx
    success/
      layout.tsx
      page.tsx
  components/
    AuthCheck.tsx
    Avatar.tsx
    AvatarGroup.tsx
    BreadcrumbButtonBase.tsx
    Breadcrumbs.tsx
    ButtonDestructive.tsx
    ButtonNormal.tsx
    CheckoutButton.tsx
    CustomTooltip.tsx
    DatePicker.tsx
    FastThemeToggle.tsx
    HubspotTracker.tsx
    IconUpload.tsx
    InputDropdown.tsx
    InputFields.tsx
    LoadingModal.tsx
    LoadingSpinner.tsx
    Modal.tsx
    OptimizedIcon.tsx
    SelectField.tsx
    ShareModal.tsx
    SkeletonCard.tsx
    SkeletonWorkflowCard.tsx
    Switch.tsx
    TabButton.tsx
    TextAreaInput.tsx
    ThemeMigrationTest.tsx
    ThemeToggle.tsx
    Toast.tsx
    ToastContainer.tsx
    Tooltip.tsx
  context/
    FastThemeContext.tsx
    ThemeContext.tsx
  dashboard/
    components/
      BillingInfoForm.tsx
      CanvaHeader.tsx
      Canvas.tsx
      ConfirmChangePasswordModal.tsx
      ConfirmDeleteFlowModal.tsx
      ConfirmDeleteFolderModal.tsx
      ConfirmDeleteModal.tsx
      CreateFlowModal.tsx
      CreateFolderModal.tsx
      CreateSubfolderModal.tsx
      CreateWorkspaceModal.tsx
      EditFlowModal.tsx
      EditFolderModal.tsx
      FolderDropdown.tsx
      folderUtils.ts
      HelpCenterModal.tsx
      IconModifier.tsx
      IconSelector.tsx
      MoveWorkflowModal.tsx
      SearchBar.tsx
      SettingsPage.tsx
      Sidebar.tsx
      SortableFolderItem.tsx
      SortableFolderList.tsx
      TabButton.tsx
      TutorialOverlay.tsx
      UploadImageModal.tsx
      UserDropdown.tsx
      UserInfo.tsx
      UserSettings.tsx
      WorkflowCard.tsx
      WorkspaceDropdownMenu.tsx
      WorkspaceSettings.tsx
    hooks/
      useFolderPositioning.ts
    styles/
      tutorial.module.css
  docs/
    page.jsx
  error/
    page.tsx
  hooks/
    useToast.ts
  join/
    page.tsx
  login/
    actions.ts
    page.tsx
  middlewares/
    workspaceProtection.ts
  not-found/
    page.tsx
  onboarding/
    components/
      CompletedStep.tsx
      MotionStep.tsx
      PersonalInfoStep.tsx
      ProfessionalInfoStep.tsx
      ProgressIndicator.tsx
      WorkspaceSetupStep.tsx
    context/
      OnboardingContext.tsx
    utils/
      inputSanitizer.ts
    layout.tsx
    page.tsx
  password-reset/
    page.tsx
  reset-email/
    page.tsx
  reset-password/
    page.tsx
  reset-password-request/
    page.tsx
  services/
    roadmapAuth.ts
  set-new-password/
    page.tsx
  shared/
    [flow]/
      embed/
        components/
          HorizontalDelay.tsx
          HorizontalLastStep.tsx
          HorizontalStep.tsx
          ProcessCard.tsx
        page.tsx
      page.tsx
  signup/
    page.tsx
  swagger-ui/
    page.jsx
  theme/
    themes/
      dark.ts
      light.ts
    colors.ts
    fast-hooks.ts
    hooks.ts
    index.ts
    registry.ts
    types.ts
    utils.ts
  types/
    block.ts
    cloudinary.d.ts
    toast-ui.d.ts
    workflow.ts
  unauthorized/
    page.tsx
  utils/
    assetUrls.ts
    checkNames.ts
    createWorkflow.ts
    deleteWorkflow.ts
    getBaseUrl.ts
    icons.ts
    isPreview.ts
    mail.ts
    modalPatterns.tsx
    roadmap.ts
    sanitize.ts
    tutorial.ts
    updateLastOpened.ts
    updateWorkflow.ts
  BodyClassProvider.tsx
  global-error.tsx
  globals-fixed.css
  globals-optimized.css
  globals-theme-fixed.css
  globals.css
  isModalOpenStore.ts
  layout.tsx
  not-found.tsx
  page.tsx
  PostHogPageView.tsx
  providers.tsx
  temp-globals.css
components/
  chat/
    AIChatMessage.tsx
    ChatContainer.tsx
    UserChatMessage.tsx
  ui/
    AIThinkingOrb.tsx
docs/
  test-cases/
    authentication.md
    dashboard.md
    editor.md
    login.md
    onboarding.md
    read-mode.md
e2e/
  features/
    authentication/
      authentication_email_confirmation.feature
      authentication_login.feature
      authentication_navigation.feature
      authentication_registration.feature
      authentication_security.feature
    dashboard/
      access_and_layout.feature
      error_handling_and_edge_cases.feature
      folder_management.feature
      help_and_tutorial.feature
      search_and_filtering.feature
      settings_and_configuration.feature
      user_profile_management.feature
      workflow_management.feature
    editor/
      access_and_layout.feature
      block_actions_and_context_menu.feature
      block_creation_and_management.feature
      block_editing_and_properties.feature
      canvas_interaction_and_navigation.feature
      documentation_and_help.feature
      error_handling_and_validation.feature
      path_management_and_conditions.feature
      sidebar_navigation_and_block_management.feature
      stroke_lines_and_connections.feature
      zoom_and_view_controls.feature
    login/
      user_login.feature
    onboarding/
      completion_step_and_workspace_creation.feature
      error_handling_and_edge_cases.feature
      navigation_and_state_management.feature
      personal_information_step.feature
      professional_information_step.feature
      user_onboarding_flow.feature
      workspace_setup_step.feature
    read-mode/
      access_and_layout.feature
      conditional_path_handling.feature
      content_display_and_media.feature
      delay_block_handling.feature
      error_handling_and_edge_cases.feature
      header_controls_and_navigation.feature
      process_completion_and_restart.feature
      sharing_and_access_control.feature
      sidebar_navigation_and_step_management.feature
      step_navigation_and_progression.feature
      view_mode_management.feature
  raw/
    authentication.feature
    dashboard.feature
    editor.feature
    login.feature
    onboarding.feature
    read-mode.feature
  step-definitions/
    authentication.steps.ts
    dashboard.steps.ts
    editor.steps.ts
    login.steps.ts
    onboarding.steps.ts
    read-mode.steps.ts
    utils.steps.ts
emails/
  components/
    signatures/
      CustomerServiceSignature.tsx
      JeanSignature.tsx
      NoReplySignature.tsx
    Button.tsx
    CustomFont.tsx
    EmailSignature.tsx
    Heading.tsx
    Text.tsx
  templates/
    CancellationFollowUpEmail.tsx
    FeedbackRequestEmail.tsx
    FollowUpEmail.tsx
    ProcessLimitEmail.tsx
    ShareRoadmap.tsx
    SubscriptionActivatedEmail.tsx
    WelcomeEmail.tsx
hooks/
  useSupabaseSession.ts
  useWorkspace.ts
lib/
  emails/
    scheduleCancellationFollowUpEmail.ts
    scheduleFeedbackRequestEmail.ts
    scheduleProcessLimitEmail.ts
    sendFeedbackRequestEmail.ts
  utils/
    cn.ts
  auth.ts
  authMiddleware.ts
  email.ts
  env-check.ts
  prisma.ts
  rateLimit.ts
  roadmapAuth.ts
  scheduledEmails.ts
  stripe.ts
  supabaseClient.ts
  supabasePublicClient.ts
  supabaseServerClient.ts
  swagger.ts
  utils.ts
prisma/
  dbml/
    schema.dbml
    schema.documentation.dbml
  migrations/
    20250308185509_initial_schema/
      migration.sql
    20250309084538_add_block_type_merge/
      migration.sql
    20250309090235_update_subscription_schema/
      migration.sql
    20250316060737_add_scheduled_emails/
      migration.sql
    20250316145246_add_unique_constraint_to_scheduled_emails/
      migration.sql
    20250318105808_add_position_to_folders/
      migration.sql
    20250318133431_add_constraint/
      migration.sql
    20250327081317_workflow_icon_and_author/
      migration.sql
    20250327170230_add_control_points_to_stroke_lines/
      migration.sql
    20250401060358_add_ai_support/
      migration.sql
    20250403173342_workflow/
      migration.sql
    20250406153757_block_original_image/
      migration.sql
    20250427124804_cascade_delete_user_workspace/
      migration.sql
    20250427125006_ondelete_cascade_workflow_fields/
      migration.sql
    20250427125203_removed_slug_unique_constraint/
      migration.sql
    20250427130205_rollback_slug_unique_constraint/
      migration.sql
    20250427130943_fixed_workspace_cascade_fields/
      migration.sql
    20250507063023_removed_unused_tables/
      migration.sql
    20250507071740_removed_unused_tables/
      migration.sql
    20250510081938_add_row_isendpoint_for_block_table/
      migration.sql
    20250527092212_modify_workflow_table/
      migration.sql
    20250527101122_modify_workflow_table/
      migration.sql
    20250611092229_add_workspace_invitation/
      migration.sql
    20250613111511_unique_userid_workspace_constraint/
      migration.sql
    20250618070313_brand_urls/
      migration.sql
    20250621164914_brand_urls/
      migration.sql
    migration_lock.toml
  schema.prisma
public/
  assets/
    icons/
      check-circle.svg
      dots-horizontal.svg
      process-step-icon.svg
      x-close.svg
    x-close.svg
  ai-thinking-orb.svg
  next.svg
  vercel.svg
supabase/
  functions/
    hello-world/
      .npmrc
      deno.json
      index.ts
    onboarding_filter/
      index.ts
    deno.json
    tsconfig.json
  migrations/
    20240320000000_add_users_rls.sql
  .gitignore
  config.toml
test-results/
  .last-run.json
tests/
  api/
    hello.test.ts
  e2e/
    signup-navigation.spec.ts
  utils/
    requestWithBypass.ts
  checkNames.test.ts
  sanitize.test.ts
types/
  action.ts
  block.ts
  canvasevent.ts
  path.ts
  role.ts
  sidebar.ts
  sidebarevent.ts
  team.ts
  todo.ts
  transformstate.ts
  user.ts
  userTeam.ts
  workflow.ts
  workspace.ts
utils/
  supabase/
    admin.ts
    client.ts
    fetch_url.ts
    middleware.ts
    server.ts
  createSignedUrls.ts
  DynamicIcon.tsx
  iconCache.ts
  optimizedIconFetch.ts
.gitignore
.prettierrc
business-logic.md
CLAUDE.md
exportFeaturesToMarkdown.js
global.d.ts
instrumentation.ts
jest.config.js
jest.setup.js
jest.setup.ts
middleware.ts
next.config.mjs
package.json
playwright.config.ts
postcss.config.mjs
README.md
sentry.client.config.ts
sentry.edge.config.ts
sentry.server.config.ts
tailwind.config.ts
theme.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "enableAllProjectMcpServers": false
}
</file>

<file path=".cursor/rules/api-standards.mdc">
---
description: Call this rules when you work with API
globs: 
alwaysApply: false
---
---
description: API Development Standards and Best Practices
globs: **/api/**/*.ts
alwaysApply: false
---
# API Standards

- **Route Structure**:
  - Place API routes inside `/app/api/` directory
  - Use **resource-based URLs** (e.g., `/api/workspace/[id]/blocks`)
  - Implement **RESTful principles** for resource manipulation
  - Structure routes with **clear hierarchy** reflecting resource relationships

- **HTTP Methods**:
  - Use **GET** for retrieving resources
  - Use **POST** for creating resources or actions that change state
  - Use **PUT** for complete resource updates
  - Use **PATCH** for partial resource updates
  - Use **DELETE** for resource removal

- **Documentation**:
  - Document APIs with **JSDoc and Swagger annotations**
  - Include **descriptions, parameters, and response types**
  - Provide **example responses** in documentation
  - Document **error responses** and status codes

- **Request Handling**:
  - Validate all **input parameters** before processing
  - Use **appropriate parameter extraction** methods:
    - URL parameters: `props.params`
    - Query parameters: `searchParams.get('param')`
    - Body data: `await request.json()`
  - Set **proper content type headers**
  - Implement **dynamic routes** for resource-specific operations

- **Response Format**:
  - Use **`NextResponse.json()`** for JSON responses
  - Include **appropriate HTTP status codes**:
    - 200: Successful operation
    - 201: Resource created
    - 400: Bad request (client error)
    - 401/403: Authentication/authorization errors
    - 404: Resource not found
    - 409: Conflict with current state
    - 500: Server error
  - Return **consistent response objects** with clear properties

- **Error Handling**:
  - Wrap API logic in **try/catch blocks**
  - Log errors with **`console.error`** for debugging
  - Return **descriptive error messages** to clients
  - Handle **specific error types** (e.g., Prisma errors)
  - Don't expose **sensitive information** in error responses

- **Authentication & Authorization**:
  - **Validate authentication** in API routes or middleware
  - **Check permissions** before accessing or modifying resources
  - Return **appropriate 401/403 responses** for unauthorized requests
  - Use **middleware for common auth logic**

- **Performance**:
  - Use **`dynamic = 'force-dynamic'`** only when necessary
  - **Select only necessary fields** in database queries
  - Implement **proper caching strategies**
  - Consider **rate limiting** for public endpoints

- **Security**:
  - **Validate and sanitize** all input data
  - Protect against **injection attacks**
  - Set **appropriate CORS headers**
  - Don't include **sensitive data** in responses
</file>

<file path=".cursor/rules/backend.mdc">
---
description: 
globs: *.ts
alwaysApply: false
---
---
description: Backend Coding Standards
globs: **/*.ts
alwaysApply: false
---
# Backend Guidelines

- Always validate API inputs before processing requests
- Use async/await consistently; avoid callbacks
- Follow Next.js API conventions for clear endpoint structures
- Use Next.js API routes for server-side logic.
- Optimize database queries for performance and scalability
- Log errors properly but avoid excessive debugging logs in production
- Client-side fetching: Use **React Query (TanStack) or SWR**
- **Server-side fetching**:
    - Use **Server Actions** (preferred) or `getServerSideProps` if needed.
    - Place API routes inside `/app/api/` instead of `pages/api/`
- **Security**:
    - **Sanitize user input** before sending it to APIs.
    - **Escape values** before inserting into JSX:
- **Use `use client` only when necessary**.
- **Use Next.js Middleware (`middleware.ts`)** for request handling.
- **Use `useFormState`** instead of `useState` for form handling in Server Components.
</file>

<file path=".cursor/rules/components.mdc">
---
description: 
globs: **/*.tsx
alwaysApply: false
---
---
description: Component Development Standard
globs: **/*.tsx
alwaysApply: false
---
# Components Guidelines

- **Use TypeScript interfaces** for all component props
- **Document props with JSDoc comments** for better code completion and readability
- **Functional components only**: Use `React.FC<PropsInterface>` typing pattern
- **Default values**: Provide sensible defaults for optional props
- **Prop naming**: Use clear, descriptive names for component props
- **Component size**: Keep components focused on a single responsibility
- **Documentation**: Include a brief description of the component's purpose above the component declaration
- **Styling**: Use Tailwind CSS classes for styling; avoid inline styles except for dynamic values. Components should be theme-aware.
- **Theme integration**: Use the `useColors()` hook for accessing theme colors
- **Icons and images**: Support both string paths and React components for flexibility
- **Error handling**: Gracefully handle edge cases and provide fallbacks
- **Responsive design**: Ensure components work across device sizes
- **Accessibility**: Follow ARIA best practices for interactive components
- **Event handling**: Use properly typed event handlers (e.g., `React.MouseEvent`)
- **Performance**: Memoize expensive calculations or rendering with `useMemo` and `useCallback`
- **State management**: Keep state minimal and use appropriate hooks (`useState`, `useReducer`)
- **Reusability**: Design components to be reusable across different contexts
- **Testing**: Write unit tests for complex component logic
- **Naming conventions**: Use PascalCase for component names and files
- **File structure**: One component per file, named the same as the component
- **Develop reusable React components in TypeScript**: The user have a component library, you can ask him the code base to search them if needed.
- **theme**: The user have his own design system and theme, you must use [hooks.ts](mdc:app/theme/hooks.ts)
- Define and use TypeScript interfaces for component props and state where applicable.
</file>

<file path=".cursor/rules/database.mdc">
---
description: 
globs: **/*.prisma
alwaysApply: false
---
---
description: Database Coding Standards
globs: **/*.prisma
alwaysApply: false
---
# Standard Database Practices

- **Prevent SQL injections** by validating all Prisma input
- Query Optimization: Select only necessary fields, always think to do the most optimized schema
- **Use transactions** when multiple queries depend on each other
- **Always run migrations via Prisma**
- **Keep `prisma/schema.prisma` clean and well-commented**
- **Use Prisma logging** for debugging performance issues
- The user use Supabase for the authentication
</file>

<file path=".cursor/rules/frontend.mdc">
---
description: 
globs: **/*.tsx
alwaysApply: false
---
---
description: Frontend Coding Standard
globs: **/*.tsx
alwaysApply: false
---
# Frontend Guidelines

- Use functional React components instead of class components.
- Apply Tailwind CSS for styling; avoid inline styles.
- Components should be modular and reusable.
- Maintain a consistent and clear component structure.
- Self-close components without children
- Use parentheses for multi-line JSX
- Develop reusable React components in TypeScript. The user have a component library, you can ask him the codebase to search them if needed
- Utilize Tailwind CSS for responsive and modern styling. The user also have his own design system and theme, you must use [hooks.ts](mdc:app/theme/hooks.ts)
- Define and use TypeScript interfaces for component props and state where applicable
- Use the `useColors()` hook for accessing theme colors
- The pages you build must always be theme-aware
</file>

<file path=".cursor/rules/general.mdc">
---
description: 
globs: 
alwaysApply: true
---
---
description: General Guidelines
globs: *
alwaysApply: true
---
# General Coding Guidelines

- Use TypeScript for all development.
- Prioritize readability and maintainability in all code.
- Ensure function and variable names are clear and descriptive.
- Use concise, meaningful comments for complex logic.
- **Function Size**: Keep functions small and focused (max **50 lines**, ideally **20-30**).
- **Single Responsibility**: Each function should do **one thing well**.
- **Parameter Handling**: If a function has **too many parameters**, refactor it to use an **object**.
- **Always handle errors gracefully**
- **Never expose sensitive errors** to the frontend.
- **Use logging tools** like Sentry for production errors.
- Follow clean code practices and SOLID principles.
- You always can ask the user to have more detailed explanations before answering completely.
</file>

<file path=".cursor/rules/performance.mdc">
---
description: 
globs: **/*.prisma,**/*.tsx,**/*.ts
alwaysApply: false
---
---
description: Performance Optimization Standards
globs: **/*.ts, **/*.tsx, **/*.prisma
alwaysApply: false
---
# Performance Guidelines

- **React Component Optimization**:
  - Use **`useMemo`** for expensive calculations and rendered components
  - Apply **`useCallback`** for functions passed to child components
  - Implement **proper dependency arrays** in `useEffect` hooks to prevent unnecessary re-renders
  - Use **conditional rendering** for expensive components

- **Code Splitting and Lazy Loading**:
  - Wrap dynamic components with **`React.Suspense`** to avoid client-side rendering deopts
  - Use Next.js **`dynamic`** imports for components not needed on initial load
  - Implement **route-based code splitting** to reduce initial bundle size

- **Resource Management**:
  - **Cache resources** like SVGs, API responses, and frequent calculations
  - **Optimize images** with proper formats and sizes
  - Apply **virtualization** for long lists with libraries like `react-window`
  - Implement **debouncing** for search inputs and resize handlers

- **State Management**:
  - Keep component state as **local as possible**
  - **Avoid prop drilling** with contextual state where appropriate
  - **Memoize selectors** when working with complex state
  - Use **optimistic updates** for better perceived performance

- **Database and API Optimization**:
  - **Select only necessary fields** in database queries
  - Use appropriate **database indexes** on frequently queried fields
  - Apply **pagination** for large data sets
  - Implement **caching strategies** for frequently accessed data
  - Use **batch operations** for multiple related database changes

- **Network Performance**:
  - Implement **data prefetching** for anticipated user actions
  - Use **SWR** or **React Query** for efficient data fetching and caching
  - Apply **appropriate cache headers** for static assets
  - Implement **HTTP/2** for parallel resource loading

- **Rendering Performance**:
  - **Avoid layout thrashing** by batching DOM reads and writes
  - Use **CSS transforms** instead of properties that trigger layout
  - Apply **throttling** for scroll and resize event handlers
  - Keep the **number of DOM nodes** to a minimum

- **Monitoring and Optimization**:
  - Use **performance profiling** tools to identify bottlenecks
  - Implement **error boundaries** to prevent entire app crashes
  - Set up **performance monitoring** in production
  - Apply **progressive enhancement** for critical functionality
</file>

<file path=".cursor/rules/security.mdc">
---
description: 
globs: **/*.tsx,**/*.ts
alwaysApply: false
---
---
description: Security Standards and Best Practices
globs: **/*.ts, **/*.tsx
alwaysApply: false
---
# Security Guidelines

- **Authentication**: Use Supabase for user authentication and authorization
- **Route Protection**: Implement middleware for protecting routes (`middleware.ts`)
- **Input Validation**: Always validate all user inputs before processing
  - Validate form inputs on both client and server sides
  - Enforce password complexity requirements (minimum 8 characters)
- **Data Sanitization**: 
  - Use `DOMPurify.sanitize()` for user-generated HTML content
  - Escape values before inserting into JSX to prevent XSS attacks
- **API Security**:
  - Validate request bodies and parameters
  - Return appropriate HTTP status codes
  - Handle errors gracefully without exposing sensitive details
- **File Uploads**:
  - Validate file types before processing
  - Use unique filenames to prevent overwriting
  - Store uploads in secure buckets with proper access controls
- **Headers and Cookies**:
  - Set proper security headers
  - Use secure and HttpOnly flags for sensitive cookies
  - Set appropriate expiration times for authentication tokens
- **Authorization**:
  - Use `x-user-id` and `x-user-role` headers for passing user context
  - Implement workspace protection for multi-tenant data
  - Check user permissions before allowing access to resources
- **Error Handling**:
  - Log errors securely without exposing sensitive information
  - Provide user-friendly error messages
- **Environment Variables**:
  - Keep secrets in environment variables
  - Never expose API keys or secrets in client-side code
- **CSRF Protection**:
  - Use proper token validation for form submissions
- **Rate Limiting**:
  - Implement rate limiting for sensitive operations like password reset
- **Password Security**:
  - Never store plain-text passwords
  - Implement secure password reset flows
  - Enforce password complexity requirements
</file>

<file path=".cursor/rules/styling.mdc">
---
description: 
globs: **/*.tsx,**/*.css
alwaysApply: false
---
---
description: Styling Standards and Best Practices
globs: **/*.css, **/*.tsx
alwaysApply: false
---
# Styling Guidelines

- **Use Tailwind CSS** as the primary styling method for all components
- **Follow theme variables** from [theme.js](mdc:theme.js) for consistent colors and styling
- **Responsive design first**: Ensure all UI elements work across device sizes
- **Typography**: Use the `Inter` font family for all text elements
- **Custom utility classes**: Create reusable utility classes in `@layer utilities` when needed
- **Avoid inline styles** except for dynamic values that can't be handled with Tailwind
- **Color naming**: Use semantic color names from the theme (e.g., `text-primary` instead of `text-gray-800`)
- **Spacing consistency**: Use the spacing scale from the theme for margins and padding
- **CSS variables**: Use CSS variables for dynamic theming and values that change based on state
- **Component-specific styling**: Keep component-specific styles within the component file
- **Class naming**: Use clear, descriptive class names following Tailwind conventions
- **Tailwind directives**: Use `@apply` sparingly and only for complex, repeating patterns
- **Media queries**: Use Tailwind's responsive prefixes (`sm:`, `md:`, `lg:`, etc.) for breakpoints
- **Accessibility**: Ensure sufficient color contrast and focus states for interactive elements
- **Animation**: Use Tailwind's transition utilities for simple animations
- **Border radius**: Follow the border radius scale from the theme for consistent UI elements
- **Shadows**: Use the shadow scale from the theme for consistent elevation
- **State styling**: Use Tailwind's state variants (`:hover`, `:active`, `:focus`, etc.) consistently
- **Custom scrollbars**: Follow the global scrollbar styling defined in [globals.css](mdc:app/globals.css)
</file>

<file path=".github/workflows/backup-supabase.yml">
name: Backup Supabase DB after production push

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  backup:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install PostgreSQL client
        run: sudo apt-get update && sudo apt-get install -y postgresql-client

      - name: Parse DB credentials and dump database
        env:
          DATABASE_URL: ${{ secrets.SUPABASE_DB_URL }}
        run: |
          # Extract connection parameters
          DB_USER=$(echo $DATABASE_URL | sed -n 's|.*://\([^:]*\):.*|\1|p')
          DB_PASSWORD=$(echo $DATABASE_URL | sed -n 's|.*://[^:]*:\([^@]*\)@.*|\1|p')
          DB_HOST=$(echo $DATABASE_URL | sed -n 's|.*@\(.*\):[0-9]*\/.*|\1|p')
          DB_NAME=$(echo $DATABASE_URL | sed -n 's|.*/\(.*\)$|\1|p')

          export PGPASSWORD=$DB_PASSWORD

          # Perform full pg_dump
          pg_dump -h $DB_HOST -U $DB_USER -d $DB_NAME -F p -f backup.sql

      - name: Upload backup to GitHub Artifact
        uses: actions/upload-artifact@v4
        with:
          name: supabase-full-backup
          path: backup.sql
</file>

<file path=".github/workflows/claude.yml">
name: Claude Code

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]

jobs:
  claude:
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
      (github.event_name == 'issues' && (contains(github.event.issue.body, '@claude') || contains(github.event.issue.title, '@claude')))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code
        id: claude
        uses: anthropics/claude-code-action@beta
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
</file>

<file path=".github/workflows/export-feature-to-md.yml">
name: Export .feature to Markdown

on:
  push:
    branches: ['**']
    paths:
      - 'e2e/**'
  workflow_dispatch: # allows manual trigger in GitHub UI

jobs:
  convert:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20' # or your preferred version

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Run export script
        run: node exportFeaturesToMarkdown.js

      - name: Commit changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add docs/test-cases
          git commit -m "chore(docs): auto-update .md from .feature files" || echo "No changes to commit"
          git push
</file>

<file path="app/[slug]/[flow]/edit/components/blocks/BasicBlock.tsx">
import React from 'react';
import { NodeProps } from '@xyflow/react';
import { useIsModalOpenStore } from '@/app/isModalOpenStore';

/**
 * BasicBlock wraps all node components to provide shared logic,
 * such as disabling interaction when a modal is open.
 */
export type BasicBlockProps = NodeProps & {
  children: React.ReactNode;
};

export function BasicBlock({ children }: BasicBlockProps) {
  const isModalOpen = useIsModalOpenStore((state: any) => state.isModalOpen);

  return (
    <div
      className={isModalOpen ? 'pointer-events-none' : ''}
      tabIndex={-1}
      aria-disabled={isModalOpen}
    >
      {children}
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/edit/components/blocks/BeginBlock.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { Handle, Position, NodeProps, useStore } from '@xyflow/react';
import { Block, NodeData, Path, PathParentBlock } from '../../../types';
import { useConnectModeStore } from '../../store/connectModeStore';
import { useEditModeStore } from '../../store/editModeStore';
import { usePathsStore } from '../../store/pathsStore';
import { useColors } from '@/app/theme/hooks';
import DeletePathModal from '../modals/DeletePathModal';
import { BasicBlock } from './BasicBlock';
import { toast } from 'sonner';
import DOMPurify from 'dompurify';

// Simple tooltip component
type TooltipProps = {
  content: string;
  children: React.ReactNode;
  show: boolean;
};

const Tooltip = ({ content, children, show }: TooltipProps) => {
  const colors = useColors();
  const zoom = useStore((state) => state.transform?.[2] ?? 1);

  if (!show) return <>{children}</>;

  return (
    <div className="relative">
      <div
        className="absolute left-0 right-0 w-full text-center bottom-full z-50"
        style={{
          transform: `scale(${1 / zoom})`,
          transformOrigin: 'center bottom',
          marginBottom: '8px',
        }}
      >
        <div
          className="inline-block py-1 px-1.5 rounded-lg text-xs whitespace-normal max-w-full mx-auto flex flex-col items-center bg-opacity-100"
          style={{
            backgroundColor: colors['utility-brand-500'],
            color: colors['text-white'],
            boxShadow:
              '0px 4px 6px -2px rgba(16, 24, 40, 0.03), 0px 12px 16px -4px rgba(16, 24, 40, 0.08)',
            maxWidth: '200px',
            fontSize: '12px',
            fontWeight: 500,
            lineHeight: '18px',
          }}
        >
          <div className="px-1">{content}</div>
          <div
            className="w-0 h-0 absolute -bottom-1"
            style={{
              borderLeft: '6px solid transparent',
              borderRight: '6px solid transparent',
              borderTop: `6px solid ${colors['utility-brand-500']}`,
            }}
          />
        </div>
      </div>
      {children}
    </div>
  );
};

function BeginBlock(props: NodeProps & { data: NodeData }) {
  const { id, data, selected } = props;
  const [isEditing, setIsEditing] = useState(false);
  const [pathName, setPathName] = useState(data.path?.name || '');
  const [isHovered, setIsHovered] = useState(false);
  const [isEditButtonHovered, setIsEditButtonHovered] = useState(false);
  const [isDeleteButtonHovered, setIsDeleteButtonHovered] = useState(false);
  const [showTooltip, setShowTooltip] = useState(false);
  const [isTitleTruncated, setIsTitleTruncated] = useState(false);
  const tooltipTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const titleRef = useRef<HTMLDivElement>(null);
  const isConnectMode = useConnectModeStore((state) => state.isConnectMode);
  const isEditMode = useEditModeStore((state) => state.isEditMode);
  const allPaths = usePathsStore((state) => state.paths);
  const setAllPaths = usePathsStore((state) => state.setPaths);
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const colors = useColors();

  // Check if title is truncated
  const checkTitleTruncation = () => {
    if (titleRef.current) {
      const isTruncated =
        titleRef.current.scrollWidth > titleRef.current.clientWidth;
      setIsTitleTruncated(isTruncated);
    }
  };

  // Run check when path name changes or on resize
  useEffect(() => {
    checkTitleTruncation();

    // Also check on window resize
    const handleResize = () => {
      checkTitleTruncation();
    };

    window.addEventListener('resize', handleResize);

    // Force a check after a small delay to ensure rendering is complete
    const timeoutId = setTimeout(() => {
      checkTitleTruncation();
    }, 100);

    return () => {
      window.removeEventListener('resize', handleResize);
      clearTimeout(timeoutId);
    };
  }, [data.path?.name]);

  const handlePathNameUpdate = async () => {
    // Save previous name for rollback
    const prevPathName = data.path?.name;
    let pathUpdated: Path | undefined = allPaths.find(
      (p) => p.id === data.path?.id
    );

    if (!pathUpdated || !data.path?.id) {
      toast.error('Path not found');
      return;
    }

    const cleanPathName = pathName;

    // Optimistically update the path name in state
    pathUpdated = {
      ...pathUpdated,
      id: data.path?.id,
      name: cleanPathName,
    };
    let updatedPaths = allPaths.map((path) =>
      path.id === pathUpdated.id ? { ...path, ...pathUpdated } : path
    );

    // Also update parent_blocks' child_paths names
    const mergedUpdatedPath = updatedPaths.find((p) => p.id === pathUpdated.id);
    if (mergedUpdatedPath && Array.isArray(mergedUpdatedPath.parent_blocks)) {
      mergedUpdatedPath.parent_blocks.forEach(
        (parentBlock: { block_id: number; path_id: number }) => {
          updatedPaths = updatedPaths.map((path: Path) => ({
            ...path,
            blocks: path.blocks.map((block: Block) => {
              if (
                block.id === parentBlock.block_id &&
                Array.isArray(block.child_paths)
              ) {
                return {
                  ...block,
                  child_paths: block.child_paths.map((cp: PathParentBlock) =>
                    cp.path_id === mergedUpdatedPath.id
                      ? {
                          ...cp,
                          path: {
                            ...cp.path,
                            name: cleanPathName,
                          },
                        }
                      : cp
                  ),
                };
              }
              return block;
            }),
          }));
        }
      );
    }

    // Optimistically update global state and UI
    setAllPaths(updatedPaths);
    data.onPathsUpdate?.(updatedPaths);
    setIsEditing(false);

    try {
      const response = await fetch(`/api/paths/${data.path?.id}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: cleanPathName,
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to update path name');
      }
      // No further action needed, optimistic update already applied
    } catch (error) {
      // Rollback: revert to previous name
      let rollbackPath = allPaths.find((p) => p.id === data.path?.id);
      if (rollbackPath && data.path?.id && prevPathName) {
        rollbackPath = {
          ...rollbackPath,
          id: data.path?.id,
          name: prevPathName,
        };
        let rollbackPaths = allPaths.map((path) =>
          path.id === rollbackPath!.id ? { ...path, ...rollbackPath } : path
        );

        // Also rollback parent_blocks' child_paths names
        const mergedRollbackPath = rollbackPaths.find(
          (p) => p.id === rollbackPath!.id
        );
        if (
          mergedRollbackPath &&
          Array.isArray(mergedRollbackPath.parent_blocks)
        ) {
          mergedRollbackPath.parent_blocks.forEach(
            (parentBlock: { block_id: number; path_id: number }) => {
              rollbackPaths = rollbackPaths.map((path: Path) => ({
                ...path,
                blocks: path.blocks.map((block: Block) => {
                  if (
                    block.id === parentBlock.block_id &&
                    Array.isArray(block.child_paths)
                  ) {
                    return {
                      ...block,
                      child_paths: block.child_paths.map(
                        (cp: PathParentBlock) =>
                          cp.path_id === mergedRollbackPath.id
                            ? {
                                ...cp,
                                path: {
                                  ...cp.path,
                                  name: mergedRollbackPath.name,
                                },
                              }
                            : cp
                      ),
                    };
                  }
                  return block;
                }),
              }));
            }
          );
        }

        setAllPaths(rollbackPaths);
        data.onPathsUpdate?.(rollbackPaths);
      }
      toast.error('Failed to update path name');
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handlePathNameUpdate();
    } else if (e.key === 'Escape') {
      setIsEditing(false);
      setPathName(data.path?.name || '');
    }
  };

  const canDelete =
    data.path?.parent_blocks && data.path?.parent_blocks.length !== 0;

  const canEdit =
    data.path?.parent_blocks && data.path?.parent_blocks.length !== 0;

  const isFirstPath =
    data.path?.parent_blocks && data.path?.parent_blocks.length === 0;

  const hasMultipleParentBlocks =
    data.path?.parent_blocks && data.path?.parent_blocks.length > 1;

  return (
    <BasicBlock {...props}>
      {hasMultipleParentBlocks ? (
        <div className="transition-opacity duration-300">
          <Handle
            type="target"
            id="top"
            position={Position.Top}
            style={{
              background: '#b1b1b7',
              width: 1,
              height: 1,
              opacity: 0,
            }}
          />
          <div className="w-1 h-1 rounded-full bg-[#b1b1b7]" />
          <Handle
            type="source"
            id="bottom"
            position={Position.Bottom}
            style={{
              background: '#b1b1b7',
              width: 1,
              height: 1,
              opacity: 0,
            }}
          />
        </div>
      ) : isFirstPath ? (
        <div
          className="flex items-center justify-center rounded-full shadow-sm relative"
          style={{
            background: colors['utility-brand-100'],
            border: `1.5px solid ${selected ? colors['utility-brand-500'] : colors['utility-brand-200']}`,
            width: '350px',
            height: '50px',
            transition: 'border 0.2s',
            padding: 0,
          }}
        >
          {/* Top Handle (hidden but present for flow) */}
          <Handle
            type="target"
            position={Position.Top}
            id="top"
            style={{
              width: 8,
              height: 8,
              opacity: 0,
              background: colors['utility-brand-500'],
              border: '2px solid white',
              pointerEvents: 'none',
              position: 'absolute',
              left: '50%',
              top: '-8px',
              transform: 'translateX(-50%)',
            }}
          />
          {/* Sparkle Icon */}
          <span className="mr-2 flex-shrink-0" aria-hidden="true">
            <img
              src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/stars-02.svg`}
              alt="Start"
              className="w-5 h-5 block"
              draggable={false}
            />
          </span>
          {/* Path Name or Default Text */}
          <div
            ref={titleRef}
            className="font-medium text-base text-center truncate"
            style={{
              color: colors['text-brand-primary'],
              fontFamily: 'Inter, sans-serif',
            }}
            onMouseEnter={() => {
              checkTitleTruncation();
              tooltipTimeoutRef.current = setTimeout(() => {
                if (
                  titleRef.current &&
                  titleRef.current.scrollWidth > titleRef.current.clientWidth
                ) {
                  setShowTooltip(true);
                }
              }, 500);
            }}
            onMouseLeave={() => {
              if (tooltipTimeoutRef.current) {
                clearTimeout(tooltipTimeoutRef.current);
                tooltipTimeoutRef.current = null;
              }
              setShowTooltip(false);
            }}
          >
            {'This is where your process starts'}
          </div>
          {/* Bottom Handle (hidden but present for flow) */}
          <Handle
            type="source"
            position={Position.Bottom}
            id="bottom"
            style={{
              width: 8,
              height: 8,
              opacity: 0,
              background: colors['utility-brand-500'],
              border: '2px solid white',
              pointerEvents: 'none',
              position: 'absolute',
              left: '50%',
              bottom: '-8px',
              transform: 'translateX(-50%)',
            }}
          />
        </div>
      ) : (
        <div
          className={`relative transition-all duration-300 flex items-center justify-center ${
            isConnectMode ? 'opacity-40' : ''
          } ${isEditMode ? 'ring-2 ring-utility-brand-500' : ''}`}
          style={{
            width: '200px',
            height: '50px',
            padding: '12px 16px',
            borderRadius: '8px',
            border: selected
              ? `2px solid ${colors['utility-brand-500']}`
              : `2px solid ${colors['utility-brand-400']}`,
            background: colors['utility-brand-100'],
            position: 'relative',
          }}
          onMouseEnter={() => setIsHovered(true)}
          onMouseLeave={() => {
            setIsHovered(false);
            setShowTooltip(false);
          }}
        >
          <Handle
            type="target"
            position={Position.Top}
            id="top"
            style={{
              width: 8,
              height: 8,
              opacity: 0,
              background: colors['utility-brand-500'],
              border: '2px solid white',
              pointerEvents: 'none',
            }}
          />

          <div className="w-full">
            {isEditing && canEdit ? (
              <input
                type="text"
                value={pathName}
                onChange={(e) => setPathName(e.target.value)}
                onKeyDown={handleKeyDown}
                onBlur={handlePathNameUpdate}
                autoFocus
                className="bg-transparent outline-none w-full text-center font-medium"
                style={{ color: colors['text-brand-primary'] }}
                placeholder="Enter path name"
              />
            ) : (
              <Tooltip content={data.path?.name || 'Path'} show={showTooltip}>
                <div
                  ref={titleRef}
                  className="font-medium truncate text-center w-full cursor-default"
                  style={{ color: colors['text-brand-primary'] }}
                  onMouseEnter={() => {
                    // Force check truncation on hover
                    checkTitleTruncation();

                    // Always set the timeout, we'll check truncation when showing
                    tooltipTimeoutRef.current = setTimeout(() => {
                      // Only actually show if truncated
                      if (
                        titleRef.current &&
                        titleRef.current.scrollWidth >
                          titleRef.current.clientWidth
                      ) {
                        setShowTooltip(true);
                      }
                    }, 500);
                  }}
                  onMouseLeave={() => {
                    if (tooltipTimeoutRef.current) {
                      clearTimeout(tooltipTimeoutRef.current);
                      tooltipTimeoutRef.current = null;
                    }
                    setShowTooltip(false);
                  }}
                >
                  {data.path?.name || 'Path'}
                </div>
              </Tooltip>
            )}
          </div>

          <Handle
            type="source"
            position={Position.Bottom}
            id="bottom"
            style={{
              width: 8,
              height: 8,
              opacity: 0,
              background: colors['utility-brand-500'],
              border: '2px solid white',
              pointerEvents: 'none',
            }}
          />

          {/* Edit and Delete buttons that appear on hover */}
          {isHovered && !isEditing && (
            <div
              className="absolute -right-2 -top-[50%] flex rounded-lg"
              style={{
                background: colors['bg-secondary'],
                border: `1px solid ${colors['border-primary']}`,
                boxShadow: '0px 1px 2px 0px rgba(16, 24, 40, 0.05)',
              }}
            >
              {canEdit && (
                <button
                  onClick={() => setIsEditing(true)}
                  onMouseEnter={() => setIsEditButtonHovered(true)}
                  onMouseLeave={() => setIsEditButtonHovered(false)}
                  className="flex items-center justify-center p-2 transition-colors duration-200"
                  style={{
                    borderRight: `1px solid ${colors['border-primary']}`,
                    borderTopLeftRadius: '8px',
                    borderBottomLeftRadius: '8px',
                    background: isEditButtonHovered
                      ? colors['bg-tertiary']
                      : colors['bg-secondary'],
                  }}
                >
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                    alt="Edit"
                    className="w-3 h-3"
                  />
                </button>
              )}
              {canDelete && (
                <button
                  onClick={() => setShowDeleteModal(true)}
                  onMouseEnter={() => setIsDeleteButtonHovered(true)}
                  onMouseLeave={() => setIsDeleteButtonHovered(false)}
                  className="flex items-center justify-center p-2 transition-colors duration-200"
                  style={{
                    borderTopRightRadius: '8px',
                    borderBottomRightRadius: '8px',
                    background: isDeleteButtonHovered
                      ? colors['bg-tertiary']
                      : colors['bg-secondary'],
                  }}
                >
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`}
                    alt="Delete"
                    className="w-3 h-3"
                  />
                </button>
              )}
            </div>
          )}
        </div>
      )}

      {showDeleteModal && (
        <DeletePathModal
          onClose={() => {
            setShowDeleteModal(false);
          }}
          onConfirm={(success: boolean, errorMessage?: string) => {
            setShowDeleteModal(false);
            if (success) {
              toast.success('Path deleted');
            } else {
              toast.error(errorMessage || 'Failed to delete path');
            }
          }}
          pathName={data.path?.name || 'this path'}
          pathId={
            data.path?.id !== undefined ? String(data.path.id) : undefined
          }
          workflowId={
            data.path?.workflow_id !== undefined
              ? String(data.path.workflow_id)
              : undefined
          }
          setAllPaths={setAllPaths}
          onPathsUpdate={data.onPathsUpdate}
        />
      )}
    </BasicBlock>
  );
}

export default BeginBlock;
</file>

<file path="app/[slug]/[flow]/edit/components/blocks/CustomBlock.module.css">
.checkbox {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  width: 1rem;
  height: 1rem;
  border-radius: 0.25rem;
  border: 2px solid;
  cursor: pointer;
  transition: all 0.2s ease;
  background-color: var(--bg-secondary);
  background-position: center;
  background-repeat: no-repeat;
  background-size: 10px 10px;
}

.checkbox:checked {
  background-color: var(--bg-brand-primary);
  border-color: var(--border-brand);
  background-image: url("data:image/svg+xml,%3Csvg width='10' height='8' viewBox='0 0 10 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M9 1L3.5 6.5L1 4' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
}

.updateCheckbox:checked {
  background-color: var(--bg-brand-primary);
  border-color: var(--border-brand);
  background-image: url("data:image/svg+xml,%3Csvg width='10' height='8' viewBox='0 0 10 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M9 1L3.5 6.5L1 4' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
}
</file>

<file path="app/[slug]/[flow]/edit/components/blocks/CustomBlock.tsx">
import React, {
  useEffect,
  useState,
  useCallback,
  useMemo,
  useRef,
} from 'react';
import {
  Handle,
  Position,
  NodeProps,
  Edge,
  useReactFlow,
  Node,
  useStore,
  getNodesBounds,
  getViewportForBounds,
} from '@xyflow/react';
import { Block, NodeData } from '../../../types';
import { useModalStore } from '../../store/modalStore';
import { useConnectModeStore } from '../../store/connectModeStore';
import { usePathSelectionStore } from '../../store/pathSelectionStore';
import { createPortal } from 'react-dom';
import { useUpdateModeStore } from '../../store/updateModeStore';
import { usePathsStore } from '../../store/pathsStore';
import BlockDetailsSidebar from '../BlockDetailsSidebar';
import { useEditModeStore } from '../../store/editModeStore';
import { useClipboardStore } from '../../store/clipboardStore';
import { useColors } from '@/app/theme/hooks';
import styles from './CustomBlock.module.css';
import { useStrokeLinesStore } from '../../store/strokeLinesStore';
import { BasicBlock } from './BasicBlock';
import { useIsModalOpenStore } from '@/app/isModalOpenStore';
import { CustomTooltip } from '@/app/components/CustomTooltip';
import { motion } from 'framer-motion';
import { generateWorkspaceURL } from '@/app/api/utils/generateWorkspaceURL';

// Regular expression to match URLs
const URL_REGEX = /(https?:\/\/[^\s]+)/g;

function CustomBlock(props: NodeProps & { data: NodeData }) {
  const { id, data, selected, ...rest } = props;
  const [isHighlighted, setIsHighlighted] = useState(false);
  const [showDropdown, setShowDropdown] = useState(false);
  const [showFullDescription, setShowFullDescription] = useState(false);
  const colors = useColors();
  const { allStrokeLinesVisible } = useStrokeLinesStore();

  const {
    getNodes,
    setEdges,
    setNodes,
    getEdges,
    viewportInitialized,
    setViewport,
    fitView,
    setNodes: reactFlowSetNodes,
  } = useReactFlow();

  const setShowConnectModal = useModalStore(
    (state) => state.setShowConnectModal
  );
  const showConnectModal = useModalStore((state) => state.showConnectModal);
  const connectData = useModalStore((state) => state.connectData);
  const setConnectData = useModalStore((state) => state.setConnectData);
  const {
    selectedPaths,
    parentBlockId,
    togglePathSelection,
    mergeMode,
    setMergeMode,
  } = usePathSelectionStore();
  const {
    isUpdateMode,
    setUpdateMode,
    mergePathId,
    setMergePathId,
    setSelectedEndBlocks,
    setOriginalEndBlocks,
    selectedEndBlocks,
    toggleEndBlockSelection,
    originalEndBlocks,
    triggerPathId,
    setTriggerPathId,
  } = useUpdateModeStore();
  const allPaths = usePathsStore((state) => state.paths);
  const setAllPaths = usePathsStore((state) => state.setPaths);

  // Get the current zoom level from ReactFlow store
  const zoom = useStore((state) => state.transform[2]);
  const transform = useStore((state) => state.transform);
  const [dropdownPosition, setDropdownPosition] = useState({ x: 0, y: 0 });

  // Add this state near the top of the CustomBlock component
  const [showSidebar, setShowSidebar] = useState(false);

  // Add block state to track changes
  const [blockData, setBlockData] = useState(data.block);

  // Generate image URL directly using generateWorkspaceURL
  const imageUrl = useMemo(() => {
    if (!blockData.image) return null;
    try {
      return generateWorkspaceURL(blockData.image);
    } catch (error) {
      console.error('Error generating workspace URL:', error);
      return null;
    }
  }, [blockData.image]);

  const isConnectMode = useConnectModeStore((state) => state.isConnectMode);
  const { isEditMode, selectedNodeId, setEditMode } = useEditModeStore();

  const setCopiedBlock = useClipboardStore((state) => state.setCopiedBlock);

  const isModalOpen = useIsModalOpenStore((state: any) => state.isModalOpen);

  // Find the merge block in the current path
  const mergeBlock = useMemo(
    () => data.path?.blocks.find((block) => block.type === 'MERGE'),
    [data.path?.blocks]
  );

  // Determine if merging to the same child
  const isMergingToSameChild = useMemo(() => {
    // If the merge block exists and has child_paths
    const childPaths = mergeBlock?.child_paths;
    if (childPaths && childPaths.length > 0 && mergePathId) {
      // Compare the first child_path id with the trigger path id
      return childPaths[0].path_id === mergePathId;
    }
    // If no child_paths, or no triggerPath, default to true (or false, depending on your logic)
    return true;
  }, [mergeBlock, mergePathId]);

  // Add this after other useMemo hooks
  const lastBlock = useMemo(() => {
    const blocks = data.path?.blocks;
    if (!blocks || blocks.length < 2) return false;
    const idx = blocks.findIndex((block) => block.id === data.block.id);
    return idx === blocks.length - 2;
  }, [data.path?.blocks, data.block.id]);

  // Handle highlight effect
  useEffect(() => {
    if (data.highlighted) {
      setIsHighlighted(true);
      const timer = setTimeout(() => {
        setIsHighlighted(false);
      }, 2000);

      return () => clearTimeout(timer);
    }
  }, [data.highlighted]);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setShowDropdown(false);
    if (showDropdown) {
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }
  }, [showDropdown]);

  const handleDropdownToggle = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (!showDropdown) {
      const rect = (e.currentTarget as HTMLElement).getBoundingClientRect();
      const dropdownWidth = 170; // px
      const dropdownHeight = 280; // px, estimate or measure your dropdown height
      const offset = 4; // px

      let x = rect.right - 30;
      // Default: show below
      let y = rect.bottom + offset;

      // Clamp to right edge
      if (x + dropdownWidth > window.innerWidth - 8) {
        x = window.innerWidth - dropdownWidth - 8;
      }
      // Clamp to left edge
      if (x < 8) {
        x = 8;
      }

      // If not enough space below, flip above
      if (y + dropdownHeight > window.innerHeight - 8) {
        // Try to show above the trigger
        y = rect.top - dropdownHeight / 1.5 - offset;
        // If still offscreen, clamp to top
        if (y < 8) y = window.innerHeight - dropdownHeight - 8;
        // If dropdown is taller than viewport, stick to top
        if (y < 8) y = 8;
      }

      setDropdownPosition({ x, y });
    }
    setShowDropdown(!showDropdown);
  };

  const handleDelete = (e: React.MouseEvent) => {
    e.stopPropagation();
    data.onDelete?.(id);
    setShowDropdown(false);
  };

  const handleConnectClick = (e: React.MouseEvent) => {
    e.stopPropagation();

    // Check if this block has stroke lines
    const hasStrokeLines = getEdges().some(
      (edge) => edge.source === id && edge.type === 'strokeEdge'
    );

    if (hasStrokeLines) {
      // Set edit links data and show the modal
      setEditLinksData({
        sourceNode: {
          id,
          data,
          position: { x: 0, y: 0 },
          type: 'custom',
          width: undefined,
          height: undefined,
        } as Node<NodeData>,
      });
      setShowEditLinksModal(true);
    } else {
      // Original connect behavior
      setConnectData({
        sourceNode: {
          id,
          data,
          position: { x: 0, y: 0 },
          type: 'custom',
          width: undefined,
          height: undefined,
        },
      });
      setShowConnectModal(true);
    }

    setShowDropdown(false);
  };

  // Check if this is the last STEP node in a path
  const isLastStepInPath =
    data.type === 'STEP' &&
    data.position === (data.path?.blocks.length ?? 0) - 2; // -2 because of END block

  // Get parent block ID for this path
  const pathParentBlockId = data.path?.parent_blocks?.[0]?.block_id;

  // Check if parent block has more than one child path
  const parentHasMultipleChildPaths = data.hasSiblings;

  // Get the end block and check if it has child paths
  const endBlock = data.path?.blocks.find(
    (block) => block.type === 'END' || block.type === 'LAST'
  );

  // Condition for showing merge-related UI
  const canShowMergeUI =
    parentHasMultipleChildPaths &&
    !data.pathHasChildren &&
    (parentBlockId === null || pathParentBlockId === parentBlockId);

  // Use this condition for both checkbox and dropdown option
  const showCheckbox = mergeMode && canShowMergeUI && lastBlock;

  const handleUpdateModeActivation = (e: React.MouseEvent) => {
    e.stopPropagation();
    setShowDropdown(false);

    // Get the parent block ID of the current node
    const parentBlockId = data.path?.parent_blocks?.[0]?.block_id;

    if (!parentBlockId) {
      console.error('No parent block found');
      return;
    }

    // Find the merge block in the current path
    const mergeBlock = data.path?.blocks.find(
      (block) => block.type === 'MERGE'
    );

    if (!mergeBlock || !mergeBlock.child_paths[0]) {
      console.error('No merge block or child path found');
      return;
    }

    const mergePathId = mergeBlock.child_paths[0].path_id;
    const mergePath = allPaths.find((path) => path.id === mergePathId);

    if (!mergePath) {
      console.error('Merge path not found');
      return;
    }

    const parentBlocks = mergePath.parent_blocks.map((pb) => pb.block_id);

    setUpdateMode(true);
    setMergePathId(mergePathId);
    setSelectedEndBlocks(parentBlocks);
    setOriginalEndBlocks(parentBlocks);
    setTriggerPathId(parentBlockId); // Set the triggering node's parent block ID
  };

  const handleCopy = (e: React.MouseEvent) => {
    e.stopPropagation();
    setCopiedBlock(blockData);
    setShowDropdown(false);
  };

  // Add this function to handle copying link
  const handleCopyLink = (e: React.MouseEvent) => {
    e.stopPropagation();
    const url = new URL(window.location.href);
    url.searchParams.set('blockId', id.replace('block-', ''));
    navigator.clipboard.writeText(url.toString());
    setShowDropdown(false);
  };

  const renderDropdown = () => {
    if (!showDropdown) return null;

    return createPortal(
      <motion.div
        initial={{ opacity: 0, scale: 0.95, y: -10 }}
        animate={{ opacity: 1, scale: 1, y: 0 }}
        exit={{ opacity: 0, scale: 0.95, y: -10 }}
        transition={{
          duration: 0.15,
          ease: [0.16, 1, 0.3, 1], // Custom easing for smooth feel
        }}
        style={{
          backgroundColor: colors['bg-secondary'],
          border: `1px solid ${colors['border-primary']}`,
          left: dropdownPosition.x,
          top: dropdownPosition.y,
          zIndex: 99999999,
        }}
        className="fixed shadow-[0px_4px_6px_-2px_rgba(16,24,40,0.03)] py-1 flex flex-col overflow-hidden cursor-pointer rounded-lg"
      >
        <div
          onClick={handleConnectClick}
          className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
        >
          <div
            style={
              {
                '--hover-bg': colors['bg-quaternary'],
              } as React.CSSProperties
            }
            className="w-[170px] grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
          >
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative overflow-hidden">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${
                    getEdges().some(
                      (edge) => edge.source === id && edge.type === 'strokeEdge'
                    )
                      ? 'connect-node.svg'
                      : 'connect-node.svg'
                  }`}
                  alt={
                    getEdges().some(
                      (edge) => edge.source === id && edge.type === 'strokeEdge'
                    )
                      ? 'Edit Links'
                      : 'Connect'
                  }
                  className="w-4 h-4"
                />
              </div>
              <div
                style={{ color: colors['text-primary'] }}
                className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
              >
                {getEdges().some(
                  (edge) => edge.source === id && edge.type === 'strokeEdge'
                )
                  ? 'Edit links'
                  : 'Connect block'}
              </div>
            </div>
          </div>
        </div>

        {canShowMergeUI && (
          <div
            onClick={(e) => {
              e.stopPropagation();
              setMergeMode(true);
              togglePathSelection(
                data.path?.id ?? -1,
                endBlock?.id ?? -1,
                pathParentBlockId ?? -1
              );
              setShowDropdown(false);
            }}
            className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
          >
            <div
              style={
                {
                  '--hover-bg': colors['bg-quaternary'],
                } as React.CSSProperties
              }
              className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
            >
              <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
                <div className="w-4 h-4 relative overflow-hidden">
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/git-merge.svg`}
                    alt="Merge Paths"
                    className="w-4 h-4"
                  />
                </div>
                <div
                  style={{ color: colors['text-primary'] }}
                  className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
                >
                  Merge paths
                </div>
              </div>
            </div>
          </div>
        )}

        {data.pathIsMerged && (
          <div
            onClick={handleUpdateModeActivation}
            className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
          >
            <div
              style={
                {
                  '--hover-bg': colors['bg-quaternary'],
                } as React.CSSProperties
              }
              className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
            >
              <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
                <div className="w-4 h-4 relative overflow-hidden">
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                    alt="Edit Merge"
                    className="w-4 h-4"
                  />
                </div>
                <div
                  style={{ color: colors['text-primary'] }}
                  className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
                >
                  Edit merge
                </div>
              </div>
            </div>
          </div>
        )}

        <div
          onClick={handleCopy}
          className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
        >
          <div
            style={
              {
                '--hover-bg': colors['bg-quaternary'],
              } as React.CSSProperties
            }
            className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
          >
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative overflow-hidden">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/copy-icon.svg`}
                  alt="Copy"
                  className="w-4 h-4"
                />
              </div>
              <div
                style={{ color: colors['text-primary'] }}
                className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
              >
                Copy
              </div>
            </div>
          </div>
        </div>

        <div
          onClick={handleCopyLink}
          className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
        >
          <div
            style={
              {
                '--hover-bg': colors['bg-quaternary'],
              } as React.CSSProperties
            }
            className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
          >
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative overflow-hidden">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/copy-link-icon.svg`}
                  alt="Copy Link"
                  className="w-4 h-4"
                />
              </div>
              <div
                style={{ color: colors['text-primary'] }}
                className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
              >
                Copy Link
              </div>
            </div>
          </div>
        </div>

        <div
          style={{ borderColor: colors['border-secondary'] }}
          className="self-stretch h-px border-b my-1"
        />

        <div
          onClick={handleDelete}
          className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
        >
          <div
            style={
              {
                '--hover-bg': colors['bg-quaternary'],
              } as React.CSSProperties
            }
            className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
          >
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative overflow-hidden">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`}
                  alt="Delete"
                  className="w-4 h-4"
                />
              </div>
              <div
                style={{ color: colors['text-primary'] }}
                className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
              >
                Delete
              </div>
            </div>
          </div>
        </div>
      </motion.div>,
      document.body
    );
  };

  // Modify the showUpdateCheckbox logic
  const showUpdateCheckbox = useMemo(() => {
    return (
      isUpdateMode &&
      data.path?.parent_blocks?.[0]?.block_id === triggerPathId &&
      isMergingToSameChild &&
      lastBlock
    );
  }, [isUpdateMode, data.path?.parent_blocks, triggerPathId, lastBlock]);

  // Get the end block ID for this path
  const endBlockId = data.path?.blocks.find(
    (block) =>
      block.type === 'END' || block.type === 'LAST' || block.type === 'MERGE'
  )?.id;

  // Modify the toggleStrokeLines function
  const toggleStrokeLines = (e: React.MouseEvent) => {
    e.stopPropagation();

    // Prevent toggling individual stroke lines when global setting is off
    if (!allStrokeLinesVisible) {
      // Optional: You could show a tooltip or notification here explaining why
      // the toggle is disabled, but for now we'll just return early
      return;
    }

    const blockId = parseInt(id.replace('block-', ''));
    const newVisibility = !data.strokeLinesVisible;
    data.updateStrokeLineVisibility?.(blockId, newVisibility);
  };

  // Check if this node is the source or target in connect mode
  const isSourceOrTargetNode =
    showConnectModal &&
    (connectData?.sourceNode?.id === id || connectData?.targetNode?.id === id);

  // Add this function to handle zooming to the node
  const zoomToNode = useCallback(() => {
    const node = getNodes().find((n) => n.id === id);
    if (!node) return;

    // Center on node and offset to the left to make room for sidebar
    setViewport(
      {
        x: -(node.position.x - window.innerWidth / 2 + 400),
        y: -(node.position.y - window.innerHeight / 2 + 200),
        zoom: 1,
      },
      { duration: 800 }
    );
  }, [id, getNodes, setViewport]);

  // Modify the click handler to include zooming
  const handleNodeClick = (e: React.MouseEvent) => {
    if (isModalOpen) {
      e.preventDefault();
      e.stopPropagation();
      return;
    }
    e.stopPropagation();

    // Just show the sidebar and zoom - the border styling depends on showSidebar
    setShowSidebar(true);

    // Update edit mode for other components to be aware
    const blockId = id.replace('block-', '');
    setEditMode(true, blockId);

    // Zoom to node
    zoomToNode();
  };

  // Add this function to parse text into segments with links
  const parseTextWithLinks = (text: string) => {
    const parts = [];
    let lastIndex = 0;
    let match;

    while ((match = URL_REGEX.exec(text)) !== null) {
      // Add text before the link
      if (match.index > lastIndex) {
        parts.push({
          type: 'text',
          content: text.slice(lastIndex, match.index),
        });
      }

      // Add the link
      parts.push({
        type: 'link',
        content: match[0],
      });

      lastIndex = match.index + match[0].length;
    }

    // Add remaining text after last link
    if (lastIndex < text.length) {
      parts.push({
        type: 'text',
        content: text.slice(lastIndex),
      });
    }

    return parts.length > 0 ? parts : [{ type: 'text', content: text }];
  };

  // Add this effect to automatically open the sidebar when the node is selected via edit mode
  useEffect(() => {
    if (isModalOpen) {
      return;
    }
    // Check if the current node is the selected node in edit mode
    if (isEditMode && selectedNodeId && `block-${selectedNodeId}` === id) {
      // Automatically open the sidebar
      setShowSidebar(true);
      // Only zoom to node if we're not handling a newly created node
      // (The Flow component already handles zooming for new nodes)
      if (viewportInitialized) {
        zoomToNode();
      }
    }
  }, [isEditMode, selectedNodeId, id, zoomToNode, viewportInitialized]);

  // Add the useTooltip hook
  const useTooltip = () => {
    const [showTooltip, setShowTooltip] = useState(false);
    const [tooltipPosition, setTooltipPosition] = useState<number | null>(null);
    const elementRef = useRef<HTMLDivElement>(null);
    const tooltipRef = useRef<HTMLDivElement>(null);

    const handleMouseEnter = useCallback(() => {
      setShowTooltip(true);
    }, []);

    const handleMouseLeave = useCallback(() => {
      setShowTooltip(false);
      setTooltipPosition(null);
    }, []);

    useEffect(() => {
      if (showTooltip && tooltipRef.current && elementRef.current) {
        const toggleRect = elementRef.current.getBoundingClientRect();
        const tooltipRect = tooltipRef.current.getBoundingClientRect();
        const gap = 12; // gap between toggle and tooltip
        setTooltipPosition(-(tooltipRect.width + gap));
      }
    }, [showTooltip]);

    return {
      elementRef,
      tooltipRef,
      showTooltip,
      tooltipPosition,
      handleMouseEnter,
      handleMouseLeave,
    };
  };

  const {
    elementRef,
    tooltipRef,
    showTooltip,
    tooltipPosition,
    handleMouseEnter,
    handleMouseLeave,
  } = useTooltip();

  useEffect(() => {
    // Find the latest block in allPaths
    const updatedBlock = allPaths
      .flatMap((path) => path.blocks)
      .find((b) => b.id === blockData.id);
    if (updatedBlock && updatedBlock.is_endpoint !== blockData.is_endpoint) {
      setBlockData((prev) => ({
        ...prev,
        is_endpoint: updatedBlock.is_endpoint,
      }));
    }
  }, [allPaths, blockData.id, blockData.is_endpoint]);

  // After the other useModalStore hooks, add these two:
  const setShowEditLinksModal = useModalStore(
    (state) => state.setShowEditLinksModal
  );
  const setEditLinksData = useModalStore((state) => state.setEditLinksData);

  // Add the update method to handle all block updates
  const handleBlockUpdate = async (updatedData: Partial<Block>) => {
    // Ensure icon reset is explicit
    if ('icon' in updatedData && updatedData.icon === undefined) {
      updatedData.icon = null;
      blockData.signedIconUrl = null;
    }
    if (
      updatedData.icon &&
      updatedData.icon.startsWith('https://cdn.brandfetch.io/')
    ) {
      blockData.signedIconUrl = null;
    }
    if (updatedData.image === undefined) {
      updatedData.image = blockData.image;
    }
    const blockId = parseInt(id.replace('block-', ''));

    // Save previous block data for rollback
    const previousBlock = allPaths
      .flatMap((path) => path.blocks)
      .find((block) => block.id === blockId);

    // Optimistically update local state
    setBlockData((prev) => ({
      ...prev,
      ...updatedData,
    }));
    // Optimistically update paths store
    const optimisticPaths = allPaths.map((path) => ({
      ...path,
      blocks: path.blocks.map((block) =>
        block.id === blockId ? { ...block, ...updatedData } : block
      ),
    }));
    setAllPaths(optimisticPaths);
    data.onPathsUpdate?.(optimisticPaths);

    try {
      const response = await fetch(`/api/blocks/${blockId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updatedData),
      });

      if (!response.ok) throw new Error('Failed to update block');

      const updatedBlock = await response.json();

      // Preserve existing image if not explicitly updated
      setBlockData((prev) => ({
        ...prev,
        ...updatedBlock,
        image:
          updatedData.image !== undefined ? updatedBlock.image : prev.image,
        icon: updatedData.icon !== undefined ? updatedBlock.icon : prev.icon,
      }));

      // Only update paths if image was changed
      if (updatedData.image !== undefined) {
        const updatedPaths = allPaths.map((path) => ({
          ...path,
          blocks: path.blocks.map((block) =>
            block.id === blockId ? { ...block, ...updatedBlock } : block
          ),
        }));

        setAllPaths(updatedPaths);
        data.onPathsUpdate?.(updatedPaths);
      }

      return updatedBlock;
    } catch (error) {
      // Rollback to previous block data
      setBlockData((prev) => ({
        ...prev,
        ...previousBlock,
      }));
      setAllPaths((paths) =>
        paths.map((path) => ({
          ...path,
          blocks: path.blocks.map((block) =>
            block.id === blockId ? { ...block, ...previousBlock } : block
          ),
        }))
      );
      data.onPathsUpdate?.(
        allPaths.map((path) => ({
          ...path,
          blocks: path.blocks.map((block) =>
            block.id === blockId ? { ...block, ...previousBlock } : block
          ),
        }))
      );
      console.error('Error updating block:', error);
      throw error;
    }
  };

  return (
    <BasicBlock {...props}>
      {/* Vertical Toggle Switch Container */}
      {getEdges().some(
        (edge) => edge.source === id && edge.type === 'strokeEdge'
      ) &&
        !showConnectModal && (
          <div
            className="absolute top-[50%] -translate-y-1/2 transition-opacity duration-300"
            style={{
              left: '-20px',
              backgroundColor: colors['bg-primary'],
              padding: '4px',
              width: '32px',
              height: '32px',
              borderRadius: '8px',
              boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
              border: `1px solid ${colors['border-secondary']}`,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'flex-start',
              paddingLeft: '6px',
            }}
          >
            <div
              ref={elementRef}
              onClick={toggleStrokeLines}
              className={`${allStrokeLinesVisible ? 'cursor-pointer' : 'cursor-not-allowed'}`}
              style={{
                width: '12px',
                height: '20px',
                borderRadius: '6px',
                backgroundColor:
                  allStrokeLinesVisible && data.strokeLinesVisible
                    ? '#FF69A3'
                    : colors['bg-quaternary'],
                transition: 'background-color 0.2s',
                position: 'relative',
                opacity: allStrokeLinesVisible ? 1 : 0.5,
              }}
              onMouseEnter={handleMouseEnter}
              onMouseLeave={handleMouseLeave}
            >
              <div
                style={{
                  width: '10px',
                  height: '10px',
                  borderRadius: '50%',
                  backgroundColor: colors['bg-primary'],
                  position: 'absolute',
                  left: '1px',
                  top:
                    allStrokeLinesVisible && data.strokeLinesVisible
                      ? '1px'
                      : '9px',
                  transition: 'top 0.2s',
                  boxShadow: '0 1px 2px rgba(0, 0, 0, 0.1)',
                }}
              />
            </div>
          </div>
        )}

      {/* Tooltip */}
      {showTooltip && (
        <div
          ref={tooltipRef}
          style={{
            position: 'absolute',
            left: '-210px', // Position it further to the left of the toggle button
            top: '50%',
            transform: 'translateY(-50%)',
            zIndex: 1000,
            pointerEvents: 'none',
          }}
        >
          <CustomTooltip
            text={
              allStrokeLinesVisible
                ? data.strokeLinesVisible
                  ? 'Hide connecting lines'
                  : 'Show connecting lines'
                : 'Global connecting lines are disabled in Settings'
            }
            show={true}
            direction="left"
          />
        </div>
      )}

      <div
        className={`relative rounded-lg
        ${isHighlighted ? 'bg-blue-50' : `bg-[${colors['bg-primary']}]`} 
        transition-all duration-300 min-w-[481px] max-w-[481px]
        ${
          (isEditMode && id !== `block-${selectedNodeId}`) ||
          (isConnectMode &&
            id !== connectData?.sourceNode?.id &&
            id !== connectData?.targetNode?.id)
            ? 'opacity-40'
            : ''
        }`}
        onClick={handleNodeClick}
        style={{
          backgroundColor: isHighlighted ? '#EAF4FE' : colors['bg-primary'],
          borderWidth: '2px',
          borderStyle: 'solid',
          borderColor: showSidebar
            ? colors['border-brand_alt']
            : colors['border-secondary'],
        }}
      >
        <Handle
          type="target"
          position={Position.Top}
          id="top"
          style={{
            width: 8,
            height: 8,
            opacity: 0,
            background: colors['fg-brand-primary'],
            border: `2px solid ${colors['bg-primary']}`,
            pointerEvents: 'none',
          }}
        />
        <Handle
          type="source"
          position={Position.Left}
          id="stroke_source"
          style={{
            width: 8,
            height: 8,
            background: colors['fg-tertiary'],
            border: `2px solid ${colors['bg-primary']}`,
            top: '35%',
            opacity: 0,
            pointerEvents: 'none',
          }}
        />
        <Handle
          type="target"
          position={Position.Left}
          id="stroke_target"
          style={{
            width: 8,
            height: 8,
            background: colors['fg-tertiary'],
            border: `2px solid ${colors['bg-primary']}`,
            top: '35%',
            left: 0,
            opacity: 0,
            pointerEvents: 'none',
          }}
        />
        <Handle
          type="target"
          position={Position.Left}
          id="stroke_self_target"
          style={{
            width: 8,
            height: 8,
            background: colors['fg-tertiary'],
            border: `2px solid ${colors['bg-primary']}`,
            top: '65%',
            opacity: 0,
            pointerEvents: 'none',
          }}
        />
        <Handle
          type="source"
          position={Position.Bottom}
          id="bottom"
          style={{
            width: 8,
            height: 8,
            opacity: 0,
            background: colors['fg-brand-primary'],
            border: `2px solid ${colors['bg-primary']}`,
            pointerEvents: 'none',
          }}
        />

        {/* Header section with separator */}
        <div
          className="p-[17px] flex items-center justify-between"
          style={{
            borderBottom:
              blockData.description || imageUrl || blockData.average_time
                ? `1px solid ${colors['border-secondary']}`
                : 'none',
          }}
        >
          <div className="flex items-center gap-3">
            <div
              className="w-10 h-10 rounded-md flex items-center justify-center flex-shrink-0"
              style={{
                border: `1px solid ${colors['border-secondary']}`,
              }}
            >
              {blockData.signedIconUrl ? (
                <img
                  src={blockData.signedIconUrl}
                  alt="Block Icon"
                  className="w-6 h-6"
                  referrerPolicy="strict-origin-when-cross-origin"
                />
              ) : blockData.icon &&
                blockData.icon.startsWith('https://cdn.brandfetch.io/') ? (
                <img
                  src={blockData.icon}
                  alt="Block Icon"
                  className="w-6 h-6"
                  referrerPolicy="strict-origin-when-cross-origin"
                />
              ) : (
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/container.svg`}
                  alt="Default Icon"
                  className="w-6 h-6"
                />
              )}
            </div>
            <div className="flex flex-col gap-0.5">
              <div
                className="text-xs font-medium"
                style={{ color: colors['fg-tertiary'] }}
              >
                Step
              </div>
              <div
                className="text-sm font-semibold line-clamp-2 break-words"
                style={{
                  color: colors['fg-primary'],
                  display: '-webkit-box',
                  WebkitLineClamp: 1,
                  WebkitBoxOrient: 'vertical',
                  overflow: 'hidden',
                  width: '333px',
                }}
              >
                {blockData.title || 'Untitled Block'}
              </div>
            </div>
          </div>
          {data.block.id >= 0 && (
            <button
              onClick={handleDropdownToggle}
              className="p-1 rounded-md transition-colors hover:bg-opacity-80"
              style={{
                color: colors['fg-tertiary'],
                backgroundColor: 'transparent',
              }}
              onMouseOver={(e) => {
                e.currentTarget.style.backgroundColor = colors['bg-secondary'];
              }}
              onMouseOut={(e) => {
                e.currentTarget.style.backgroundColor = 'transparent';
              }}
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dots-horizontal.svg`}
                alt="Menu"
                className="w-5 h-5"
              />
            </button>
          )}
        </div>

        {/* Content section - only render if there's content */}
        {(blockData.description || imageUrl || blockData.average_time) && (
          <div className="p-[17px] flex flex-col gap-[13.7px]">
            {blockData.description && (
              <p
                className="text-xs mt-1 line-clamp-2 whitespace-pre-line"
                style={{ color: colors['fg-tertiary'] }}
              >
                {parseTextWithLinks(blockData.description).map(
                  (segment, index) =>
                    segment.type === 'link' ? (
                      <a
                        key={index}
                        href={segment.content}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-blue-500 hover:underline"
                        onClick={(e) => {
                          e.stopPropagation();
                          e.preventDefault();
                          window.open(
                            segment.content,
                            '_blank',
                            'noopener,noreferrer'
                          );
                        }}
                      >
                        {segment.content}
                      </a>
                    ) : (
                      <span key={index}>{segment.content}</span>
                    )
                )}
              </p>
            )}

            {/* Image with signed URL */}
            {imageUrl && (
              <div
                className="rounded-md overflow-hidden h-[267px] w-full"
                style={{ backgroundColor: colors['bg-secondary'] }}
              >
                <img
                  src={imageUrl}
                  alt="Block Media"
                  className="w-full h-full object-contain"
                />
              </div>
            )}

            {/* Average time - only show if defined */}
            {blockData.average_time && (
              <span
                className="flex w-fit px-3 py-1 rounded-full text-xs"
                style={{
                  backgroundColor: colors['bg-secondary'],
                  borderWidth: '1px',
                  borderStyle: 'solid',
                  borderColor: colors['border-secondary'],
                  color: colors['fg-tertiary'],
                }}
              >
                {blockData.average_time} min
              </span>
            )}
          </div>
        )}

        {showCheckbox && (
          <div className="absolute -top-8 left-0 flex items-center gap-2">
            <label
              className="flex items-center gap-2 px-2 py-1 rounded-md bg-gray-900 dark:bg-white border border-gray-700 dark:border-gray-200 cursor-pointer"
              onClick={(e) => e.stopPropagation()}
            >
              <input
                type="checkbox"
                checked={selectedPaths.includes(data.path?.id ?? -1)}
                onChange={() =>
                  togglePathSelection(
                    data.path?.id ?? -1,
                    endBlock?.id ?? -1,
                    pathParentBlockId ?? -1
                  )
                }
                className={styles.checkbox}
                style={
                  {
                    borderColor: colors['border-primary'],
                    '--bg-brand-primary': colors['bg-brand-solid'],
                    '--border-brand': colors['border-brand'],
                    '--bg-secondary': colors['bg-primary'],
                  } as React.CSSProperties
                }
              />
              <span className="text-sm text-gray-300 dark:text-gray-600 select-none">
                {selectedPaths.includes(data.path?.id ?? -1)
                  ? 'Selected'
                  : 'Not selected'}
              </span>
            </label>
          </div>
        )}

        {showUpdateCheckbox && endBlockId && (
          <div className="absolute -top-8 left-0 flex items-center gap-2">
            <label
              className="flex items-center gap-2 px-2 py-1 rounded-md bg-gray-900 dark:bg-white border border-gray-700 dark:border-gray-200 cursor-pointer"
              onClick={(e) => e.stopPropagation()}
            >
              <input
                type="checkbox"
                checked={selectedEndBlocks.includes(endBlockId)}
                onChange={() => toggleEndBlockSelection(endBlockId)}
                className={`${styles.checkbox} ${styles.updateCheckbox}`}
                style={
                  {
                    borderColor: colors['border-primary'],
                    '--bg-brand-primary': colors['bg-brand-solid'],
                    '--border-brand': colors['border-brand'],
                    '--bg-secondary': colors['bg-primary'],
                  } as React.CSSProperties
                }
              />
              <span className="text-sm text-gray-300 dark:text-gray-600 select-none">
                {selectedEndBlocks.includes(endBlockId)
                  ? 'Selected'
                  : 'Not selected'}
              </span>
            </label>
          </div>
        )}

        {renderDropdown()}
      </div>

      {showSidebar && (
        <BlockDetailsSidebar
          block={blockData}
          signedImageUrl={imageUrl}
          onClose={() => {
            setShowSidebar(false);
            // We don't need to change edit mode or selection state
          }}
          onUpdate={handleBlockUpdate}
        />
      )}
    </BasicBlock>
  );
}

export default CustomBlock;
</file>

<file path="app/[slug]/[flow]/edit/components/blocks/EndBlock.tsx">
import React, { useState } from 'react';
import { Handle, Position, NodeProps } from '@xyflow/react';
import { NodeData } from '../../../types';
import { BlockEndType } from '@/types/block';
import { useConnectModeStore } from '../../store/connectModeStore';
import { useEditModeStore } from '../../store/editModeStore';
import { useColors } from '@/app/theme/hooks';
import DynamicIcon from '@/utils/DynamicIcon';
import { BasicBlock } from './BasicBlock';
import { usePathsStore } from '../../store/pathsStore';

function EndBlock(props: NodeProps & { data: NodeData }) {
  const { id, data, selected } = props;
  const isConnectMode = useConnectModeStore((state) => state.isConnectMode);
  const isEditMode = useEditModeStore((state) => state.isEditMode);
  const colors = useColors();
  const [isHovered, setIsHovered] = useState(false);
  const [isDeleteButtonHovered, setIsDeleteButtonHovered] = useState(false);
  const setPaths = usePathsStore((state) => state.setPaths);

  const handleConvertToLast = async (e: React.MouseEvent) => {
    e.stopPropagation();
    // Optimistically update to LAST
    setPaths((currentPaths) => {
      const updatedPaths = currentPaths.map((path) =>
        path.id === data.path?.id
          ? {
              ...path,
              blocks: path.blocks.map((b) =>
                b.id === data.block.id ? { ...b, type: BlockEndType.LAST } : b
              ),
            }
          : path
      );
      if (typeof data.onPathsUpdate === 'function') {
        data.onPathsUpdate(updatedPaths);
      }
      return updatedPaths;
    });
    try {
      await fetch(`/api/blocks/${id.replace('block-', '')}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: BlockEndType.LAST,
        }),
      });
    } catch (error) {
      // Rollback to END if error
      setPaths((currentPaths) => {
        const rolledBackPaths = currentPaths.map((path) =>
          path.id === data.path?.id
            ? {
                ...path,
                blocks: path.blocks.map((b) =>
                  b.id === data.block.id ? { ...b, type: BlockEndType.END } : b
                ),
              }
            : path
        );
        if (typeof data.onPathsUpdate === 'function') {
          data.onPathsUpdate(rolledBackPaths);
        }
        return rolledBackPaths;
      });
      console.error('Error converting to LAST:', error);
    }
  };

  return (
    <BasicBlock {...props}>
      <div
        className={`transition-opacity duration-300 relative ${isConnectMode || isEditMode ? 'opacity-40' : ''}`}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
      >
        {isHovered && (
          <div
            className="absolute -right-1 -top-[40%] flex rounded-lg z-10"
            style={{
              background: colors['bg-secondary'],
              border: `1px solid ${colors['border-primary']}`,
              boxShadow: '0px 1px 2px 0px rgba(16, 24, 40, 0.05)',
            }}
          >
            <button
              onClick={handleConvertToLast}
              onMouseEnter={() => setIsDeleteButtonHovered(true)}
              onMouseLeave={() => setIsDeleteButtonHovered(false)}
              className="flex items-center justify-center p-2 transition-colors duration-200"
              style={{
                borderRadius: '8px',
                background: isDeleteButtonHovered
                  ? colors['bg-tertiary']
                  : colors['bg-secondary'],
              }}
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`}
                alt="Delete"
                className="w-3 h-3"
              />
            </button>
          </div>
        )}

        <div
          className={`transition-all duration-300 flex items-center gap-3 w-fit text-sm relative`}
          style={{
            height: '48px',
            width: '290px',
            padding: '12px 18px',
            borderRadius: '9999px',
            background: colors['utility-error-100'],
            border: `1px solid ${colors['utility-error-200']}`,
          }}
        >
          <Handle
            type="target"
            position={Position.Top}
            id="top"
            style={{
              width: 6,
              height: 6,
              opacity: 0,
              background: '#60a5fa',
              border: '2px solid white',
              pointerEvents: 'none',
            }}
          />
          <DynamicIcon
            url={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/stop-circle-icon.svg`}
            size={16}
            color={colors['utility-error-700']}
            className="w-4 h-4"
          />
          <div
            style={{ color: colors['utility-error-700'] }}
            className="text-sm font-normal flex-1"
          >
            This is where your process ends
          </div>
          <Handle
            type="source"
            position={Position.Bottom}
            id="bottom"
            style={{
              width: 6,
              height: 6,
              opacity: 0,
              background: '#60a5fa',
              border: '2px solid white',
              pointerEvents: 'none',
            }}
          />
        </div>
      </div>
    </BasicBlock>
  );
}

export default EndBlock;
</file>

<file path="app/[slug]/[flow]/edit/components/blocks/EventDelayBlock.tsx">
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { NodeProps, Position, Handle, Node } from '@xyflow/react';
import { DelayType, NodeData } from '../../../types';
import { useColors } from '@/app/theme/hooks';
import { createPortal } from 'react-dom';
import DelayTypeModal from '../modals/DelayTypeModal';
import { usePathsStore } from '../../store/pathsStore';
import { usePathSelectionStore } from '../../store/pathSelectionStore';
import { useUpdateModeStore } from '../../store/updateModeStore';
import { useModalStore } from '../../store/modalStore';
import { BasicBlock } from './BasicBlock';
import { useConnectModeStore } from '../../store/connectModeStore';
import { useStrokeLinesStore } from '../../store/strokeLinesStore';
import { useReactFlow } from '@xyflow/react';
import { CustomTooltip } from '@/app/components/CustomTooltip';

const EventDelayBlock = (props: NodeProps & { data: NodeData }) => {
  const { id, data } = props;
  const colors = useColors();
  const { block } = data;
  const [showDropdown, setShowDropdown] = useState(false);
  const [dropdownPosition, setDropdownPosition] = useState({ x: 0, y: 0 });
  const [showDelayModal, setShowDelayModal] = useState(false);
  const allPaths = usePathsStore((state) => state.paths);
  const setAllPaths = usePathsStore((state) => state.setPaths);
  const setShowConnectModal = useModalStore(
    (state) => state.setShowConnectModal
  );
  const isConnectMode = useConnectModeStore((state) => state.isConnectMode);
  const showConnectModal = useModalStore((state) => state.showConnectModal);
  const connectData = useModalStore((state) => state.connectData);
  const setConnectData = useModalStore((state) => state.setConnectData);
  // --- Checkbox and update checkbox logic ---
  const {
    selectedPaths,
    parentBlockId,
    togglePathSelection,
    mergeMode,
    setMergeMode,
  } = usePathSelectionStore();
  const {
    isUpdateMode,
    setUpdateMode,
    mergePathId,
    setMergePathId,
    setSelectedEndBlocks,
    setOriginalEndBlocks,
    selectedEndBlocks,
    toggleEndBlockSelection,
    originalEndBlocks,
    triggerPathId,
    setTriggerPathId,
  } = useUpdateModeStore();

  // Find the merge block in the current path
  const mergeBlock = React.useMemo(
    () => data.path?.blocks.find((block) => block.type === 'MERGE'),
    [data.path?.blocks]
  );

  // Determine if merging to the same child
  const isMergingToSameChild = React.useMemo(() => {
    const childPaths = mergeBlock?.child_paths;
    if (childPaths && childPaths.length > 0 && mergePathId) {
      return childPaths[0].path_id === mergePathId;
    }
    return true;
  }, [mergeBlock, mergePathId]);

  // Is this the last STEP node in a path?
  const isLastStepInPath =
    data.type === 'STEP' &&
    data.position === (data.path?.blocks.length ?? 0) - 2;

  // Get parent block ID for this path
  const pathParentBlockId = data.path?.parent_blocks?.[0]?.block_id;

  // Check if parent block has more than one child path
  const parentHasMultipleChildPaths = data.hasSiblings;

  // Get the end block and check if it has child paths
  const endBlock = data.path?.blocks.find(
    (block) => block.type === 'END' || block.type === 'LAST'
  );

  // Condition for showing merge-related UI
  const canShowMergeUI =
    parentHasMultipleChildPaths &&
    !data.pathHasChildren &&
    (parentBlockId === null || pathParentBlockId === parentBlockId);

  // Only show if this is the second-to-last block in the path
  const isSecondToLastBlock =
    typeof data.position === 'number' &&
    data.path?.blocks &&
    data.position === data.path.blocks.length - 2;
  // Use this condition for both checkbox and dropdown option
  const showCheckbox = mergeMode && canShowMergeUI && isSecondToLastBlock;

  // --- Update checkbox logic ---
  const showUpdateCheckbox = React.useMemo(() => {
    return (
      isUpdateMode &&
      data.path?.parent_blocks?.[0]?.block_id === triggerPathId &&
      isMergingToSameChild &&
      isSecondToLastBlock
    );
  }, [
    isUpdateMode,
    data.path?.parent_blocks,
    triggerPathId,
    isMergingToSameChild,
    isSecondToLastBlock,
  ]);

  // Get the end block ID for this path
  const endBlockId = data.path?.blocks.find(
    (block) =>
      block.type === 'END' || block.type === 'LAST' || block.type === 'MERGE'
  )?.id;

  // Add useEffect for handling clicks outside dropdown
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (showDropdown) {
        setShowDropdown(false);
      }
    };

    document.addEventListener('click', handleClickOutside);
    return () => {
      document.removeEventListener('click', handleClickOutside);
    };
  }, [showDropdown]);

  const handleConnectClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    setConnectData({
      sourceNode: {
        id,
        data,
        position: { x: 0, y: 0 },
        type: 'custom',
        width: undefined,
        height: undefined,
      } as Node,
    });
    setShowConnectModal(true);
    setShowDropdown(false);
  };

  const handleDropdownToggle = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (!showDropdown) {
      const rect = (e.currentTarget as HTMLElement).getBoundingClientRect();
      const dropdownWidth = 170; // px
      const dropdownHeight = 280; // px, estimate for dropdown height
      const offset = 4; // px

      let x = rect.right - 30;
      // Default: show below
      let y = rect.bottom + offset;

      // Clamp to right edge
      if (x + dropdownWidth > window.innerWidth - 8) {
        x = window.innerWidth - dropdownWidth - 8;
      }
      // Clamp to left edge
      if (x < 8) {
        x = 8;
      }

      // If not enough space below, flip above
      if (y + dropdownHeight > window.innerHeight - 8) {
        // Try to show above the trigger
        y = rect.top - dropdownHeight / 1.5 - offset;
        // If still offscreen, clamp to top
        if (y < 8) y = window.innerHeight - dropdownHeight - 8;
        // If dropdown is taller than viewport, stick to top
        if (y < 8) y = 8;
      }

      setDropdownPosition({ x, y });
    }
    setShowDropdown(!showDropdown);
  };

  const handleModifyDelay = (e: React.MouseEvent) => {
    e.stopPropagation();
    setShowDelayModal(true);
    setShowDropdown(false);
  };

  const handleDelete = (e: React.MouseEvent) => {
    e.stopPropagation();
    data.onDelete?.(id);
    setShowDropdown(false);
  };

  // Add this handler for activating update mode (edit merge)
  const handleUpdateModeActivation = (e: React.MouseEvent) => {
    e.stopPropagation();
    setShowDropdown(false);

    // Get the parent block ID of the current node
    const parentBlockId = data.path?.parent_blocks?.[0]?.block_id;

    if (!parentBlockId) {
      console.error('No parent block found');
      return;
    }

    // Find the merge block in the current path
    const mergeBlock = data.path?.blocks.find(
      (block) => block.type === 'MERGE'
    );

    if (!mergeBlock || !mergeBlock.child_paths[0]) {
      console.error('No merge block or child path found');
      return;
    }

    const mergePathId = mergeBlock.child_paths[0].path_id;
    const mergePath = allPaths.find((path) => path.id === mergePathId);

    if (!mergePath) {
      console.error('Merge path not found');
      return;
    }

    const parentBlocks = mergePath.parent_blocks.map((pb) => pb.block_id);

    setUpdateMode(true);
    setMergePathId(mergePathId);
    setSelectedEndBlocks(parentBlocks);
    setOriginalEndBlocks(parentBlocks);
    setTriggerPathId(parentBlockId); // Set the triggering node's parent block ID
  };

  // Add handleBlockClick function
  const handleBlockClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (!isConnectMode) {
      setShowDelayModal(true);
    }
  };

  const renderDropdown = () => {
    if (!showDropdown) return null;

    return createPortal(
      <div
        style={{
          backgroundColor: colors['bg-secondary'],
          border: `1px solid ${colors['border-primary']}`,
          left: dropdownPosition.x,
          top: dropdownPosition.y,
          zIndex: 99999999,
        }}
        className="fixed shadow-[0px_4px_6px_-2px_rgba(16,24,40,0.03)] py-1 flex flex-col overflow-hidden cursor-pointer rounded-lg"
      >
        {/* Merge paths option */}
        {canShowMergeUI && (
          <div
            onClick={(e) => {
              e.stopPropagation();
              setMergeMode(true);
              togglePathSelection(
                data.path?.id ?? -1,
                endBlock?.id ?? -1,
                pathParentBlockId ?? -1
              );
              setShowDropdown(false);
            }}
            className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
          >
            <div
              style={
                {
                  '--hover-bg': colors['bg-quaternary'],
                } as React.CSSProperties
              }
              className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
            >
              <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
                <div className="w-4 h-4 relative overflow-hidden">
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/git-merge.svg`}
                    alt="Merge Paths"
                    className="w-4 h-4"
                  />
                </div>
                <div
                  style={{ color: colors['text-primary'] }}
                  className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
                >
                  Merge paths
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Edit merge option */}
        {data.pathIsMerged && (
          <div
            onClick={handleUpdateModeActivation}
            className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
          >
            <div
              style={
                {
                  '--hover-bg': colors['bg-quaternary'],
                } as React.CSSProperties
              }
              className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
            >
              <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
                <div className="w-4 h-4 relative overflow-hidden">
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                    alt="Edit Merge"
                    className="w-4 h-4"
                  />
                </div>
                <div
                  style={{ color: colors['text-primary'] }}
                  className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
                >
                  Edit merge
                </div>
              </div>
            </div>
          </div>
        )}

        <div
          onClick={handleConnectClick}
          className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
        >
          <div
            style={
              { '--hover-bg': colors['bg-quaternary'] } as React.CSSProperties
            }
            className="w-[170px] grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300"
          >
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/connect-node.svg`}
                  alt="Modify"
                  className="w-4 h-4"
                />
              </div>
              <div
                style={{ color: colors['text-primary'] }}
                className="text-sm"
              >
                Connect block
              </div>
            </div>
          </div>
        </div>

        <div
          onClick={handleModifyDelay}
          className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
        >
          <div
            style={
              { '--hover-bg': colors['bg-quaternary'] } as React.CSSProperties
            }
            className="w-[170px] grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300"
          >
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                  alt="Modify"
                  className="w-4 h-4"
                />
              </div>
              <div
                style={{ color: colors['text-primary'] }}
                className="text-sm"
              >
                Modify delay
              </div>
            </div>
          </div>
        </div>

        {/* Separator */}
        <div
          style={{ borderColor: colors['border-secondary'] }}
          className="self-stretch h-px border-b my-1"
        />

        <div
          onClick={handleDelete}
          className="self-stretch px-1.5 py-px flex items-center gap-3"
        >
          <div
            style={
              { '--hover-bg': colors['bg-quaternary'] } as React.CSSProperties
            }
            className="w-[170px] grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300"
          >
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`}
                  alt="Delete"
                  className="w-4 h-4"
                />
              </div>
              <div
                style={{ color: colors['text-primary'] }}
                className="text-sm"
              >
                Delete
              </div>
            </div>
          </div>
        </div>
      </div>,
      document.body
    );
  };

  const expirationText = () => {
    if (!block.delay_seconds) return '';
    const days = Math.floor(block.delay_seconds / 86400);
    const hours = Math.floor((block.delay_seconds % 86400) / 3600);
    const minutes = Math.floor((block.delay_seconds % 3600) / 60);

    const parts = [];
    if (days > 0) parts.push(`${days} ${days === 1 ? 'day' : 'days'}`);
    if (hours > 0) parts.push(`${hours} ${hours === 1 ? 'hour' : 'hours'}`);
    if (minutes > 0)
      parts.push(`${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`);

    return parts.length > 0 ? `${parts.join(' and ')}` : '';
  };

  // --- Stroke lines toggle logic ---
  const { allStrokeLinesVisible } = useStrokeLinesStore();
  const { getEdges } = useReactFlow();

  // Tooltip hook (copied from CustomBlock)
  const useTooltip = () => {
    const [showTooltip, setShowTooltip] = useState(false);
    const [tooltipPosition, setTooltipPosition] = useState<number | null>(null);
    const elementRef = useRef<HTMLDivElement>(null);
    const tooltipRef = useRef<HTMLDivElement>(null);

    const handleMouseEnter = useCallback(() => {
      setShowTooltip(true);
    }, []);

    const handleMouseLeave = useCallback(() => {
      setShowTooltip(false);
      setTooltipPosition(null);
    }, []);

    useEffect(() => {
      if (showTooltip && tooltipRef.current && elementRef.current) {
        const toggleRect = elementRef.current.getBoundingClientRect();
        const tooltipRect = tooltipRef.current.getBoundingClientRect();
        const gap = 12; // gap between toggle and tooltip
        setTooltipPosition(-(tooltipRect.width + gap));
      }
    }, [showTooltip]);

    return {
      elementRef,
      tooltipRef,
      showTooltip,
      tooltipPosition,
      handleMouseEnter,
      handleMouseLeave,
    };
  };

  const {
    elementRef,
    tooltipRef,
    showTooltip,
    tooltipPosition,
    handleMouseEnter,
    handleMouseLeave,
  } = useTooltip();

  // Toggle handler (copied from CustomBlock)
  const toggleStrokeLines = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (!allStrokeLinesVisible) return;
    const blockId = parseInt(id.replace('block-', ''));
    const newVisibility = !data.strokeLinesVisible;
    data.updateStrokeLineVisibility?.(blockId, newVisibility);
  };

  return (
    <BasicBlock {...props}>
      {/* --- Vertical Toggle Switch Container (copied from CustomBlock) --- */}
      {getEdges().some(
        (edge) => edge.source === id && edge.type === 'strokeEdge'
      ) &&
        !showConnectModal && (
          <div
            className="absolute top-[50%] -translate-y-1/2 transition-opacity duration-300"
            style={{
              left: '-20px',
              backgroundColor: colors['bg-primary'],
              padding: '4px',
              width: '32px',
              height: '32px',
              borderRadius: '8px',
              boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
              border: `1px solid ${colors['border-secondary']}`,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'flex-start',
              paddingLeft: '6px',
            }}
          >
            <div
              ref={elementRef}
              onClick={toggleStrokeLines}
              className={`${allStrokeLinesVisible ? 'cursor-pointer' : 'cursor-not-allowed'}`}
              style={{
                width: '12px',
                height: '20px',
                borderRadius: '6px',
                backgroundColor:
                  allStrokeLinesVisible && data.strokeLinesVisible
                    ? '#FF69A3'
                    : colors['bg-quaternary'],
                transition: 'background-color 0.2s',
                position: 'relative',
                opacity: allStrokeLinesVisible ? 1 : 0.5,
              }}
              onMouseEnter={handleMouseEnter}
              onMouseLeave={handleMouseLeave}
            >
              <div
                style={{
                  width: '10px',
                  height: '10px',
                  borderRadius: '50%',
                  backgroundColor: colors['bg-primary'],
                  position: 'absolute',
                  left: '1px',
                  top:
                    allStrokeLinesVisible && data.strokeLinesVisible
                      ? '1px'
                      : '9px',
                  transition: 'top 0.2s',
                  boxShadow: '0 1px 2px rgba(0, 0, 0, 0.1)',
                }}
              />
            </div>
          </div>
        )}

      {/* Tooltip for the toggle */}
      {showTooltip && (
        <div
          ref={tooltipRef}
          style={{
            position: 'absolute',
            left: '-210px',
            top: '50%',
            transform: 'translateY(-50%)',
            zIndex: 1000,
            pointerEvents: 'none',
          }}
        >
          <CustomTooltip
            text={
              allStrokeLinesVisible
                ? data.strokeLinesVisible
                  ? 'Hide connecting lines'
                  : 'Show connecting lines'
                : 'Global connecting lines are disabled in Settings'
            }
            show={true}
            direction="left"
          />
        </div>
      )}
      <div
        className={`w-[481px] relative ${
          isConnectMode &&
          id !== connectData?.sourceNode?.id &&
          id !== connectData?.targetNode?.id
            ? 'opacity-40'
            : ''
        }`}
        onClick={handleBlockClick}
      >
        {/* --- Checkbox UI --- */}
        {showCheckbox && (
          <div className="absolute -top-8 left-0 flex items-center gap-2">
            <label
              className="flex items-center gap-2 px-2 py-1 rounded-md bg-gray-900 dark:bg-white border border-gray-700 dark:border-gray-200"
              onClick={e => e.stopPropagation()}
            >
              <input
                type="checkbox"
                checked={selectedPaths.includes(data.path?.id ?? -1)}
                onChange={() =>
                  togglePathSelection(
                    data.path?.id ?? -1,
                    endBlock?.id ?? -1,
                    pathParentBlockId ?? -1
                  )
                }
                style={
                  {
                    borderColor: colors['border-primary'],
                    '--bg-brand-primary': colors['bg-brand-solid'],
                    '--border-brand': colors['border-brand'],
                    '--bg-secondary': colors['bg-primary'],
                  } as React.CSSProperties
                }
                onClick={(e) => e.stopPropagation()}
              />
              <span className="text-sm text-gray-300 dark:text-gray-600">
                {selectedPaths.includes(data.path?.id ?? -1)
                  ? 'Selected'
                  : 'Not selected'}
              </span>
            </label>
          </div>
        )}

        {/* --- Update Checkbox UI --- */}
        {showUpdateCheckbox && endBlockId && (
          <div className="absolute -top-8 left-0 flex items-center gap-2">
            <label
              className="flex items-center gap-2 px-2 py-1 rounded-md bg-gray-900 dark:bg-white border border-gray-700 dark:border-gray-200"
              onClick={e => e.stopPropagation()}
            >
              <input
                type="checkbox"
                checked={selectedEndBlocks.includes(endBlockId)}
                onChange={() => toggleEndBlockSelection(endBlockId)}
                style={
                  {
                    borderColor: colors['border-primary'],
                    '--bg-brand-primary': colors['bg-brand-solid'],
                    '--border-brand': colors['border-brand'],
                    '--bg-secondary': colors['bg-primary'],
                  } as React.CSSProperties
                }
                onClick={(e) => e.stopPropagation()}
              />
              <span className="text-sm text-gray-300 dark:text-gray-600">
                {selectedEndBlocks.includes(endBlockId)
                  ? 'Selected'
                  : 'Not selected'}
              </span>
            </label>
          </div>
        )}

        <Handle
          type="target"
          position={Position.Top}
          id="top"
          style={{
            width: 8,
            height: 8,
            opacity: 0,
            background: colors['fg-brand-primary'],
            border: `2px solid ${colors['bg-primary']}`,
            pointerEvents: 'none',
            cursor: 'default',
          }}
        />
        <div
          className="rounded-lg border-2 flex flex-col"
          style={{
            backgroundColor: colors['bg-primary'],
            borderColor: colors['border-secondary'],
          }}
        >
          {/* Header with separator */}
          <div
            className="p-[17px] flex items-center justify-between"
            style={{
              borderBottom: `1px solid ${colors['border-secondary']}`,
            }}
          >
            <div className="flex items-center gap-3">
              <div
                className="w-10 h-10 rounded-md flex items-center justify-center flex-shrink-0"
                style={{
                  border: `1px solid ${colors['border-secondary']}`,
                }}
              >
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/calendar-clock-1.svg`}
                  alt="Event Delay"
                  className="w-6 h-6"
                />
              </div>
              <div className="flex flex-col gap-0.5">
                <div
                  className="text-xs font-medium"
                  style={{ color: colors['fg-tertiary'] }}
                >
                  Delay
                </div>
                <div
                  className="text-sm font-semibold"
                  style={{ color: colors['fg-primary'] }}
                >
                  Event-Based Delay
                </div>
              </div>
            </div>
            <button
              className="p-1 rounded-md hover:bg-[var(--hover-bg)] transition-all duration-300"
              onClick={handleDropdownToggle}
              style={
                {
                  '--hover-bg': colors['bg-quaternary'],
                } as React.CSSProperties
              }
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dots-horizontal.svg`}
                alt="Menu"
                className="w-5 h-5"
              />
            </button>
          </div>

          {/* Content section */}
          <div className="p-[17px] flex flex-col gap-[13.7px]">
            {block.delay_event && (
              <div className="flex items-center gap-2">
                <span
                  className="text-sm"
                  style={{ color: colors['text-secondary'] }}
                >
                  Waiting for:
                </span>
                <span
                  className="text-sm font-medium line-clamp-2 break-words"
                  style={{
                    color: colors['text-primary'],
                    display: '-webkit-box',
                    WebkitLineClamp: 2,
                    WebkitBoxOrient: 'vertical',
                    overflow: 'hidden',
                  }}
                >
                  {block.delay_event}
                </span>
              </div>
            )}

            {(block.delay_seconds ?? 0) > 0 && (
              <div className="flex items-center gap-2">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/hourglass-01.svg`}
                  alt="Clock"
                  className="w-4 h-4"
                />
                <span
                  className="text-sm"
                  style={{ color: colors['text-secondary'] }}
                >
                  Expires after {expirationText()}
                </span>
              </div>
            )}

            <div
              className="flex items-center gap-2 p-3 rounded-lg bg-opacity-5"
              style={{ backgroundColor: colors['bg-secondary'] }}
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/pause-circle.svg`}
                alt="Info"
                className="w-5 h-5"
              />
              <span
                className="text-sm whitespace-nowrap"
                style={{ color: colors['text-secondary'] }}
              >
                {(block.delay_seconds ?? 0) > 0
                  ? 'Flow paused until event occurs or time expires'
                  : 'Flow paused until event occurs'}
              </span>
            </div>
          </div>
        </div>
        <Handle
          type="source"
          position={Position.Left}
          id="stroke_source"
          style={{
            width: 8,
            height: 8,
            background: colors['fg-tertiary'],
            border: `2px solid ${colors['bg-primary']}`,
            top: '35%',
            opacity: 0,
            pointerEvents: 'none',
          }}
        />
        <Handle
          type="target"
          position={Position.Left}
          id="stroke_target"
          style={{
            width: 8,
            height: 8,
            background: colors['fg-tertiary'],
            border: `2px solid ${colors['bg-primary']}`,
            top: '35%',
            left: 0,
            opacity: 0,
            pointerEvents: 'none',
          }}
        />
        <Handle
          type="target"
          position={Position.Left}
          id="stroke_self_target"
          style={{
            width: 8,
            height: 8,
            background: colors['fg-tertiary'],
            border: `2px solid ${colors['bg-primary']}`,
            top: '65%',
            opacity: 0,
            pointerEvents: 'none',
          }}
        />
        <Handle
          type="source"
          position={Position.Bottom}
          id="bottom"
          style={{
            width: 8,
            height: 8,
            opacity: 0,
            background: colors['fg-brand-primary'],
            border: `2px solid ${colors['bg-primary']}`,
            pointerEvents: 'none',
          }}
        />
        {renderDropdown()}
        {showDelayModal && (
          <DelayTypeModal
            onClose={() => setShowDelayModal(false)}
            onSelect={async (delayType, delayData) => {
              try {
                setShowDelayModal(false);
                const blockId = id.replace('block-', '');
                const response = await fetch(`/api/blocks/${blockId}`, {
                  method: 'PATCH',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    type: 'DELAY',
                    delay_type: delayType,
                    delay_seconds: delayData.seconds,
                    delay_event: delayData.eventName,
                  }),
                });

                if (!response.ok) throw new Error('Failed to update delay');

                const updatedBlock = await response.json();
                const updatedPaths = allPaths.map((path) => ({
                  ...path,
                  blocks: path.blocks.map((block) =>
                    block.id === parseInt(blockId)
                      ? { ...block, ...updatedBlock }
                      : block
                  ),
                }));

                setAllPaths(updatedPaths);
                data.onPathsUpdate?.(updatedPaths);
              } catch (error) {
                console.error('Error updating delay:', error);
              }
            }}
            initialData={{
              delayType: data.delayType || undefined,
              eventName: data.eventName || undefined,
              seconds: data.seconds || undefined,
            }}
          />
        )}
      </div>
    </BasicBlock>
  );
};

export default EventDelayBlock;
</file>

<file path="app/[slug]/[flow]/edit/components/blocks/FixedDelayBlock.tsx">
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { NodeProps, Position, Handle, Node } from '@xyflow/react';
import { DelayType, NodeData } from '../../../types';
import { useColors } from '@/app/theme/hooks';
import { createPortal } from 'react-dom';
import DelayTypeModal from '../modals/DelayTypeModal';
import FixedDelayModal from '../modals/FixedDelayModal';
import EventDelayModal from '../modals/EventDelayModal';
import { usePathsStore } from '../../store/pathsStore';
import { usePathSelectionStore } from '../../store/pathSelectionStore';
import { useUpdateModeStore } from '../../store/updateModeStore';
import { useModalStore } from '../../store/modalStore';
import { BasicBlock } from './BasicBlock';
import { useConnectModeStore } from '../../store/connectModeStore';
import { useStrokeLinesStore } from '../../store/strokeLinesStore';
import { useReactFlow } from '@xyflow/react';
import { CustomTooltip } from '@/app/components/CustomTooltip';

const FixedDelayBlock = (props: NodeProps & { data: NodeData }) => {
  const { id, data } = props;
  const colors = useColors();
  const { block } = data;
  const [showDropdown, setShowDropdown] = useState(false);
  const [dropdownPosition, setDropdownPosition] = useState({ x: 0, y: 0 });
  const [showDelayModal, setShowDelayModal] = useState(false);
  const [showFixedDelayModal, setShowFixedDelayModal] = useState(false);
  const [showEventDelayModal, setShowEventDelayModal] = useState(false);
  const allPaths = usePathsStore((state) => state.paths);
  const setAllPaths = usePathsStore((state) => state.setPaths);
  const setShowConnectModal = useModalStore(
    (state) => state.setShowConnectModal
  );
  const isConnectMode = useConnectModeStore((state) => state.isConnectMode);
  const showConnectModal = useModalStore((state) => state.showConnectModal);
  const connectData = useModalStore((state) => state.connectData);
  const setConnectData = useModalStore((state) => state.setConnectData);
  // --- Checkbox and update checkbox logic ---
  const {
    selectedPaths,
    parentBlockId,
    togglePathSelection,
    mergeMode,
    setMergeMode,
  } = usePathSelectionStore();
  const {
    isUpdateMode,
    setUpdateMode,
    mergePathId,
    setMergePathId,
    setSelectedEndBlocks,
    setOriginalEndBlocks,
    selectedEndBlocks,
    toggleEndBlockSelection,
    originalEndBlocks,
    triggerPathId,
    setTriggerPathId,
  } = useUpdateModeStore();

  // --- Stroke lines toggle logic ---
  const { allStrokeLinesVisible } = useStrokeLinesStore();
  const { getEdges } = useReactFlow();

  // Tooltip hook (copied from CustomBlock)
  const useTooltip = () => {
    const [showTooltip, setShowTooltip] = useState(false);
    const [tooltipPosition, setTooltipPosition] = useState<number | null>(null);
    const elementRef = useRef<HTMLDivElement>(null);
    const tooltipRef = useRef<HTMLDivElement>(null);

    const handleMouseEnter = useCallback(() => {
      setShowTooltip(true);
    }, []);

    const handleMouseLeave = useCallback(() => {
      setShowTooltip(false);
      setTooltipPosition(null);
    }, []);

    useEffect(() => {
      if (showTooltip && tooltipRef.current && elementRef.current) {
        const toggleRect = elementRef.current.getBoundingClientRect();
        const tooltipRect = tooltipRef.current.getBoundingClientRect();
        const gap = 12; // gap between toggle and tooltip
        setTooltipPosition(-(tooltipRect.width + gap));
      }
    }, [showTooltip]);

    return {
      elementRef,
      tooltipRef,
      showTooltip,
      tooltipPosition,
      handleMouseEnter,
      handleMouseLeave,
    };
  };

  const {
    elementRef,
    tooltipRef,
    showTooltip,
    tooltipPosition,
    handleMouseEnter,
    handleMouseLeave,
  } = useTooltip();

  // Toggle handler (copied from CustomBlock)
  const toggleStrokeLines = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (!allStrokeLinesVisible) return;
    const blockId = parseInt(id.replace('block-', ''));
    const newVisibility = !data.strokeLinesVisible;
    data.updateStrokeLineVisibility?.(blockId, newVisibility);
  };

  // Find the merge block in the current path
  const mergeBlock = React.useMemo(
    () => data.path?.blocks.find((block) => block.type === 'MERGE'),
    [data.path?.blocks]
  );

  // Determine if merging to the same child
  const isMergingToSameChild = React.useMemo(() => {
    const childPaths = mergeBlock?.child_paths;
    if (childPaths && childPaths.length > 0 && mergePathId) {
      return childPaths[0].path_id === mergePathId;
    }
    return true;
  }, [mergeBlock, mergePathId]);

  // Is this the last STEP node in a path?
  const isLastStepInPath =
    data.type === 'STEP' &&
    data.position === (data.path?.blocks.length ?? 0) - 2;

  // Get parent block ID for this path
  const pathParentBlockId = data.path?.parent_blocks?.[0]?.block_id;

  // Check if parent block has more than one child path
  const parentHasMultipleChildPaths = data.hasSiblings;

  // Get the end block and check if it has child paths
  const endBlock = data.path?.blocks.find(
    (block) => block.type === 'END' || block.type === 'LAST'
  );

  // Condition for showing merge-related UI
  const canShowMergeUI =
    parentHasMultipleChildPaths &&
    !data.pathHasChildren &&
    (parentBlockId === null || pathParentBlockId === parentBlockId);

  // Only show if this is the second-to-last block in the path
  const isSecondToLastBlock =
    typeof data.position === 'number' &&
    data.path?.blocks &&
    data.position === data.path.blocks.length - 2;
  // Use this condition for both checkbox and dropdown option
  const showCheckbox = mergeMode && canShowMergeUI && isSecondToLastBlock;

  // --- Update checkbox logic ---
  const showUpdateCheckbox = React.useMemo(() => {
    return (
      isUpdateMode &&
      data.path?.parent_blocks?.[0]?.block_id === triggerPathId &&
      isMergingToSameChild &&
      isSecondToLastBlock
    );
  }, [
    isUpdateMode,
    data.path?.parent_blocks,
    triggerPathId,
    isMergingToSameChild,
    isSecondToLastBlock,
  ]);

  // Get the end block ID for this path
  const endBlockId = data.path?.blocks.find(
    (block) =>
      block.type === 'END' || block.type === 'LAST' || block.type === 'MERGE'
  )?.id;

  // Add useEffect for handling clicks outside dropdown
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (showDropdown) {
        setShowDropdown(false);
      }
    };

    document.addEventListener('click', handleClickOutside);
    return () => {
      document.removeEventListener('click', handleClickOutside);
    };
  }, [showDropdown]);

  const handleDropdownToggle = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (!showDropdown) {
      const rect = (e.currentTarget as HTMLElement).getBoundingClientRect();
      const dropdownWidth = 170; // px
      const dropdownHeight = 280; // px, estimate for dropdown height
      const offset = 4; // px

      let x = rect.right - 30;
      // Default: show below
      let y = rect.bottom + offset;

      // Clamp to right edge
      if (x + dropdownWidth > window.innerWidth - 8) {
        x = window.innerWidth - dropdownWidth - 8;
      }
      // Clamp to left edge
      if (x < 8) {
        x = 8;
      }

      // If not enough space below, flip above
      if (y + dropdownHeight > window.innerHeight - 8) {
        // Try to show above the trigger
        y = rect.top - dropdownHeight / 1.5 - offset;
        // If still offscreen, clamp to top
        if (y < 8) y = window.innerHeight - dropdownHeight - 8;
        // If dropdown is taller than viewport, stick to top
        if (y < 8) y = 8;
      }

      setDropdownPosition({ x, y });
    }
    setShowDropdown(!showDropdown);
  };

  const handleConnectClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    setConnectData({
      sourceNode: {
        id,
        data,
        position: { x: 0, y: 0 },
        type: 'custom',
        width: undefined,
        height: undefined,
      } as Node,
    });
    setShowConnectModal(true);
    setShowDropdown(false);
  };

  const handleModifyDelay = (e: React.MouseEvent) => {
    e.stopPropagation();
    setShowDelayModal(true);
    setShowDropdown(false);
  };

  const handleDelete = (e: React.MouseEvent) => {
    e.stopPropagation();
    data.onDelete?.(id);
    setShowDropdown(false);
  };

  // Add this handler for activating update mode (edit merge)
  const handleUpdateModeActivation = (e: React.MouseEvent) => {
    e.stopPropagation();
    setShowDropdown(false);

    // Get the parent block ID of the current node
    const parentBlockId = data.path?.parent_blocks?.[0]?.block_id;

    if (!parentBlockId) {
      console.error('No parent block found');
      return;
    }

    // Find the merge block in the current path
    const mergeBlock = data.path?.blocks.find(
      (block) => block.type === 'MERGE'
    );

    if (!mergeBlock || !mergeBlock.child_paths[0]) {
      console.error('No merge block or child path found');
      return;
    }

    const mergePathId = mergeBlock.child_paths[0].path_id;
    const mergePath = allPaths.find((path) => path.id === mergePathId);

    if (!mergePath) {
      console.error('Merge path not found');
      return;
    }

    const parentBlocks = mergePath.parent_blocks.map((pb) => pb.block_id);

    setUpdateMode(true);
    setMergePathId(mergePathId);
    setSelectedEndBlocks(parentBlocks);
    setOriginalEndBlocks(parentBlocks);
    setTriggerPathId(parentBlockId); // Set the triggering node's parent block ID
  };

  // Add handleBlockClick function
  const handleBlockClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (!isConnectMode) {
      setShowDelayModal(true);
    }
  };

  const renderDropdown = () => {
    if (!showDropdown) return null;
    return createPortal(
      <div
        style={{
          backgroundColor: colors['bg-secondary'],
          border: `1px solid ${colors['border-primary']}`,
          left: dropdownPosition.x,
          top: dropdownPosition.y,
          zIndex: 99999999,
        }}
        className="fixed shadow-[0px_4px_6px_-2px_rgba(16,24,40,0.03)] py-1 flex flex-col overflow-hidden cursor-pointer rounded-lg"
      >
        {/* Merge paths option */}
        {canShowMergeUI && (
          <div
            onClick={(e) => {
              e.stopPropagation();
              setMergeMode(true);
              togglePathSelection(
                data.path?.id ?? -1,
                endBlock?.id ?? -1,
                pathParentBlockId ?? -1
              );
              setShowDropdown(false);
            }}
            className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
          >
            <div
              style={
                {
                  '--hover-bg': colors['bg-quaternary'],
                } as React.CSSProperties
              }
              className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
            >
              <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
                <div className="w-4 h-4 relative overflow-hidden">
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/git-merge.svg`}
                    alt="Merge Paths"
                    className="w-4 h-4"
                  />
                </div>
                <div
                  style={{ color: colors['text-primary'] }}
                  className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
                >
                  Merge paths
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Edit merge option */}
        {data.pathIsMerged && (
          <div
            onClick={handleUpdateModeActivation}
            className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
          >
            <div
              style={
                {
                  '--hover-bg': colors['bg-quaternary'],
                } as React.CSSProperties
              }
              className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
            >
              <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
                <div className="w-4 h-4 relative overflow-hidden">
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                    alt="Edit Merge"
                    className="w-4 h-4"
                  />
                </div>
                <div
                  style={{ color: colors['text-primary'] }}
                  className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
                >
                  Edit merge
                </div>
              </div>
            </div>
          </div>
        )}
        <div
          onClick={handleConnectClick}
          className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
        >
          <div
            style={
              { '--hover-bg': colors['bg-quaternary'] } as React.CSSProperties
            }
            className="w-[170px] grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300"
          >
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/connect-node.svg`}
                  alt="Modify"
                  className="w-4 h-4"
                />
              </div>
              <div
                style={{ color: colors['text-primary'] }}
                className="text-sm"
              >
                Connect block
              </div>
            </div>
          </div>
        </div>

        <div
          onClick={handleModifyDelay}
          className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
        >
          <div
            style={
              { '--hover-bg': colors['bg-quaternary'] } as React.CSSProperties
            }
            className="w-[170px] grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300"
          >
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                  alt="Modify"
                  className="w-4 h-4"
                />
              </div>
              <div
                style={{ color: colors['text-primary'] }}
                className="text-sm"
              >
                Modify delay
              </div>
            </div>
          </div>
        </div>

        <div
          style={{ borderColor: colors['border-secondary'] }}
          className="self-stretch h-px border-b my-1"
        />

        <div
          onClick={handleDelete}
          className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
        >
          <div
            style={
              { '--hover-bg': colors['bg-quaternary'] } as React.CSSProperties
            }
            className="w-[170px] grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300"
          >
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`}
                  alt="Delete"
                  className="w-4 h-4"
                />
              </div>
              <div
                style={{ color: colors['text-primary'] }}
                className="text-sm"
              >
                Delete delay
              </div>
            </div>
          </div>
        </div>
      </div>,
      document.body
    );
  };

  const delayText = () => {
    if (!block.delay_seconds) return '';
    const days = Math.floor(block.delay_seconds / 86400);
    const hours = Math.floor((block.delay_seconds % 86400) / 3600);
    const minutes = Math.floor((block.delay_seconds % 3600) / 60);

    const parts = [];
    if (days > 0) parts.push(`${days} ${days === 1 ? 'day' : 'days'}`);
    if (hours > 0) parts.push(`${hours} ${hours === 1 ? 'hour' : 'hours'}`);
    if (minutes > 0)
      parts.push(`${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`);

    return parts.join(' and ');
  };

  return (
    <BasicBlock {...props}>
      {/* --- Vertical Toggle Switch Container (copied from CustomBlock) --- */}
      {getEdges().some(
        (edge) => edge.source === id && edge.type === 'strokeEdge'
      ) &&
        !showConnectModal && (
          <div
            className="absolute top-[50%] -translate-y-1/2 transition-opacity duration-300"
            style={{
              left: '-20px',
              backgroundColor: colors['bg-primary'],
              padding: '4px',
              width: '32px',
              height: '32px',
              borderRadius: '8px',
              boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
              border: `1px solid ${colors['border-secondary']}`,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'flex-start',
              paddingLeft: '6px',
            }}
          >
            <div
              ref={elementRef}
              onClick={toggleStrokeLines}
              className={`${allStrokeLinesVisible ? 'cursor-pointer' : 'cursor-not-allowed'}`}
              style={{
                width: '12px',
                height: '20px',
                borderRadius: '6px',
                backgroundColor:
                  allStrokeLinesVisible && data.strokeLinesVisible
                    ? '#FF69A3'
                    : colors['bg-quaternary'],
                transition: 'background-color 0.2s',
                position: 'relative',
                opacity: allStrokeLinesVisible ? 1 : 0.5,
              }}
              onMouseEnter={handleMouseEnter}
              onMouseLeave={handleMouseLeave}
            >
              <div
                style={{
                  width: '10px',
                  height: '10px',
                  borderRadius: '50%',
                  backgroundColor: colors['bg-primary'],
                  position: 'absolute',
                  left: '1px',
                  top:
                    allStrokeLinesVisible && data.strokeLinesVisible
                      ? '1px'
                      : '9px',
                  transition: 'top 0.2s',
                  boxShadow: '0 1px 2px rgba(0, 0, 0, 0.1)',
                }}
              />
            </div>
          </div>
        )}

      {/* Tooltip for the toggle */}
      {showTooltip && (
        <div
          ref={tooltipRef}
          style={{
            position: 'absolute',
            left: '-210px',
            top: '50%',
            transform: 'translateY(-50%)',
            zIndex: 1000,
            pointerEvents: 'none',
          }}
        >
          <CustomTooltip
            text={
              allStrokeLinesVisible
                ? data.strokeLinesVisible
                  ? 'Hide connecting lines'
                  : 'Show connecting lines'
                : 'Global connecting lines are disabled in Settings'
            }
            show={true}
            direction="left"
          />
        </div>
      )}

      <div
        className={`w-[481px] relative ${
          isConnectMode &&
          id !== connectData?.sourceNode?.id &&
          id !== connectData?.targetNode?.id
            ? 'opacity-40'
            : ''
        }`}
        onClick={handleBlockClick}
      >
        {/* --- Checkbox UI --- */}
        {showCheckbox && (
          <div className="absolute -top-8 left-0 flex items-center gap-2">
            <label
              className="flex items-center gap-2 px-2 py-1 rounded-md bg-gray-900 dark:bg-white border border-gray-700 dark:border-gray-200"
              onClick={e => e.stopPropagation()}
            >
              <input
                type="checkbox"
                checked={selectedPaths.includes(data.path?.id ?? -1)}
                onChange={() =>
                  togglePathSelection(
                    data.path?.id ?? -1,
                    endBlock?.id ?? -1,
                    pathParentBlockId ?? -1
                  )
                }
                style={
                  {
                    borderColor: colors['border-primary'],
                    '--bg-brand-primary': colors['bg-brand-solid'],
                    '--border-brand': colors['border-brand'],
                    '--bg-secondary': colors['bg-primary'],
                  } as React.CSSProperties
                }
                onClick={(e) => e.stopPropagation()}
              />
              <span className="text-sm text-gray-300 dark:text-gray-600">
                {selectedPaths.includes(data.path?.id ?? -1)
                  ? 'Selected'
                  : 'Not selected'}
              </span>
            </label>
          </div>
        )}

        {/* --- Update Checkbox UI --- */}
        {showUpdateCheckbox && endBlockId && (
          <div className="absolute -top-8 left-0 flex items-center gap-2">
            <label
              className="flex items-center gap-2 px-2 py-1 rounded-md bg-gray-900 dark:bg-white border border-gray-700 dark:border-gray-200"
              onClick={e => e.stopPropagation()}
            >
              <input
                type="checkbox"
                checked={selectedEndBlocks.includes(endBlockId)}
                onChange={() => toggleEndBlockSelection(endBlockId)}
                style={
                  {
                    borderColor: colors['border-primary'],
                    '--bg-brand-primary': colors['bg-brand-solid'],
                    '--border-brand': colors['border-brand'],
                    '--bg-secondary': colors['bg-primary'],
                  } as React.CSSProperties
                }
                onClick={(e) => e.stopPropagation()}
              />
              <span className="text-sm text-gray-300 dark:text-gray-600">
                {selectedEndBlocks.includes(endBlockId)
                  ? 'Selected'
                  : 'Not selected'}
              </span>
            </label>
          </div>
        )}

        <Handle
          type="target"
          position={Position.Top}
          id="top"
          style={{
            width: 8,
            height: 8,
            opacity: 0,
            background: colors['fg-brand-primary'],
            border: `2px solid ${colors['bg-primary']}`,
            pointerEvents: 'none',
          }}
        />
        <div
          className="rounded-lg border-2 flex flex-col"
          style={{
            backgroundColor: colors['bg-primary'],
            borderColor: colors['border-secondary'],
          }}
        >
          {/* Header with separator */}
          <div 
            className="p-[17px] flex items-center justify-between"
            style={{
              borderBottom: `1px solid ${colors['border-secondary']}`
            }}
          >
            <div className="flex items-center gap-3">
              <div
                className="w-10 h-10 rounded-md flex items-center justify-center flex-shrink-0"
                style={{
                  border: `1px solid ${colors['border-secondary']}`,
                }}
              >
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/clock-stopwatch-1.svg`}
                  alt="Fixed Delay"
                  className="w-6 h-6"
                />
              </div>
              <div className="flex flex-col gap-0.5">
                <div className="text-xs font-medium" style={{ color: colors['fg-tertiary'] }}>
                  Delay
                </div>
                <div className="text-sm font-semibold" style={{ color: colors['fg-primary'] }}>
                  Fixed Duration
                </div>
              </div>
            </div>
            <button
              className="p-1 rounded-md hover:bg-[var(--hover-bg)] transition-all duration-300"
              onClick={handleDropdownToggle}
              style={
                {
                  '--hover-bg': colors['bg-quaternary'],
                } as React.CSSProperties
              }
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dots-horizontal.svg`}
                alt="Menu"
                className="w-5 h-5"
              />
            </button>
          </div>

          {/* Content section */}
          <div className="p-[17px] flex flex-col gap-[13.7px]">
            {/* Tooltip */}
            <div
              className="flex items-center gap-2 p-3 rounded-lg bg-opacity-5"
              style={{ backgroundColor: colors['bg-secondary'] }}
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/pause-circle.svg`}
                alt="Info"
                className="w-5 h-5"
              />
              <span
                className="text-sm"
                style={{ color: colors['text-secondary'] }}
              >
                Flow paused for {delayText()}
              </span>
            </div>
          </div>
        </div>
        <Handle
          type="source"
          position={Position.Left}
          id="stroke_source"
          style={{
            width: 8,
            height: 8,
            background: colors['fg-tertiary'],
            border: `2px solid ${colors['bg-primary']}`,
            top: '35%',
            opacity: 0,
            pointerEvents: 'none',
          }}
        />
        <Handle
          type="target"
          position={Position.Left}
          id="stroke_target"
          style={{
            width: 8,
            height: 8,
            background: colors['fg-tertiary'],
            border: `2px solid ${colors['bg-primary']}`,
            top: '35%',
            left: 0,
            opacity: 0,
            pointerEvents: 'none',
          }}
        />
        <Handle
          type="target"
          position={Position.Left}
          id="stroke_self_target"
          style={{
            width: 8,
            height: 8,
            background: colors['fg-tertiary'],
            border: `2px solid ${colors['bg-primary']}`,
            top: '65%',
            opacity: 0,
            pointerEvents: 'none',
          }}
        />
        <Handle
          type="source"
          position={Position.Bottom}
          id="bottom"
          style={{
            width: 8,
            height: 8,
            opacity: 0,
            background: colors['fg-brand-primary'],
            border: `2px solid ${colors['bg-primary']}`,
            pointerEvents: 'none',
          }}
        />
        {renderDropdown()}
        {showDelayModal && (
          <DelayTypeModal
            onClose={() => setShowDelayModal(false)}
            onSelect={async (delayType, delayData) => {
              try {
                setShowDelayModal(false);
                const blockId = id.replace('block-', '');
                const response = await fetch(`/api/blocks/${blockId}`, {
                  method: 'PATCH',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    type: 'DELAY',
                    delay_type: delayType,
                    delay_seconds: delayData.seconds,
                    delay_event: delayData.eventName,
                  }),
                });

                if (!response.ok) throw new Error('Failed to update delay');

                const updatedBlock = await response.json();
                const updatedPaths = allPaths.map((path) => ({
                  ...path,
                  blocks: path.blocks.map((block) =>
                    block.id === parseInt(blockId)
                      ? { ...block, ...updatedBlock }
                      : block
                  ),
                }));

                setAllPaths(updatedPaths);
                data.onPathsUpdate?.(updatedPaths);
              } catch (error) {
                console.error('Error updating delay:', error);
              }
            }}
            initialData={{
              delayType: data.delayType || undefined,
              eventName: data.eventName || undefined,
              seconds: data.seconds || undefined,
            }}
          />
        )}
      </div>
    </BasicBlock>
  );
};

export default FixedDelayBlock;
</file>

<file path="app/[slug]/[flow]/edit/components/blocks/InvisibleBlock.tsx">
import React from 'react';
import { NodeProps } from '@xyflow/react';
import { NodeData } from '../../../types';
import { BasicBlock } from './BasicBlock';

interface InvisibleBlockProps extends NodeProps {
  data: NodeData;
  id: string;
}

function InvisibleBlock(props: NodeProps & { data: NodeData }) {
  return (
    <BasicBlock {...props}>
      <div className="w-full h-[120px] pointer-events-none" />
    </BasicBlock>
  );
}

export default InvisibleBlock;
</file>

<file path="app/[slug]/[flow]/edit/components/blocks/LastBlock.tsx">
import React from 'react';
import { Handle, Position, NodeProps } from '@xyflow/react';
import { NodeData } from '../../../types';
import { useConnectModeStore } from '../../store/connectModeStore';
import { useEditModeStore } from '../../store/editModeStore';
import { useColors } from '@/app/theme/hooks';
import { BasicBlock } from './BasicBlock';

function LastBlock(props: NodeProps & { data: NodeData }) {
  const { id, data, selected } = props;

  // Find the block before this one in its path
  const pathBlocks = data.path?.blocks || [];
  const thisBlockIndex = pathBlocks.findIndex((b) => b.id === data.block.id);
  const prevBlock = thisBlockIndex > 0 ? pathBlocks[thisBlockIndex - 1] : null;

  // If the previous block is_endpoint, hide this component
  if (prevBlock && prevBlock.is_endpoint) {
    return null;
  }

  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (data.handleAddBlockOnEdge && data.path) {
      data.handleAddBlockOnEdge(data.position, data.path, e);
    }
  };

  const colors = useColors();
  const isConnectMode = useConnectModeStore((state) => state.isConnectMode);
  const isEditMode = useEditModeStore((state) => state.isEditMode);
  return (
    <BasicBlock {...props}>
      <div
        className={`transition-opacity duration-300 ${isConnectMode || isEditMode ? 'opacity-40' : ''}`}
      >
        <Handle
          type="target"
          position={Position.Top}
          id="top"
          style={{
            width: 8,
            height: 8,
            opacity: 0,
            background: colors['button-primary-bg'],
            border: `2px solid ${colors['base-white']}`,
            pointerEvents: 'none',
          }}
        />
        <button
          onClick={handleClick}
          className="w-8 h-8 border-2 rounded-full transition-colors flex items-center justify-center"
          style={{
            background: colors['bg-primary'],
            borderColor: colors['button-primary-bg'],
            color: colors['button-primary-bg'],
          }}
          onMouseOver={(e) => {
            e.currentTarget.style.background = colors['bg-primary_hover'];
          }}
          onMouseOut={(e) => {
            e.currentTarget.style.background = colors['bg-primary'];
          }}
        >
          <img
            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/plus-icon.svg`}
            alt="Add"
            className="w-6 h-6"
          />
        </button>
        <Handle
          type="source"
          position={Position.Bottom}
          id="bottom"
          style={{
            width: 8,
            height: 8,
            opacity: 0,
            background: colors['button-primary-bg'],
            border: `2px solid ${colors['base-white']}`,
            pointerEvents: 'none',
          }}
        />
      </div>
    </BasicBlock>
  );
}

export default LastBlock;
</file>

<file path="app/[slug]/[flow]/edit/components/blocks/MergeBlock.tsx">
import React from 'react';
import { Handle, Position, NodeProps } from '@xyflow/react';
import { NodeData } from '../../../types';
import { useConnectModeStore } from '../../store/connectModeStore';
import { useEditModeStore } from '../../store/editModeStore';
import { BasicBlock } from './BasicBlock';

interface MergeNodeProps extends NodeProps {
  data: NodeData;
  id: string;
}

function MergeBlock(props: NodeProps & { data: NodeData }) {
  const { id, data } = props;
  const isConnectMode = useConnectModeStore((state) => state.isConnectMode);
  const isEditMode = useEditModeStore((state) => state.isEditMode);
  return (
    <BasicBlock {...props}>
      <div
        className={`transition-opacity duration-300 ${isConnectMode || isEditMode ? 'opacity-50' : 'opacity-100'}`}
      >
        <Handle
          type="target"
          id="top"
          position={Position.Top}
          style={{
            background: '#b1b1b7',
            width: 1,
            height: 1,
            opacity: 0,
          }}
        />
        <div className="w-1 h-1 rounded-full bg-[#b1b1b7]" />
        <Handle
          type="source"
          id="bottom"
          position={Position.Bottom}
          style={{
            background: '#b1b1b7',
            width: 1,
            height: 1,
            opacity: 0,
          }}
        />
      </div>
    </BasicBlock>
  );
}

export default MergeBlock;
</file>

<file path="app/[slug]/[flow]/edit/components/blocks/PathBlock.tsx">
import React, { useState, useRef, useEffect, useCallback } from 'react';
import { Handle, Position, NodeProps, Node } from '@xyflow/react';
import { NodeData } from '../../../types';
import UpdatePathModal from '../modals/UpdatePathModal';
import { createChildPaths } from '../../utils/createChildPaths';
import { useConnectModeStore } from '../../store/connectModeStore';
import { useEditModeStore } from '../../store/editModeStore';
import { useColors } from '@/app/theme/hooks';
import { BasicBlock } from './BasicBlock';
import { createPortal } from 'react-dom';
import collectAllPathIds from '../../utils/collectAllPathIds';
import { usePathsStore } from '../../store/pathsStore';
import { BlockEndType } from '@/types/block';
import { useModalStore } from '../../store/modalStore';
import { useStrokeLinesStore } from '../../store/strokeLinesStore';
import { useReactFlow } from '@xyflow/react';
import { CustomTooltip } from '@/app/components/CustomTooltip';

function PathBlock(props: NodeProps & { data: NodeData }) {
  const { id, data, selected } = props;
  const [showModal, setShowModal] = useState(false);
  const [showDropdown, setShowDropdown] = useState(false);
  const [dropdownPosition, setDropdownPosition] = useState<{
    x: number;
    y: number;
  }>({ x: 0, y: 0 });
  const dropdownRef = useRef<HTMLDivElement>(null);
  const isConnectMode = useConnectModeStore((state) => state.isConnectMode);
  const setShowConnectModal = useModalStore(
    (state) => state.setShowConnectModal
  );
  const showConnectModal = useModalStore((state) => state.showConnectModal);
  const connectData = useModalStore((state) => state.connectData);
  const setConnectData = useModalStore((state) => state.setConnectData);
  const isEditMode = useEditModeStore((state) => state.isEditMode);
  const colors = useColors();
  const allPaths = usePathsStore((state) => state.paths);
  const setAllPaths = usePathsStore((state) => state.setPaths);
  const { allStrokeLinesVisible } = useStrokeLinesStore();
  const { getEdges } = useReactFlow();

  // Find the path block to get the count of existing child paths
  const pathBlock = data.path?.blocks.find(
    (block: { id: number }) => block.id === parseInt(id.replace('block-', ''))
  );

  const existingPathsCount = pathBlock?.child_paths?.length || 0;
  // Get the names and IDs of existing child paths
  const existingPaths: { id: number; name: string }[] =
    pathBlock?.child_paths?.map((cp) => ({
      id: cp.path.id,
      name: cp.path.name,
    })) || [];

  // Add URL regex constant
  const URL_REGEX = /(https?:\/\/[^\s]+)/g;

  // Add parseTextWithLinks function
  const parseTextWithLinks = (text: string) => {
    const parts = [];
    let lastIndex = 0;
    let match;

    while ((match = URL_REGEX.exec(text)) !== null) {
      // Add text before the link
      if (match.index > lastIndex) {
        parts.push({
          type: 'text',
          content: text.slice(lastIndex, match.index),
        });
      }

      // Add the link
      parts.push({
        type: 'link',
        content: match[0],
      });

      lastIndex = match.index + match[0].length;
    }

    // Add remaining text after last link
    if (lastIndex < text.length) {
      parts.push({
        type: 'text',
        content: text.slice(lastIndex),
      });
    }

    return parts.length > 0 ? parts : [{ type: 'text', content: text }];
  };

  const handleBlockClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (!isConnectMode && !isEditMode && !showModal) {
      setShowModal(true);
    }
  };

  const handleConnectClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    setConnectData({
      sourceNode: {
        id,
        data,
        position: { x: 0, y: 0 },
        type: 'custom',
        width: undefined,
        height: undefined,
      } as Node,
    });
    setShowConnectModal(true);
    setShowDropdown(false);
  };
  /**
   * Handles updating, adding, and removing child paths.
   * @param modalData Object containing condition name, description, icon, and path updates
   */
  const handleCreateChildPaths = async (modalData: {
    conditionName: string;
    conditionDescription: string;
    icon?: string;
    pathsToUpdate: { index: number; name: string }[];
    pathsToAdd: string[];
    pathsToRemove: { index: number; name: string }[];
  }) => {
    try {
      setShowModal(false);

      if (!data.path?.workflow_id || !data.path) {
        throw new Error('Path data is missing');
      }

      // Add new paths
      if (modalData.pathsToAdd.length > 0) {
        await createChildPaths(
          modalData.pathsToAdd,
          data.path.workflow_id,
          data.path
        );
      }

      // Delete removed paths
      if (modalData.pathsToRemove.length > 0) {
        const pathsToRemoveIds = modalData.pathsToRemove.map(
          (path) => existingPaths[path.index].id
        );
        await Promise.all(
          pathsToRemoveIds.map(async (id) => {
            await fetch(`/api/paths/${id}`, {
              method: 'DELETE',
            });
          })
        );
      }

      // Update existing paths
      if (modalData.pathsToUpdate.length > 0) {
        const pathsToUpdateIdsandname = modalData.pathsToUpdate.map((path) => ({
          id: existingPaths[path.index].id,
          name: path.name,
        }));
        await Promise.all(
          pathsToUpdateIdsandname.map(async (path) => {
            await fetch(`/api/paths/${path.id}`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ name: path.name }),
            });
          })
        );
      }

      // Update the block with condition data
      await fetch(`/api/blocks/${pathBlock?.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: modalData.conditionName,
          title: modalData.conditionName,
          description: modalData.conditionDescription,
          icon: modalData.icon,
        }),
      });

      // Just fetch the updated paths to refresh the UI
      const pathsResponse = await fetch(
        `/api/workspace/${data.path.workflow_id}/paths?workflow_id=${data.path.workflow_id}`
      );
      if (pathsResponse.ok) {
        const pathsData = await pathsResponse.json();
        data.onPathsUpdate?.(pathsData.paths);
      }
    } catch (error) {
      console.error('Error managing child paths:', error);
    }
  };

  // Close dropdown when clicking outside
  useEffect(() => {
    if (!showDropdown) return;

    const handleClickOutside = (event: MouseEvent) => {
      setShowDropdown(false);
    };

    const handleEsc = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        setShowDropdown(false);
      }
    };

    document.addEventListener('click', handleClickOutside);
    document.addEventListener('keydown', handleEsc);

    return () => {
      document.removeEventListener('click', handleClickOutside);
      document.removeEventListener('keydown', handleEsc);
    };
  }, [showDropdown]);

  const handleDropdownToggle = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (!showDropdown) {
      const rect = (e.currentTarget as HTMLElement).getBoundingClientRect();
      const dropdownWidth = 170; // px
      const dropdownHeight = 280; // px, estimate for dropdown height
      const offset = 4; // px

      let x = rect.right - 30;
      // Default: show below
      let y = rect.bottom + offset;

      // Clamp to right edge
      if (x + dropdownWidth > window.innerWidth - 8) {
        x = window.innerWidth - dropdownWidth - 8;
      }
      // Clamp to left edge
      if (x < 8) {
        x = 8;
      }

      // If not enough space below, flip above
      if (y + dropdownHeight > window.innerHeight - 8) {
        // Try to show above the trigger
        y = rect.top - dropdownHeight / 1.5 - offset;
        // If still offscreen, clamp to top
        if (y < 8) y = window.innerHeight - dropdownHeight - 8;
        // If dropdown is taller than viewport, stick to top
        if (y < 8) y = 8;
      }

      setDropdownPosition({ x, y });
    }
    setShowDropdown(!showDropdown);
  };

  const handleEdit = (e: React.MouseEvent) => {
    e.stopPropagation();
    setShowDropdown(false);
    setShowModal(true);
  };

  const handleDelete = async (e: React.MouseEvent) => {
    e.stopPropagation();
    setShowDropdown(false);

    if (!data.path) {
      console.error('Path data is missing');
      return;
    }
    const path = allPaths.find((p) => p.id === data.path?.id);
    if (!path) {
      console.error('Path not found');
      return;
    }

    // 1. Prepare blocksToDelete and previousPaths
    const blocksToDelete = [data.block.id];
    const previousPaths = allPaths;

    // 2. Find the last block to delete by position
    const blocksToDeleteSet = new Set(blocksToDelete);
    const blocksToDeleteInPath = data.path.blocks.filter((b) =>
      blocksToDeleteSet.has(b.id)
    );
    const lastBlockToDelete = blocksToDeleteInPath.length
      ? blocksToDeleteInPath.reduce((prev, curr) =>
          curr.position > prev.position ? curr : prev
        )
      : null;

    // 3. Check the last block to delete for special child path logic
    let pathIdsToActuallyDelete = collectAllPathIds(data.path, allPaths);
    if (
      lastBlockToDelete &&
      Array.isArray(lastBlockToDelete.child_paths) &&
      lastBlockToDelete.child_paths.length === 1
    ) {
      const childPathId = lastBlockToDelete.child_paths[0].path_id;
      const childPath = allPaths.find((p) => p.id === childPathId);
      if (
        childPath &&
        Array.isArray(childPath.parent_blocks) &&
        childPath.parent_blocks.length > 1
      ) {
        // Don't delete this path
        pathIdsToActuallyDelete = new Set();
      }
    }

    // 4. Optimistically update the store
    const updatedPaths = allPaths
      .filter((p) => !pathIdsToActuallyDelete.has(p.id)) // Remove descendant paths
      .map((p) => {
        if (p.id === path.id) {
          // Remove blocks to delete and reindex positions
          let remainingBlocks = p.blocks
            .filter(
              (b) =>
                !(
                  blocksToDelete.includes(b.id) &&
                  (b.type === 'STEP' || b.type === 'DELAY')
                )
            )
            .map((b, idx) => ({ ...b, position: idx }));
          // Set the last block to type LAST if it exists in remainingBlocks and is not MERGE
          if (lastBlockToDelete && lastBlockToDelete.type !== 'MERGE') {
            const idx = remainingBlocks.findIndex(
              (b) => b.id === lastBlockToDelete.id
            );
            if (idx !== -1) {
              remainingBlocks[idx] = {
                ...remainingBlocks[idx],
                type: BlockEndType.LAST,
                child_paths: [],
              };
            }
          }
          return { ...p, blocks: remainingBlocks };
        }
        return p;
      });
    setAllPaths(updatedPaths);
    data.onPathsUpdate?.(updatedPaths);

    // 5. API call and rollback on error
    try {
      const response = await fetch('/api/blocks/delete-multiple', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          blockIds: blocksToDelete,
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to delete blocks');
      }
      // Success: do nothing, optimistic update already applied
    } catch (error) {
      // Rollback to previous state
      setAllPaths(previousPaths);
      data.onPathsUpdate?.(previousPaths);
      console.error('Error deleting blocks:', error);
    }
  };

  // --- Stroke lines toggle logic ---
  const useTooltip = () => {
    const [showTooltip, setShowTooltip] = useState(false);
    const [tooltipPosition, setTooltipPosition] = useState<number | null>(null);
    const elementRef = useRef<HTMLDivElement>(null);
    const tooltipRef = useRef<HTMLDivElement>(null);

    const handleMouseEnter = useCallback(() => {
      setShowTooltip(true);
    }, []);

    const handleMouseLeave = useCallback(() => {
      setShowTooltip(false);
      setTooltipPosition(null);
    }, []);

    useEffect(() => {
      if (showTooltip && tooltipRef.current && elementRef.current) {
        const toggleRect = elementRef.current.getBoundingClientRect();
        const tooltipRect = tooltipRef.current.getBoundingClientRect();
        const gap = 12; // gap between toggle and tooltip
        setTooltipPosition(-(tooltipRect.width + gap));
      }
    }, [showTooltip]);

    return {
      elementRef,
      tooltipRef,
      showTooltip,
      tooltipPosition,
      handleMouseEnter,
      handleMouseLeave,
    };
  };

  const {
    elementRef,
    tooltipRef,
    showTooltip,
    tooltipPosition,
    handleMouseEnter,
    handleMouseLeave,
  } = useTooltip();

  // Toggle handler (copied from CustomBlock)
  const toggleStrokeLines = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (!allStrokeLinesVisible) return;
    const blockId = parseInt(id.replace('block-', ''));
    const newVisibility = !data.strokeLinesVisible;
    data.updateStrokeLineVisibility?.(blockId, newVisibility);
  };

  return (
    <BasicBlock {...props}>
      {/* --- Vertical Toggle Switch Container (copied from CustomBlock) --- */}
      {getEdges().some(
        (edge) => edge.source === id && edge.type === 'strokeEdge'
      ) &&
        !showConnectModal && (
          <div
            className="absolute top-[50%] -translate-y-1/2 transition-opacity duration-300"
            style={{
              left: '-20px',
              backgroundColor: colors['bg-primary'],
              padding: '4px',
              width: '32px',
              height: '32px',
              borderRadius: '8px',
              boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
              border: `1px solid ${colors['border-secondary']}`,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'flex-start',
              paddingLeft: '6px',
            }}
          >
            <div
              ref={elementRef}
              onClick={toggleStrokeLines}
              className={`${allStrokeLinesVisible ? 'cursor-pointer' : 'cursor-not-allowed'}`}
              style={{
                width: '12px',
                height: '20px',
                borderRadius: '6px',
                backgroundColor:
                  allStrokeLinesVisible && data.strokeLinesVisible
                    ? '#FF69A3'
                    : colors['bg-quaternary'],
                transition: 'background-color 0.2s',
                position: 'relative',
                opacity: allStrokeLinesVisible ? 1 : 0.5,
              }}
              onMouseEnter={handleMouseEnter}
              onMouseLeave={handleMouseLeave}
            >
              <div
                style={{
                  width: '10px',
                  height: '10px',
                  borderRadius: '50%',
                  backgroundColor: colors['bg-primary'],
                  position: 'absolute',
                  left: '1px',
                  top:
                    allStrokeLinesVisible && data.strokeLinesVisible
                      ? '1px'
                      : '9px',
                  transition: 'top 0.2s',
                  boxShadow: '0 1px 2px rgba(0, 0, 0, 0.1)',
                }}
              />
            </div>
          </div>
        )}

      {/* Tooltip for the toggle */}
      {showTooltip && (
        <div
          ref={tooltipRef}
          style={{
            position: 'absolute',
            left: '-210px',
            top: '50%',
            transform: 'translateY(-50%)',
            zIndex: 1000,
            pointerEvents: 'none',
          }}
        >
          <CustomTooltip
            text={
              allStrokeLinesVisible
                ? data.strokeLinesVisible
                  ? 'Hide connecting lines'
                  : 'Show connecting lines'
                : 'Global connecting lines are disabled in Settings'
            }
            show={true}
            direction="left"
          />
        </div>
      )}
      <div
        className={`transition-opacity duration-300 ${
          isConnectMode &&
          id !== connectData?.sourceNode?.id &&
          id !== connectData?.targetNode?.id
            ? 'opacity-40'
            : isEditMode
              ? 'opacity-40'
              : ''
        }`}
        onClick={handleBlockClick}
      >
        <div
          className="transition-all duration-300 relative rounded-lg bg-white shadow-sm overflow-hidden min-w-[481px] max-w-[481px]"
          style={{
            backgroundColor: colors['bg-primary'],
            borderWidth: '2px',
            borderStyle: 'solid',
            borderColor: showModal
              ? colors['border-brand_alt']
              : colors['border-secondary'],
          }}
        >
          <Handle
            type="target"
            position={Position.Top}
            id="top"
            style={{
              width: 8,
              height: 8,
              opacity: 0,
              background: colors['fg-brand-primary'],
              border: `2px solid ${colors['bg-primary']}`,
              pointerEvents: 'none',
            }}
          />

          {/* Header - Condition styling */}
          <div
            className="p-[17px] flex items-center justify-between"
            style={{
              borderBottom: data.block.description
                ? `1px solid ${colors['border-secondary']}`
                : 'none',
            }}
          >
            {/* Icon section */}
            <div className="flex items-center gap-3">
              <div
                className="w-10 h-10 rounded-md flex items-center justify-center flex-shrink-0"
                style={{
                  backgroundColor: colors['bg-primary'],
                  border: `1px solid ${colors['border-secondary']}`,
                }}
              >
                {data.block.signedIconUrl ? (
                  <img
                    src={data.block.signedIconUrl}
                    alt="Block Icon"
                    className="w-6 h-6"
                    referrerPolicy="strict-origin-when-cross-origin"
                  />
                ) : data.block.icon && data.block.icon.startsWith('https://cdn.brandfetch.io/') ? (
                    <img
                      src={data.block.icon}
                      alt="Block Icon"
                      className="w-6 h-6"
                      referrerPolicy="strict-origin-when-cross-origin"
                    />
                  ) : (
                    <img
                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dataflow-icon.svg`}
                    alt="Default Icon"
                    className="w-6 h-6"
                  />
                )}
              </div>
              <div className="flex flex-col gap-0.5">
                <div
                  className="text-xs font-medium"
                  style={{ color: colors['fg-tertiary'] }}
                >
                  Condition
                </div>
                <div
                  className="text-sm font-semibold break-words line-clamp-1"
                  style={{ color: colors['fg-primary'], width: '333px' }}
                >
                  {data.block.title || 'Untitled Condition'}
                </div>
              </div>
            </div>
            {/* Dropdown toggle button with hover effect */}
            <button
              className="p-1 rounded-md transition-colors hover:bg-opacity-80"
              style={{
                color: colors['fg-tertiary'],
                backgroundColor: 'transparent',
              }}
              onMouseOver={(e) => {
                e.currentTarget.style.backgroundColor = colors['bg-secondary'];
              }}
              onMouseOut={(e) => {
                e.currentTarget.style.backgroundColor = 'transparent';
              }}
              onClick={handleDropdownToggle}
              type="button"
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dots-horizontal.svg`}
                alt="Menu"
                className="w-5 h-5"
              />
            </button>
          </div>

          {/* Dropdown menu */}
          {showDropdown &&
            createPortal(
              <div
                ref={dropdownRef}
                style={{
                  backgroundColor: colors['bg-secondary'],
                  border: `1px solid ${colors['border-primary']}`,
                  left: dropdownPosition.x,
                  top: dropdownPosition.y,
                  zIndex: 99999999,
                }}
                className="fixed shadow-[0px_4px_6px_-2px_rgba(16,24,40,0.03)] py-1 flex flex-col overflow-hidden cursor-pointer rounded-lg"
              >
                {/* Connect block - now first */}
                <div
                  onClick={handleConnectClick}
                  className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
                >
                  <div
                    style={
                      {
                        '--hover-bg': colors['bg-quaternary'],
                      } as React.CSSProperties
                    }
                    className="w-[170px] grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
                  >
                    <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
                      <div className="w-4 h-4 relative overflow-hidden">
                        <img
                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/connect-node.svg`}
                          alt="Connect"
                          className="w-4 h-4"
                        />
                      </div>
                      <div
                        style={{ color: colors['text-primary'] }}
                        className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
                      >
                        Connect block
                      </div>
                    </div>
                  </div>
                </div>

                {/* Edit */}
                <div
                  onClick={handleEdit}
                  className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
                >
                  <div
                    style={
                      {
                        '--hover-bg': colors['bg-quaternary'],
                      } as React.CSSProperties
                    }
                    className="w-[170px] grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
                  >
                    <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
                      <div className="w-4 h-4 relative overflow-hidden">
                        <img
                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                          alt="Edit"
                          className="w-4 h-4"
                        />
                      </div>
                      <div
                        style={{ color: colors['text-primary'] }}
                        className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
                      >
                        Edit
                      </div>
                    </div>
                  </div>
                </div>

                {/* Separator */}
                <div
                  style={{ borderColor: colors['border-secondary'] }}
                  className="self-stretch h-px border-b my-1"
                />

                {/* Delete */}
                <div
                  onClick={handleDelete}
                  className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
                >
                  <div
                    style={
                      {
                        '--hover-bg': colors['bg-quaternary'],
                      } as React.CSSProperties
                    }
                    className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
                  >
                    <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
                      <div className="w-4 h-4 relative overflow-hidden">
                        <img
                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`}
                          alt="Delete"
                          className="w-4 h-4"
                        />
                      </div>
                      <div
                        style={{ color: colors['text-primary'] }}
                        className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
                      >
                        Delete
                      </div>
                    </div>
                  </div>
                </div>
              </div>,
              document.body
            )}

          {/* Content section - only render if there's content */}
          {data.block.description && (
            <div className="p-[17px] flex flex-col gap-[13.7px]">
              <p
                className="text-xs mt-1 line-clamp-2 break-words whitespace-pre-line"
                style={{ color: colors['fg-tertiary'] }}
              >
                {parseTextWithLinks(data.block.description).map(
                  (
                    segment: { type: string; content: string },
                    index: number
                  ) =>
                    segment.type === 'link' ? (
                      <a
                        key={index}
                        href={segment.content}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-blue-500 hover:underline"
                        onClick={(e) => {
                          e.stopPropagation();
                          e.preventDefault();
                          window.open(
                            segment.content,
                            '_blank',
                            'noopener,noreferrer'
                          );
                        }}
                      >
                        {segment.content}
                      </a>
                    ) : (
                      <span key={index}>{segment.content}</span>
                    )
                )}
              </p>
            </div>
          )}
          <Handle
            type="source"
            position={Position.Left}
            id="stroke_source"
            style={{
              width: 8,
              height: 8,
              background: colors['fg-tertiary'],
              border: `2px solid ${colors['bg-primary']}`,
              top: '35%',
              opacity: 0,
              pointerEvents: 'none',
            }}
          />
          <Handle
            type="target"
            position={Position.Left}
            id="stroke_target"
            style={{
              width: 8,
              height: 8,
              background: colors['fg-tertiary'],
              border: `2px solid ${colors['bg-primary']}`,
              top: '35%',
              left: 0,
              opacity: 0,
              pointerEvents: 'none',
            }}
          />
          <Handle
            type="target"
            position={Position.Left}
            id="stroke_self_target"
            style={{
              width: 8,
              height: 8,
              background: colors['fg-tertiary'],
              border: `2px solid ${colors['bg-primary']}`,
              top: '65%',
              opacity: 0,
              pointerEvents: 'none',
            }}
          />
          <Handle
            type="source"
            position={Position.Bottom}
            id="bottom"
            style={{
              width: 8,
              height: 8,
              opacity: 0,
              background: colors['fg-brand-primary'],
              border: `2px solid ${colors['bg-primary']}`,
              pointerEvents: 'none',
            }}
          />
        </div>

        {showModal && data.block && (
          <UpdatePathModal
            onClose={() => setShowModal(false)}
            onConfirm={handleCreateChildPaths}
            existingPathsCount={existingPathsCount}
            existingPaths={existingPaths.map((p) => p.name)}
            block={data.block}
          />
        )}
      </div>
    </BasicBlock>
  );
}

export default PathBlock;
</file>

<file path="app/[slug]/[flow]/edit/components/edges/BasicEdge.tsx">
import React from 'react';
import { EdgeProps } from '@xyflow/react';
import { useIsModalOpenStore } from '@/app/isModalOpenStore';

/**
 * BasicEdge wraps all edge components to provide shared logic,
 * such as disabling interaction when a modal is open.
 */
export type BasicEdgeProps = EdgeProps & {
  children: React.ReactNode;
};

export function BasicEdge({ children }: BasicEdgeProps) {
  const isModalOpen = useIsModalOpenStore((state: any) => state.isModalOpen);

  return (
    <g
      className={isModalOpen ? 'pointer-events-none' : ''}
      aria-disabled={isModalOpen}
    >
      {children}
    </g>
  );
}
</file>

<file path="app/[slug]/[flow]/edit/components/edges/CustomSmoothStepEdge.tsx">
import React, { useState } from 'react';
import { EdgeProps, getSmoothStepPath } from '@xyflow/react';
import { EdgeData, Path, Block } from '../../../types';
import { BlockEndType } from '@/types/block';
import { useConnectModeStore } from '../../store/connectModeStore';
import { useEditModeStore } from '../../store/editModeStore';
import DeleteBlocksModal from '../modals/DeleteBlocksModal';
import { usePathsStore } from '../../store/pathsStore';
import { useColors, useThemeAssets } from '@/app/theme/hooks';
import { BasicEdge } from './BasicEdge';
import collectAllPathIds from '../../utils/collectAllPathIds';

// Helper function to check if we're in non-production environment
const isNonProduction = () => process.env.NODE_ENV !== 'production';

function CustomSmoothStepEdge({
  id,
  source,
  target,
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourcePosition,
  targetPosition,
  style = {},
  data,
}: EdgeProps & { data: EdgeData }) {
  const colors = useColors();
  const assets = useThemeAssets();

  const [edgePath] = getSmoothStepPath({
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    borderRadius: 16,
    offset: 16,
  });

  const sourceBlock = data.blocks.find((b) => `block-${b.id}` === source);
  const targetBlock = data.blocks.find((b) => `block-${b.id}` === target);
  const isLastTypeInvolved =
    sourceBlock?.type === BlockEndType.LAST ||
    targetBlock?.type === BlockEndType.LAST;

  const handleEdgeClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (sourceBlock && targetBlock) {
      const position = Math.ceil(
        (sourceBlock.position + targetBlock.position) / 2
      );
      data.handleAddBlockOnEdge?.(position, data.path, e);
    }
  };

  const isConnectMode = useConnectModeStore((state) => state.isConnectMode);
  const isEditMode = useEditModeStore((state) => state.isEditMode);

  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const allPaths = usePathsStore((state) => state.paths);
  const setAllPaths = usePathsStore((state) => state.setPaths);
  // Recursively collect all unique path IDs from a path and its descendants


  const handleDeleteBlocks = async () => {
    // Get all blocks after this position except the last one
    const path = allPaths.find((p) => p.id === data.path.id);
    if (!path) return;

    if (!sourceBlock || !targetBlock) {
      if (isNonProduction()) {
        console.log('sourceBlock or targetBlock is undefined');
      }
      return;
    }
    if (isNonProduction()) {
      console.log('sourceBlock and targetBlock are defined');
    }
    const position = Math.ceil(
      (sourceBlock.position + targetBlock.position) / 2
    );
    const blocksToDelete = path.blocks
      .filter((b) => b.position >= position)
      .map((b) => b.id);

    if (blocksToDelete.length === 0) return;

    // Recursively collect all descendant path IDs
    const allPathIdsToDelete = collectAllPathIds(path, allPaths);

    // Save previous state for rollback
    const previousPaths = allPaths;

    // Find the last block to delete by position
    const blocksToDeleteSet = new Set(blocksToDelete);
    const blocksToDeleteInPath = path.blocks.filter((b) =>
      blocksToDeleteSet.has(b.id)
    );
    const lastBlockToDelete = blocksToDeleteInPath.length
      ? blocksToDeleteInPath.reduce((prev, curr) =>
          curr.position > prev.position ? curr : prev
        )
      : null;

    // Check the last block to delete for special child path logic
    let pathIdsToActuallyDelete = allPathIdsToDelete;
    if (
      lastBlockToDelete &&
      Array.isArray(lastBlockToDelete.child_paths) &&
      lastBlockToDelete.child_paths.length === 1
    ) {
      const childPathId = lastBlockToDelete.child_paths[0].path_id;
      const childPath = allPaths.find((p) => p.id === childPathId);
      if (
        childPath &&
        Array.isArray(childPath.parent_blocks) &&
        childPath.parent_blocks.length > 1
      ) {
        // Don't delete this path
        pathIdsToActuallyDelete = new Set();
      }
    }

    // Optimistically update the store
    const updatedPaths = allPaths
      .filter((p) => !pathIdsToActuallyDelete.has(p.id)) // Remove descendant paths
      .map((p) => {
        if (p.id === path.id) {
          // Remove blocks to delete and reindex positions
          let remainingBlocks = p.blocks
            .filter(
              (b) =>
                !(
                  blocksToDelete.includes(b.id) &&
                  (b.type === 'STEP' || b.type === 'DELAY')
                )
            )
            .map((b, idx) => ({ ...b, position: idx }));
          // Set the last block to type LAST if it exists in remainingBlocks and is not MERGE
          if (lastBlockToDelete && lastBlockToDelete.type !== 'MERGE') {
            const idx = remainingBlocks.findIndex(
              (b) => b.id === lastBlockToDelete.id
            );
            if (idx !== -1) {
              remainingBlocks[idx] = {
                ...remainingBlocks[idx],
                type: BlockEndType.LAST,
                child_paths: [],
              };
            }
          }
          return { ...p, blocks: remainingBlocks };
        }
        return p;
      });
    setAllPaths(updatedPaths);
    data.onPathsUpdate?.(updatedPaths);

    try {
      const response = await fetch('/api/blocks/delete-multiple', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          blockIds: blocksToDelete,
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to delete blocks');
      }
      // Success: do nothing, optimistic update already applied
    } catch (error) {
      // Rollback to previous state
      setAllPaths(previousPaths);
      data.onPathsUpdate?.(previousPaths);
      console.error('Error deleting blocks:', error);
    }
  };

  return (
    <BasicEdge
      id={id}
      source={source}
      target={target}
      sourceX={sourceX}
      sourceY={sourceY}
      targetX={targetX}
      targetY={targetY}
      sourcePosition={sourcePosition}
      targetPosition={targetPosition}
      style={style}
      data={data}
    >
      <path
        id={id}
        className={`react-flow__edge-path ${
          isConnectMode || isEditMode ? 'opacity-40' : ''
        }`}
        d={edgePath}
        style={{
          strokeWidth: 2,
          stroke: colors['border'],
          ...style,
        }}
      />
      <path
        d={edgePath}
        fill="none"
        strokeWidth="20"
        stroke="transparent"
        onClick={handleEdgeClick}
        style={{ cursor: 'pointer' }}
      />
      {!isLastTypeInvolved && !isConnectMode && !isEditMode && (
        <foreignObject
          width={100}
          height={40}
          x={(sourceX + targetX) / 2 - 50}
          y={(sourceY + targetY) / 2 - 20}
          className="edgebutton-foreignobject"
          requiredExtensions="http://www.w3.org/1999/xhtml"
        >
          <div className="flex items-center justify-center w-full h-full">
            <div
              style={{
                backgroundColor: colors['bg-primary'],
                borderColor: colors['border-secondary'],
              }}
              className="flex rounded-lg overflow-hidden border"
            >
              <button
                onClick={handleEdgeClick}
                style={
                  {
                    '--hover-bg': colors['bg-secondary'],
                    borderRight: `1px solid ${colors['border-secondary']}`,
                  } as React.CSSProperties
                }
                className="flex items-center justify-center p-2 hover:bg-[var(--hover-bg)]"
              >
                <img
                  src={
                    (assets.icons as Record<string, string>)['plus'] ||
                    `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/plus-circle.svg`
                  }
                  alt="Add"
                  style={{ stroke: colors['icon-secondary'] }}
                  className="w-3 h-3"
                />
              </button>
              <button
                style={
                  {
                    '--hover-bg': colors['bg-secondary'],
                  } as React.CSSProperties
                }
                className="flex items-center justify-center p-2 hover:bg-[var(--hover-bg)]"
                onClick={(e) => {
                  e.stopPropagation();
                  setShowDeleteModal(true);
                }}
              >
                <img
                  src={
                    (assets.icons as Record<string, string>)['trash'] ||
                    `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`
                  }
                  alt="Delete"
                  style={{ stroke: colors['icon-secondary'] }}
                  className="w-3 h-3"
                />
              </button>
            </div>
          </div>
        </foreignObject>
      )}
      {showDeleteModal && (
        <DeleteBlocksModal
          onClose={() => setShowDeleteModal(false)}
          onConfirm={handleDeleteBlocks}
        />
      )}
    </BasicEdge>
  );
}

export default CustomSmoothStepEdge;
</file>

<file path="app/[slug]/[flow]/edit/components/edges/SmoothStepCustomParent.tsx">
import { BaseEdge, EdgeProps, getSmoothStepPath } from '@xyflow/react';
import { useConnectModeStore } from '../../store/connectModeStore';
import { useEditModeStore } from '../../store/editModeStore';

function SmoothStepCustomParent({
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourcePosition,
  targetPosition,
  style = {},
  markerEnd,
}: EdgeProps) {
  const [edgePath] = getSmoothStepPath({
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
  });

  const isConnectMode = useConnectModeStore((state) => state.isConnectMode);
  const isEditMode = useEditModeStore((state) => state.isEditMode);

  return (
    <BaseEdge
      path={edgePath}
      markerEnd={markerEnd}
      style={{
        ...style,
        strokeWidth: 2,
        stroke: '#b1b1b7',
      }}
      className={`${
        isConnectMode || isEditMode ? 'opacity-40' : ''
      }`}
    />
  );
}

export default SmoothStepCustomParent;
</file>

<file path="app/[slug]/[flow]/edit/components/edges/StrokeEdge.module.css">
.strokeEdge {
  stroke-width: 2;
  stroke: #FF69A3;
  stroke-dasharray: 5;
  pointer-events: none;
  animation: flowAnimation 30s linear infinite;
}

@keyframes flowAnimation {
  0% {
    stroke-dashoffset: 0;
  }
  100% {
    stroke-dashoffset: 1000;
  }
}
</file>

<file path="app/[slug]/[flow]/edit/components/edges/StrokeEdge.tsx">
import React, {
  useState,
  useCallback,
  CSSProperties,
  useRef,
  ReactNode,
  useEffect,
} from 'react';
import {
  EdgeProps as BaseEdgeProps,
  getSmoothStepPath,
  Edge,
  useReactFlow,
  BaseEdge,
  EdgeLabelRenderer,
  useStore,
  Position,
} from '@xyflow/react';
import { useConnectModeStore } from '../../store/connectModeStore';
import { useEditModeStore } from '../../store/editModeStore';
import DeleteStrokeEdgeModal from '../modals/DeleteStrokeEdgeModal';
import styles from './StrokeEdge.module.css';
import { updateStrokeLineControlPoints } from '../../utils/stroke-lines';
import { useStrokeLinesStore } from '../../store/strokeLinesStore';
import { BasicEdge } from './BasicEdge';
import { useIsModalOpenStore } from '@/app/isModalOpenStore';
import { usePathsStore } from '../../store/pathsStore';
import { Block, StrokeLine } from '../../../types';

interface StrokeEdgeData {
  [key: string]: unknown;
  id: string;
  source: string;
  target: string;
  sourceHandle?: string;
  targetHandle?: string;
  label: string;
  preview?: boolean;
  isVisible?: boolean;
  onStrokeLinesUpdate?: (updateFn: (prev: any[]) => any[]) => void;
  controlPoints?: { x: number; y: number }[];
  strokeLines?: StrokeLine[];
  onPathsUpdate?: (updateFn: (prev: any[]) => any[]) => void;
}

type EdgeProps = Omit<BaseEdgeProps, 'data'> & {
  data?: StrokeEdgeData;
};

interface Point {
  x: number;
  y: number;
}

// Helper function to calculate distance between two points
const getDistance = (p1: Point, p2: Point) => {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
};

// Helper function to clamp a value between min and max
const clamp = (value: number, min: number, max: number) => {
  return Math.min(Math.max(value, min), max);
};

// Helper function to determine if a point is near another point
const isNearPoint = (p1: Point, p2: Point, threshold = 20) => {
  return getDistance(p1, p2) < threshold;
};

// Helper function to snap a point to the nearest grid position
const snapToGrid = (point: Point, gridSize = 20) => {
  return {
    x: Math.round(point.x / gridSize) * gridSize,
    y: Math.round(point.y / gridSize) * gridSize,
  };
};

function StrokeEdge({
  id,
  source,
  target,
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourcePosition,
  targetPosition,
  style = {} as CSSProperties,
  data,
}: EdgeProps): JSX.Element {
  const [showLabel, setShowLabel] = useState(false);
  const [showDeleteButton, setShowDeleteButton] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [labelPosition, setLabelPosition] = useState({ x: 0, y: 0 });
  const [deleteButtonPosition, setDeleteButtonPosition] = useState({
    x: 0,
    y: 0,
  });
  const [controlPoints, setControlPoints] = useState<Point[]>([]);
  const [isDragging, setIsDragging] = useState(false);
  const [activePointIndex, setActivePointIndex] = useState<number | null>(null);
  const [isHoveringControlPoint, setIsHoveringControlPoint] = useState(false);
  const [isHoveringEdge, setIsHoveringEdge] = useState(false);
  const { screenToFlowPosition } = useReactFlow();
  const { isConnectMode, previewEdgeId } = useConnectModeStore();
  const zoom = useStore((state) => state.transform[2]);
  const isEditMode = useEditModeStore((state) => state.isEditMode);
  const hideTimeoutRef = useRef<NodeJS.Timeout>();
  const { allStrokeLinesVisible } = useStrokeLinesStore();
  const isModalOpen = useIsModalOpenStore((state: any) => state.isModalOpen);
  const allPaths = usePathsStore((state) => state.paths);
  const setAllPaths = usePathsStore((state) => state.setPaths);

  const isSelfLoop = data?.source === data?.target;
  const markerId = `stroke-arrow-${id}`;

  const handleMouseEnter = useCallback(
    (event: React.MouseEvent) => {
      if (hideTimeoutRef.current) {
        clearTimeout(hideTimeoutRef.current);
      }
      if (!isHoveringControlPoint) {
        const flowPosition = screenToFlowPosition({
          x: event.clientX,
          y: event.clientY,
        });
        setLabelPosition(flowPosition);
        setDeleteButtonPosition(flowPosition);
        setShowLabel(true);
        setShowDeleteButton(true);
        setIsHoveringEdge(true);
      }
    },
    [screenToFlowPosition, isHoveringControlPoint]
  );

  const handleMouseMove = useCallback(
    (event: React.MouseEvent) => {
      if (showDeleteButton && !isHoveringControlPoint) {
        const flowPosition = screenToFlowPosition({
          x: event.clientX,
          y: event.clientY,
        });
        setDeleteButtonPosition(flowPosition);
      }
    },
    [screenToFlowPosition, showDeleteButton, isHoveringControlPoint]
  );

  // Clean up timeout on unmount
  useEffect(() => {
    return () => {
      if (hideTimeoutRef.current) {
        clearTimeout(hideTimeoutRef.current);
      }
    };
  }, []);

  const handleMouseLeave = useCallback(() => {
    if (hideTimeoutRef.current) {
      clearTimeout(hideTimeoutRef.current);
    }
    hideTimeoutRef.current = setTimeout(() => {
      if (!isHoveringControlPoint) {
        setShowLabel(false);
        setShowDeleteButton(false);
        setIsHoveringEdge(false);
      }
    }, 400);
  }, [isHoveringControlPoint]);

  const handleControlPointMouseEnter = useCallback(() => {
    if (hideTimeoutRef.current) {
      clearTimeout(hideTimeoutRef.current);
    }
    setIsHoveringControlPoint(true);
    setShowLabel(false);
    setShowDeleteButton(false);
  }, []);

  const handleControlPointMouseLeave = useCallback(() => {
    setIsHoveringControlPoint(false);
  }, []);

  const handleDelete = async () => {
    setIsDeleting(true);
    try {
      // Extract the stroke line ID from the edge ID
      const strokeLineId = id.replace('stroke-edge-', '');

      // Call the API to delete the stroke line
      const response = await fetch(`/api/stroke-lines?id=${strokeLineId}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error('Failed to delete stroke line');
      }

      // --- NEW LOGIC: Check if the source block has any other outgoing stroke lines ---
      // Find the source block id (from data)
      const sourceBlockId = Number(
        data?.source?.replace?.('block-', '') || data?.source
      );
      // Use the strokeLines prop from data (already up-to-date except for the just-deleted one)
      const remainingStrokeLines = (data?.strokeLines || []).filter(
        (line) => line.id.toString() !== strokeLineId // Exclude the just-deleted stroke line
      );
      // Filter for outgoing stroke lines from this source block (excluding self-loops)
      const outgoing = remainingStrokeLines.filter(
        (line) =>
          line.source_block_id === sourceBlockId &&
          line.target_block_id !== sourceBlockId
      );
      if (outgoing.length === 0) {
        // Update the block in allPaths to set is_endpoint: false
        setAllPaths((paths) =>
          paths.map((path) => ({
            ...path,
            blocks: path.blocks.map((block) => {
              if (block.id === sourceBlockId) {
                return { ...block, is_endpoint: false };
              }
              return block;
            }),
          }))
        );
        if (data?.onPathsUpdate) {
          data.onPathsUpdate((paths) =>
            paths.map((path) => ({
              ...path,
              blocks: path.blocks.map((block: Block) =>
                block.id === sourceBlockId
                  ? { ...block, is_endpoint: false }
                  : block
              ),
            }))
          );
        }
      }

      // Update the stroke lines in the parent component
      if (data?.onStrokeLinesUpdate) {
        const updateFn = (prev: any[]) =>
          prev.filter((line) => line.id.toString() !== strokeLineId);
        data.onStrokeLinesUpdate(updateFn);
      }
      // --- END NEW LOGIC ---
    } catch (error) {
      console.error('Error deleting stroke line:', error);
    }
    setShowDeleteModal(false);
  };

  const handleControlPointDragStart =
    (index: number) => (event: React.MouseEvent) => {
      event.stopPropagation();
      setIsDragging(true);
      setActivePointIndex(index);
    };

  // Helper function to get the handle position
  const getHandlePosition = useCallback(
    (position: Position | undefined, isSource: boolean) => {
      if (!position) return isSource ? 'left' : 'right';
      return position.toLowerCase();
    },
    []
  );

  // Get actual connection points based on handle positions
  const getConnectionPoint = useCallback(
    (
      x: number,
      y: number,
      position: Position | undefined,
      isSource: boolean
    ) => {
      const handlePos = getHandlePosition(position, isSource);
      const offset = 12; // Handle offset from node edge

      switch (handlePos) {
        case 'left':
          return { x: x - offset, y };
        case 'right':
          return { x: x + offset, y };
        case 'top':
          return { x, y: y - offset };
        case 'bottom':
          return { x, y: y + offset };
        default:
          return { x, y };
      }
    },
    [getHandlePosition]
  );

  const handleControlPointDrag = useCallback(
    (event: MouseEvent) => {
      if (isDragging && activePointIndex !== null) {
        event.preventDefault(); // Prevent default browser drag behavior
        const flowPosition = screenToFlowPosition({
          x: event.clientX,
          y: event.clientY,
        });

        const source = getConnectionPoint(
          sourceX,
          sourceY,
          sourcePosition,
          true
        );
        const target = getConnectionPoint(
          targetX,
          targetY,
          targetPosition,
          false
        );

        // Calculate the total path length for constraints
        const pathLength = getDistance(source, target);
        const maxOffset = Math.min(pathLength * 0.4, 120); // Reduced max offset for better control

        setControlPoints((prev) => {
          const newPoints = [...prev];
          const point = newPoints[activePointIndex];

          // Snap to grid for more precise control
          const snappedPosition = snapToGrid(flowPosition);

          // For a three-point path, middle point moves with enhanced constraints
          if (newPoints.length === 3 && activePointIndex === 1) {
            // Determine primary direction based on source and target positions
            const isHorizontalPrimary =
              Math.abs(target.x - source.x) > Math.abs(target.y - source.y);

            if (isHorizontalPrimary) {
              // Keep middle point centered horizontally
              const midX = source.x + (target.x - source.x) / 2;
              const minY = Math.min(source.y, target.y) - maxOffset;
              const maxY = Math.max(source.y, target.y) + maxOffset;

              // Snap to source or target Y if near
              if (
                isNearPoint(
                  { x: midX, y: snappedPosition.y },
                  { x: midX, y: source.y }
                )
              ) {
                point.y = source.y;
              } else if (
                isNearPoint(
                  { x: midX, y: snappedPosition.y },
                  { x: midX, y: target.y }
                )
              ) {
                point.y = target.y;
              } else {
                point.y = clamp(snappedPosition.y, minY, maxY);
              }
              point.x = midX;

              // Update adjacent points to maintain orthogonal path
              newPoints[0].x = source.x;
              newPoints[0].y = point.y;
              newPoints[2].x = target.x;
              newPoints[2].y = point.y;
            } else {
              // Keep middle point centered vertically
              const midY = source.y + (target.y - source.y) / 2;
              const minX = Math.min(source.x, target.x) - maxOffset;
              const maxX = Math.max(source.x, target.x) + maxOffset;

              // Snap to source or target X if near
              if (
                isNearPoint(
                  { x: snappedPosition.x, y: midY },
                  { x: source.x, y: midY }
                )
              ) {
                point.x = source.x;
              } else if (
                isNearPoint(
                  { x: snappedPosition.x, y: midY },
                  { x: target.x, y: midY }
                )
              ) {
                point.x = target.x;
              } else {
                point.x = clamp(snappedPosition.x, minX, maxX);
              }
              point.y = midY;

              // Update adjacent points to maintain orthogonal path
              newPoints[0].x = point.x;
              newPoints[0].y = source.y;
              newPoints[2].x = point.x;
              newPoints[2].y = target.y;
            }
          } else {
            // For end points, enhance constraints and add snapping
            const isSource = activePointIndex === 0;
            const handlePosition = isSource ? sourcePosition : targetPosition;
            const anchorPoint = isSource ? source : target;
            const otherPoint = newPoints[isSource ? 1 : newPoints.length - 2];

            if (
              handlePosition === Position.Left ||
              handlePosition === Position.Right
            ) {
              const minY = Math.min(source.y, target.y) - maxOffset;
              const maxY = Math.max(source.y, target.y) + maxOffset;

              // Snap to source, target, or other control point Y if near
              if (
                isNearPoint(
                  { x: anchorPoint.x, y: snappedPosition.y },
                  { x: anchorPoint.x, y: source.y }
                )
              ) {
                point.y = source.y;
              } else if (
                isNearPoint(
                  { x: anchorPoint.x, y: snappedPosition.y },
                  { x: anchorPoint.x, y: target.y }
                )
              ) {
                point.y = target.y;
              } else {
                point.y = clamp(snappedPosition.y, minY, maxY);
              }
              point.x = anchorPoint.x;
              otherPoint.y = point.y;
            } else {
              const minX = Math.min(source.x, target.x) - maxOffset;
              const maxX = Math.max(source.x, target.x) + maxOffset;

              // Snap to source, target, or other control point X if near
              if (
                isNearPoint(
                  { x: snappedPosition.x, y: anchorPoint.y },
                  { x: source.x, y: anchorPoint.y }
                )
              ) {
                point.x = source.x;
              } else if (
                isNearPoint(
                  { x: snappedPosition.x, y: anchorPoint.y },
                  { x: target.x, y: anchorPoint.y }
                )
              ) {
                point.x = target.x;
              } else {
                point.x = clamp(snappedPosition.x, minX, maxX);
              }
              point.y = anchorPoint.y;
              otherPoint.x = point.x;
            }
          }

          return newPoints;
        });
      }
    },
    [
      isDragging,
      activePointIndex,
      screenToFlowPosition,
      sourceX,
      sourceY,
      targetX,
      targetY,
      sourcePosition,
      targetPosition,
      getConnectionPoint,
    ]
  );

  // Save control points when they change
  const saveControlPoints = useCallback(async () => {
    try {
      const strokeLineId = parseInt(id.replace('stroke-edge-', ''));
      const result = await updateStrokeLineControlPoints(
        strokeLineId,
        controlPoints
      );

      if (!result) {
        throw new Error('Failed to save control points');
      }
    } catch (error) {
      console.error('Error saving control points:', error);
    }
  }, [id, controlPoints]);

  useEffect(() => {
    const loadControlPoints = async () => {
      try {
        let strokeLine = null;
        const source = getConnectionPoint(
          sourceX,
          sourceY,
          sourcePosition,
          true
        );
        const target = getConnectionPoint(
          targetX,
          targetY,
          targetPosition,
          false
        );
        const strokeLineId = id.replace('stroke-edge-', '');
        if (data && !data.preview) {
          const response = await fetch(`/api/stroke-lines?id=${strokeLineId}`);

          if (!response.ok) {
            throw new Error('Failed to load stroke line data');
          }

          strokeLine = await response.json();
        }
        if (
          strokeLine &&
          strokeLine.control_points &&
          Array.isArray(strokeLine.control_points) &&
          strokeLine.control_points.length > 0
        ) {
          // Enforce orthogonal rules on loaded control points
          const enforcedPoints = enforceOrthogonalConstraints(
            strokeLine.control_points,
            source,
            target
          );
          setControlPoints(enforcedPoints);

          // Save the enforced points if they differ from the loaded ones
          if (
            JSON.stringify(enforcedPoints) !==
            JSON.stringify(strokeLine.control_points)
          ) {
            await updateStrokeLineControlPoints(
              parseInt(strokeLineId),
              enforcedPoints
            );
          }
        } else {
          // Initialize with three points in the most logical direction
          const isHorizontal =
            Math.abs(target.x - source.x) > Math.abs(target.y - source.y);

          if (isHorizontal) {
            const midX = source.x + (target.x - source.x) / 2;
            const midY = source.y + (target.y - source.y) / 2;

            // If nodes are very close vertically, add a small offset
            const offset = Math.abs(target.y - source.y) < 50 ? 25 : 0;
            const y = midY + offset * (midY > source.y ? 1 : -1);

            const initialPoints = [
              { x: source.x, y },
              { x: midX, y },
              { x: target.x, y },
            ];
            setControlPoints(initialPoints);

            // Save initial points to database
            if (data && !data.preview) {
              await updateStrokeLineControlPoints(
                parseInt(strokeLineId),
                initialPoints
              );
            }
          } else {
            const midX = source.x + (target.x - source.x) / 2;
            const midY = source.y + (target.y - source.y) / 2;

            // If nodes are very close horizontally, add a small offset
            const offset = Math.abs(target.x - source.x) < 50 ? 25 : 0;
            const x = midX + offset * (midX > source.x ? 1 : -1);

            const initialPoints = [
              { x, y: source.y },
              { x, y: midY },
              { x, y: target.y },
            ];
            setControlPoints(initialPoints);

            // Save initial points to database
            if (data && !data.preview) {
              await updateStrokeLineControlPoints(
                parseInt(strokeLineId),
                initialPoints
              );
            }
          }
        }
      } catch (error) {
        console.error('Error loading control points:', error);
        // Simple fallback
        const source = getConnectionPoint(
          sourceX,
          sourceY,
          sourcePosition,
          true
        );
        const target = getConnectionPoint(
          targetX,
          targetY,
          targetPosition,
          false
        );
        const midX = source.x + (target.x - source.x) / 2;
        const midY = source.y + (target.y - source.y) / 2;

        const fallbackPoints = [
          { x: source.x, y: midY },
          { x: midX, y: midY },
          { x: target.x, y: midY },
        ];
        setControlPoints(fallbackPoints);

        // Save fallback points to database
        try {
          const strokeLineId = parseInt(id.replace('stroke-edge-', ''));
          if (data && !data.preview) {
            await updateStrokeLineControlPoints(strokeLineId, fallbackPoints);
          }
        } catch (saveError) {
          console.error('Error saving fallback control points:', saveError);
        }
      }
    };

    loadControlPoints();
  }, [
    id,
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourcePosition,
    targetPosition,
    getConnectionPoint,
  ]);

  // Debounced save when control points change
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      if (controlPoints.length > 0) {
        if (data && !data.preview) {
          saveControlPoints();
        }
      }
    }, 500); // Debounce for 500ms

    return () => clearTimeout(timeoutId);
  }, [controlPoints, saveControlPoints, data]);

  const handleControlPointDragEnd = useCallback(() => {
    setIsDragging(false);
    setActivePointIndex(null);
    // Save immediately after drag ends
    if (data && !data.preview) {
      saveControlPoints();
    }
  }, [saveControlPoints, data]);

  // Add back the drag event listeners
  useEffect(() => {
    if (isDragging) {
      window.addEventListener('mousemove', handleControlPointDrag);
      window.addEventListener('mouseup', handleControlPointDragEnd);
    }

    return () => {
      window.removeEventListener('mousemove', handleControlPointDrag);
      window.removeEventListener('mouseup', handleControlPointDragEnd);
    };
  }, [isDragging, handleControlPointDrag, handleControlPointDragEnd]);

  // Inside the StrokeEdge component, add an effect to handle global visibility changes

  // Add this useEffect after the other useEffect hooks
  useEffect(() => {
    // If global visibility is turned off, we need to update the UI to reflect that
    if (!allStrokeLinesVisible) {
      if (showLabel) {
        setShowLabel(false);
      }
      if (showDeleteButton) {
        setShowDeleteButton(false);
      }
    }
  }, [allStrokeLinesVisible, showLabel, showDeleteButton]);

  let edgePath = '';

  if (isSelfLoop) {
    const radius = 40;
    const centerX = sourceX - radius;
    const centerY = sourceY + (targetY - sourceY) / 2;

    edgePath = `M ${sourceX} ${sourceY} 
                C ${centerX} ${sourceY} 
                  ${centerX} ${targetY} 
                  ${targetX} ${targetY}`;
  } else if (controlPoints.length > 0) {
    // Get actual source and target points
    const source = getConnectionPoint(sourceX, sourceY, sourcePosition, true);
    const target = getConnectionPoint(targetX, targetY, targetPosition, false);

    // Create orthogonal path starting from source handle
    edgePath = `M ${source.x} ${source.y}`;

    // Add all control points
    for (const point of controlPoints) {
      edgePath += ` L ${point.x} ${point.y}`;
    }

    // End at target handle
    edgePath += ` L ${target.x} ${target.y}`;
  }

  // Add this helper function before the handleControlPointDragEnd function
  const enforceOrthogonalConstraints = useCallback(
    (points: Point[], source: Point, target: Point): Point[] => {
      // If we don't have enough points for orthogonal path, return as is
      if (points.length < 3) return points;

      // Create a copy of the points to work with
      const newPoints = [...points];

      // Determine if this is primarily a horizontal or vertical connection
      const isHorizontalPrimary =
        Math.abs(target.x - source.x) > Math.abs(target.y - source.y);

      if (isHorizontalPrimary) {
        // For horizontal primary, all points should share the same Y coordinate (middle point's Y)
        const middlePointIndex = Math.floor(points.length / 2);
        const middleY = points[middlePointIndex].y;

        // First segment: horizontal from source to first bend
        newPoints[0] = { x: source.x, y: middleY };

        // Middle segments: maintain the same Y
        for (let i = 1; i < points.length - 1; i++) {
          newPoints[i] = { x: points[i].x, y: middleY };
        }

        // Last segment: horizontal to target
        newPoints[points.length - 1] = { x: target.x, y: middleY };
      } else {
        // For vertical primary, all points should share the same X coordinate (middle point's X)
        const middlePointIndex = Math.floor(points.length / 2);
        const middleX = points[middlePointIndex].x;

        // First segment: vertical from source to first bend
        newPoints[0] = { x: middleX, y: source.y };

        // Middle segments: maintain the same X
        for (let i = 1; i < points.length - 1; i++) {
          newPoints[i] = { x: middleX, y: points[i].y };
        }

        // Last segment: vertical to target
        newPoints[points.length - 1] = { x: middleX, y: target.y };
      }

      return newPoints;
    },
    []
  );

  return (
    <BasicEdge
      id={id}
      source={source}
      target={target}
      sourceX={sourceX}
      sourceY={sourceY}
      targetX={targetX}
      targetY={targetY}
      sourcePosition={sourcePosition}
      targetPosition={targetPosition}
      style={style}
      data={data}
    >
      <defs>
        <marker
          id={markerId}
          markerWidth="6"
          markerHeight="6"
          refX="5"
          refY="3"
          orient="auto"
        >
          <path
            d="M 0 0 L 6 3 L 0 6 z"
            fill="#FF69A3"
            className="transition-colors duration-300"
          />
        </marker>
      </defs>
      {/* Visible stroke line */}
      <path
        id={id}
        className={`react-flow__edge-path stroke-edge-animated ${isDeleting ? 'opacity-0 transition-opacity duration-300' : ''}`}
        d={edgePath}
        style={{
          ...style,
          strokeWidth: 2,
          stroke: '#FF69A3',
          strokeDasharray: '5',
          opacity:
            isConnectMode && previewEdgeId !== id
              ? 0.4
              : isEditMode
                ? 0.4
                : !allStrokeLinesVisible || data?.isVisible === false
                  ? 0
                  : 1,
          markerEnd: `url(#${markerId})`,
          pointerEvents: 'none',
        }}
      />
      {/* Wide hover detection path */}
      <path
        d={edgePath}
        fill="none"
        strokeWidth="24"
        stroke="transparent"
        onMouseEnter={handleMouseEnter}
        onMouseMove={handleMouseMove}
        onMouseLeave={handleMouseLeave}
        style={{
          cursor: 'grab',
          opacity: !allStrokeLinesVisible || data?.isVisible === false ? 0 : 1,
          pointerEvents:
            !allStrokeLinesVisible || data?.isVisible === false
              ? 'none'
              : 'stroke',
        }}
      />

      {/* Control Points */}
      {!isDeleting &&
        allStrokeLinesVisible &&
        data?.isVisible !== false &&
        (isHoveringEdge || isDragging) &&
        !isModalOpen &&
        controlPoints.map((point, index) => (
          <EdgeLabelRenderer key={`control-${index}`}>
            <div
              style={{
                position: 'absolute',
                transform: `translate(-50%, -50%) translate(${point.x}px,${point.y}px) scale(${1 / zoom})`,
                pointerEvents: 'all',
                cursor:
                  isDragging && activePointIndex === index
                    ? 'grabbing'
                    : 'grab',
                zIndex: 1000,
                width: '32px',
                height: '32px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                background: 'rgba(255, 255, 255, 0.01)',
                borderRadius: '50%',
              }}
              onMouseDown={handleControlPointDragStart(index)}
              onMouseEnter={handleControlPointMouseEnter}
              onMouseLeave={handleControlPointMouseLeave}
              className="control-point-hitbox"
            >
              <div
                className={`w-4 h-4 rounded-full bg-[#FF69A3] border-2 border-white shadow-md transition-all duration-200 ${
                  isDragging && activePointIndex === index ? 'scale-125' : ''
                } ${index === 1 ? 'bg-blue-500' : ''} hover:scale-150 hover:shadow-lg`}
              />
            </div>
          </EdgeLabelRenderer>
        ))}

      {/* Edge Controls Container */}
      {showLabel &&
        !isHoveringControlPoint &&
        !isModalOpen &&
        allStrokeLinesVisible &&
        data?.isVisible !== false && (
          <EdgeLabelRenderer>
            <div
              style={{
                position: 'absolute',
                transform: `translate(-50%, -50%) translate(${labelPosition.x}px,${labelPosition.y}px) scale(${1 / zoom})`,
                pointerEvents: 'all',
                zIndex: 9999,
              }}
              onMouseEnter={() => {
                if (hideTimeoutRef.current) {
                  clearTimeout(hideTimeoutRef.current);
                }
                setShowLabel(true);
                setShowDeleteButton(true);
              }}
              onMouseLeave={handleMouseLeave}
            >
              <div className="flex items-center gap-2 px-3 py-1.5 bg-white rounded-lg shadow-md border border-[#F670C7] transition-all duration-200">
                {/* Label */}
                {data?.label && (
                  <span
                    className="text-sm"
                    style={{
                      color: '#C11574',
                    }}
                  >
                    {data.label.toString()}
                  </span>
                )}

                {/* Divider */}
                {data?.label && (
                  <div className="w-px h-4 bg-[#F670C7] opacity-30" />
                )}

                {/* Delete Button */}
                <button
                  className="w-5 h-5 rounded-full bg-[#FF69A3] hover:bg-[#ff4d93] flex items-center justify-center transition-colors duration-200"
                  onClick={(e) => {
                    e.stopPropagation();
                    if (isModalOpen) return;
                    setShowDeleteModal(true);
                  }}
                >
                  <svg
                    width="10"
                    height="10"
                    viewBox="0 0 12 12"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      d="M1 1L11 11M1 11L11 1"
                      stroke="white"
                      strokeWidth="2"
                      strokeLinecap="round"
                    />
                  </svg>
                </button>
              </div>
            </div>
          </EdgeLabelRenderer>
        )}

      {/* Delete confirmation modal */}
      {showDeleteModal && (
        <DeleteStrokeEdgeModal
          onClose={() => setShowDeleteModal(false)}
          onDelete={handleDelete}
          label={data?.label?.toString()}
        />
      )}

      <style>
        {`
          @keyframes flowAnimation {
            0% {
              stroke-dashoffset: 0;
            }
            100% {
              stroke-dashoffset: 1000;
            }
          }
          
          /* Enhanced control point styles */
          .control-point-hitbox {
            transition: all 0.2s ease;
          }
          
          .control-point-hitbox:hover {
            background: rgba(255, 255, 255, 0.1);
          }
          
          .control-point-hitbox:active {
            transform: scale(1.1); 
          }
        `}
      </style>
    </BasicEdge>
  );
}

export default StrokeEdge;
</file>

<file path="app/[slug]/[flow]/edit/components/modals/ConnectNodeModal.tsx">
import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { Node, Edge } from '@xyflow/react';
import { createPortal } from 'react-dom';
import { useReactFlow } from '@xyflow/react';
import { useColors } from '@/app/theme/hooks';
// import { PreviewEdgePortal } from './PreviewEdgePortal';
import { useConnectModeStore } from '../../store/connectModeStore';
import { useModalStore } from '../../store/modalStore';
import ButtonNormal from '@/app/components/ButtonNormal';
import InputField from '@/app/components/InputFields';
// No longer need separate ThemeProvider for modals
import { useIsModalOpenStore } from '@/app/isModalOpenStore';
import { Block, BlockType, NodeData } from '../../../types';
import Modal from '@/app/components/Modal';
import { updateStrokeLine } from '../../utils/stroke-lines';

interface ConnectNodeModalProps {
  onClose: () => void;
  onConfirm: (targetNodeId: string, label: string) => void;
  sourceNode: Node;
  availableNodes: Node[];
  onPreviewUpdate?: (edge: Edge | null) => void;
  initialTargetNodeId?: string;
  initialLabel?: string;
  editStrokeLineId?: string;
  isEdit?: boolean;
  onLinkUpdated?: (updatedStrokeLine: any) => void;
}

const ConnectNodeModal: React.FC<ConnectNodeModalProps> = ({
  onClose,
  onConfirm,
  sourceNode,
  availableNodes,
  onPreviewUpdate,
  initialTargetNodeId,
  initialLabel,
  editStrokeLineId,
  isEdit,
  onLinkUpdated,
}) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedNodeId, setSelectedNodeId] = useState<string>(initialTargetNodeId || '');
  const [label, setLabel] = useState(initialLabel || '');
  const { fitView, getNode } = useReactFlow();
  const colors = useColors();
  const [previewEdge, setPreviewEdge] = useState<Edge | null>(null);
  const { setTargetBlockId, setPreviewEdgeId } = useConnectModeStore();
  const setConnectData = useModalStore((state) => state.setConnectData);
  const [isInputFocused, setIsInputFocused] = useState(false);
  const [blurTimeout, setBlurTimeout] = useState<NodeJS.Timeout | null>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLDivElement>(null);
  const [dropdownPosition, setDropdownPosition] = useState<'top' | 'bottom'>(
    'bottom'
  );
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const setIsModalOpen = useIsModalOpenStore((state) => state.setIsModalOpen);
  const [originalTargetNodeId] = useState(initialTargetNodeId || '');
  const [originalLabel] = useState(initialLabel || '');
  
  // Add ref to prevent cascading updates
  const isUpdatingPreview = useRef(false);

  useEffect(() => {
    setIsModalOpen(true);
    return () => setIsModalOpen(false);
  }, [setIsModalOpen]);

  // Helper function for consistent view options
  const getFitViewOptions = useCallback((nodes: Node[]) => ({
    nodes,
    duration: 800,
    padding: 1.2,
    maxZoom: 1.2,
    // Add offset to account for modal width (600px + padding)
    offset: [-(600 + 32), 0], // 600px is modal width, 32px is right padding
  }), []);

  // Memoize the preview edge to prevent unnecessary recreations
  const memoizedPreviewEdge = useMemo(() => {
    if (!selectedNodeId) return null;
    
    return {
      id: 'preview-edge',
      source: sourceNode.id,
      target: selectedNodeId,
      type: 'strokeEdge',
      sourceHandle: 'stroke_source',
      targetHandle:
        selectedNodeId === sourceNode.id
          ? 'stroke_self_target'
          : 'stroke_target',
      style: {
        opacity: 1,
        stroke: colors['accent-primary'],
        strokeWidth: 3,
        strokeDasharray: '5,5',
        zIndex: 9999,
      },
      animated: true,
      data: {
        source: sourceNode.id,
        target: selectedNodeId,
        preview: true,
        isVisible: true,
      },
      zIndex: 9999,
    } as Edge;
  }, [selectedNodeId, sourceNode.id, colors]);

  // Stable update preview function
  const updatePreview = useCallback((edge: Edge | null) => {
    if (isUpdatingPreview.current) return;
    isUpdatingPreview.current = true;
    
    try {
      onPreviewUpdate?.(edge);
    } finally {
      // Reset the flag after a brief delay to allow the update to complete
      setTimeout(() => {
        isUpdatingPreview.current = false;
      }, 0);
    }
  }, [onPreviewUpdate]);

  // Initial zoom to source node - only run once
  useEffect(() => {
    const node = getNode(sourceNode.id);
    if (node) {
      fitView(getFitViewOptions([node]));
    }
  }, [sourceNode.id]); // Removed getNode and fitView from dependencies to prevent re-runs

  // Zoom to both nodes when target is selected - debounced
  useEffect(() => {
    if (!selectedNodeId) return;
    
    const timeoutId = setTimeout(() => {
      const source = getNode(sourceNode.id);
      const target = getNode(selectedNodeId);
      if (source && target) {
        fitView(getFitViewOptions([source, target]));
      }
    }, 100); // Small debounce to prevent rapid calls

    return () => clearTimeout(timeoutId);
  }, [selectedNodeId, sourceNode.id]); // Removed getNode and fitView from dependencies

  // Update preview edge - optimized to prevent infinite loops
  useEffect(() => {
    if (isUpdatingPreview.current) return;
    
    setPreviewEdge(memoizedPreviewEdge);
    updatePreview(memoizedPreviewEdge);
  }, [memoizedPreviewEdge, updatePreview]);

  // Add escape key handler
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        setSearchTerm('');
      }
    };

    document.addEventListener('keydown', handleEscape);
    return () => document.removeEventListener('keydown', handleEscape);
  }, []);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target as Element)
      ) {
        setIsInputFocused(false);
      }
    };

    if (isInputFocused) {
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isInputFocused]);

  // Calculate dropdown position based on available space
  useEffect(() => {
    if (isInputFocused && inputRef.current) {
      const inputRect = inputRef.current.getBoundingClientRect();
      const spaceBelow = window.innerHeight - inputRect.bottom;
      const spaceAbove = inputRect.top;
      const requiredSpace = 240; // max-height of dropdown

      if (spaceBelow < requiredSpace && spaceAbove > spaceBelow) {
        setDropdownPosition('top');
      } else {
        setDropdownPosition('bottom');
      }
    }
  }, [isInputFocused]);

  const filteredNodes = availableNodes.filter(
    (node) =>
      // Only include STEP type nodes
      (node.data.type === 'STEP' ||
        node.data.type === 'DELAY' ||
        node.data.type === 'PATH') &&
      ((typeof node.data.label === 'string' &&
        node.data.label.toLowerCase().includes(searchTerm.toLowerCase())) ||
        `Block ${node.data.position}`
          .toLowerCase()
          .includes(searchTerm.toLowerCase()))
  );

  const handleModalClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const handleConfirm = useCallback(async () => {
    if (selectedNodeId && label.trim()) {
      try {
        setError(null);
        setIsLoading(true);
        if (isEdit && editStrokeLineId) {
          // Update existing stroke line
          const nodeData = sourceNode.data as NodeData;
          const workflowId = nodeData.path?.workflow_id;
          if (!workflowId) {
            setError('Workflow ID is missing from source node');
            setIsLoading(false);
            return;
          }
          const updated = await updateStrokeLine({
            id: parseInt(editStrokeLineId.replace('stroke-edge-', '')),
            source_block_id: parseInt(sourceNode.id.replace('block-', '')),
            target_block_id: parseInt(selectedNodeId.replace('block-', '')),
            workflow_id: workflowId,
            label: label,
          });
          if (!updated) throw new Error('Failed to update link');
          if (onLinkUpdated) onLinkUpdated(updated);
          onClose(); // Close modal after successful update
        } else {
          await onConfirm(selectedNodeId, label);
        }
        setPreviewEdge(null);
        updatePreview(null);
      } catch (err) {
        setError(
          err instanceof Error ? err.message : 'An unexpected error occurred'
        );
      } finally {
        setIsLoading(false);
      }
    }
  }, [selectedNodeId, label, isEdit, editStrokeLineId, sourceNode, onLinkUpdated, onClose, onConfirm, updatePreview]);

  const handleNodeSelect = useCallback((nodeId: string) => {
    // Batch state updates to prevent cascading re-renders
    setSelectedNodeId(nodeId);
    
    // Set connect data
    const targetNode = getNode(nodeId);
    if (targetNode) {
      setConnectData({
        sourceNode: sourceNode,
        targetNode: targetNode,
      });
    }

    // Set preview edge ID for the store
    setPreviewEdgeId('preview-edge');
    
    // The preview edge will be automatically created by the memoizedPreviewEdge useMemo
    // and updated by the useEffect, so we don't need to manually create it here
  }, [getNode, sourceNode, setConnectData, setPreviewEdgeId]);

  const clearSelection = useCallback(() => {
    setTargetBlockId(null);
    setPreviewEdgeId(null);
    setSelectedNodeId('');
    setSearchTerm('');
    // The preview will be automatically cleared by the useEffect when selectedNodeId becomes empty
  }, [setTargetBlockId, setPreviewEdgeId]);

  const handleClose = useCallback(() => {
    clearSelection();
    onClose();
  }, [clearSelection, onClose]);

  const handleBlur = useCallback(() => {
    // Set a small delay before hiding the list
    const timeout = setTimeout(() => {
      setIsInputFocused(false);
    }, 200);
    setBlurTimeout(timeout);
  }, []);

  const handleNodeClick = useCallback((nodeId: string) => {
    // Clear the blur timeout if it exists
    if (blurTimeout) {
      clearTimeout(blurTimeout);
    }
    handleNodeSelect(nodeId);
    setIsInputFocused(false); // Hide list after selection
  }, [blurTimeout, handleNodeSelect]);

  const handleChange = useCallback((value: string) => {
    setSearchTerm(value);
    
    // Only show loading state for longer searches
    if (value.length > 2) {
      setIsLoading(true);
      setTimeout(() => setIsLoading(false), 200);
    }

    // If there's a value and the dropdown isn't visible, show it
    if (!isInputFocused) {
      setIsInputFocused(true);
    }
  }, [isInputFocused]);

  // Helper function to get icon URL based on node type
  const getNodeTypeIcon = (type: string): string => {
    switch (type) {
      case 'STEP':
        return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/git-commit.svg`;
      case 'PATH':
        return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dataflow-04.svg`;
      case 'DELAY':
        return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/clock-stopwatch-1.svg`;
      default:
        return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/default-icon.svg`;
    }
  };

  const modalContent = (
    <>
      {/* <PreviewEdgePortal edge={previewEdge} /> */}
      {/* Semi-transparent overlay */}
      {/* <div
        className="fixed inset-0 bg-black bg-opacity-0 z-40"
        onClick={handleClose}
      /> */}
      {/* Modal - keep high z-index */}
      <div
        className="fixed bottom-20 right-8 w-[600px] rounded-xl shadow-lg z-50 border"
        style={{
          backgroundColor: colors['bg-primary'],
          borderColor: colors['border-secondary'],
        }}
        onClick={handleModalClick}
      >
        {/* Header */}
        <div
          className="flex items-center gap-4 px-6 pt-6 pb-6 border-b"
          style={{ borderColor: colors['border-secondary'] }}
        >
          <div
            className="w-12 h-12 p-3 rounded-[10px] shadow-[0px_1px_2px_0px_rgba(16,24,40,0.05)] border justify-center items-center inline-flex overflow-hidden"
            style={{
              backgroundColor: colors['bg-secondary'],
              borderColor: colors['border-secondary'],
            }}
          >
            <img
              src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/connect-node.svg`}
              alt="Connect blocks"
              className="w-6 h-6"
            />
          </div>
          <h2
            className="text-lg font-medium"
            style={{ color: colors['text-primary'] }}
          >
            Create a path to a block
          </h2>
        </div>

        {/* Content */}
        <div className="p-6">
          <div className="flex flex-col gap-4">
            <div
              className="text-sm font-semibold"
              style={{ color: colors['text-secondary'] }}
            >
              Select Block
            </div>

            {/* Two Column Layout */}
            <div className="flex justify-end">
              <div className="flex gap-0">
                {/* Connection Line Image Column */}
                <div className="w-4 flex-shrink-0 relative">
                  <div className="absolute top-[60px] bottom-[60px]">
                    <img
                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/connect-line.svg`}
                      alt="Connection line"
                      className="h-full w-full object-fill"
                    />
                    {/* Check Icon */}
                    <div className="absolute left-[0.4px] top-1/2 -translate-x-1/2 -translate-y-1/2 w-6 h-6 rounded-full flex items-center justify-center">
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-icon-white.svg`}
                        alt="Check"
                        className="w-3 h-3"
                      />
                    </div>
                  </div>
                </div>

                {/* Nodes Column */}
                <div className="w-[450px] flex flex-col gap-6">
                  {/* Source Block */}
                  <div
                    className="w-full p-4 rounded-lg"
                    style={{
                      backgroundColor: colors['bg-secondary'],
                      borderColor: colors['border-light'],
                      border: `1px solid ${colors['border-light']}`,
                    }}
                  >
                    <div
                      className="text-sm mb-2"
                      style={{ color: colors['text-secondary'] }}
                    >
                      Node 1
                    </div>
                    <div
                      className="text-xs mb-1"
                      style={{ color: colors['text-tertiary'] }}
                    >
                      #{(sourceNode.data.block as Block).type}
                    </div>
                    <div
                      className="text-sm font-medium break-words line-clamp-2"
                      style={{ color: colors['text-primary'] }}
                    >
                      {sourceNode.data.label as string}
                    </div>
                  </div>

                  {/* Target Block */}
                  {selectedNodeId ? (
                    <div
                      className="w-full p-4 rounded-lg"
                      style={{
                        backgroundColor: colors['bg-secondary'],
                        borderColor: colors['border-light'],
                        border: `1px solid ${colors['border-light']}`,
                      }}
                    >
                      <div className="flex justify-between items-start mb-2">
                        <div
                          className="text-sm"
                          style={{ color: colors['text-secondary'] }}
                        >
                          Node 2
                        </div>
                        <ButtonNormal
                          onClick={() => {
                            clearSelection();
                          }}
                          variant="tertiary"
                          iconOnly
                          size="small"
                          leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`}
                        />
                      </div>
                      <div
                        className="text-xs mb-1"
                        style={{ color: colors['text-tertiary'] }}
                      >
                        #{(getNode(selectedNodeId)?.data.block as Block).type}
                      </div>
                      <div
                        className="text-sm font-medium break-words line-clamp-2"
                        style={{ color: colors['text-primary'] }}
                      >
                        {getNode(selectedNodeId)?.data.label as string}
                      </div>
                    </div>
                  ) : (
                    <div
                      className="w-full p-4 rounded-lg"
                      style={{
                        backgroundColor: colors['bg-secondary'],
                        borderColor: colors['border-light'],
                        border: `1px solid ${colors['border-light']}`,
                      }}
                    >
                      <div
                        className="text-sm mb-2"
                        style={{ color: colors['text-secondary'] }}
                      >
                        Node 2
                      </div>
                      <div className="relative" ref={dropdownRef}>
                        <div
                          className="cursor-pointer"
                          onClick={() => setIsInputFocused(true)}
                          ref={inputRef}
                        >
                          <InputField
                            type="icon-leading"
                            iconUrl={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/search-icon.svg`}
                            value={searchTerm}
                            onChange={handleChange}
                            placeholder="Search for a node..."
                          />
                        </div>

                        <div
                          className="flex items-center gap-2 absolute right-2 top-2.5 z-50 cursor-pointer transition-transform duration-200"
                          style={{
                            transform: isInputFocused
                              ? 'rotate(180deg)'
                              : 'rotate(0deg)',
                          }}
                          onClick={() => setIsInputFocused(!isInputFocused)}
                        >
                          <svg
                            className="w-5 h-5"
                            fill="none"
                            stroke={colors['text-tertiary']}
                            viewBox="0 0 24 24"
                          >
                            <path
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              strokeWidth={2}
                              d="M19 9l-7 7-7-7"
                            />
                          </svg>
                        </div>

                        {/* Search list with improved UX */}
                        {isInputFocused && (
                          <div
                            className={`absolute left-0 right-0 rounded-lg shadow-lg max-h-[240px] overflow-y-auto z-10 transition-all duration-200 ease-in-out border py-1 ${
                              dropdownPosition === 'top'
                                ? 'bottom-[calc(100%_+_5px)]'
                                : 'top-[calc(100%_+_5px)]'
                            }`}
                            style={{
                              backgroundColor: colors['bg-secondary'],
                              borderColor: colors['border-secondary'],
                              animation: 'fadeIn 0.2s ease-out',
                            }}
                          >
                            {isLoading ? (
                              <div className="p-4 text-sm text-center flex items-center justify-center">
                                <div
                                  className="w-5 h-5 border-2 rounded-full border-t-transparent animate-spin mr-2"
                                  style={{
                                    borderColor: `${colors['accent-primary']} transparent ${colors['accent-primary']} ${colors['accent-primary']}`,
                                  }}
                                ></div>
                                <span
                                  style={{ color: colors['text-secondary'] }}
                                >
                                  Searching...
                                </span>
                              </div>
                            ) : filteredNodes.length > 0 ? (
                              filteredNodes.map((node) => (
                                <button
                                  key={node.id}
                                  onMouseDown={(e) => {
                                    e.preventDefault(); // Prevent blur from firing before click
                                    handleNodeClick(node.id);
                                  }}
                                  className="w-full text-left text-sm transition-colors flex items-center justify-between p-[1px] px-[6px]"
                                  style={{
                                    color: colors['text-primary'],
                                    backgroundColor:
                                      selectedNodeId === node.id
                                        ? `${colors['accent-primary']}15`
                                        : 'transparent',
                                  }}
                                  onMouseOver={(e) => {
                                    if (selectedNodeId !== node.id) {
                                      const innerDiv =
                                        e.currentTarget.querySelector('div');
                                      if (innerDiv) {
                                        innerDiv.style.backgroundColor =
                                          colors['bg-tertiary'];
                                      }
                                    }
                                  }}
                                  onMouseOut={(e) => {
                                    if (selectedNodeId !== node.id) {
                                      const innerDiv =
                                        e.currentTarget.querySelector('div');
                                      if (innerDiv) {
                                        innerDiv.style.backgroundColor =
                                          'transparent';
                                      }
                                    }
                                  }}
                                >
                                  <div className="flex items-center gap-2 w-full rounded-[6px] py-[10px] px-[10px] pl-[8px]">
                                    <div className="w-5 h-5 flex-shrink-0">
                                      <img
                                        src={getNodeTypeIcon(
                                          node.data.type as string
                                        )}
                                        alt={`${node.data.type} icon`}
                                        className="w-full h-full object-contain"
                                      />
                                    </div>
                                    <div className="text-sm font-medium">
                                      {node.data.label as string}
                                    </div>
                                    {selectedNodeId === node.id && (
                                      <div className="ml-auto">
                                        <svg
                                          className="w-4 h-4"
                                          fill="none"
                                          viewBox="0 0 24 24"
                                          stroke={colors['accent-primary']}
                                        >
                                          <path
                                            strokeLinecap="round"
                                            strokeLinejoin="round"
                                            strokeWidth={2}
                                            d="M5 13l4 4L19 7"
                                          />
                                        </svg>
                                      </div>
                                    )}
                                  </div>
                                </button>
                              ))
                            ) : searchTerm ? (
                              <div
                                className="p-6 text-sm text-center flex flex-col items-center justify-center gap-2"
                                style={{ color: colors['text-tertiary'] }}
                              >
                                <svg
                                  className="w-6 h-6 mb-1"
                                  fill="none"
                                  viewBox="0 0 24 24"
                                  stroke={colors['text-tertiary']}
                                >
                                  <path
                                    strokeLinecap="round"
                                    strokeLinejoin="round"
                                    strokeWidth={1.5}
                                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                                  />
                                </svg>
                                <span>No matching nodes found</span>
                                <span className="text-xs opacity-80">
                                  Try a different search term
                                </span>
                              </div>
                            ) : (
                              <div className="p-4 text-sm">
                                {availableNodes
                                  .filter((node) => node.data.type === 'STEP')
                                  .slice(0, 5)
                                  .map((node) => (
                                    <button
                                      key={node.id}
                                      onMouseDown={(e) => {
                                        e.preventDefault();
                                        handleNodeClick(node.id);
                                      }}
                                      className="w-full text-left text-sm transition-colors flex items-center justify-between p-[1px] px-[6px]"
                                      style={{
                                        color: colors['text-primary'],
                                      }}
                                      onMouseOver={(e) => {
                                        const innerDiv =
                                          e.currentTarget.querySelector(
                                            'div'
                                          );
                                        if (innerDiv) {
                                          innerDiv.style.backgroundColor =
                                            colors['bg-tertiary'];
                                        }
                                      }}
                                      onMouseOut={(e) => {
                                        const innerDiv =
                                          e.currentTarget.querySelector(
                                            'div'
                                          );
                                        if (innerDiv) {
                                          innerDiv.style.backgroundColor =
                                            'transparent';
                                        }
                                      }}
                                    >
                                      <div className="flex items-center gap-2 w-full rounded-[6px] py-[10px] px-[10px] pl-[8px]">
                                        <div className="w-5 h-5 flex-shrink-0">
                                          <img
                                            src={getNodeTypeIcon(
                                              node.data.type as string
                                            )}
                                            alt={`${node.data.type} icon`}
                                            className="w-full h-full object-contain"
                                          />
                                        </div>
                                        <div className="text-sm font-medium">
                                          {node.data.label as string}
                                        </div>
                                      </div>
                                    </button>
                                  ))}
                                {availableNodes.filter(
                                  (node) => node.data.type === 'STEP'
                                ).length > 5 && (
                                  <div
                                    className="px-4 py-2 text-xs text-center"
                                    style={{ color: colors['text-tertiary'] }}
                                  >
                                    Type to search more blocks
                                  </div>
                                )}
                              </div>
                            )}
                          </div>
                        )}
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </div>
            
            {/* Link Name Input - Added here */}
            <div className="mt-6">
              <div className="flex items-center gap-1 mb-2">
                <label
                  className="text-sm font-semibold"
                  style={{ color: colors['text-secondary'] }}
                >
                  Link name
                </label>
                <span style={{ color: colors['accent-primary'] }}>*</span>
              </div>
              <InputField
                value={label}
                onChange={(value) => setLabel(value)}
                placeholder="Enter a label for this connection"
              />
            </div>
          </div>

          {error && (
            <div
              className="p-4 rounded-lg flex items-center gap-3 text-sm mt-4"
              style={{
                backgroundColor: `${colors['error-primary']}15`,
                color: colors['error-primary'],
                border: `1px solid ${colors['error-primary']}25`,
              }}
            >
              <svg
                className="w-5 h-5 flex-shrink-0"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                />
              </svg>
              <span style={{ color: colors['error-primary'] }}>
                {error}
              </span>
            </div>
          )}
        </div>

        {/* Actions */}
        <div
          className="flex justify-end gap-3 p-6 border-t"
          style={{ borderColor: colors['border-secondary'] }}
        >
          <div className="flex gap-2">
            <ButtonNormal
              variant="secondary"
              onClick={handleClose}
              size="small"
              disabled={isLoading}
            >
              Cancel
            </ButtonNormal>
            <ButtonNormal
              variant="primary"
              onClick={handleConfirm}
              disabled={
                !selectedNodeId || !label.trim() || isLoading ||
                (isEdit && selectedNodeId === originalTargetNodeId && label === originalLabel)
              }
              size="small"
            >
              {isLoading ? (
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin" />
                  <span>{isEdit ? 'Updating...' : 'Creating...'}</span>
                </div>
              ) : (
                isEdit ? 'Update link' : 'Create link'
              )}
            </ButtonNormal>
          </div>
        </div>
      </div>
    </>
  );

  if (typeof window === 'undefined') return null;
  return createPortal(
    modalContent,
    document.body
  );
};

export default ConnectNodeModal;
</file>

<file path="app/[slug]/[flow]/edit/components/modals/CreateParallelPathModal.tsx">
import React, { useState, useEffect, useMemo } from 'react';
import { createPortal } from 'react-dom';
import Modal from '@/app/components/Modal';
import ButtonNormal from '@/app/components/ButtonNormal';
import InputField from '@/app/components/InputFields';
import InputDropdown from '@/app/components/InputDropdown';
import { useColors, useTheme } from '@/app/theme/hooks';
import { Path } from '../../../types';
import IconModifier from '../IconModifier';
import DOMPurify from 'dompurify';

/**
 * Modal for creating a new parallel path condition.
 * Allows user to specify a condition name, description, and multiple paths.
 * @param onClose - Closes the modal
 * @param onConfirm - Confirms creation with all data
 * @param path - The current path object
 * @param position - The position in the flow
 * @param existingPaths - Optional, pre-existing path names
 */
interface CreateParallelPathModalProps {
  /** Closes the modal */
  onClose: () => void;
  /** Confirms creation with all data */
  onConfirm: (data: {
    conditionName: string;
    conditionDescription?: string;
    icon?: string;
    paths_to_create: string[];
    path_to_move: number;
  }) => void;
  path: Path;
  position: number;
  existingPaths?: string[];
}

const CreateParallelPathModal: React.FC<CreateParallelPathModalProps> = ({
  onClose,
  onConfirm,
  path,
  position,
  existingPaths = [],
}) => {
  const [conditionName, setConditionName] = useState<string>('');
  const [conditionDescription, setConditionDescription] = useState<string>('');
  const [icon, setIcon] = useState<string | undefined>(
    `step-icons/default-icons/dataflow.svg`
  );
  const [pathNames, setPathNames] = useState<string[]>([]);
  const [selectedPath, setSelectedPath] = useState<number>(0);
  const colors = useColors();
  const { currentTheme } = useTheme();

  // Initialize pathNames with existing paths when the modal opens
  useEffect(() => {
    if (existingPaths.length > 0) {
      setPathNames(existingPaths);
    } else {
      setPathNames(['Path n1', 'Path n2']);
    }
  }, [existingPaths]);

  // Check if there are blocks after the specified position
  const hasBlocksAfterPosition = (position: number) => {
    return path.blocks.some(
      (block) =>
        block.position > position ||
        (block.type === 'PATH' && block.position === position)
    );
  };

  // Check if any path name is empty or if condition name is empty
  const hasEmptyPath = pathNames.some((name) => name.trim() === '');
  const isConditionNameEmpty = conditionName.trim() === '';

  const handleAddPath = () => {
    setPathNames([...pathNames, `Path n${pathNames.length + 1}`]);
  };

  const handleRemovePath = (index: number) => {
    const newPathNames = [...pathNames];
    newPathNames.splice(index, 1);
    setPathNames(newPathNames);
  };

  const minimalBlock = useMemo(
    () => ({
      id: 0,
      created_at: '',
      updated_at: '',
      type: 'STEP' as const,
      position: 0,
      workflow_id: 0,
      path_id: 0,
      workflow: path.workflow,
      path: path,
      child_paths: [],
      icon: icon || undefined,
    }),
    [icon, path]
  );

  const modalContent = (
    <div className={currentTheme}>
      <Modal
        title="Create a new condition"
        onClose={onClose}
        icon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dataflow-icon.svg`}
        iconBackgroundColor={colors['bg-secondary']}
        iconBorderColor={colors['border-secondary']}
        showHeaderSeparator={true}
        showActionsSeparator={true}
        width="w-[600px]"
        className="overflow-hidden"
        actions={
          <div className="flex justify-end gap-2 w-full">
            <ButtonNormal variant="secondary" size="small" onClick={onClose}>
              Cancel
            </ButtonNormal>
            <ButtonNormal
              variant="primary"
              size="small"
              onClick={() =>
                onConfirm({
                  conditionName: conditionName,
                  conditionDescription: conditionDescription,
                  icon,
                  paths_to_create: pathNames,
                  path_to_move: selectedPath,
                })
              }
              disabled={
                isConditionNameEmpty || hasEmptyPath || pathNames.length === 0
              }
            >
              Create condition
            </ButtonNormal>
          </div>
        }
      >
        <div
          className="flex flex-col gap-6 pb-4"
          style={{ color: colors['text-primary'] }}
        >
          {/* Condition Name + Icon Selector */}
          <div className="flex flex-col gap-2">
            <label
              className="text-sm font-semibold flex items-center gap-1 text-left"
              style={{ color: colors['text-secondary'] }}
            >
              Condition name <span className="text-primary">*</span>
            </label>
            <div className="flex flex-row items-center w-full gap-2">
              <div className="flex items-center">
                <IconModifier
                  block={minimalBlock}
                  onUpdate={(update) =>
                    setIcon(
                      update.icon ?? 'step-icons/default-icons/dataflow.svg'
                    )
                  }
                />
              </div>
              <div className="flex-1">
                <InputField
                  type="default"
                  value={conditionName}
                  onChange={setConditionName}
                  placeholder="Enter condition name"
                />
              </div>
            </div>
          </div>
          {/* Condition Description */}
          <div className="flex flex-col gap-2">
            <label
              className="text-sm font-semibold"
              style={{ color: colors['text-secondary'] }}
            >
              Condition description
            </label>
            <textarea
              className="border rounded-lg p-3 min-h-[80px] resize-y text-sm focus:outline-none focus:ring-2 focus:ring-primary bg-primary"
              style={{
                background: colors['bg-primary'],
                borderColor: colors['border-primary'],
              }}
              value={conditionDescription}
              onChange={(e) => setConditionDescription(e.target.value)}
              placeholder="Describe the condition (optional)"
            />
          </div>
          {/* Paths Section */}
          <div className="flex flex-col gap-4">
            <div className="flex flex-col gap-4 max-h-[240px] overflow-y-auto p-1">
              {pathNames.map((name, index) => (
                <div key={index} className="flex gap-2 items-end">
                  <div className="flex flex-col gap-1 flex-grow">
                    <label
                      className="text-sm"
                      style={{ color: colors['text-secondary'] }}
                    >
                      Path n{index + 1}
                    </label>
                    <InputField
                      type="default"
                      value={name}
                      onChange={(value) => {
                        const newNames = [...pathNames];
                        newNames[index] = value;
                        setPathNames(newNames);
                      }}
                      placeholder={`This is your path n${index + 1}`}
                    />
                  </div>
                  {index > 1 && (
                    <ButtonNormal
                      variant="secondary"
                      size="medium"
                      onClick={() => handleRemovePath(index)}
                      leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`}
                    />
                  )}
                </div>
              ))}
            </div>
            <ButtonNormal
              variant="secondary"
              size="small"
              onClick={handleAddPath}
              leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/plus-icon-white.svg`}
            >
              Add new path
            </ButtonNormal>
          </div>
          {/* Move blocks dropdown if needed */}
          {hasBlocksAfterPosition(position) && (
            <div className="flex flex-col gap-1">
              <label
                className="text-sm"
                style={{ color: colors['text-secondary'] }}
              >
                Move blocks to
              </label>
              <InputDropdown
                value={pathNames[selectedPath]}
                onChange={(value) => {
                  const index = pathNames.findIndex((name) => name === value);
                  if (index !== -1) {
                    setSelectedPath(index);
                  }
                }}
                options={pathNames.map((name) => ({ name, handle: name }))}
                mode={currentTheme === 'dark' ? 'dark' : 'light'}
              />
            </div>
          )}
        </div>
      </Modal>
    </div>
  );

  // Only render if we're in a browser environment
  if (typeof window === 'undefined') return null;

  return createPortal(modalContent, document.body);
};

export default CreateParallelPathModal;
</file>

<file path="app/[slug]/[flow]/edit/components/modals/DelayTypeModal.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { useColors } from '@/app/theme/hooks';
import { DelayType } from '../../../types';
import FixedDelayModal from './FixedDelayModal';
import EventDelayModal from './EventDelayModal';
import Modal from '@/app/components/Modal';
import ButtonNormal from '@/app/components/ButtonNormal';

interface DelayTypeModalProps {
  onClose: () => void;
  onSelect: (
    delayType: DelayType,
    data: { seconds?: number; eventName?: string }
  ) => void;
  initialData?: {
    delayType?: DelayType;
    eventName?: string;
    seconds?: number;
  };
  isVisible?: boolean;
}

// Define a type for the active modal
type ActiveModal = 'delayType' | 'fixedDelay' | 'eventDelay';

const DelayTypeModal: React.FC<DelayTypeModalProps> = ({
  onClose,
  onSelect,
  initialData,
  isVisible = true,
}) => {
  const colors = useColors();
  const [selectedType, setSelectedType] = useState<DelayType | null>(
    initialData?.delayType || null
  );
  const [activeModal, setActiveModal] = useState<ActiveModal>('delayType');
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLDivElement>(null);
  const [dropdownPosition, setDropdownPosition] = useState<'top' | 'bottom'>(
    'bottom'
  );
  const [isLoaded, setIsLoaded] = useState(false);

  // Set isLoaded to true after a longer delay to ensure theme is properly applied
  useEffect(() => {
    if (isVisible) {
      const timer = setTimeout(() => {
        setIsLoaded(true);
      }, 50); // Reduced from 150ms to 50ms for less lag
      return () => clearTimeout(timer);
    }
    return () => {};
  }, [isVisible]);

  // Pre-compute button styles to ensure they're ready before display
  const buttonSecondaryStyle = {
    backgroundColor: colors['bg-secondary'],
    borderColor: colors['border-primary'],
    color: colors['text-primary'],
  };

  const handleFixedDelaySubmit = (seconds: number) => {
    onSelect(DelayType.FIXED_DURATION, { seconds });
  };

  const handleEventDelaySubmit = (
    eventName: string,
    expirationTime?: number
  ) => {
    onSelect(DelayType.WAIT_FOR_EVENT, { seconds: expirationTime, eventName });
  };

  // Calculate dropdown position based on available space
  useEffect(() => {
    if (isDropdownOpen && inputRef.current) {
      const inputRect = inputRef.current.getBoundingClientRect();
      const spaceBelow = window.innerHeight - inputRect.bottom;
      const spaceAbove = inputRect.top;
      const requiredSpace = 200; // max-height of dropdown

      if (spaceBelow < requiredSpace && spaceAbove > spaceBelow) {
        setDropdownPosition('top');
      } else {
        setDropdownPosition('bottom');
      }
    }
  }, [isDropdownOpen]);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target as Element)
      ) {
        setIsDropdownOpen(false);
      }
    };

    if (isDropdownOpen) {
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isDropdownOpen]);

  // Add escape key handler
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        setIsDropdownOpen(false);
      }
    };

    document.addEventListener('keydown', handleEscape);
    return () => document.removeEventListener('keydown', handleEscape);
  }, []);

  const handleTypeSelect = (type: DelayType) => {
    setSelectedType(type);
    setIsDropdownOpen(false);
  };

  const getDelayTypeDisplayText = (type: DelayType | null) => {
    switch (type) {
      case DelayType.FIXED_DURATION:
        return 'Fixed Duration';
      case DelayType.WAIT_FOR_EVENT:
        return 'Wait for Event';
      default:
        return 'Select a delay type';
    }
  };

  // Create dynamic CSS for the dropdown options
  const getOptionStyles = () => {
    return {
      option: {
        display: 'flex',
        width: '100%',
        alignItems: 'center',
        justifyContent: 'space-between',
        padding: '10px 8px',
        margin: '1px 6px',
        borderRadius: '6px',
        cursor: 'pointer',
        transition: 'background-color 0.15s ease',
      },
      selected: {
        backgroundColor: `${colors['accent-primary']}15`,
      },
      optionHover: {
        '&:hover': {
          backgroundColor: colors['bg-tertiary'],
        },
      },
    };
  };

  // Create a style tag with our dynamic CSS
  useEffect(() => {
    const style = document.createElement('style');
    style.textContent = `
      .delay-type-option {
        cursor: pointer;
        transition: background-color 0.15s ease;
      }
      .delay-type-option:hover > div {
        background-color: ${colors['bg-tertiary']} !important;
      }
    `;
    document.head.appendChild(style);

    return () => {
      document.head.removeChild(style);
    };
  }, [colors]);

  // Handle continue button click to navigate to the next modal
  const handleContinue = () => {
    if (selectedType === DelayType.FIXED_DURATION) {
      setActiveModal('fixedDelay');
    } else if (selectedType === DelayType.WAIT_FOR_EVENT) {
      setActiveModal('eventDelay');
    }
  };

  // If the modal isn't visible, we still render but don't show it
  if (!isVisible) {
    return null;
  }

  // Render the appropriate modal based on activeModal state
  if (activeModal === 'fixedDelay') {
    return (
      <FixedDelayModal
        onClose={() => setActiveModal('delayType')}
        onSubmit={handleFixedDelaySubmit}
        initialSeconds={initialData?.seconds}
      />
    );
  }

  if (activeModal === 'eventDelay') {
    return (
      <EventDelayModal
        onClose={() => setActiveModal('delayType')}
        onSubmit={handleEventDelaySubmit}
        initialEventName={initialData?.eventName}
        initialSeconds={initialData?.seconds}
      />
    );
  }

  return (
    <div
      className={`fixed inset-0 z-[99999] flex items-center justify-center transition-opacity duration-300 ease-in-out ${isLoaded ? 'opacity-0' : 'opacity-0'}`}
      style={{ background: 'rgba(0,0,0,0.35)' }}
      onClick={onClose}
    >
      <div
        onClick={(e) => e.stopPropagation()}
        className="flex items-center justify-center w-full h-full"
      >
        <Modal
          title="Set delay"
          subtitle="Pause the Flow"
          onClose={onClose}
          width="w-[400px]"
          icon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/clock-stopwatch-1.svg`}
          actions={
            <div className="flex gap-3 w-full">
              <ButtonNormal
                onClick={onClose}
                variant="secondary"
                size="small"
                className="flex-1"
              >
                Cancel
              </ButtonNormal>
              <ButtonNormal
                onClick={handleContinue}
                disabled={!selectedType}
                variant="primary"
                size="small"
                className="flex-1"
              >
                Continue
              </ButtonNormal>
            </div>
          }
        >
          <div className="flex flex-col gap-4">
            <div>
              <label
                className="block mb-1.5 text-sm font-medium"
                style={{ color: colors['text-primary'] }}
              >
                Type of delay*
              </label>
              <div className="relative" ref={dropdownRef}>
                <div
                  ref={inputRef}
                  className="cursor-pointer"
                  onClick={() => setIsDropdownOpen(!isDropdownOpen)}
                >
                  <div
                    className="w-full px-3 py-2 rounded-lg border flex items-center justify-between"
                    style={{
                      borderColor: colors['border-primary'],
                      backgroundColor: colors['bg-secondary'],
                      color: selectedType
                        ? colors['text-primary']
                        : colors['text-tertiary'],
                    }}
                  >
                    <span
                      className="text-sm font-normal text-left"
                      style={{ color: colors['text-primary'] }}
                    >
                      {getDelayTypeDisplayText(selectedType)}
                    </span>
                    <div
                      className="flex items-center gap-2 transition-transform duration-200"
                      style={{
                        transform: isDropdownOpen
                          ? 'rotate(180deg)'
                          : 'rotate(0deg)',
                      }}
                    >
                      <svg
                        className="w-5 h-5"
                        fill="none"
                        stroke={colors['text-tertiary']}
                        viewBox="0 0 24 24"
                      >
                        <path
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          strokeWidth={2}
                          d="M19 9l-7 7-7-7"
                        />
                      </svg>
                    </div>
                  </div>
                </div>

                {/* Dropdown menu */}
                {isDropdownOpen && (
                  <div
                    className="fixed rounded-lg shadow-lg max-h-[200px] overflow-y-auto transition-all duration-200 ease-in-out border py-1"
                    style={{
                      backgroundColor: colors['bg-secondary'],
                      borderColor: colors['border-secondary'],
                      animation: 'fadeIn 0.2s ease-out',
                      zIndex: 99999,
                      width: dropdownRef.current?.offsetWidth || 'auto',
                      left:
                        dropdownRef.current?.getBoundingClientRect().left || 0,
                      top:
                        dropdownPosition === 'top'
                          ? (dropdownRef.current?.getBoundingClientRect().top ||
                              0) -
                            10 -
                            (dropdownRef.current?.offsetHeight || 0)
                          : (dropdownRef.current?.getBoundingClientRect()
                              .bottom || 0) + 10,
                    }}
                  >
                    {/* Fixed Duration Option */}
                    <div
                      className="delay-type-option px-[6px] py-[1px]"
                      onClick={() => handleTypeSelect(DelayType.FIXED_DURATION)}
                    >
                      <div
                        className="flex items-center justify-between w-full rounded-[6px] py-[10px] px-[10px] pl-[8px]"
                        style={{
                          backgroundColor:
                            selectedType === DelayType.FIXED_DURATION
                              ? `${colors['accent-primary']}15`
                              : 'transparent',
                        }}
                      >
                        <div className="flex items-center gap-2">
                          <div className="w-5 h-5 flex-shrink-0">
                            <img
                              src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/clock-stopwatch-1.svg`}
                              alt="Fixed Duration"
                              className="w-full h-full object-contain"
                            />
                          </div>
                          <div
                            className="text-sm font-normal text-left"
                            style={{ color: colors['text-primary'] }}
                          >
                            Fixed Duration
                          </div>
                        </div>
                        {selectedType === DelayType.FIXED_DURATION && (
                          <div
                            className="flex-shrink-0 w-5 h-5 rounded-full flex items-center justify-center"
                            style={{
                              backgroundColor: `${colors['accent-primary']}20`,
                            }}
                          >
                            <img
                              src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-icon2.svg`}
                              alt="Selected"
                              className="w-4 h-4 object-contain"
                            />
                          </div>
                        )}
                      </div>
                    </div>

                    {/* Wait for Event Option */}
                    <div
                      className="delay-type-option px-[6px] py-[1px]"
                      onClick={() => handleTypeSelect(DelayType.WAIT_FOR_EVENT)}
                    >
                      <div
                        className="flex items-center justify-between w-full rounded-[6px] py-[10px] px-[10px] pl-[8px]"
                        style={{
                          backgroundColor:
                            selectedType === DelayType.WAIT_FOR_EVENT
                              ? `${colors['accent-primary']}15`
                              : 'transparent',
                        }}
                      >
                        <div className="flex items-center gap-2">
                          <div className="w-5 h-5 flex-shrink-0">
                            <img
                              src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/calendar-clock-1.svg`}
                              alt="Wait for Event"
                              className="w-full h-full object-contain"
                            />
                          </div>
                          <div
                            className="text-sm font-normal text-left"
                            style={{ color: colors['text-primary'] }}
                          >
                            Wait for Event
                          </div>
                        </div>
                        {selectedType === DelayType.WAIT_FOR_EVENT && (
                          <div
                            className="flex-shrink-0 w-5 h-5 rounded-full flex items-center justify-center"
                            style={{
                              backgroundColor: `${colors['accent-primary']}20`,
                            }}
                          >
                            <img
                              src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-icon2.svg`}
                              alt="Selected"
                              className="w-4 h-4 object-contain"
                            />
                          </div>
                        )}
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>
        </Modal>
      </div>
    </div>
  );
};

export default DelayTypeModal;
</file>

<file path="app/[slug]/[flow]/edit/components/modals/DeleteBlocksModal.tsx">
import { createDeleteConfirmationModal } from '@/app/utils/modalPatterns';

interface DeleteBlocksModalProps {
  onClose: () => void;
  onConfirm: () => void;
}

export default function DeleteBlocksModal({
  onClose,
  onConfirm,
}: DeleteBlocksModalProps) {
  return createDeleteConfirmationModal({
    title: 'Delete Blocks',
    message:
      'Are you sure you want to delete all blocks after this position? This action cannot be undone.',
    itemType: 'blocks',
    onDelete: onConfirm,
    onClose: onClose,
  });
}
</file>

<file path="app/[slug]/[flow]/edit/components/modals/DeletePathModal.tsx">
import React, { useState } from 'react';
import { createDeleteConfirmationModal } from '@/app/utils/modalPatterns';
import { usePathsStore } from '../../store/pathsStore';
import { Block } from '../../../types';

interface DeletePathModalProps {
  onClose: () => void;
  onConfirm: (success: boolean, errorMessage?: string) => void; // Updated
  pathName: string;
  pathId?: string;
  workflowId?: string;
  setAllPaths?: (paths: any[]) => void;
  onPathsUpdate?: (paths: any[]) => void;
}

// Utility function to remove the path from parent blocks' child_paths
function removePathFromParentBlocks(
  paths: any[],
  pathToDelete: any,
  pathId: string
) {
  if (!Array.isArray(pathToDelete.parent_blocks)) return paths;

  let updatedPaths = paths;
  pathToDelete.parent_blocks.forEach((parentBlock: any) => {
    updatedPaths = updatedPaths.map((path) => {
      if (!Array.isArray(path.blocks)) return path;
      return {
        ...path,
        blocks: path.blocks.map((block: Block) => {
          if (
            block.id === parentBlock.block_id &&
            Array.isArray(block.child_paths)
          ) {
            return {
              ...block,
              child_paths: block.child_paths.filter(
                (cp: any) => String(cp.path_id) !== String(pathId)
              ),
            };
          }
          return block;
        }),
      };
    });
  });
  return updatedPaths;
}

// Utility function to remove a path by id from the store and clean up parent blocks' child_paths
function removePathById(pathId: string, isSubPath = false) {
  usePathsStore.setState((state) => {
    // Find the path to be deleted
    const pathToDelete = state.paths.find(
      (p) => String(p.id) === String(pathId)
    );
    if (!pathToDelete) {
      return {
        paths: state.paths.filter((path) => String(path.id) !== String(pathId)),
      };
    }

    // --- Prevent deletion if parent block would be left with only one child path ---
    if (
      Array.isArray(pathToDelete.parent_blocks) &&
      pathToDelete.parent_blocks.length === 1 &&
      !isSubPath
    ) {
      const parentBlock = pathToDelete.parent_blocks[0];
      // Find the parent block in the paths store
      const parentPath = state.paths.find(
        (p) =>
          Array.isArray(p.blocks) &&
          p.blocks.some((b) => b.id === parentBlock.block_id)
      );
      const parentBlockObj = parentPath?.blocks?.find(
        (b: any) => b.id === parentBlock.block_id
      );
      if (
        parentBlockObj &&
        Array.isArray(parentBlockObj.child_paths) &&
        parentBlockObj.child_paths.length <= 2 // because we're about to remove one
      ) {
        throw new Error(
          'Cannot delete this path: its parent block would be left with only one child path.'
        );
      }
    }

    // --- Cascade delete: recursively remove all child paths ---
    if (Array.isArray(pathToDelete.blocks)) {
      pathToDelete.blocks.forEach((block: any) => {
        if (Array.isArray(block.child_paths)) {
          block.child_paths.forEach((cp: any) => {
            // Recursively remove each child path
            removePathById(String(cp.path_id), true);
          });
        }
      });
    }

    // Remove the path from the list
    let updatedPaths = state.paths.filter(
      (path) => String(path.id) !== String(pathId)
    );

    // Remove the path from parent blocks' child_paths using the helper
    updatedPaths = removePathFromParentBlocks(
      updatedPaths,
      pathToDelete,
      pathId
    );

    return { paths: updatedPaths };
  });
}

export default function DeletePathModal({
  onClose,
  onConfirm,
  pathName,
  pathId,
  workflowId,
  setAllPaths,
  onPathsUpdate,
}: DeletePathModalProps) {
  const [isLoading, setIsLoading] = useState(false);

  const handleDeletePath = async () => {
    setIsLoading(true);
    try {
      // Remove the path from the store immediately
      if (pathId) {
        try {
          removePathById(pathId);
        } catch (err: any) {
          setIsLoading(false);
          onConfirm(false, err?.message || 'Error deleting path.');
          return;
        }
      }
      setIsLoading(false);
      onConfirm(true); // Success
      const response = await fetch(`/api/paths/${pathId}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        let errorMessage = 'Error deleting path. Please try again.';
        try {
          const data = await response.json();
          if (data && data.error) {
            errorMessage = data.error;
          } else if (data && data.message) {
            errorMessage = data.message;
          }
        } catch {
          // fallback to default errorMessage if not JSON
        }
        throw new Error(errorMessage);
      }

      // Optionally fetch updated paths from the server
      // if (workflowId) {
      //   const pathsResponse = await fetch(
      //     `/api/workspace/${workflowId}/paths?workflow_id=${workflowId}`
      //   );

      //   if (pathsResponse.ok) {
      //     const pathsData = await pathsResponse.json();
      //     setAllPaths?.(pathsData.paths);
      //     onPathsUpdate?.(pathsData.paths);
      //   }
      // }
    } catch (error) {
      setIsLoading(false);
      let message = 'Error deleting path. Please try again.';
      if (typeof error === 'object' && error && 'message' in error) {
        message = (error as { message: string }).message;
      }
      onConfirm(false, message); // Failure, pass error message
      onClose();
    }
  };

  return createDeleteConfirmationModal({
    title: 'Delete Path',
    message: `Are you sure you want to delete ${pathName} and all blocks after this position? This action cannot be undone.`,
    itemType: 'path',
    onDelete: handleDeletePath,
    onClose,
    isLoading,
  });
}
</file>

<file path="app/[slug]/[flow]/edit/components/modals/DeleteStrokeEdgeModal.tsx">
import { createDeleteConfirmationModal } from '@/app/utils/modalPatterns';

interface DeleteStrokeEdgeModalProps {
  onClose: () => void;
  onDelete: () => void;
  label?: string;
}

export default function DeleteStrokeEdgeModal({
  onClose,
  onDelete,
  label,
}: DeleteStrokeEdgeModalProps) {
  return createDeleteConfirmationModal({
    title: 'Delete Connection',
    message: `Are you sure you want to delete this connection${label ? ` labeled "${label}"` : ''}? This action cannot be undone.`,
    itemType: 'connection',
    onDelete,
    onClose,
  });
}
</file>

<file path="app/[slug]/[flow]/edit/components/modals/EventDelayModal.tsx">
import React, { useState, useEffect } from 'react';
import { useColors } from '@/app/theme/hooks';
import Modal from '@/app/components/Modal';
import ButtonNormal from '@/app/components/ButtonNormal';
import DOMPurify from 'dompurify';

interface EventDelayModalProps {
  onClose: () => void;
  onSubmit: (eventName: string, expirationTime?: number) => void;
  initialEventName?: string;
  initialSeconds?: number;
}

const EventDelayModal: React.FC<EventDelayModalProps> = ({
  onClose,
  onSubmit,
  initialEventName = '',
  initialSeconds = 0,
}) => {
  const colors = useColors();
  const [eventName, setEventName] = useState(initialEventName);
  const [hasExpiration, setHasExpiration] = useState(initialSeconds > 0);

  // Convert initial seconds to days, hours, minutes
  const [days, setDays] = useState(Math.floor(initialSeconds / 86400));
  const [hours, setHours] = useState(
    Math.floor((initialSeconds % 86400) / 3600)
  );
  const [minutes, setMinutes] = useState(
    Math.floor((initialSeconds % 3600) / 60)
  );
  const [isLoaded, setIsLoaded] = useState(false);
  const [isFocused, setIsFocused] = useState(false);

  // Set isLoaded to true after a longer delay to ensure theme is properly applied
  useEffect(() => {
    const timer = setTimeout(() => {
      setIsLoaded(true);
    }, 50); // Reduced from 150ms to 50ms for less lag
    return () => clearTimeout(timer);
  }, []);

  // Pre-compute button styles to ensure they're ready before display
  const buttonSecondaryStyle = {
    backgroundColor: colors['bg-secondary'],
    borderColor: colors['border-primary'],
    color: colors['text-primary'],
  };

  const increment = (
    setter: React.Dispatch<React.SetStateAction<number>>,
    value: number,
    max: number | null = null
  ): void => {
    setter((prev) => (max !== null && prev >= max ? prev : prev + value));
  };

  const decrement = (
    setter: React.Dispatch<React.SetStateAction<number>>,
    value: number,
    min: number = 0
  ): void => {
    setter((prev) => (prev <= min ? prev : prev - value));
  };

  const delayText = () => {
    if (!hasExpiration) {
      return 'Flow paused until event occurs';
    }
    if (days === 0 && hours === 0 && minutes === 0) return null;

    const parts = [];
    if (days > 0) parts.push(`${days} ${days === 1 ? 'day' : 'days'}`);
    if (hours > 0) parts.push(`${hours} ${hours === 1 ? 'hour' : 'hours'}`);
    if (minutes > 0)
      parts.push(`${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`);

    return `Delay of ${parts.join(' and ')}.`;
  };

  const handleSubmit = () => {
    const cleanEventName = eventName.trim();
    if (cleanEventName) {
      const expirationSeconds = hasExpiration
        ? days * 86400 + hours * 3600 + minutes * 60
        : 0;
      onSubmit(cleanEventName, expirationSeconds);
    }
  };

  return (
    <div
      className={`transition-opacity duration-300 ease-in-out ${isLoaded ? 'opacity-100' : 'opacity-0'}`}
    >
      <Modal
        title="Set an event based delay"
        subtitle="Pause the Flow until a specific event occurs. Optionally, set a time limit to continue if the event doesn't happen."
        onClose={onClose}
        width="w-[512px]"
        icon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/calendar-clock-1.svg`}
        actions={
          <div className="flex gap-3 w-full">
            <ButtonNormal
              onClick={onClose}
              variant="secondary"
              size="small"
              className="flex-1"
            >
              Cancel
            </ButtonNormal>
            <ButtonNormal
              onClick={handleSubmit}
              disabled={!eventName.trim()}
              variant="primary"
              size="small"
              className="flex-1"
            >
              Confirm
            </ButtonNormal>
          </div>
        }
      >
        <div className="flex flex-col gap-4">
          <div>
            <label
              className="block mb-1.5 text-sm font-medium"
              style={{ color: colors['text-primary'] }}
            >
              Event to wait for*
            </label>
            <input
              type="text"
              value={eventName}
              onChange={(e) => setEventName(e.target.value)}
              onFocus={() => setIsFocused(true)}
              onBlur={() => setIsFocused(false)}
              placeholder="User completes onboarding"
              className="w-full px-3 py-2 rounded-lg border outline-none"
              style={{
                borderColor: isFocused
                  ? colors['border-primary']
                  : colors['border-primary'],
                backgroundColor: colors['bg-secondary'],
                color: colors['text-primary'],
                boxShadow: isFocused
                  ? '0px 0px 0px 4px rgba(78,107,215,0.12)'
                  : '0px 1px 2px rgba(16, 24, 40, 0.05)',
                transition: 'border-color 0.2s, box-shadow 0.2s',
              }}
            />
          </div>

          <div className="flex items-center justify-between">
            <div>
              <div
                className="text-sm font-medium"
                style={{ color: colors['text-primary'] }}
              >
                Set expiration time
              </div>
              <div
                className="text-sm"
                style={{ color: colors['text-secondary'] }}
              >
                Continue if the event doesn't occur within a specific time
              </div>
            </div>
            <button
              onClick={() => setHasExpiration(!hasExpiration)}
              className={`w-12 h-6 rounded-full transition-colors`}
              style={{
                backgroundColor: hasExpiration
                  ? colors['fg-brand-primary']
                  : colors['bg-tertiary'],
              }}
            >
              <div
                className={`w-5 h-5 bg-white rounded-full transform transition-transform ${
                  hasExpiration ? 'translate-x-7' : 'translate-x-0'
                }`}
              />
            </button>
          </div>

          {hasExpiration && (
            <div className="flex gap-4">
              {/* Days counter */}
              <div className="flex-1">
                <label
                  className="block mb-1.5 text-sm font-medium"
                  style={{ color: colors['text-primary'] }}
                >
                  Days
                </label>
                <div
                  className="relative rounded-lg border overflow-hidden"
                  style={{ borderColor: colors['border-primary'] }}
                >
                  <input
                    type="number"
                    value={days}
                    onChange={(e) =>
                      setDays(Math.max(0, parseInt(e.target.value) || 0))
                    }
                    className="w-full px-3 py-2 border-none rounded-lg [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                    style={{
                      backgroundColor: colors['bg-secondary'],
                      color: colors['text-primary'],
                    }}
                  />
                  <div
                    className="absolute right-0 top-0 bottom-0 flex flex-col border-l"
                    style={{ borderColor: colors['border-primary'] }}
                  >
                    <button
                      onClick={() => increment(setDays, 1)}
                      className="h-1/2 px-1.5 flex items-center justify-center transition-colors duration-150 border-b"
                      style={{
                        backgroundColor: colors['bg-secondary'],
                        borderColor: colors['border-primary'],
                      }}
                      onMouseOver={(e) => {
                        e.currentTarget.style.backgroundColor =
                          colors['bg-hover'];
                      }}
                      onMouseOut={(e) => {
                        e.currentTarget.style.backgroundColor =
                          colors['bg-secondary'];
                      }}
                    >
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/chevron-up.svg`}
                        alt="Increase"
                        className="w-2.5 h-2.5"
                      />
                    </button>
                    <button
                      onClick={() => decrement(setDays, 1)}
                      className="h-1/2 px-1.5 flex items-center justify-center transition-colors duration-150"
                      style={{
                        backgroundColor: colors['bg-secondary'],
                      }}
                      onMouseOver={(e) => {
                        e.currentTarget.style.backgroundColor =
                          colors['bg-hover'];
                      }}
                      onMouseOut={(e) => {
                        e.currentTarget.style.backgroundColor =
                          colors['bg-secondary'];
                      }}
                    >
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/chevron-down.svg`}
                        alt="Decrease"
                        className="w-2.5 h-2.5"
                      />
                    </button>
                  </div>
                </div>
              </div>

              {/* Hours counter */}
              <div className="flex-1">
                <label
                  className="block mb-1.5 text-sm font-medium"
                  style={{ color: colors['text-primary'] }}
                >
                  Hours
                </label>
                <div
                  className="relative rounded-lg border overflow-hidden"
                  style={{ borderColor: colors['border-primary'] }}
                >
                  <input
                    type="number"
                    value={hours}
                    onChange={(e) =>
                      setHours(
                        Math.min(23, Math.max(0, parseInt(e.target.value) || 0))
                      )
                    }
                    className="w-full px-3 py-2 border-none rounded-lg [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                    style={{
                      backgroundColor: colors['bg-secondary'],
                      color: colors['text-primary'],
                    }}
                  />
                  <div
                    className="absolute right-0 top-0 bottom-0 flex flex-col border-l"
                    style={{ borderColor: colors['border-primary'] }}
                  >
                    <button
                      onClick={() => increment(setHours, 1, 23)}
                      className="h-1/2 px-1.5 flex items-center justify-center transition-colors duration-150 border-b"
                      style={{
                        backgroundColor: colors['bg-secondary'],
                        borderColor: colors['border-primary'],
                      }}
                      onMouseOver={(e) => {
                        e.currentTarget.style.backgroundColor =
                          colors['bg-hover'];
                      }}
                      onMouseOut={(e) => {
                        e.currentTarget.style.backgroundColor =
                          colors['bg-secondary'];
                      }}
                    >
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/chevron-up.svg`}
                        alt="Increase"
                        className="w-2.5 h-2.5"
                      />
                    </button>
                    <button
                      onClick={() => decrement(setHours, 1)}
                      className="h-1/2 px-1.5 flex items-center justify-center transition-colors duration-150"
                      style={{
                        backgroundColor: colors['bg-secondary'],
                      }}
                      onMouseOver={(e) => {
                        e.currentTarget.style.backgroundColor =
                          colors['bg-hover'];
                      }}
                      onMouseOut={(e) => {
                        e.currentTarget.style.backgroundColor =
                          colors['bg-secondary'];
                      }}
                    >
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/chevron-down.svg`}
                        alt="Decrease"
                        className="w-2.5 h-2.5"
                      />
                    </button>
                  </div>
                </div>
              </div>

              {/* Minutes counter */}
              <div className="flex-1">
                <label
                  className="block mb-1.5 text-sm font-medium"
                  style={{ color: colors['text-primary'] }}
                >
                  Minutes
                </label>
                <div
                  className="relative rounded-lg border overflow-hidden"
                  style={{ borderColor: colors['border-primary'] }}
                >
                  <input
                    type="number"
                    value={minutes}
                    onChange={(e) =>
                      setMinutes(
                        Math.min(59, Math.max(0, parseInt(e.target.value) || 0))
                      )
                    }
                    className="w-full px-3 py-2 border-none rounded-lg [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                    style={{
                      backgroundColor: colors['bg-secondary'],
                      color: colors['text-primary'],
                    }}
                  />
                  <div
                    className="absolute right-0 top-0 bottom-0 flex flex-col border-l"
                    style={{ borderColor: colors['border-primary'] }}
                  >
                    <button
                      onClick={() => increment(setMinutes, 1, 59)}
                      className="h-1/2 px-1.5 flex items-center justify-center transition-colors duration-150 border-b"
                      style={{
                        backgroundColor: colors['bg-secondary'],
                        borderColor: colors['border-primary'],
                      }}
                      onMouseOver={(e) => {
                        e.currentTarget.style.backgroundColor =
                          colors['bg-hover'];
                      }}
                      onMouseOut={(e) => {
                        e.currentTarget.style.backgroundColor =
                          colors['bg-secondary'];
                      }}
                    >
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/chevron-up.svg`}
                        alt="Increase"
                        className="w-2.5 h-2.5"
                      />
                    </button>
                    <button
                      onClick={() => decrement(setMinutes, 1)}
                      className="h-1/2 px-1.5 flex items-center justify-center transition-colors duration-150"
                      style={{
                        backgroundColor: colors['bg-secondary'],
                      }}
                      onMouseOver={(e) => {
                        e.currentTarget.style.backgroundColor =
                          colors['bg-hover'];
                      }}
                      onMouseOut={(e) => {
                        e.currentTarget.style.backgroundColor =
                          colors['bg-secondary'];
                      }}
                    >
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/chevron-down.svg`}
                        alt="Decrease"
                        className="w-2.5 h-2.5"
                      />
                    </button>
                  </div>
                </div>
              </div>
            </div>
          )}

          {delayText() && (
            <div
              className="flex items-center gap-2 p-3 rounded-xl border"
              style={{
                backgroundColor: colors['bg-secondary'],
                borderColor: colors['border-secondary'],
              }}
            >
              <div className="w-5 h-5 flex-shrink-0">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/info-circle.svg`}
                  alt="Info"
                  className="w-full h-full object-contain"
                />
              </div>
              <div
                className="text-sm font-normal"
                style={{ color: colors['text-primary'] }}
              >
                {delayText()}
              </div>
            </div>
          )}
        </div>
      </Modal>
    </div>
  );
};

export default EventDelayModal;
</file>

<file path="app/[slug]/[flow]/edit/components/modals/FixedDelayModal.tsx">
import React, { useState, useEffect } from 'react';
import { useColors } from '@/app/theme/hooks';
import Modal from '@/app/components/Modal';
import ButtonNormal from '@/app/components/ButtonNormal';

interface FixedDelayModalProps {
  onClose: () => void;
  onSubmit: (delaySeconds: number) => void;
  initialSeconds?: number;
}

const FixedDelayModal: React.FC<FixedDelayModalProps> = ({
  onClose,
  onSubmit,
  initialSeconds = 0,
}) => {
  const colors = useColors();
  const [days, setDays] = useState(Math.floor(initialSeconds / 86400));
  const [hours, setHours] = useState(
    Math.floor((initialSeconds % 86400) / 3600)
  );
  const [minutes, setMinutes] = useState(
    Math.floor((initialSeconds % 3600) / 60)
  );
  const [isLoaded, setIsLoaded] = useState(false);

  // Set isLoaded to true after a longer delay to ensure theme is properly applied
  useEffect(() => {
    const timer = setTimeout(() => {
      setIsLoaded(true);
    }, 50); // Reduced from 150ms to 50ms for less lag
    return () => clearTimeout(timer);
  }, []);

  // Pre-compute button styles to ensure they're ready before display
  const buttonSecondaryStyle = {
    backgroundColor: colors['bg-secondary'],
    borderColor: colors['border-primary'],
    color: colors['text-primary']
  };

  const increment = (
    setter: React.Dispatch<React.SetStateAction<number>>,
    value: number,
    max: number | null = null
  ): void => {
    setter((prev) => (max !== null && prev >= max ? prev : prev + value));
  };

  const decrement = (
    setter: React.Dispatch<React.SetStateAction<number>>,
    value: number,
    min: number = 0
  ): void => {
    setter((prev) => (prev <= min ? prev : prev - value));
  };

  const delayText = () => {
    if (days === 0 && hours === 0 && minutes === 0) return null;

    const parts = [];
    if (days > 0) parts.push(`${days} ${days === 1 ? 'day' : 'days'}`);
    if (hours > 0) parts.push(`${hours} ${hours === 1 ? 'hour' : 'hours'}`);
    if (minutes > 0)
      parts.push(`${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`);

    return `Delay of ${parts.join(' and ')}.`;
  };

  const handleSubmit = () => {
    const totalSeconds = days * 86400 + hours * 3600 + minutes * 60;
    onSubmit(totalSeconds);
  };

  return (
    <div className={`transition-opacity duration-300 ease-in-out ${isLoaded ? 'opacity-100' : 'opacity-0'}`}>
      <Modal
        title="Set Fixed Delay"
        subtitle="Wait for a specified amount of time before continuing"
        onClose={onClose}
        width="w-[512px]"
        icon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/clock-stopwatch-1.svg`}
        actions={
          <div className="flex gap-3 w-full">
            <ButtonNormal 
              onClick={onClose}
              variant="secondary"
              size="small"
              className="flex-1"
            >
              Cancel
            </ButtonNormal>
            <ButtonNormal
              onClick={handleSubmit}
              disabled={days === 0 && hours === 0 && minutes === 0}
              variant="primary"
              size="small"
              className="flex-1"
            >
              Confirm
            </ButtonNormal>
          </div>
        }
      >
        <div className="flex flex-col gap-4">
          <div className="flex gap-4">
            {/* Days counter */}
            <div className="flex-1">
              <label
                className="block mb-1.5 text-sm font-medium"
                style={{ color: colors['text-primary'] }}
              >
                Days
              </label>
              <div className="relative rounded-lg border overflow-hidden" style={{ borderColor: colors['border-primary'] }}>
                <input
                  type="number"
                  value={days}
                  onChange={(e) =>
                    setDays(Math.max(0, parseInt(e.target.value) || 0))
                  }
                  className="w-full px-3 py-2 border-none rounded-lg [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                  style={{
                    backgroundColor: colors['bg-secondary'],
                    color: colors['text-primary'],
                  }}
                />
                <div
                  className="absolute right-0 top-0 bottom-0 flex flex-col border-l"
                  style={{ borderColor: colors['border-primary'] }}
                >
                  <button
                    onClick={() => increment(setDays, 1)}
                    className="h-1/2 px-1.5 flex items-center justify-center transition-colors duration-150 border-b"
                    style={{ 
                      backgroundColor: colors['bg-secondary'],
                      borderColor: colors['border-primary']
                    }}
                    onMouseOver={(e) => {
                      e.currentTarget.style.backgroundColor = colors['bg-hover'];
                    }}
                    onMouseOut={(e) => {
                      e.currentTarget.style.backgroundColor = colors['bg-secondary'];
                    }}
                  >
                    <img
                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/chevron-up.svg`}
                      alt="Increase"
                      className="w-2.5 h-2.5"
                    />
                  </button>
                  <button
                    onClick={() => decrement(setDays, 1)}
                    className="h-1/2 px-1.5 flex items-center justify-center transition-colors duration-150"
                    style={{ 
                      backgroundColor: colors['bg-secondary']
                    }}
                    onMouseOver={(e) => {
                      e.currentTarget.style.backgroundColor = colors['bg-hover'];
                    }}
                    onMouseOut={(e) => {
                      e.currentTarget.style.backgroundColor = colors['bg-secondary'];
                    }}
                  >
                    <img
                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/chevron-down.svg`}
                      alt="Decrease"
                      className="w-2.5 h-2.5"
                    />
                  </button>
                </div>
              </div>
            </div>

            {/* Hours counter */}
            <div className="flex-1">
              <label
                className="block mb-1.5 text-sm font-medium"
                style={{ color: colors['text-primary'] }}
              >
                Hours
              </label>
              <div className="relative rounded-lg border overflow-hidden" style={{ borderColor: colors['border-primary'] }}>
                <input
                  type="number"
                  value={hours}
                  onChange={(e) =>
                    setHours(
                      Math.min(23, Math.max(0, parseInt(e.target.value) || 0))
                    )
                  }
                  className="w-full px-3 py-2 border-none rounded-lg [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                  style={{
                    backgroundColor: colors['bg-secondary'],
                    color: colors['text-primary'],
                  }}
                />
                <div
                  className="absolute right-0 top-0 bottom-0 flex flex-col border-l"
                  style={{ borderColor: colors['border-primary'] }}
                >
                  <button
                    onClick={() => increment(setHours, 1, 23)}
                    className="h-1/2 px-1.5 flex items-center justify-center transition-colors duration-150 border-b"
                    style={{ 
                      backgroundColor: colors['bg-secondary'],
                      borderColor: colors['border-primary']
                    }}
                    onMouseOver={(e) => {
                      e.currentTarget.style.backgroundColor = colors['bg-hover'];
                    }}
                    onMouseOut={(e) => {
                      e.currentTarget.style.backgroundColor = colors['bg-secondary'];
                    }}
                  >
                    <img
                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/chevron-up.svg`}
                      alt="Increase"
                      className="w-2.5 h-2.5"
                    />
                  </button>
                  <button
                    onClick={() => decrement(setHours, 1)}
                    className="h-1/2 px-1.5 flex items-center justify-center transition-colors duration-150"
                    style={{ 
                      backgroundColor: colors['bg-secondary']
                    }}
                    onMouseOver={(e) => {
                      e.currentTarget.style.backgroundColor = colors['bg-hover'];
                    }}
                    onMouseOut={(e) => {
                      e.currentTarget.style.backgroundColor = colors['bg-secondary'];
                    }}
                  >
                    <img
                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/chevron-down.svg`}
                      alt="Decrease"
                      className="w-2.5 h-2.5"
                    />
                  </button>
                </div>
              </div>
            </div>

            {/* Minutes counter */}
            <div className="flex-1">
              <label
                className="block mb-1.5 text-sm font-medium"
                style={{ color: colors['text-primary'] }}
              >
                Minutes
              </label>
              <div className="relative rounded-lg border overflow-hidden" style={{ borderColor: colors['border-primary'] }}>
                <input
                  type="number"
                  value={minutes}
                  onChange={(e) =>
                    setMinutes(
                      Math.min(59, Math.max(0, parseInt(e.target.value) || 0))
                    )
                  }
                  className="w-full px-3 py-2 border-none rounded-lg [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                  style={{
                    backgroundColor: colors['bg-secondary'],
                    color: colors['text-primary'],
                  }}
                />
                <div
                  className="absolute right-0 top-0 bottom-0 flex flex-col border-l"
                  style={{ borderColor: colors['border-primary'] }}
                >
                  <button
                    onClick={() => increment(setMinutes, 1, 59)}
                    className="h-1/2 px-1.5 flex items-center justify-center transition-colors duration-150 border-b"
                    style={{ 
                      backgroundColor: colors['bg-secondary'],
                      borderColor: colors['border-primary']
                    }}
                    onMouseOver={(e) => {
                      e.currentTarget.style.backgroundColor = colors['bg-hover'];
                    }}
                    onMouseOut={(e) => {
                      e.currentTarget.style.backgroundColor = colors['bg-secondary'];
                    }}
                  >
                    <img
                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/chevron-up.svg`}
                      alt="Increase"
                      className="w-2.5 h-2.5"
                    />
                  </button>
                  <button
                    onClick={() => decrement(setMinutes, 1)}
                    className="h-1/2 px-1.5 flex items-center justify-center transition-colors duration-150"
                    style={{ 
                      backgroundColor: colors['bg-secondary']
                    }}
                    onMouseOver={(e) => {
                      e.currentTarget.style.backgroundColor = colors['bg-hover'];
                    }}
                    onMouseOut={(e) => {
                      e.currentTarget.style.backgroundColor = colors['bg-secondary'];
                    }}
                  >
                    <img
                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/chevron-down.svg`}
                      alt="Decrease"
                      className="w-2.5 h-2.5"
                    />
                  </button>
                </div>
              </div>
            </div>
          </div>

          {delayText() && (
            <div
              className="flex items-center gap-2 p-3 rounded-xl border"
              style={{
                backgroundColor: colors['bg-secondary'],
                borderColor: colors['border-secondary'],
              }}
            >
              <div className="w-5 h-5 flex-shrink-0">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/info-circle.svg`}
                  alt="Info"
                  className="w-full h-full object-contain"
                />
              </div>
              <div
                className="text-sm font-normal"
                style={{ color: colors['text-primary'] }}
              >
                {delayText()}
              </div>
            </div>
          )}
        </div>
      </Modal>
    </div>
  );
};

export default FixedDelayModal;
</file>

<file path="app/[slug]/[flow]/edit/components/modals/UpdatePathModal.tsx">
import React, { useState, useEffect, useMemo } from 'react';
import { createPortal } from 'react-dom';
import Modal from '@/app/components/Modal';
import ButtonNormal from '@/app/components/ButtonNormal';
import InputField from '@/app/components/InputFields';
import { useColors, useTheme } from '@/app/theme/hooks';
import { remove } from 'lodash';
import IconModifier from '../IconModifier';
import { Block } from '../../../types';
import DOMPurify from 'dompurify';

interface UpdatePathModalProps {
  onClose: () => void;
  onConfirm: (data: {
    conditionName: string;
    conditionDescription: string;
    icon?: string;
    pathsToUpdate: { index: number; name: string }[];
    pathsToAdd: string[];
    pathsToRemove: { index: number; name: string }[];
  }) => void;
  existingPathsCount: number;
  existingPaths?: string[];
  block: Block;
}

type PathRow = {
  id: number;
  name: string;
  originalName?: string;
  originalIndex?: number;
};

const UpdatePathModal: React.FC<UpdatePathModalProps> = ({
  onClose,
  onConfirm,
  existingPathsCount = 0,
  existingPaths = [],
  block,
}) => {
  const [conditionName, setConditionName] = useState<string>(block.title || '');
  const [conditionDescription, setConditionDescription] = useState<string>(
    block.description || ''
  );
  const [icon, setIcon] = useState<string | undefined>(
    block.icon || 'step-icons/default-icons/dataflow.svg'
  );
  const [pathRows, setPathRows] = useState<PathRow[]>([]);
  const [removedPaths, setRemovedPaths] = useState<PathRow[]>([]);

  const colors = useColors();
  const { currentTheme } = useTheme();

  // Initialize pathRows with existing paths when the modal opens
  useEffect(() => {
    if (existingPaths.length > 0) {
      // If you want to pass IDs, you need to pass them from the parent as well.
      // For now, we assume only names, so we can't track updates/removes by ID.
      // Let's assume the parent will pass an array of {id, name} instead of just names.
      // For now, fallback to names only.
      setPathRows(
        existingPaths.map((name, idx) => ({
          id: idx,
          name,
          originalName: name,
          originalIndex: idx,
        }))
      );
    } else {
      setPathRows([
        { id: 0, name: 'Path n1' },
        { id: 1, name: 'Path n2' },
      ]);
    }
    setRemovedPaths([]);
  }, [existingPaths]);

  // Check if any path name is empty
  const hasEmptyPath = pathRows.some((row) => row.name.trim() === '');

  const handleAddPath = () => {
    const nextPathNumber = pathRows.length;
    setPathRows([
      ...pathRows,
      { id: nextPathNumber, name: `Path n${nextPathNumber + 1}` },
    ]);
    // No need to update removedPaths
  };

  const handleRemovePath = (index: number) => {
    setPathRows((prevRows) => {
      const removed = prevRows[index];
      const newRows = [...prevRows];
      newRows.splice(index, 1);

      if (removed.id !== undefined && removed.originalIndex !== undefined) {
        setRemovedPaths((old) => {
          // Only add if there is no existing pair with same index and name
          if (!old.some((p) => p.id === index && p.name === removed.name)) {
            return [
              ...old,
              { id: removed.originalIndex ?? 0, name: removed.name },
            ];
          }
          return old;
        });
      }

      return newRows;
    });
  };

  const handleNameChange = (index: number, value: string) => {
    setPathRows((prev) => {
      const newRows = [...prev];
      newRows[index] = { ...newRows[index], name: value };
      return newRows;
    });
  };

  const handleConfirm = () => {
    // pathsToAdd: all rows without id
    const pathsToAdd = pathRows
      .filter((row) => row.originalIndex === undefined)
      .map((row) => row.name);

    // pathsToRemove: all removed paths with id, deduplicated by (index, name)
    const seen = new Set<string>();
    const pathsToRemove = removedPaths
      .map((row) => ({
        index: row?.id ?? 0,
        name: row.name,
      }))
      .filter((row) => {
        const key = `${row.index}|${row.name}`;
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });

    // pathsToUpdate: all rows with id and name changed
    const pathsToUpdate = pathRows
      .filter(
        (row) =>
          row.id !== undefined &&
          row.name !== row.originalName &&
          row.originalIndex !== undefined
      )
      .map((row) => ({
        index: row.id as number,
        name: row.name,
      }));

    onConfirm({
      conditionName: conditionName,
      conditionDescription: conditionDescription,
      icon,
      pathsToUpdate,
      pathsToAdd,
      pathsToRemove,
    });
  };

  // Minimal block for icon selector
  const minimalBlock: Block = useMemo(
    () => ({
      ...block,
      icon: icon || undefined,
    }),
    [icon, block]
  );

  const modalContent = (
    <div className={currentTheme}>
      <Modal
        title="Add Child Paths"
        onClose={onClose}
        icon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dataflow-icon.svg`}
        iconBackgroundColor={colors['bg-secondary']}
        iconBorderColor={colors['border-secondary']}
        showHeaderSeparator={true}
        showActionsSeparator={true}
        width="w-[600px]"
        className="overflow-hidden"
        actions={
          <div className="flex justify-end gap-2 w-full">
            <ButtonNormal variant="secondary" size="small" onClick={onClose}>
              Cancel
            </ButtonNormal>
            <ButtonNormal
              variant="primary"
              size="small"
              onClick={handleConfirm}
              disabled={hasEmptyPath || pathRows.length <= 1}
            >
              {existingPaths.length > 0 ? 'Update paths' : 'Create paths'}
            </ButtonNormal>
          </div>
        }
      >
        <div
          className="flex flex-col gap-6 pb-4"
          style={{ color: colors['text-primary'] }}
        >
          {/* Condition Name + Icon Selector */}
          <div className="flex flex-col gap-2">
            <label
              className="text-sm font-semibold flex items-center gap-1 text-left"
              style={{ color: colors['text-secondary'] }}
            >
              Condition name <span className="text-primary">*</span>
            </label>
            <div className="flex flex-row items-center w-full gap-2">
              <div className="flex items-center">
                <IconModifier
                  block={minimalBlock}
                  onUpdate={(update) => {
                    setIcon(update.icon ?? 'step-icons/default-icons/dataflow.svg');
                  }}
                />
              </div>
              <div className="flex-1">
                <InputField
                  type="default"
                  value={conditionName}
                  onChange={setConditionName}
                  placeholder="Enter condition name"
                />
              </div>
            </div>
          </div>
          {/* Condition Description */}
          <div className="flex flex-col gap-2">
            <label
              className="text-sm font-semibold"
              style={{ color: colors['text-secondary'] }}
            >
              Condition description
            </label>
            <textarea
              className="border rounded-lg p-3 min-h-[80px] resize-y text-sm focus:outline-none focus:ring-2 focus:ring-primary bg-primary"
              style={{
                background: colors['bg-primary'],
                borderColor: colors['border-primary'],
              }}
              value={conditionDescription}
              onChange={(e) => setConditionDescription(e.target.value)}
              placeholder="Describe the condition (optional)"
            />
          </div>
          <div className="flex flex-col gap-4">
            <div className="flex flex-col gap-4 max-h-[240px] overflow-y-auto p-1">
              {pathRows.map((row, index) => (
                <div key={index} className="flex gap-2 items-end">
                  <div className="flex flex-col gap-1 flex-grow">
                    <label
                      className="text-sm"
                      style={{ color: colors['text-secondary'] }}
                    >
                      Path n{index + 1}
                    </label>
                    <InputField
                      type="default"
                      value={row.name}
                      onChange={(value) => handleNameChange(index, value)}
                      placeholder={`This is your path n${index + 1}`}
                    />
                  </div>
                  <ButtonNormal
                    variant="secondary"
                    size="medium"
                    onClick={() => handleRemovePath(index)}
                    leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`}
                  />
                </div>
              ))}
            </div>
            <ButtonNormal
              variant="secondary"
              size="small"
              onClick={handleAddPath}
              leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/plus-icon-white.svg`}
            >
              Add new path
            </ButtonNormal>
          </div>
        </div>
      </Modal>
    </div>
  );

  // Only render if we're in a browser environment
  if (typeof window === 'undefined') return null;

  return createPortal(modalContent, document.body);
};

export default UpdatePathModal;
</file>

<file path="app/[slug]/[flow]/edit/components/BlockDetailsSidebar.tsx">
import React, { useRef, useState, useEffect } from 'react';
import { createPortal } from 'react-dom';
import TextEditor from './TextEditor';
import { useColors } from '@/app/theme/hooks';
import { Block, TaskType } from '../../types';
import BlockMediaVisualizer from './BlockMediaVisualizer';
import MediaUploader from './MediaUploader';
import IconModifier from './IconModifier';
import { useEditModeStore } from '../store/editModeStore';
import ButtonNormal from '@/app/components/ButtonNormal';
import { InputTokens } from '@/app/theme/types';
import InputField from '@/app/components/InputFields';
import DOMPurify from 'dompurify';

// Helper function from TextAreaInput
const getInputToken = (
  state: 'normal' | 'hover' | 'focus',
  type: 'bg' | 'fg' | 'border',
  destructive: boolean = false,
  disabled: boolean = false
): keyof InputTokens => {
  if (disabled) {
    return `input-disabled-${type}` as keyof InputTokens;
  }

  const prefix = destructive ? 'input-destructive-' : 'input-';
  const suffix = state === 'normal' ? '' : `-${state}`;
  return `${prefix}${type}${suffix}` as keyof InputTokens;
};

interface BlockDetailsSidebarProps {
  block: Block;
  signedImageUrl?: string | null;
  onClose: () => void;
  onUpdate: (updatedData: Partial<Block>) => void;
}

export default function BlockDetailsSidebar({
  block,
  signedImageUrl,
  onClose,
  onUpdate,
}: BlockDetailsSidebarProps) {
  const sidebarRef = useRef<HTMLDivElement>(null);
  const textEditorRef = useRef<HTMLDivElement>(null);
  const [isEditingTitle, setIsEditingTitle] = useState(false);
  const [isEditingAverageTime, setIsEditingAverageTime] = useState(false);
  const [title, setTitle] = useState(block.title || '');
  const [averageTime, setAverageTime] = useState(block.average_time || '');
  const [taskType, setTaskType] = useState(block.task_type || 'MANUAL');
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const [description, setDescription] = useState(block.description || '');
  const [isEditingDescription, setIsEditingDescription] = useState(false);
  const colors = useColors(); // Get colors from the theme hook

  const setEditMode = useEditModeStore((state) => state.setEditMode);

  useEffect(() => {
    setEditMode(true, block.id.toString());
    if (process.env.NODE_ENV === 'development') {
      console.log('block', block);
    }
    return () => setEditMode(false);
  }, [block.id, setEditMode]);

  // Auto-focus the textarea when editing mode becomes active
  useEffect(() => {
    if (isEditingDescription && textEditorRef.current) {
      const textarea = textEditorRef.current.querySelector('textarea');
      if (textarea) {
        // Use setTimeout to ensure the textarea is rendered
        setTimeout(() => {
          textarea.focus();
          // Position cursor at the end
          textarea.setSelectionRange(textarea.value.length, textarea.value.length);
        }, 0);
      }
    }
  }, [isEditingDescription]);

  const handleTitleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      onUpdate({ title: title });
      setIsEditingTitle(false);
    } else if (e.key === 'Escape') {
      setTitle(block.title || '');
      setIsEditingTitle(false);
    }
  };

  const handleAverageTimeKeyDown = (
    e: React.KeyboardEvent<HTMLInputElement>
  ) => {
    if (e.key === 'Enter') {
      onUpdate({ average_time: averageTime });
      setIsEditingAverageTime(false);
    } else if (e.key === 'Escape') {
      setAverageTime(block.average_time || '');
      setIsEditingAverageTime(false);
    }
  };

  // Only allow numbers in average time input with 12 digits limit
  const handleAverageTimeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    if ((value === '' || /^\d+$/.test(value)) && value.length <= 12) {
      setAverageTime(value);
    }
  };

  const handleTaskTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const newType = e.target.value;
    setTaskType(newType);
    onUpdate({ task_type: newType as TaskType });
  };

  const handleDescriptionUpdate = () => {
    if (description !== block.description) {
      onUpdate({ description: description });
    }
    setIsEditingDescription(false);
  };

  const handleDescriptionKeyDown = (e: React.KeyboardEvent) => {
    // if (e.key === 'Enter' && !e.shiftKey) {
    //   e.preventDefault();
    //   handleDescriptionUpdate();
    // }
    //  else
    if (e.key === 'Escape') {
      setDescription(block.description || '');
      setIsEditingDescription(false);
    }
  };

  const handleCopyLink = () => {
    const url = new URL(window.location.href);
    url.searchParams.set('blockId', block.id.toString());
    navigator.clipboard.writeText(url.toString());
  };

  // Create sidebar content to be wrapped with ThemeProvider
  const sidebarContent = (
    <>
      {/* Overlay */}
      <div
        className="fixed inset-0 bg-black bg-opacity-0 z-40"
        onClick={onClose}
      />

      {/* Sidebar */}
      <div
        className="fixed top-0 right-0 h-screen w-[540px] shadow-lg p-6 border-l z-50 flex flex-col overflow-y-auto transform transition-all duration-300 ease-out animate-in slide-in-from-right-0"
        style={{
          backgroundColor: colors['bg-primary'],
          borderColor: colors['border-primary'],
        }}
        ref={sidebarRef}
      >
        {/* Close Button */}
        <ButtonNormal
          onClick={onClose}
          className="absolute top-4 left-6"
          size="small"
          variant="secondary"
          iconOnly
          leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/close-drawer.svg`}
          aria-label="Close"
        />

        {/* Container for the buttons to be aligned to the far right */}
        <div className="absolute top-4 right-4 hidden gap-2">
          {/* Link Button */}
          <ButtonNormal
            onClick={handleCopyLink}
            size="small"
            variant="secondary"
            iconOnly
            leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/link-icon.svg`}
            aria-label="Copy Link"
          />

          {/* Message Button */}
          <ButtonNormal
            size="small"
            variant="secondary"
            iconOnly
            leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/message-icon.svg`}
            aria-label="Message"
          />
        </div>

        {block && (
          <>
            {/* Information Section */}
            <div className="flex items-center mt-14 h-[50px] space-x-4">
              <IconModifier block={block} onUpdate={onUpdate} />
              {isEditingTitle ? (
                <input
                  type="text"
                  value={title}
                  onChange={(e) => setTitle(e.target.value)}
                  onBlur={() => onUpdate({ title: title })}
                  onKeyDown={handleTitleKeyDown}
                  autoFocus
                  className="text-lg font-semibold border-b-2 outline-none bg-transparent"
                  style={{
                    color: colors['text-primary'],
                    borderColor: colors['accent-primary'],
                  }}
                  placeholder="Enter title"
                />
              ) : (
                <h1
                  className="text-lg font-semibold cursor-pointer px-2 py-1 rounded hover:bg-opacity-50 break-words line-clamp-2 transition-all duration-200 hover:scale-[1.02]"
                  style={{
                    color: colors['text-primary'],
                    backgroundColor: 'transparent',
                  }}
                  onClick={() => {
                    setIsEditingTitle(true);
                    setTitle(block.title || '');
                  }}
                >
                  {block.title || 'Untitled Block'}
                </h1>
              )}
            </div>

            {/* Main Info Container */}
            <div
              className="border-t border-b my-4 py-4"
              style={{ borderColor: colors['border-primary'] }}
            >
              <div className=" flex flex-col gap-4">
                {/* Last Modified */}
                <div className="flex justify-start items-center space-x-[45px]">
                  <div
                    className="text-sm font-normal font-['Inter']"
                    style={{ color: colors['text-primary'] }}
                  >
                    Last Modified
                  </div>
                  <div
                    className="text-sm font-normal font-['Inter']"
                    style={{ color: colors['text-secondary'] }}
                  >
                    {block.updated_at
                      ? new Date(block.updated_at).toLocaleDateString()
                      : 'N/A'}
                  </div>
                </div>

                {/* Average Time */}
                <div className="flex justify-start items-center space-x-[36px]">
                  <div
                    className="text-sm font-normal font-['Inter']"
                    style={{ color: colors['text-primary'] }}
                  >
                    Average Time
                  </div>
                  <div
                    className="flex items-center gap-2"
                    style={{ width: '140px' }}
                  >
                    <InputField
                      type="default"
                      size="small"
                      value={averageTime}
                      onChange={(value) => {
                        if (
                          (value === '' || /^\d+$/.test(value)) &&
                          value.length <= 12
                        ) {
                          setAverageTime(value);
                        }
                      }}
                      onBlur={() => {
                        onUpdate({ average_time: averageTime });
                        setIsEditingAverageTime(false);
                      }}
                      onKeyDown={handleAverageTimeKeyDown}
                      placeholder="Enter time"
                    />
                    <span
                      className="text-sm"
                      style={{ color: colors['text-secondary'] }}
                    >
                      min
                    </span>
                  </div>
                </div>

                {/* Task Type
                <div className="flex justify-start items-center space-x-[94px]">
                  <div
                    className="text-sm font-normal font-['Inter']"
                    style={{ color: colors['text-primary'] }}
                  >
                    Type
                  </div>
                  <div className="relative" style={{ width: '140px' }}>
                    <div
                      onClick={() => setIsDropdownOpen(!isDropdownOpen)}
                      className={`flex items-center justify-between px-3 py-1.5 rounded-lg border transition-all duration-200 cursor-pointer`}
                      style={{
                        backgroundColor: colors[getInputToken('normal', 'bg', false, false)],
                        borderColor: isDropdownOpen 
                          ? colors[getInputToken('focus', 'border', false, false)]
                          : colors[getInputToken('normal', 'border', false, false)],
                        boxShadow: isDropdownOpen
                          ? "0px 0px 0px 4px rgba(78,107,215,0.12)"
                          : '0px 1px 2px rgba(16, 24, 40, 0.05)',
                      }}
                    >
                      <div className="flex items-center gap-2">
                        
                        <span className="text-sm font-medium" style={{ color: colors['text-primary'] }}>
                          {taskType === 'MANUAL' ? 'Manual' : 'Automatic'}
                        </span>
                      </div>
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/chevron-${isDropdownOpen ? 'up' : 'down'}.svg`}
                        alt="Toggle dropdown"
                        className="w-4 h-4"
                      />
                    </div>

                    {isDropdownOpen && (
                      <div 
                        className="absolute top-full left-0 mt-1 w-full border rounded-lg shadow-lg z-50 overflow-hidden"
                        style={{ 
                          backgroundColor: colors['bg-primary'],
                          borderColor: colors['border-primary']
                        }}
                      >
                        {[
                          { value: 'MANUAL', label: 'Manual', icon: 'manual-icon.svg' },
                          { value: 'AUTOMATIC', label: 'Automatic', icon: 'automatic-icon.svg' }
                        ].map((option) => (
                          <div
                            key={option.value}
                            onClick={() => {
                              handleTaskTypeChange({ target: { value: option.value } } as any);
                              setIsDropdownOpen(false);
                            }}
                            className="flex items-center justify-between px-3 py-2 cursor-pointer transition-colors duration-150"
                            style={{
                              backgroundColor: taskType === option.value 
                                ? colors['bg-selected'] 
                                : 'transparent',
                              color: colors['text-primary']
                            }}
                          >
                            <div className="flex items-center gap-2">
                             
                              <span className="text-sm font-medium">
                                {option.label}
                              </span>
                            </div>
                            {taskType === option.value && (
                              <img
                                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-icon2.svg`}
                                alt="Selected"
                                className="w-4 h-4"
                              />
                            )}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </div>*/}
              </div>
            </div>

            {/* Description Section */}
            <div className="my-4">
              <div
                className="text-sm font-medium font-['Inter'] leading-tight mb-3"
                style={{ color: colors['text-primary'] }}
              >
                Description
              </div>
              <div
                className="h-[200px] rounded-lg transition-all duration-200"
                onClick={() => {
                  if (!isEditingDescription) {
                    setIsEditingDescription(true);
                  }
                }}
                style={{ cursor: !isEditingDescription ? 'pointer' : 'default' }}
              >
                <div
                  style={{
                    backgroundColor: colors[getInputToken('normal', 'bg', false, false)],
                    color: colors[getInputToken('normal', 'fg', false, false)],
                    borderColor: isEditingDescription
                      ? colors[getInputToken('focus', 'border', false, false)]
                      : colors[getInputToken('normal', 'border', false, false)],
                    boxShadow: isEditingDescription
                      ? '0px 0px 0px 4px rgba(78,107,215,0.12)'
                      : '0px 1px 2px rgba(16, 24, 40, 0.05)',
                    borderWidth: '1px',
                    borderRadius: '0.5rem',
                  }}
                  className="flex items-start gap-2 p-3 transition-all duration-200 h-full"
                  ref={textEditorRef}
                >
                  <TextEditor
                    value={description}
                    onChange={(value) => setDescription(value)}
                    onBlur={handleDescriptionUpdate}
                    onKeyDown={handleDescriptionKeyDown}
                    readOnly={false}
                    className={`w-full h-full border-none outline-none resize-vertical text-base leading-6 font-inter ${isEditingDescription ? 'cursor-text' : 'cursor-pointer'}`}
                    placeholder="Add a description..."
                    textColor={colors['text-primary']}
                  />
                </div>
              </div>
            </div>

            {/* Media Section */}
            <div className="flex flex-col justify-start mt-2">
              <div
                className="text-sm font-medium font-['Inter'] leading-tight mb-3"
                style={{ color: colors['text-primary'] }}
              >
                Media
              </div>
              {block.image ? (
                <BlockMediaVisualizer
                  block={block}
                  altText="Block Media"
                  signedImageUrl={signedImageUrl}
                  onUpdate={onUpdate}
                />
              ) : (
                <div onClick={(e) => e.stopPropagation()}>
                  <MediaUploader block={block} onUpdate={onUpdate} />
                </div>
              )}
            </div>
          </>
        )}
      </div>
    </>
  );

  // Use createPortal without the conflicting ThemeProvider wrapper
  return createPortal(
    sidebarContent,
    document.body
  );
}
</file>

<file path="app/[slug]/[flow]/edit/components/BlockMediaVisualizer.tsx">
import { Block } from '../../types';
import React, { useEffect, useState } from 'react';
import ButtonNormal from '@/app/components/ButtonNormal';
import ImageEditor from './ImageEditor';
import { useColors } from '@/app/theme/hooks';
import { createPortal } from 'react-dom';

interface BlockMediaVisualizerProps {
  block: Block;
  altText: string;
  signedImageUrl?: string | null;
  onUpdate: (updatedBlock: Partial<Block>) => void;
}

export default function BlockMediaVisualizer({
  block,
  altText,
  signedImageUrl,
  onUpdate,
}: BlockMediaVisualizerProps) {
  const [isEditing, setIsEditing] = useState(false);
  const colors = useColors();

  const handleRemoveImage = async () => {
    // Save previous image for rollback
    const previousImage = block.image;
    // Optimistically update UI
    onUpdate({ image: '' });
    try {
      // Delete the image on the server
      const response = await fetch(`/api/blocks/${block.id}/image`, {
        method: 'DELETE',
      });
      if (!response.ok) {
        throw new Error('Failed to delete image');
      }
    } catch (error) {
      // Rollback if error
      onUpdate({ image: previousImage });
      console.error('Error removing image:', error);
    }
  };

  const handleResetImage = () => {
    if (block.original_image) {
      onUpdate({ image: block.original_image, original_image: '' });
    }
  };

  const handleSaveEdit = async (editedImageUrl: string) => {
    // This will be implemented later with actual image editing functionality
    setIsEditing(false);
    onUpdate({
      image: editedImageUrl,
      original_image: block.original_image ? block.original_image : block.image,
    });
  };

  if (!signedImageUrl) return null;

  return (
    <>
      <div
        className="relative w-full h-[267px] rounded-xl overflow-hidden"
        style={{ backgroundColor: colors['bg-secondary'] }}
      >
        <img
          className="w-full h-full object-contain rounded-xl"
          src={signedImageUrl}
          alt={altText}
        />
        <div className="absolute top-2 right-2 flex gap-2">
          {block.original_image && (
            <ButtonNormal
              onClick={handleResetImage}
              size="small"
              variant="secondary"
              aria-label="Reset to Original Image"
              className="h-8 min-w-[100px]"
            >
              Reset Original
            </ButtonNormal>
          )}
          <ButtonNormal
            onClick={() => setIsEditing(true)}
            size="small"
            variant="secondary"
            iconOnly
            className="h-8 w-8"
            leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-icon.svg`}
            aria-label="Edit Image"
          />
          <ButtonNormal
            onClick={handleRemoveImage}
            size="small"
            variant="secondary"
            iconOnly
            className="h-8 w-8"
            leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-icon.svg`}
            aria-label="Remove Image"
          />
        </div>
      </div>

      {isEditing && signedImageUrl && (
        createPortal(
          <ImageEditor
            imageUrl={signedImageUrl}
            onClose={() => setIsEditing(false)}
            onSave={handleSaveEdit}
          />,
          document.body
        )
      )}
    </>
  );
}
</file>

<file path="app/[slug]/[flow]/edit/components/DocumentationModal.tsx">
import React, { useState, useMemo, useRef, useEffect } from 'react';
import { useColors } from '@/app/theme/hooks';
import DynamicIcon from '@/utils/DynamicIcon';
import ButtonNormal from '@/app/components/ButtonNormal';
import InputField from '@/app/components/InputFields';

interface Tab {
  id: string;
  icon: string;
  label: string;
  content: {
    title: string;
    description: string;
    image?: string;
    bullets?: string[];
  }[];
}

interface DocumentationModalProps {
  onClose: () => void;
}

const tabs: Tab[] = [
  {
    id: 'step',
    icon: 'git-commit',
    label: 'Step',
    content: [
      {
        title: 'Step Block',
        description: 'The Step Block is the fundamental building block of any Flow. It represents a single action, task, or stage in your process and provides detailed information to help users understand exactly what needs to be done.',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/git-commit.svg`
      },
      {
        title: 'When to use',
        description: '',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/help-circle.svg`,
        bullets: [
          'To break down complex processes into understandable segments',
          'When users need clear guidance with visual support',
          'As the primary building blocks of straightforward, linear processes'
        ]
      },
      {
        title: 'How to add',
        description: '',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/plus-circle.svg`,
        bullets: [
          'Click on the "+" to add a new step to your flow',
          'Select the "Step"'
        ]
      }
    ]
  },
  {
    id: 'delay',
    icon: 'clock-stopwatch',
    label: 'Delay',
    content: [
      {
        title: 'Delay Block',
        description: 'The Delay Block allows you to introduce waiting periods into your Flow. This is essential for modeling real-world scenarios where tasks may require waiting for specific durations or external events before proceeding.',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/clock-stopwatch.svg`
      },
      {
        title: 'Fixed Duration Delay',
        description: 'A strict waiting period that must be fully completed before the process can continue.',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/clock-stopwatch.svg`,
        bullets: [
          'Mandatory waiting periods (e.g., "Wait 24 hours for the solution to set")',
          'Regulatory holding periods (e.g., "Wait 7 days before processing the refund")'
        ]
      },
      {
        title: 'Wait For Event',
        description: 'A flexible waiting period that concludes when either an external event occurs or a maximum time limit is reached.',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/calendar-date.svg`,
        bullets: [
          'Client responses (e.g., "Wait for client feedback for up to 3 days")',
          'Approval workflows (e.g., "Wait for manager approval within 48 hours")',
          'Conditional actions (e.g., "Wait for payment confirmation for up to 7 days")'
        ]
      },
      {
        title: 'How to add',
        description: '',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/plus-circle.svg`,
        bullets: [
          'Click on the "+" to add a new step to your flow',
          'Select the delay block',
          'Setup your delay block'
        ]
      }
    ]
  },
  {
    id: 'link',
    icon: 'connect-node',
    label: 'Link',
    content: [
      {
        title: 'Link',
        description: 'The Link allows you to create connections between blocks that don\'t follow the standard top-to-bottom flow. This is essential for representing complex processes that include cycles, loops, decision points with returns to previous steps, or any non-linear flow.',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/connect-node.svg`
      },
      {
        title: 'When to use',
        description: '',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/help-circle.svg`,
        bullets: [
          'To create loops (e.g., "If document needs revision, return to Step 2")',
          'To represent conditional returns to earlier steps (e.g., "If application is incomplete, return to data collection")',
          'When a process requires jumping between different sections based on specific conditions',
          'To simplify complex workflows by avoiding redundant steps'
        ]
      },
      {
        title: 'How to add',
        description: '',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dots-horizontal.svg`,
        bullets: [
          'Click on the three dot on a step block, it will open a menu.',
          'Select "connect blocks"',
          'Click on the source block (where the link starts)',
          'Click on the target block (where the link ends)',
          'Add an optional label to describe the purpose of the connection'
        ]
      }
    ]
  },
  {
    id: 'condition',
    icon: 'dataflow-04',
    label: 'Condition',
    content: [
      {
        title: 'Conditional Path',
        description: 'The Conditional Path functionality enables you to create multiple alternative paths in your workflow based on different scenarios, decisions, or conditions. This powerful feature allows your processes to adapt to varying circumstances, making them more flexible and realistic.',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dataflow-04.svg`
      },
      {
        title: 'When to use',
        description: '',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/help-circle.svg`,
        bullets: [
          'When a process can take different routes based on specific criteria',
          'For approval workflows with "approved" and "rejected" outcomes',
          'When representing decision trees with multiple possible answers',
          'When documenting exception handling in standard procedures',
          'For compliance documentation that covers multiple scenarios'
        ]
      },
      {
        title: 'How to add',
        description: '',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/plus-circle.svg`,
        bullets: [
          'Click on the "+" to add a new step to your flow',
          'Select the "Condition"'
        ]
      }
    ]
  },
  {
    id: 'merge',
    icon: 'git-merge',
    label: 'Merge',
    content: [
      {
        title: 'Merge Paths',
        description: 'The Merge Paths allows you to unify multiple paths back into a single path, making it essential for workflows where different conditions or parallel processes eventually converge to a common next step. This creates cleaner, more maintainable processes by avoiding redundant blocks after decision points.',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/git-merge.svg`
      },
      {
        title: 'When to use',
        description: '',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/help-circle.svg`,
        bullets: [
          'After conditional paths that eventually lead to the same next steps',
          'When multiple approval or review paths converge to a common outcome',
          'To simplify workflow visualization by reducing redundant blocks'
        ]
      },
      {
        title: 'How to add',
        description: '',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dots-horizontal.svg`,
        bullets: [
          'Click on the three dot on a step block, it will open a menu.',
          'Select "Merge paths"',
          'Choose the paths you want to merge (it can only be the paths on the same path and at the same level).',
          'Click on "Merge Paths" once you\'ve choose your block to merge.'
        ]
      }
    ]
  },
  {
    id: 'path-labels',
    icon: 'text-input',
    label: 'Path Labels',
    content: [
      {
        title: 'Path Labels',
        description: 'Path Labels are descriptive text elements that identify the different options at decision points in your workflow. They appear on Conditional Paths and Link Lines, providing clear guidance to users when they need to make selections in Read Mode.',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/text-input.svg`
      },
      {
        title: 'When to use',
        description: '',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/help-circle.svg`,
        bullets: [
          'On all conditional paths to clearly distinguish between options',
          'When creating interactive processes where users select their own path',
          'When documenting decision trees with multiple options',
          'For any workflow where users need to make choices based on specific criteria'
        ]
      },
      {
        title: 'How to add',
        description: '',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`,
        bullets: [
          'Label are automatically added on path when needed',
          'You can always modify the text on it by clicking on the edit button'
        ]
      }
    ]
  },
  {
    id: 'end',
    icon: 'stop-circle',
    label: 'End',
    content: [
      {
        title: 'End Block',
        description: 'The End Block represents the final point of a process path. Unlike the Start block (which is automatically added to every workflow and cannot be deleted), End blocks are optional visual elements that help users clearly identify where specific paths terminate.',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/stop-circle.svg`
      },
      {
        title: 'When to use',
        description: '',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/help-circle.svg`,
        bullets: [
          'At the conclusion of every meaningful path in your workflow',
          'To mark different possible outcomes of a process (e.g., "Application Approved," "Application Rejected")',
          'When documenting process termination points for compliance or training purposes',
          'To make complex workflows with multiple branches easier to understand'
        ]
      },
      {
        title: 'How to add',
        description: '',
        image: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/plus-circle.svg`,
        bullets: [
          'Click on the "+" to add a new step to your flow',
          'Select the End block, which will only be visible if there are no steps below the current one.'
        ]
      }
    ]
  }
];

export function DocumentationModal({ onClose }: DocumentationModalProps) {
  const colors = useColors();
  const [activeTab, setActiveTab] = useState<string>(tabs[0].id);
  const [searchQuery, setSearchQuery] = useState<string>('');
  const contentRef = useRef<HTMLDivElement>(null);

  // Filter tabs based on search query
  const filteredTabs = useMemo(() => {
    if (!searchQuery) return tabs;
    
    const query = searchQuery.toLowerCase();
    return tabs.filter(tab => {
      // Search in tab label
      if (tab.label.toLowerCase().includes(query)) return true;
      
      // Search in tab content
      return tab.content.some(content => 
        content.title.toLowerCase().includes(query) ||
        content.description.toLowerCase().includes(query) ||
        content.bullets?.some(bullet => bullet.toLowerCase().includes(query))
      );
    });
  }, [searchQuery, tabs]);

  // Reset scroll position when active tab changes
  useEffect(() => {
    if (contentRef.current) {
      contentRef.current.scrollTop = 0;
    }
  }, [activeTab]);

  const activeTabContent = tabs.find((tab) => tab.id === activeTab)?.content || [];

  return (
    <>
      <div 
        className="flex items-center justify-center p-8 h-full w-full"
        onClick={onClose}
      >
        {/* Backdrop */}
        <div className="absolute inset-0">
          <div 
            style={{ backgroundColor: colors['bg-overlay'] }}
            className="absolute inset-0 opacity-70" 
          />
        </div>

        <div 
          className="relative z-10 w-[900px] h-[600px] rounded-lg flex overflow-hidden shadow-[0_20px_70px_-15px_rgba(0,0,0,0.3)] border border-white/10"
          style={{ 
            backgroundColor: colors['bg-primary'],
            boxShadow: `0 10px 50px -12px ${colors['accent-primary']}30`
          }}
          onClick={(e) => e.stopPropagation()}
        >
          {/* Left sidebar with tabs */}
          <div 
            className="w-[240px] h-full py-6 border-r flex flex-col"
            style={{ 
              backgroundColor: colors['bg-secondary'],
              borderColor: colors['border-primary'],
              borderRightWidth: '1px',
              borderStyle: 'solid'
            }}
          >
            <div className="px-4 space-y-6">
              <h2 
                className="px-2 text-sm font-regular"
                style={{ color: colors['text-quaternary'] }}
              >
                Documentation
              </h2>
              <div className="px-0">
                <InputField
                  type="icon-leading"
                  size="small"
                  placeholder="Search"
                  value={searchQuery}
                  onChange={setSearchQuery}
                  iconUrl={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/search-icon.svg`}
                />
              </div>
            </div>

            <div className="mt-6 flex flex-col space-y-1 flex-1 overflow-y-auto custom-scrollbar px-2">
              {filteredTabs.map((tab) => (
                <button
                  key={tab.id}
                  className={`flex items-center gap-3 mx-2 px-3 py-2.5 text-sm font-medium rounded-xl transition-all duration-200 ${
                    activeTab === tab.id 
                      ? 'shadow-sm' 
                      : 'hover:bg-white/[0.02]'
                  }`}
                  style={{ 
                    color: activeTab === tab.id ? colors['text-primary'] : colors['text-secondary'],
                    backgroundColor: activeTab === tab.id ? colors['bg-tertiary'] : 'transparent',
                    transform: activeTab === tab.id ? 'scale(1.02)' : 'scale(1)',
                  }}
                  onClick={() => setActiveTab(tab.id)}
                >
                  <DynamicIcon
                    url={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${tab.icon}.svg`}
                    size={18}
                    variant={activeTab === tab.id ? 'primary' : 'tertiary'}
                  />
                  {tab.label}
                </button>
              ))}
            </div>
          </div>

          {/* Right content area */}
          <div className="flex-1 flex flex-col">
            {/* Header */}
            <div 
              className="px-6 py-6 border-b flex items-center justify-between"
              style={{ borderColor: colors['border-primary'] }}
            >
              <div>
                <h1 
                  className="text-lg font-semibold mb-1.5"
                  style={{ color: colors['text-primary'] }}
                >
                  {tabs.find(tab => tab.id === activeTab)?.label}
                </h1>
                <p 
                  className="text-sm"
                  style={{ color: colors['text-secondary'] }}
                >
                  Learn how to use a {tabs.find(tab => tab.id === activeTab)?.label.toLowerCase()} in your flow
                </p>
              </div>
              <ButtonNormal
                leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/x-close-icon.svg`}
                iconOnly={true}
                variant="tertiary"
                onClick={onClose}
              />
            </div>

            {/* Content */}
            <div 
              ref={contentRef}
              className="flex-1 overflow-y-auto px-6 py-4 custom-scrollbar"
              style={{
                scrollbarGutter: 'stable',
              }}
            >
              <div className="flex flex-col gap-4 pb-4">
                {activeTabContent.map((content, index) => (
                  <div
                    key={index}
                    className="p-6 rounded-2xl border"
                    style={{ 
                      backgroundColor: colors['bg-secondary'],
                      borderColor: colors['border-primary']
                    }}
                  >
                    <div className="flex items-start gap-5">
                      {content.image && (
                        <div 
                          className="w-10 h-10 rounded-xl flex items-center justify-center flex-shrink-0"
                          style={{ backgroundColor: colors['bg-tertiary'] }}
                        >
                          <DynamicIcon
                            url={content.image}
                            size={20}
                            variant="primary"
                          />
                        </div>
                      )}
                      <div className="flex flex-col gap-3 min-w-0">
                        <h3 
                          className="text-[15px] font-semibold"
                          style={{ color: colors['text-primary'] }}
                        >
                          {content.title}
                        </h3>
                        {content.description && (
                          <p 
                            className="text-sm leading-relaxed"
                            style={{ color: colors['text-secondary'] }}
                          >
                            {content.description}
                          </p>
                        )}
                        {content.bullets && content.bullets.length > 0 && (
                          <ul className="flex flex-col gap-2.5 mt-1">
                            {content.bullets.map((bullet, i) => (
                              <li 
                                key={i} 
                                className="flex items-start gap-3 text-sm leading-relaxed"
                                style={{ color: colors['text-secondary'] }}
                              >
                                <span 
                                  className="mt-[7px] w-1 h-1 rounded-full flex-shrink-0"
                                  style={{ backgroundColor: colors['text-secondary'] }}
                                />
                                {bullet}
                              </li>
                            ))}
                          </ul>
                        )}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>
      </div>

      <style>
        {`
          .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
          }
          
          .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
          }
          
          .custom-scrollbar::-webkit-scrollbar-thumb {
            background: ${colors['border-primary']};
            border-radius: 10px;
          }
          
          .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: ${colors['border-secondary']};
          }

          @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0px); }
          }
        `}
      </style>
    </>
  );
}
</file>

<file path="app/[slug]/[flow]/edit/components/Flow.tsx">
import '@xyflow/react/dist/style.css';

import React, {
  useCallback,
  useEffect,
  useState,
  useRef,
  useMemo,
} from 'react';
import {
  ReactFlow,
  Node,
  Edge,
  useReactFlow,
  Background,
  Controls,
  MiniMap,
  Panel,
  useStore,
} from '@xyflow/react';
import { createElkLayout } from '../utils/elkLayout';
import CustomBlock from './blocks/CustomBlock';
import CustomSmoothStepEdge from './edges/CustomSmoothStepEdge';
import AddBlockDropdownMenu from './AddBlockDropdownMenu';
import {
  NodeData,
  EdgeData,
  DropdownDatas,
  Path,
  Block,
  DelayType,
  StrokeLine,
} from '../../types';
import path from 'path';
import { processPath } from '../utils/processPath';
import BeginBlock from './blocks/BeginBlock';
import EndBlock from './blocks/EndBlock';
import SmoothStepCustomParent from './edges/SmoothStepCustomParent';
import { BlockEndType } from '@/types/block';
import LastBlock from './blocks/LastBlock';
import PathBlock from './blocks/PathBlock';
import { useModalStore } from '../store/modalStore';
import CreateParallelPathModal from './modals/CreateParallelPathModal';
import { createParallelPaths } from '../utils/createParallelPaths';
import StrokeEdge from './edges/StrokeEdge';
import ConnectNodeModal from './modals/ConnectNodeModal';
import { useConnectModeStore } from '../store/connectModeStore';
import { PathSelectionBox } from './PathSelectionBox';
import MergeBlock from './blocks/MergeBlock';
import { usePathsStore } from '../store/pathsStore';
import { UpdatePathSelectionBox } from './UpdatePathSelectionBox';
import InvisibleBlock from './blocks/InvisibleBlock';
import { useEditModeStore } from '../store/editModeStore';
import { useSearchParams } from 'next/navigation';
import ZoomBar from './ZoomBar';
import { Sidebar } from './Sidebar';
import { useColors } from '@/app/theme/hooks';
import FixedDelayBlock from './blocks/FixedDelayBlock';
import EventDelayBlock from './blocks/EventDelayBlock';
import { useStrokeLinesStore } from '../store/strokeLinesStore';
import { useIsModalOpenStore } from '@/app/isModalOpenStore';
import { useLoadingStore } from '../store/loadingStore';
import EditLinksModal from './modals/EditLinksModal';
import { debounce } from '../utils/debounce';

type StrokeLineVisibility = [number, boolean];

const nodeTypes = {
  custom: CustomBlock,
  begin: BeginBlock,
  end: EndBlock,
  last: LastBlock,
  path: PathBlock,
  merge: MergeBlock,
  invisible: InvisibleBlock,
  fixedDelay: FixedDelayBlock,
  eventDelay: EventDelayBlock,
} as const;

const edgeTypes = {
  smoothstepCustom: CustomSmoothStepEdge,
  smoothstepCustomParent: SmoothStepCustomParent,
  strokeEdge: StrokeEdge,
} as const;

interface FlowProps {
  workflowName: string;
  workspaceId: string;
  workflowId: string;
  onBlockAdd: (
    blockData: any,
    path_id: number,
    position: number
  ) => Promise<void>;
  strokeLines: StrokeLine[];
  setStrokeLines: React.Dispatch<React.SetStateAction<StrokeLine[]>>;
  newBlockId: number | null;
  clearNewBlockId: () => void;
}

export const Flow = React.memo(function Flow({
  workflowName,
  workspaceId,
  workflowId,
  onBlockAdd,
  strokeLines,
  setStrokeLines,
  newBlockId,
  clearNewBlockId,
}: FlowProps) {
  const colors = useColors();
  const { paths, setPaths } = usePathsStore();
  // Reset paths store on mount and unmount
  useEffect(() => {
    setPaths([]);
    return () => {
      setPaths([]);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const [nodes, setNodes] = useState<Node[]>([]);
  const [edges, setEdges] = useState<Edge[]>([]);
  const { fitView, setCenter, getNode, getNodes, setViewport } = useReactFlow();
  const [showDropdown, setShowDropdown] = useState(false);
  const [dropdownDatas, setDropdownDatas] = useState<DropdownDatas | null>(
    null
  );
  const isFirstRender = useRef(true);
  const [strokeLineVisibilities, setStrokeLineVisibilities] = useState<
    StrokeLineVisibility[]
  >([]);
  const { allStrokeLinesVisible, setAllStrokeLinesVisible } =
    useStrokeLinesStore();
  const [previewEdge, setPreviewEdge] = useState<Edge | null>(null);
  const { isConnectMode, setIsConnectMode, setSourceBlockId, reset } =
    useConnectModeStore();
  const isEditMode = useEditModeStore((state) => state.isEditMode);
  const searchParams = useSearchParams();
  const [defaultViewport, setDefaultViewport] = useState({
    x: 0,
    y: 0,
    zoom: 1,
  });
  const { setEditMode } = useEditModeStore();
  const isModalOpen = useIsModalOpenStore((state: any) => state.isModalOpen);
  const setIsModalOpen = useIsModalOpenStore(
    (state: any) => state.setIsModalOpen
  );
  // Get viewport dimensions from ReactFlow store
  const viewportWidth = useStore((store) => store.width);
  const viewportHeight = useStore((store) => store.height);

  const setAllPaths = usePathsStore((state) => state.setPaths);

  // Calculate bounds based on viewport size
  const translateExtent = useMemo((): [[number, number], [number, number]] => {
    const padding = 2000;

    if (nodes.length === 0)
      return [
        [-1000, -1000],
        [1000, 1000],
      ];

    const xPositions = nodes.map((node) => node.position.x);
    const yPositions = nodes.map((node) => node.position.y);

    const minX = Math.min(...xPositions) - padding;
    const maxX = Math.max(...xPositions) + padding;
    const minY = Math.min(...yPositions) - padding;
    const maxY = Math.max(...yPositions) + padding;

    return [
      [minX, minY],
      [maxX, maxY],
    ];
  }, [nodes]);

  const handleDeleteBlock = useCallback(
    async (nodeId: string) => {
      const blockId = nodeId.replace('block-', '');

      // Optimistically update UI
      setPaths((currentPaths) => {
        // Find the path and the deleted block's position
        let deletedBlockPosition: number | null = null;
        let deletedBlockPathId: number | null = null;

        currentPaths.forEach((path) => {
          const found = path.blocks.find(
            (block) => block.id === parseInt(blockId)
          );
          if (found) {
            deletedBlockPosition = found.position;
            deletedBlockPathId = path.id;
          }
        });

        if (deletedBlockPosition === null || deletedBlockPathId === null) {
          // Block not found, just filter as before
          return currentPaths.map((path) => ({
            ...path,
            blocks: path.blocks.filter(
              (block) => block.id !== parseInt(blockId)
            ),
          }));
        }

        // Update the path: remove the block, and decrement positions
        return currentPaths.map((path) => {
          if (path.id !== deletedBlockPathId) {
            return {
              ...path,
              blocks: path.blocks,
            };
          }
          const filteredBlocks = path.blocks
            .filter((block) => block.id !== parseInt(blockId))
            .map((block) => {
              if (block.position > deletedBlockPosition!) {
                return { ...block, position: block.position - 1 };
              }
              return block;
            });
          return {
            ...path,
            blocks: filteredBlocks,
          };
        });
      });

      // Save previous state for rollback
      const previousPaths = usePathsStore.getState().paths;

      try {
        const response = await fetch(`/api/blocks/${blockId}`, {
          method: 'DELETE',
        });
        if (!response.ok) {
          // Rollback on error
          setPaths(previousPaths);
          throw new Error('Failed to delete block');
        }
      } catch (error) {
        // Rollback on error
        setPaths(previousPaths);
        console.error('Error deleting block:', error);
      }
    },
    [setPaths]
  );

  const handleAddBlockOnEdge = useCallback(
    (
      position: number,
      path: Path,
      event?: { clientX: number; clientY: number }
    ) => {
      if (event) {
        setDropdownDatas({
          x: event.clientX,
          y: event.clientY,
          position,
          path: path,
        });
        setShowDropdown(true);
      }
    },
    []
  );

  const updateStrokeLineVisibility = useCallback(
    (blockId: number, isVisible: boolean) => {
      setStrokeLineVisibilities((prev) => {
        const existing = prev.find(([id]) => id === blockId);
        if (existing) {
          return prev.map(([id, vis]) =>
            id === blockId ? [id, isVisible] : [id, vis]
          );
        }
        return [...prev, [blockId, isVisible]];
      });
    },
    []
  );

  // Initialize stroke line visibilities separately
  useEffect(() => {
    if (paths) {
      const initialVisibilities: StrokeLineVisibility[] = [];
      paths.forEach((path) => {
        path.blocks.forEach((block) => {
          initialVisibilities.push([block.id, true]);
        });
      });
      setStrokeLineVisibilities(initialVisibilities);
    }
  }, [paths]);

  // Add state for linkNode
  const [linkNode, setLinkNode] = useState<Node | null>(null);

  // Add state for ConnectNodeModal at the top of Flow
  const [showConnectNodeModal, setShowConnectNodeModal] = useState(false);
  const [connectModalSourceNode, setConnectModalSourceNode] =
    useState<Node | null>(null);
  const [connectModalTargetNode, setConnectModalTargetNode] =
    useState<Node | null>(null);
  const [connectModalLabel, setConnectModalLabel] = useState<string>('');
  const { setShowEditLinksModal } = useModalStore();
  const showEditLinksModal = useModalStore((state) => state.showEditLinksModal);
  const [editStrokeLineId, setEditStrokeLineId] = useState<string | undefined>(
    undefined
  );
  const [isEditLink, setIsEditLink] = useState(false);

  // Add a callback to update a stroke line in state
  const handleLinkUpdated = useCallback(
    (updatedStrokeLine: StrokeLine) => {
      setStrokeLines((prev) =>
        prev.map((line) =>
          line.id === updatedStrokeLine.id
            ? { ...line, ...updatedStrokeLine }
            : line
        )
      );
    },
    [setStrokeLines]
  );

  // Main effect for creating nodes and edges
  useEffect(() => {
    if (!Array.isArray(paths)) return;

    const createLayoutedNodes = async () => {
      try {
        // Find ALL paths with no parent blocks (root paths) instead of just the first one
        const rootPaths = paths.filter((path) => path.parent_blocks?.length === 0);
        
        if (rootPaths.length > 0) {
          const nodes: Node[] = [];
          const edges: Edge[] = [];

          // Process each root path to ensure all workflow nodes are created
          rootPaths.forEach((rootPath) => {
            processPath(
              workspaceId,
              rootPath,
              nodes,
              edges,
              handleDeleteBlock,
              handleAddBlockOnEdge,
              new Set<string>(),
              setPaths,
              setStrokeLines,
              updateStrokeLineVisibility,
              strokeLineVisibilities,
              paths
            );
          });

          // Add stroke edges with visibility check
          const strokeEdges: Edge[] = strokeLines.map((strokeLine) => {
            const isSelfLoop =
              strokeLine.source_block_id === strokeLine.target_block_id;
            const visibility =
              strokeLineVisibilities.find(
                ([id]) => id === strokeLine.source_block_id
              )?.[1] ?? true;

            return {
              id: `stroke-edge-${strokeLine.id}`,
              source: `block-${strokeLine.source_block_id}`,
              target: `block-${strokeLine.target_block_id}`,
              sourceHandle: 'stroke_source',
              targetHandle: isSelfLoop ? 'stroke_self_target' : 'stroke_target',
              type: 'strokeEdge',
              animated: true,
              data: {
                source: `block-${strokeLine.source_block_id}`,
                target: `block-${strokeLine.target_block_id}`,
                label: strokeLine.label,
                onStrokeLinesUpdate: setStrokeLines,
                onPathsUpdate: setPaths,
                strokeLines: strokeLines,
                isVisible: visibility,
              },
              style: { zIndex: 1000 },
            };
          });

          const allEdges = [...edges, ...strokeEdges];
          setEdges(allEdges);

          // Only layout the nodes
          const layoutedNodes = await createElkLayout(
            nodes,
            edges.filter((e) => !e.type?.includes('stroke'))
          );
          setNodes(layoutedNodes);

          // Check for blockId in URL and set viewport accordingly
          const blockId = searchParams ? searchParams.get('blockId') : null;
          if (blockId) {
            const targetNode = layoutedNodes.find(
              (n) => n.id === `block-${blockId}`
            );
            if (targetNode) {
              setDefaultViewport({
                x: -(targetNode.position.x - window.innerWidth / 2),
                y: -(targetNode.position.y - window.innerHeight / 2),
                zoom: 1,
              });
              setLinkNode(targetNode);
            }
          }
        }
      } catch (error) {
        console.error('Error creating layout:', error);
        // Provide fallback - set empty nodes/edges to prevent crashes
        setNodes([]);
        setEdges([]);
      }
    };
    createLayoutedNodes();
  }, [
    paths,
    strokeLines,
    handleDeleteBlock,
    handleAddBlockOnEdge,
    setPaths,
    setStrokeLines,
    updateStrokeLineVisibility,
    strokeLineVisibilities,
    searchParams,
  ]);

  const handleBlockTypeSelect = async (
    blockType: 'STEP' | 'PATH' | 'DELAY',
    dropdownDatas: DropdownDatas,
    delayOptions?: {
      delayType?: DelayType;
      eventName?: string;
      seconds?: number;
    }
  ) => {
    try {
      // Validate delay options if it's a DELAY block
      if (blockType === 'DELAY') {
        if (!delayOptions?.delayType) {
          throw new Error('Delay type is required for DELAY blocks');
        }
        if (
          delayOptions.delayType === DelayType.FIXED_DURATION &&
          (typeof delayOptions.seconds !== 'number' || delayOptions.seconds < 0)
        ) {
          throw new Error(
            'A valid delay value (non-negative number) is required for fixed duration delays'
          );
        }
        if (
          delayOptions.delayType === DelayType.WAIT_FOR_EVENT &&
          !delayOptions.eventName
        ) {
          throw new Error('Event name is required for event-based delays');
        }
        // For event-based delays, seconds is optional but must be non-negative if provided
        if (
          delayOptions.delayType === DelayType.WAIT_FOR_EVENT &&
          delayOptions.seconds !== undefined &&
          delayOptions.seconds < 0
        ) {
          throw new Error('If provided, expiration time must be non-negative');
        }
      }

      const blockData = {
        type: blockType,
        position: dropdownDatas.position,
        path_id: dropdownDatas.path.id,
        delay_type: delayOptions?.delayType as string,
        delay_event: delayOptions?.eventName,
        delay_seconds: delayOptions?.seconds,
      };

      await onBlockAdd(
        blockData,
        dropdownDatas.path.id,
        dropdownDatas.position
      );
      setShowDropdown(false);
    } catch (error) {
      console.error('Error creating block:', error);
      setShowDropdown(false);
      // Optionally show user-friendly error message
      // You could add a toast notification here
    }
  };

  const showParallelPathModal = useModalStore(
    (state) => state.showParallelPathModal
  );
  const modalData = useModalStore((state) => state.modalData);
  const setShowModal = useModalStore((state) => state.setShowModal);

  const handleCreateParallelPaths = async (data: {
    conditionName: string;
    conditionDescription?: string;
    icon?: string;
    paths_to_create: string[];
    path_to_move: number;
  }) => {
    try {
      setShowModal(false);
      if (modalData.path) {
        // Create parallel paths using the modal data
        setIsModalOpen(true);
        const creationData: {
          updatedPaths: Path[];
          rollbackPaths: Path[];
        } = await createParallelPaths(
          paths,
          modalData.path,
          modalData.position,
          {
            paths_to_create: data.paths_to_create,
            path_to_move: data.path_to_move,
            pathblock_title: data.conditionName,
            pathblock_description: data.conditionDescription,
            pathblock_icon: data.icon,
          },
          setPaths
        );
        setIsModalOpen(false);
      }
    } catch (error) {
      console.error('Error creating parallel paths:', error);
      setIsModalOpen(false);
      // Optionally show user-friendly error message
      // You could add a toast notification here
    }
  };

  const toggleAllStrokeLines = useCallback(() => {
    const newVisibility = !allStrokeLinesVisible;
    setAllStrokeLinesVisible(newVisibility);

    // Update all stroke line visibilities
    const blockIds = new Set<number>();
    paths.forEach((path) => {
      path.blocks.forEach((block) => {
        blockIds.add(block.id);
      });
    });

    blockIds.forEach((blockId) => {
      updateStrokeLineVisibility(blockId, newVisibility);
    });
  }, [
    paths,
    allStrokeLinesVisible,
    updateStrokeLineVisibility,
    setAllStrokeLinesVisible,
  ]);

  // Combine regular edges with preview edge
  const allEdges = useMemo(() => {
    return previewEdge ? [...edges, previewEdge] : edges;
  }, [edges, previewEdge]);

  const showConnectModal = useModalStore((state) => state.showConnectModal);
  const connectData = useModalStore((state) => state.connectData);
  const setShowConnectModal = useModalStore(
    (state) => state.setShowConnectModal
  );

  const handleConnect = useCallback(
    async (targetNodeId: string, label: string) => {
      try {
        const sourceNode = nodes.find(
          (node) => node.id === connectData?.sourceNode.id
        );

        if (!sourceNode?.data.path) {
          throw new Error('Source path not found');
        }

        const response = await fetch('/api/stroke-lines', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            source_block_id: parseInt(sourceNode.id.replace('block-', '')),
            target_block_id: parseInt(targetNodeId.replace('block-', '')),
            workflow_id: parseInt(workflowId),
            label: label,
          }),
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || 'Failed to create connection');
        }

        // Close modal
        setShowConnectModal(false);

        // Fetch updated stroke lines
        const strokeLinesResponse = await fetch(
          `/api/stroke-lines?workflow_id=${parseInt(workflowId)}`
        );
        if (!strokeLinesResponse.ok) {
          throw new Error('Failed to fetch updated connections');
        }
        const strokeLines = await strokeLinesResponse.json();
        setStrokeLines(strokeLines);
      } catch (error) {
        console.error('Error in handleConnect:', error);
        // Re-throw the error to be handled by the modal
        throw error;
      }
    },
    [nodes, connectData, setShowConnectModal, setStrokeLines, workflowId]
  );

  useEffect(() => {
    if (showConnectModal && connectData?.sourceNode) {
      setIsConnectMode(true);
      setSourceBlockId(connectData.sourceNode.id);
    } else {
      reset(); // This will clear all states including sourceBlockId
    }
  }, [
    showConnectModal,
    connectData,
    setIsConnectMode,
    setSourceBlockId,
    reset,
  ]);

  useEffect(() => {
    if (isConnectMode && connectData?.sourceNode) {
      setNodes((nodes) =>
        nodes.map((node) => ({
          ...node,
          className: `${node.className || ''} ${
            node.id === connectData.sourceNode.id ? 'source-node' : ''
          }`,
        }))
      );
    } else {
      setNodes((nodes) =>
        nodes.map((node) => ({
          ...node,
          className: node.className?.replace('source-node', ''),
        }))
      );
    }
  }, [isConnectMode, connectData]);

  // Create a debounced version of setPaths
  const debouncedSetPaths = useCallback(
    debounce((newPaths: Path[]) => {
      setPaths(newPaths);
    }, 100),
    [setPaths]
  );

  useEffect(() => {
    const handlePathsUpdate = (event: CustomEvent) => {
      debouncedSetPaths(event.detail);
    };

    window.addEventListener('updatePaths', handlePathsUpdate as EventListener);

    return () => {
      window.removeEventListener(
        'updatePaths',
        handlePathsUpdate as EventListener
      );
    };
  }, [debouncedSetPaths]);

  useEffect(() => {
    setAllPaths(paths);
  }, [paths, setAllPaths]);

  useEffect(() => {
    if (newBlockId && nodes.length > 0) {
      // Find the node with the new block ID
      const nodeId = `block-${newBlockId}`;
      const node = nodes.find((n) => n.id === nodeId);

      const newblock: Block | undefined = paths
        .flatMap((p) => p.blocks)
        .find((b) => b.id === newBlockId);
      if (!newblock || newblock.type !== 'STEP') return;

      if (node) {
        // Set this node as selected in edit mode
        setEditMode(true, newBlockId.toString());

        // Center the view on the node and offset to make room for sidebar
        setViewport(
          {
            x: -(node.position.x - window.innerWidth / 2 + 400),
            y: -(node.position.y - window.innerHeight / 2 + 200),
            zoom: 1,
          },
          { duration: 800 }
        );

        // Clear the newBlockId after handling it
        clearNewBlockId();
      }
    }
  }, [newBlockId, nodes, setEditMode, setViewport, clearNewBlockId]);

  // Effect to sync individual stroke line visibilities with global setting
  useEffect(() => {
    if (paths.length > 0) {
      // Update all stroke line visibilities based on global setting
      const blockIds = new Set<number>();
      paths.forEach((path) => {
        path.blocks.forEach((block) => {
          blockIds.add(block.id);
        });
      });

      blockIds.forEach((blockId) => {
        updateStrokeLineVisibility(blockId, allStrokeLinesVisible);
      });
    }
  }, [allStrokeLinesVisible, paths, updateStrokeLineVisibility]);

  // Set the modal store's onStrokeLinesUpdate to setStrokeLines
  useEffect(() => {
    useModalStore.getState().setOnStrokeLinesUpdate(setStrokeLines);
    // Optionally, clean up on unmount
    return () => {
      useModalStore.getState().setOnStrokeLinesUpdate(undefined);
    };
  }, [setStrokeLines]);

  return (
    <div
      className={`fixed inset-0 flex-1 w-full h-screen overflow-hidden ${
        isEditMode || isConnectMode ? '' : ''
      }`}
      style={{
        backgroundColor:
          isEditMode || isConnectMode
            ? colors['bg-primary-solid']
            : colors['bg-primary'],
      }}
    >
      <ReactFlow
        nodes={nodes}
        edges={allEdges}
        nodeTypes={nodeTypes}
        edgeTypes={edgeTypes}
        minZoom={0.1}
        maxZoom={4}
        defaultViewport={{ x: 0, y: 0, zoom: 1 }}
        translateExtent={translateExtent}
        onNodeClick={(event, node) => {
          if (isModalOpen) return;
          event.preventDefault();
          event.stopPropagation();
          if (node.data.type !== 'STEP') return;
          const blockId = node.id.replace('block-', '');
          setEditMode(true, blockId);

          setViewport(
            {
              x: -(node.position.x - window.innerWidth / 2 + 400),
              y: -(node.position.y - window.innerHeight / 2 + 200),
              zoom: 1,
            },
            { duration: 800 }
          );
        }}
        onPaneClick={() => {
          setEditMode(false, null);
        }}
        fitView={true}
        panOnScroll
        panOnDrag
        zoomOnScroll
        selectionOnDrag={false}
        nodesDraggable={false}
        nodesConnectable={false}
        elementsSelectable={true}
        preventScrolling={true}
        proOptions={{ hideAttribution: true }}
        snapToGrid={true}
        snapGrid={[15, 15]}
        fitViewOptions={{
          nodes: linkNode ? [linkNode] : nodes,
          padding: 0.5,
          duration: 200,
          minZoom: 0.5,
          maxZoom: 1,
          includeHiddenNodes: true,
        }}
        className={`w-full h-full ${isConnectMode ? 'connect-mode' : ''}`}
        style={{
          backgroundColor: colors['bg-secondary'],
        }}
      >
        <Background gap={20} size={3} color={colors['border-primary']} />
        <MiniMap
          nodeColor={colors['fg-brand-primary']}
          maskColor={`${colors['bg-primary']}20`}
          className="custom-minimap"
          style={{ 
            bottom: 90,
            borderRadius: '8px',
            border: `1px solid ${colors['border-secondary']}`,
          }}
          nodeStrokeColor={colors['border-primary']}
          nodeStrokeWidth={2}
          nodeBorderRadius={4}
          pannable={true}
          zoomable={true}
        />
      </ReactFlow>
      <PathSelectionBox workspaceId={workspaceId} workflowId={workflowId} />
      <UpdatePathSelectionBox
        workspaceId={workspaceId}
        workflowId={workflowId}
      />
      {showDropdown && dropdownDatas && (
        <AddBlockDropdownMenu
          dropdownDatas={dropdownDatas}
          onSelect={handleBlockTypeSelect}
          onClose={() => {
            setShowDropdown(false);
          }}
          workspaceId={workspaceId}
          workflowId={workflowId}
          onPathsUpdate={setPaths}
        />
      )}

      {showParallelPathModal && modalData.path && (
        <CreateParallelPathModal
          onClose={() => setShowModal(false)}
          onConfirm={handleCreateParallelPaths}
          path={modalData.path}
          position={modalData.position}
          existingPaths={modalData.existingPaths}
        />
      )}

      {showConnectModal && connectData && connectData.sourceNode && (
        <ConnectNodeModal
          onClose={() => {
            setPreviewEdge(null);
            setShowConnectModal(false);
          }}
          onConfirm={handleConnect}
          sourceNode={
            nodes.find((node) => node.id === connectData.sourceNode.id) as Node
          }
          availableNodes={getNodes()}
          onPreviewUpdate={setPreviewEdge}
        />
      )}

      {showConnectNodeModal &&
        connectModalSourceNode &&
        connectModalTargetNode && (
          <ConnectNodeModal
            onClose={() => setShowConnectNodeModal(false)}
            onConfirm={() => setShowConnectNodeModal(false)}
            sourceNode={connectModalSourceNode}
            availableNodes={getNodes()}
            initialTargetNodeId={connectModalTargetNode.id}
            initialLabel={connectModalLabel}
            editStrokeLineId={editStrokeLineId}
            isEdit={isEditLink}
            onLinkUpdated={handleLinkUpdated}
          />
        )}

      <EditLinksModal
        onEditLink={(sourceNode, targetNode, label, strokeLineId) => {
          setConnectModalSourceNode(sourceNode);
          setConnectModalTargetNode(targetNode);
          setConnectModalLabel(label);
          setEditStrokeLineId(strokeLineId);
          setIsEditLink(true);
          setShowConnectNodeModal(true);
          setShowEditLinksModal(false);
        }}
      />

      <Sidebar workspaceId={workspaceId} workflowId={workflowId} />

      <div className="absolute top-20 right-8 z-10">
        <ZoomBar />
      </div>
    </div>
  );
});
</file>

<file path="app/[slug]/[flow]/edit/components/IconModifier.tsx">
import React, { useState, useEffect } from 'react';
import IconSelector from './IconSelector';
import { Block } from '../../types';
import { useColors, useThemeAssets } from '@/app/theme/hooks';
import { fetchSignedUrl } from '@/utils/supabase/fetch_url';
import {
  fetchIconsBatch,
  preloadCriticalIcons,
} from '@/utils/optimizedIconFetch';

interface Entity {
  basicUrl: string;
  signedUrl: string;
}

interface IconModifierProps {
  block: Block;
  onUpdate: (updatedBlock: Partial<Block>) => void;
}

export default function IconModifier({ block, onUpdate }: IconModifierProps) {
  const [showSelector, setShowSelector] = useState(false);
  const [isHovering, setIsHovering] = useState(false);
  const [iconUrl, setIconUrl] = useState<string | null>(null);
  const [applist, setAppList] = useState<Entity[]>([]);
  const [iconlist, setIconList] = useState<Entity[]>([]);
  const colors = useColors();
  const themeAssets = useThemeAssets();

  useEffect(() => {
    let isMounted = true;
    const getIconUrl = async () => {
      let iconPath: string;
      if (!block.icon) {
        iconPath = 'step-icons/default-icons/container.svg';
      } else if (block.icon.startsWith('https://cdn.brandfetch.io/')) {
        setIconUrl(block.icon);
        return;
      } else {
        iconPath = block.icon;
      }
      // Fetch signed URL for the icon (either default or custom)
      const signedUrl = await fetchSignedUrl(iconPath);
      if (isMounted) setIconUrl(signedUrl);
    };
    getIconUrl();
    return () => {
      isMounted = false;
    };
  }, [block.icon]);

  // Fetch icons and signed URLs with optimized batch loading
  useEffect(() => {
    const fetchIcons = async () => {
      try {
        const response = await fetch('/api/step-icons');
        if (!response.ok) throw new Error('Failed to fetch icons');
        const data = await response.json();

        // Use optimized batch fetching with caching and fallback
        const { applistResult, iconlistResult } = await fetchIconsBatch(
          data.applist,
          data.iconlist
        );

        // Convert to Entity format
        const appEntities: Entity[] = applistResult.map((item) => ({
          basicUrl: item.basicUrl,
          signedUrl: item.signedUrl,
        }));

        const iconEntities: Entity[] = iconlistResult.map((item) => ({
          basicUrl: item.basicUrl,
          signedUrl: item.signedUrl,
        }));

        setAppList(appEntities);
        setIconList(iconEntities);

        // Preload critical icons for better perceived performance
        const criticalIconUrls = [
          ...appEntities.slice(0, 10).map((item) => item.signedUrl),
          ...iconEntities.slice(0, 10).map((item) => item.signedUrl),
        ].filter((url) => url);

        if (criticalIconUrls.length > 0) {
          preloadCriticalIcons(criticalIconUrls, 20);
        }
      } catch (error) {
        console.error('Error fetching icons:', error);

        // Fallback to old method if new approach fails completely
        try {
          const response = await fetch('/api/step-icons');
          if (!response.ok) throw new Error('Failed to fetch icons');
          const data = await response.json();

          // Set initial lists with empty signedUrl
          const applistResult: Entity[] = data.applist.map((app: string) => ({
            basicUrl: `step-icons/apps/${app}`,
            signedUrl: '',
          }));
          const iconlistResult: Entity[] = data.iconlist.map(
            (icon: string) => ({
              basicUrl: `step-icons/default-icons/${icon}`,
              signedUrl: '',
            })
          );

          setAppList(applistResult);
          setIconList(iconlistResult);

          // Fetch signed URLs in the background for apps
          data.applist.forEach(async (app: string, idx: number) => {
            const basicUrl = `step-icons/apps/${app}`;
            const signedUrl = await fetchSignedUrl(basicUrl);
            setAppList((prev) =>
              prev.map((item, i) =>
                i === idx ? { ...item, signedUrl: signedUrl || '' } : item
              )
            );
          });

          // Fetch signed URLs in the background for icons
          data.iconlist.forEach(async (icon: string, idx: number) => {
            const basicUrl = `step-icons/default-icons/${icon}`;
            const signedUrl = await fetchSignedUrl(basicUrl);
            setIconList((prev) =>
              prev.map((item, i) =>
                i === idx ? { ...item, signedUrl: signedUrl || '' } : item
              )
            );
          });
        } catch (fallbackError) {
          console.error('Fallback icon fetching also failed:', fallbackError);
        }
      }
    };
    fetchIcons();
  }, []);

  const handleIconSelect = (icon?: string) => {
    if (icon) {
      onUpdate({ icon });
    } else {
      onUpdate({ icon: undefined });
    }
    setShowSelector(false);
  };

  const handleOverlayClick = () => {
    setShowSelector(false);
  };

  return (
    <div className="relative">
      {/* Icon Display */}
      <div
        className="w-10 h-10 rounded-lg border flex items-center justify-center cursor-pointer transition-colors duration-200"
        style={{
          borderColor: colors['border-primary'],
          backgroundColor: showSelector
            ? colors['bg-active']
            : isHovering
              ? colors['bg-primary_hover']
              : 'transparent',
        }}
        onClick={() => setShowSelector(!showSelector)}
        onMouseEnter={() => setIsHovering(true)}
        onMouseLeave={() => setIsHovering(false)}
      >
        {iconUrl ? (
          <img
            src={iconUrl}
            alt="Selected Icon"
            className="w-6 h-auto object-contain select-none pointer-events-none"
            referrerPolicy="strict-origin-when-cross-origin"
          />
        ) : (
          <div className="w-6 h-6 flex justify-center items-center" />
        )}
      </div>

      {/* Backdrop */}
      {showSelector && (
        <div
          className="fixed inset-0 z-50"
          style={{
            backgroundColor: colors['bg-overlay'],
            opacity: 0.5,
          }}
          onClick={handleOverlayClick}
        />
      )}

      {/* Icon Selector */}
      {showSelector && (
        <div className="absolute top-12 left-0 z-50">
          <IconSelector
            onSelect={handleIconSelect}
            applist={applist}
            iconlist={iconlist}
          />
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/edit/components/IconSelector.tsx">
import React, { useEffect, useState, useCallback } from 'react';
import { useColors } from '@/app/theme/hooks';
import Tooltip from '@/app/components/Tooltip';
import { fetchSignedUrl } from '@/utils/supabase/fetch_url';

const TABS = ['Apps', 'Icons', 'Upload'];
const BRANDFETCH_TIMEOUT = 10000; // 10 seconds timeout
const ACCEPTED_FILE_TYPES = 'image/png,image/jpeg,image/svg+xml';
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

interface Entity {
  basicUrl: string;
  signedUrl: string;
}

interface IconSelectorProps {
  onSelect: (icon?: string) => void;
  applist: Entity[];
  iconlist: Entity[];
}

// Popular brands mapping
const BRAND_TO_DOMAIN: { [brand: string]: string } = {
  ProcessFlow: 'process-flow.io',
  Google: 'google.com',
  Facebook: 'facebook.com',
  Twitter: 'twitter.com',
  Instagram: 'instagram.com',
  LinkedIn: 'linkedin.com',
  Microsoft: 'microsoft.com',
  Apple: 'apple.com',
  Amazon: 'amazon.com',
  Netflix: 'netflix.com',
  Spotify: 'spotify.com',
  Uber: 'uber.com',
  Airbnb: 'airbnb.com',
  Slack: 'slack.com',
  Dropbox: 'dropbox.com',
  Zoom: 'zoom.us',
  Pinterest: 'pinterest.com',
  Reddit: 'reddit.com',
  Salesforce: 'salesforce.com',
  Shopify: 'shopify.com',
  Adobe: 'adobe.com',
};

export default function IconSelector({
  onSelect,
  applist,
  iconlist,
}: IconSelectorProps) {
  const colors = useColors();
  const [searchTerm, setSearchTerm] = useState<string>('');
  const [activeTab, setActiveTab] = useState<string>('Apps');
  const [hoveredButton, setHoveredButton] = useState<string | null>(null);
  const [uploadError, setUploadError] = useState<string>('');
  const [isUploading, setIsUploading] = useState(false);

  // Add state for BrandFetch preview loading
  const [brandFetchLoading, setBrandFetchLoading] = useState(false);
  const [brandFetchUrl, setBrandFetchUrl] = useState<string | null>(null);
  const [brandFetchError, setBrandFetchError] = useState(false);
  const [hoveredIcon, setHoveredIcon] = useState<{
    name: string;
    type: string;
  } | null>(null);

  const handleFileUpload = useCallback(
    async (file: File) => {
      if (!file.type.match(ACCEPTED_FILE_TYPES.replace(/,/g, '|'))) {
        setUploadError(
          'Invalid file type. Please upload PNG, JPEG, or SVG files.'
        );
        return;
      }

      if (file.size > MAX_FILE_SIZE) {
        setUploadError('File size exceeds 5MB limit.');
        return;
      }

      setIsUploading(true);
      setUploadError('');

      try {
        const formData = new FormData();
        formData.append('file', file);

        const response = await fetch('/api/upload-icon', {
          method: 'POST',
          body: formData,
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Failed to upload file');
        }

        if (!data.success) {
          throw new Error(data.error || 'Upload failed');
        }

        onSelect(data.data.iconUrl);
      } catch (error) {
        console.error('Upload error:', error);
        setUploadError(
          error instanceof Error
            ? error.message
            : 'Failed to upload file. Please try again.'
        );
      } finally {
        setIsUploading(false);
      }
    },
    [onSelect]
  );

  // Update effect for BrandFetch search
  useEffect(() => {
    const fetchBrandIcon = async () => {
      if (
        !searchTerm ||
        applist.some((app) =>
          app.basicUrl.toLowerCase().includes(searchTerm.toLowerCase())
        )
      ) {
        setBrandFetchUrl(null);
        return;
      }

      setBrandFetchLoading(true);
      setBrandFetchError(false);
      setBrandFetchUrl(null);

      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(
          () => controller.abort(),
          BRANDFETCH_TIMEOUT
        );

        const response = await fetch(
          `/api/logo-search?q=${encodeURIComponent(searchTerm)}`,
          {
            signal: controller.signal,
          }
        );

        clearTimeout(timeoutId);

        if (!response.ok) throw new Error('Failed to fetch brand icon');
        const data = await response.json();

        if (data.icon) {
          setBrandFetchUrl(data.icon);
        } else {
          setBrandFetchError(true);
        }
      } catch (error) {
        setBrandFetchError(true);
      } finally {
        setBrandFetchLoading(false);
      }
    };

    const debounceTimer = setTimeout(fetchBrandIcon, 500);
    return () => clearTimeout(debounceTimer);
  }, [searchTerm, applist]);

  return (
    <div
      className="w-[502px] h-[328px] rounded-xl flex flex-col overflow-hidden shadow-lg"
      style={{
        backgroundColor: colors['bg-primary'],
        borderWidth: '1px',
        borderStyle: 'solid',
        borderColor: colors['border-primary'],
      }}
    >
      {/* Tabs */}
      <div
        className="self-stretch flex justify-between items-center"
        style={{
          borderBottomWidth: '1px',
          borderBottomStyle: 'solid',
          borderBottomColor: colors['border-primary'],
        }}
      >
        <div className="flex gap-3 pt-3 px-3">
          {TABS.map((tab) => (
            <div
              key={tab}
              className={`px-2 pb-3 cursor-pointer transition-colors duration-200 ${
                activeTab === tab ? 'border-b-2 font-medium' : ''
              }`}
              style={{
                color:
                  activeTab === tab
                    ? colors['text-brand-secondary']
                    : colors['text-secondary'],
                borderBottomColor:
                  activeTab === tab ? colors['bg-brand-solid'] : 'transparent',
              }}
              onClick={() => setActiveTab(tab)}
            >
              {tab}
            </div>
          ))}
        </div>
        <div
          className="px-4 cursor-pointer transition-colors duration-200"
          style={{ color: colors['text-secondary'] }}
          onClick={() => onSelect()}
        >
          Reset
        </div>
      </div>

      {/* Search Bar */}
      <div
        className="self-stretch px-4 py-3 flex flex-col gap-2"
        style={{
          backgroundColor: colors['bg-primary'],
          borderBottomWidth: '1px',
          borderBottomStyle: 'solid',
          borderBottomColor: colors['border-primary'],
          display: activeTab === 'Upload' ? 'none' : 'flex',
        }}
      >
        <div className="flex items-center gap-2">
          <img
            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/search-lg-icon.svg`}
            alt="Search icon"
            className="w-4 h-4 select-none pointer-events-none"
          />
          <input
            type="text"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            placeholder="Search..."
            className="flex-grow text-sm bg-transparent focus:outline-none placeholder:text-secondary"
            style={{ color: colors['text-primary'] }}
          />
        </div>
        {activeTab === 'Apps' && (
          <div
            className="flex items-start gap-2 mt-1 px-3 py-2 rounded-md text-xs"
            style={{
              backgroundColor: colors['bg-quaternary'],
              color: colors['text-secondary'],
              borderLeft: `3px solid ${colors['border-brand_alt']}`,
            }}
          >
            <svg
              className="w-4 h-4 mt-0.5 flex-shrink-0"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              viewBox="0 0 24 24"
            >
              <circle
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                strokeWidth="2"
                fill="none"
              />
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M12 16v-4m0-4h.01"
              />
            </svg>
            <span>
              You can search for any company logo by typing a domain (e.g.,{' '}
              <span className="font-semibold">google.com</span>) or brand name.
              If not found, we'll fetch it.
            </span>
          </div>
        )}
      </div>

      {/* Content */}
      <div
        className="self-stretch h-60 flex flex-col overflow-y-auto p-3"
        style={{ backgroundColor: colors['bg-primary'] }}
      >
        {activeTab === 'Apps' && (
          <div className="grid grid-cols-12 gap-3">
            {applist
              .filter((app) =>
                app.basicUrl.toLowerCase().includes(searchTerm.toLowerCase())
              )
              .map((app, index) => (
                <button
                  key={index}
                  onClick={() => onSelect(app.basicUrl)}
                  className="w-10 h-10 rounded-md flex items-center justify-center transition-colors duration-200 relative"
                  style={{
                    backgroundColor:
                      hoveredButton === `app-${index}`
                        ? colors['bg-quaternary']
                        : 'transparent',
                  }}
                  onMouseEnter={() => {
                    setHoveredButton(`app-${index}`);
                    setHoveredIcon({
                      name: app.basicUrl.split('/').pop()?.split('.')[0] || '',
                      type: 'App',
                    });
                  }}
                  onMouseLeave={() => {
                    setHoveredButton(null);
                    setHoveredIcon(null);
                  }}
                >
                  {app.signedUrl ? (
                    <img
                      src={app.signedUrl}
                      alt={app.basicUrl}
                      className="w-6 h-6 object-contain select-none pointer-events-none"
                    />
                  ) : (
                    <div className="w-6 h-6 bg-gray-100 rounded" />
                  )}
                  <Tooltip
                    text={hoveredIcon?.name || ''}
                    visible={
                      hoveredIcon?.type === 'App' &&
                      hoveredButton === `app-${index}`
                    }
                  />
                </button>
              ))}
            {/* BrandFetch integration in Apps tab */}
            {searchTerm &&
              applist.filter((app) =>
                app.basicUrl.toLowerCase().includes(searchTerm.toLowerCase())
              ).length === 0 && (
                <button
                  className="w-10 h-10 rounded-md flex items-center justify-center transition-colors duration-200 relative"
                  style={{
                    backgroundColor:
                      hoveredButton === 'apps-brandfetch'
                        ? colors['bg-quaternary']
                        : 'transparent',
                  }}
                  onClick={() => brandFetchUrl && onSelect(brandFetchUrl)}
                  onMouseEnter={() => setHoveredButton('apps-brandfetch')}
                  onMouseLeave={() => setHoveredButton(null)}
                  disabled={!brandFetchUrl || brandFetchError}
                >
                  {brandFetchLoading && (
                    <svg
                      className="animate-spin w-6 h-6"
                      viewBox="0 0 24 24"
                      fill="none"
                      style={{ color: colors['border-brand_alt'] }}
                    >
                      <circle
                        className="opacity-25"
                        cx="12"
                        cy="12"
                        r="10"
                        stroke="currentColor"
                        strokeWidth="4"
                      />
                      <path
                        className="opacity-75"
                        fill="currentColor"
                        d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"
                      />
                    </svg>
                  )}
                  {brandFetchUrl && !brandFetchLoading && (
                    <img
                      src={brandFetchUrl}
                      alt={`Logo for ${searchTerm}`}
                      className="w-6 h-6 object-contain select-none pointer-events-none"
                      referrerPolicy="strict-origin-when-cross-origin"
                      onError={() => setBrandFetchError(true)}
                    />
                  )}
                  {brandFetchError && !brandFetchLoading && (
                    <svg
                      className="w-6 h-6"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                      style={{ color: colors['text-error'] }}
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
                      />
                    </svg>
                  )}
                </button>
              )}
          </div>
        )}

        {activeTab === 'Icons' && (
          <div className="grid grid-cols-12 gap-3">
            {iconlist
              .filter((icon) =>
                icon.basicUrl.toLowerCase().includes(searchTerm.toLowerCase())
              )
              .map((icon, index) => (
                <button
                  key={index}
                  onClick={() => onSelect(icon.basicUrl)}
                  className="w-10 h-10 rounded-md flex items-center justify-center transition-colors duration-200 relative"
                  style={{
                    backgroundColor:
                      hoveredButton === `icon-${index}`
                        ? colors['bg-quaternary']
                        : 'transparent',
                  }}
                  onMouseEnter={() => {
                    setHoveredButton(`icon-${index}`);
                    setHoveredIcon({
                      name: icon.basicUrl.split('/').pop()?.split('.')[0] || '',
                      type: 'Icon',
                    });
                  }}
                  onMouseLeave={() => {
                    setHoveredButton(null);
                    setHoveredIcon(null);
                  }}
                >
                  <img
                    src={icon.signedUrl || '/spinner.svg'}
                    alt={icon.basicUrl}
                    className="w-6 h-6 object-contain select-none pointer-events-none"
                  />
                  <Tooltip
                    text={hoveredIcon?.name || ''}
                    visible={
                      hoveredIcon?.type === 'Icon' &&
                      hoveredButton === `icon-${index}`
                    }
                  />
                </button>
              ))}
          </div>
        )}

        {activeTab === 'Upload' && (
          <div className="flex flex-col items-center justify-center h-full gap-4 px-6">
            <div
              className={`w-full p-5 border border-dashed rounded-lg flex flex-col items-center gap-3 transition-colors duration-200 cursor-pointer ${
                isUploading
                  ? 'opacity-50 cursor-not-allowed'
                  : 'hover:border-brand-secondary'
              }`}
              style={{ borderColor: colors['border-primary'] }}
              onDragOver={(e) => {
                e.preventDefault();
                e.stopPropagation();
              }}
              onDrop={(e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!isUploading && e.dataTransfer.files?.[0]) {
                  handleFileUpload(e.dataTransfer.files[0]);
                }
              }}
              onClick={() => {
                if (!isUploading) {
                  const input = document.createElement('input');
                  input.type = 'file';
                  input.accept = ACCEPTED_FILE_TYPES;
                  input.onchange = (e) => {
                    const file = (e.target as HTMLInputElement).files?.[0];
                    if (file) handleFileUpload(file);
                  };
                  input.click();
                }
              }}
            >
              {isUploading ? (
                <div className="flex flex-col items-center gap-2">
                  <svg
                    className="animate-spin w-6 h-6"
                    viewBox="0 0 24 24"
                    fill="none"
                    style={{ color: colors['border-brand_alt'] }}
                  >
                    <circle
                      className="opacity-25"
                      cx="12"
                      cy="12"
                      r="10"
                      stroke="currentColor"
                      strokeWidth="4"
                    />
                    <path
                      className="opacity-75"
                      fill="currentColor"
                      d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"
                    />
                  </svg>
                  <span style={{ color: colors['text-secondary'] }}>
                    Uploading...
                  </span>
                </div>
              ) : (
                <>
                  <div
                    className="w-12 h-12 rounded-lg flex items-center justify-center"
                    style={{
                      backgroundColor: colors['bg-primary'],
                      boxShadow:
                        '0px 1px 2px 0px rgba(16, 24, 40, 0.05), inset 0px -2px 0px 0px rgba(16, 24, 40, 0.05), inset 0px 0px 0px 1px rgba(16, 24, 40, 0.18)',
                    }}
                  >
                    <img
                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/upload-cloud-02.svg`}
                      alt="Upload icon"
                      className="w-6 h-6 select-none pointer-events-none"
                    />
                  </div>
                  <div className="flex flex-col items-center gap-1">
                    <div className="flex items-center gap-1">
                      <span
                        className="text-sm font-semibold"
                        style={{ color: colors['text-brand-secondary'] }}
                      >
                        Click to upload
                      </span>
                      <span
                        className="text-sm"
                        style={{ color: colors['text-secondary'] }}
                      >
                        or drag and drop
                      </span>
                    </div>
                    <p
                      className="text-xs text-center"
                      style={{ color: colors['text-secondary'] }}
                    >
                      SVG, PNG, JPG
                    </p>
                  </div>
                </>
              )}
            </div>
            {uploadError && (
              <div
                className="text-sm px-4 py-2 rounded-md"
                style={{
                  backgroundColor: colors['bg-error'],
                  color: colors['text-error'],
                }}
              >
                {uploadError}
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/edit/components/ImageEditor.tsx">
import React, { useEffect, useRef, useState, useCallback } from 'react';
import { useColors } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';
import dynamic from 'next/dynamic';
import 'tui-image-editor/dist/tui-image-editor.css';
import 'tui-color-picker/dist/tui-color-picker.css';

// Error boundary component to catch editor errors
class ImageEditorErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean }
> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('ImageEditor Error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="flex items-center justify-center w-full h-full">
          <div className="text-lg">Something went wrong with the editor. Please try again.</div>
        </div>
      );
    }

    return this.props.children;
  }
}

// Dynamically import the ImageEditor component with no SSR
const TuiImageEditor = dynamic(
  () => import('@toast-ui/react-image-editor'),
  { 
    ssr: false,
    loading: () => (
      <div className="flex items-center justify-center w-full h-full bg-gray-100/50">
        <div className="text-lg">Loading editor...</div>
      </div>
    )
  }
);

interface ImageEditorProps {
  imageUrl: string;
  onClose: () => void;
  onSave: (editedImageUrl: string) => void;
}

export default function ImageEditorModal({
  imageUrl,
  onClose,
  onSave,
}: ImageEditorProps) {
  const colors = useColors();
  const editorRef = useRef<any>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const instanceRef = useRef<any>(null);
  const originalOverflowRef = useRef<string>('');

  // Handle body overflow
  useEffect(() => {
    // Store the original overflow value
    originalOverflowRef.current = window.getComputedStyle(document.body).overflow || '';
    // Set overflow to hidden
    document.body.style.overflow = 'hidden';

    return () => {
      // Restore original overflow
      document.body.style.overflow = originalOverflowRef.current || '';
    };
  }, []);

  // Handle editor initialization
  useEffect(() => {
    let initializationAttempts = 0;
    const maxAttempts = 50; // 5 seconds max

    const checkInstance = () => {
      try {
        initializationAttempts++;
        
        if (initializationAttempts > maxAttempts) {
          setError('Failed to initialize editor');
          setIsLoading(false);
          return true;
        }

        if (editorRef.current?.getInstance) {
          const instance = editorRef.current.getInstance();
          if (instance && instance.invoke) {
            instanceRef.current = instance;
            setIsLoading(false);
            setError(null);
            return true;
          }
        }
        return false;
      } catch (err) {
        console.error('Error getting editor instance:', err);
        if (initializationAttempts > maxAttempts) {
          setError('Failed to initialize editor');
          setIsLoading(false);
          return true;
        }
        return false;
      }
    };

    const initializeInterval = setInterval(() => {
      if (checkInstance()) {
        clearInterval(initializeInterval);
      }
    }, 100);

    return () => {
      clearInterval(initializeInterval);
    };
  }, []);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (instanceRef.current) {
        try {
          if (typeof instanceRef.current.destroy === 'function') {
            instanceRef.current.destroy();
          }
        } catch (e) {
          console.warn('Error during TUI Image Editor cleanup:', e);
        }
        instanceRef.current = null;
      }
    };
  }, []);

  const handleClose = useCallback(() => {
    onClose();
  }, [onClose]);

  const handleSave = useCallback(async () => {
    if (!instanceRef.current) {
      setError('Editor not ready');
      return;
    }

    try {
      const dataUrl = instanceRef.current.toDataURL();
      if (!dataUrl) {
        throw new Error('Failed to get image data');
      }

      const imageFile = dataURLtoFile(dataUrl, 'edited-image.png');
      await uploadFile(imageFile);
      onClose();
      
    } catch (err) {
      console.error('Error saving image:', err);
      setError('Failed to save image');
    }
  }, [onClose]);

  const uploadFile = async (file: File) => {
    const formData = new FormData();
    formData.append('file', file);

    try {
      const response = await fetch('/api/upload', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error('Upload failed');
      }

      const data = await response.json();
      onSave(data.filePath);
    } catch (error) {
      console.error('Error uploading file:', error);
      throw new Error('Failed to upload file');
    }
  };

  const dataURLtoFile = (dataurl: string, filename: string): File => {
    const arr = dataurl.split(',');
    const mime = arr[0].match(/:(.*?);/)?.[1];
    const bstr = atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);

    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }

    return new File([u8arr], filename, { type: mime });
  };

  const handleModalClick = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (e.target === e.currentTarget) {
      handleClose();
    }
  }, [handleClose]);

  const handleContentClick = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
  }, []);

  return (
    <div 
      className="fixed inset-0 z-[1000] overflow-hidden"
      style={{ backgroundColor: 'rgba(0, 0, 0, 0.5)' }}
      onClick={handleModalClick}
    >
      <div
        className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 rounded-xl p-6 flex flex-col"
        style={{ 
          backgroundColor: colors['bg-primary'],
          width: '80vw',
          height: '80vh',
        }}
        onClick={handleContentClick}
      >
        <div className="flex justify-between items-center mb-4 flex-shrink-0">
          <h2
            className="text-lg font-semibold"
            style={{ color: colors['text-primary'] }}
          >
            Edit Image
          </h2>
          <div className="flex gap-2">
            <ButtonNormal 
              onClick={handleClose} 
              size="small" 
              variant="secondary"
            >
              Cancel
            </ButtonNormal>
            <ButtonNormal 
              onClick={handleSave} 
              size="small" 
              variant="primary"
              disabled={isLoading || !!error}
            >
              Save
            </ButtonNormal>
          </div>
        </div>

        <div className="flex-1 min-h-0 rounded-lg overflow-hidden">
          {error ? (
            <div className="flex items-center justify-center w-full h-full">
              <div className="text-red-500">{error}</div>
            </div>
          ) : (
            <ImageEditorErrorBoundary>
              <div style={{ width: '100%', height: '100%' }}>
                <TuiImageEditor
                  ref={editorRef}
                  includeUI={{
                    loadImage: {
                      path: imageUrl,
                      name: 'Image',
                    },
                    theme: {
                      'common.backgroundColor': colors['bg-primary'],
                      'common.border': `1px solid ${colors['border-primary']}`,
                      'common.color': colors['text-primary'],
                    },
                    menu: ['crop', 'flip', 'rotate', 'draw', 'shape', 'icon', 'text'],
                    menuBarPosition: 'bottom',
                    uiSize: {
                      width: '100%',
                      height: '100%',
                    },
                  }}
                  cssMaxHeight={700}
                  cssMaxWidth={1000}
                  selectionStyle={{
                    cornerSize: 20,
                    rotatingPointOffset: 70,
                  }}
                />
              </div>
            </ImageEditorErrorBoundary>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/edit/components/PathContainer.tsx">
import React from 'react';
import { Path } from '../../types';
import { useColors } from '@/app/theme/hooks';

interface PathContainerProps {
  path: Path;
  level: number;
  renderContent: (path: Path, level: number) => React.ReactNode;
}

export const PathContainer: React.FC<PathContainerProps> = ({
  path,
  level,
  renderContent,
}) => {
  const colors = useColors();

  return (
    <div className="w-full">
      {renderContent(path, level)}
    </div>
  );
};
</file>

<file path="app/[slug]/[flow]/edit/components/PathSelectionBox.tsx">
import { Path } from '../../types';
import React, { useState } from 'react';
import { usePathSelectionStore } from '../store/pathSelectionStore';
import { useColors } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';

export function PathSelectionBox({
  workspaceId,
  workflowId,
}: {
  workspaceId: string;
  workflowId: string;
}) {
  const { selectedPaths, selectedEndBlocks, reset, mergeMode, setMergeMode } =
    usePathSelectionStore();
  const colors = useColors();
  const [isMerging, setIsMerging] = useState(false);

  if (!mergeMode) return null;

  const handleMerge = async () => {
    if (selectedPaths.length < 2) return;

    setIsMerging(true);
    try {
      const payload = {
        name: 'Merge',
        workflow_id: parseInt(workflowId),
        parent_blocks: selectedEndBlocks,
      };
      await fetch('/api/paths/merge', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      // Fetch updated paths after merge
      const pathsResponse = await fetch(
        `/api/workspace/${workspaceId}/paths?workflow_id=${workflowId}`
      );

      if (pathsResponse.ok) {
        const pathsData = await pathsResponse.json();
        // Update paths in the Flow component
        window.dispatchEvent(
          new CustomEvent('updatePaths', {
            detail: pathsData.paths,
          })
        );
      }

      reset();
    } catch (error) {
      console.error('Error during merge:', error);
    } finally {
      setIsMerging(false);
      reset();
    }
  };

  const handleClose = () => {
    setMergeMode(false);
    reset();
  };

  return (
    <div className="fixed bottom-4 left-1/2 -translate-x-1/2 w-[400px] flex items-center justify-between gap-2 px-2 py-2 rounded-lg shadow-lg border bg-gray-900 dark:bg-white border-gray-700 dark:border-gray-200">
      <div className="flex items-center gap-2">
        <span className="text-sm text-gray-300 dark:text-gray-600">
          {selectedPaths.length} block{selectedPaths.length > 1 ? 's' : ''}{' '}
          selected
        </span>
        <button
          onClick={handleClose}
          disabled={isMerging}
          className={`p-1 rounded-full text-gray-300 dark:text-gray-600 hover:bg-gray-800 dark:hover:bg-gray-100 transition-colors ${
            isMerging ? 'opacity-50 cursor-not-allowed' : ''
          }`}
        >
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path
              d="M6 18L18 6M6 6l12 12"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
            />
          </svg>
        </button>
      </div>
      <ButtonNormal
        onClick={handleMerge}
        disabled={selectedPaths.length <= 1 || isMerging}
        isLoading={isMerging}
        loadingText="Merging..."
        variant="primary"
        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/git-merge.svg`}
        size="small"
      >
        Merge Paths
      </ButtonNormal>
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/edit/components/PreviewEdgePortal.tsx">
// import { Edge } from '@xyflow/react';
// import { createPortal } from 'react-dom';
// import StrokeEdge from './StrokeEdge';

// interface PreviewEdgePortalProps {
//   edge: Edge | null;
// }

// export const PreviewEdgePortal = ({ edge }: PreviewEdgePortalProps) => {
//   if (!edge) return null;

//   // Create a background edge with white stroke
//   const backgroundEdge: Edge = {
//     ...edge,
//     style: {
//       ...edge.style,
//       stroke: 'white',
//       strokeWidth: (edge.style?.strokeWidth as number || 3) + 4, // Wider than the main stroke
//       opacity: 1,
//     },
//   };

//   return createPortal(
//     <svg
//       style={{
//         position: 'fixed',
//         inset: 0,
//         pointerEvents: 'none',
//         zIndex: 9999,
//       }}
//     >
//       <StrokeEdge {...backgroundEdge} /> {/* Render white background stroke first */}
//       <StrokeEdge {...edge} /> {/* Render colored stroke on top */}
//     </svg>,
//     document.body
//   );
// };
</file>

<file path="app/[slug]/[flow]/edit/components/ReactFlowPageClient.tsx">
'use client';
import React, { useEffect, useState } from 'react';
import { ReactFlowProvider, useReactFlow } from '@xyflow/react';
import { Flow } from './Flow';
import { NodeData, Path, Block, StrokeLine } from '../../types';
import { getWorkflowStrokeLines } from '../utils/stroke-lines';
import WorkflowHeader from './WorkflowHeader';
import { useSearchParams } from 'next/navigation';
import { usePathsStore } from '../store/pathsStore';
import { Workspace } from '@/types/workspace';
import { toast } from 'sonner';

interface ReactFlowPageClientProps {
  workspaceId: string;
  workflowId: string;
}

import { ScreenSizeOverlay } from './ScreenSizeOverlay';
import { isPreview } from '@/app/utils/isPreview';

export function ReactFlowPageClient({
  workspaceId,
  workflowId,
}: ReactFlowPageClientProps) {
  const [workflowName, setWorkflowName] = useState<string>('');
  const [strokeLines, setStrokeLines] = useState<StrokeLine[]>([]);
  const [parentFolder, setParentFolder] = useState<string | undefined>();
  const [grandParentFolder, setGrandParentFolder] = useState<
    string | undefined
  >();
  const [workspace, setWorkspace] = useState<Workspace | undefined>();
  const setPaths = usePathsStore((state) => state.setPaths);
  const paths = usePathsStore((state) => state.paths);
  const [newBlockId, setNewBlockId] = useState<number | null>(null);

  const searchParams = useSearchParams();

  const handleBlockAdd = async (
    blockData: any,
    path_id: number,
    position: number
  ) => {
    // Ensure path_id is a number
    if (!path_id || typeof path_id !== 'number') {
      console.error('Invalid path_id:', path_id);
      return;
    }

    // Find the blocks array for the given path_id
    const path = paths.find((p) => p.id === path_id);
    const blocksLength = path?.blocks?.length ?? 0;
    // Cap position to (blocksLength - 1), but not less than 0
    const cap = Math.max(1, blocksLength - 1);
    const cappedPosition = Math.min(position, cap);

    // Prepare the block data
    const data = {
      title: blockData.title,
      type: blockData.type,
      position: cappedPosition,
      workflow_id: parseInt(workflowId),
      path_id: path_id,
      icon:
        blockData.type === 'STEP'
          ? '/step-icons/default-icons/container.svg'
          : blockData.type === 'PATH'
            ? `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dataflow-04.svg`
            : blockData.type === 'DELAY'
              ? '/step-icons/default-icons/delay.svg'
              : '/step-icons/default-icons/path.svg',
      description: '',
      delay_type: blockData.delay_type,
      delay_event: blockData.delay_event,
      delay_seconds: blockData.delay_seconds,
    };

    try {
      const response = await fetch('/api/blocks', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error('Failed to add block:', errorData);
        return;
      }

      // Get the newly created block's ID from the response
      const newBlock = await response.json();

      // Update paths locally instead of refetching
      setPaths((prevPaths) => {
        return prevPaths.map((p) => {
          if (p.id !== path_id) return p;
          // Insert the new block at the correct position
          const blocks = Array.isArray(p.blocks) ? [...p.blocks] : [];
          const insertAt = Math.min(newBlock.position, blocks.length);
          blocks.splice(insertAt, 0, newBlock);
          // Update positions of all blocks after the inserted one
          for (let i = insertAt + 1; i < blocks.length; i++) {
            blocks[i] = {
              ...blocks[i],
              position: (blocks[i].position ?? i - 1) + 1,
            };
          }
          return { ...p, blocks };
        });
      });
      setNewBlockId(newBlock.id);
    } catch (error) {
      console.error('Error adding block:', error);
    }
  };

  // Move fetchData outside of useEffect so it can be reused
  const fetchData = React.useCallback(async () => {
    try {
      const [workflowRes, pathsRes] = await Promise.all([
        fetch(`/api/workspace/${workspaceId}/workflows/${workflowId}`),
        fetch(`/api/workspace/${workspaceId}/paths?workflow_id=${workflowId}`),
      ]);

      const workflow = await workflowRes.json();
      setWorkflowName(workflow.name);
      setWorkspace(workflow.workspace);
      setParentFolder(workflow.folder?.name);
      setGrandParentFolder(workflow.folder?.parent?.name);

      const pathsData = await pathsRes.json();
      setPaths(pathsData.paths);

      // Fetch stroke lines
      const strokeLinesData = await getWorkflowStrokeLines(
        parseInt(workflowId)
      );
      if (strokeLinesData) {
        setStrokeLines(strokeLinesData);
      }
    } catch (error) {
      console.error('Error fetching data:', error);
    }
  }, [workspaceId, workflowId, setPaths]);

  // Initial fetch and set up interval
  useEffect(() => {
    if (isPreview()) {
      console.log('[DEBUG] Fetching data...');
    }
    fetchData();

    const interval = setInterval(() => {
      fetchData();
    }, 43_200_000); // 12 hours

    return () => clearInterval(interval);
  }, [fetchData]);

  return (
    <>
      <ScreenSizeOverlay />
      <div className="h-screen flex flex-col">
        <WorkflowHeader
          workflowId={workflowId}
          parentFolder={parentFolder}
          grandParentFolder={grandParentFolder}
          slug={workspace?.name}
        />
        <div className="pt-[72px] flex-1 h-[calc(100vh-56px)]">
          <ReactFlowProvider>
            <Flow
              workflowName={workflowName}
              workspaceId={workspaceId}
              workflowId={workflowId}
              onBlockAdd={handleBlockAdd}
              strokeLines={strokeLines}
              setStrokeLines={setStrokeLines}
              newBlockId={newBlockId}
              clearNewBlockId={() => setNewBlockId(null)}
            />
          </ReactFlowProvider>
        </div>
      </div>
    </>
  );
}
</file>

<file path="app/[slug]/[flow]/edit/components/ScreenSizeOverlay.tsx">
import React, { useEffect, useState } from 'react';

const MIN_WIDTH = 900;

/**
 * Overlay that blocks the page if the screen is too small.
 * Only visible if window.innerWidth < 900px.
 */
export const ScreenSizeOverlay: React.FC = () => {
  const [showOverlay, setShowOverlay] = useState(false);

  useEffect(() => {
    const checkWidth = () => setShowOverlay(window.innerWidth < MIN_WIDTH);
    checkWidth();
    window.addEventListener('resize', checkWidth);
    return () => window.removeEventListener('resize', checkWidth);
  }, []);

  if (!showOverlay) return null;

  return (
    <div className="fixed inset-0 z-[1000] flex flex-col items-center justify-center bg-black bg-opacity-70">
      <div className="flex flex-col items-center">
        {/* Icon: Exclamation mark inside a circle */}
        <svg className="w-16 h-16 text-red-500 mb-4" fill="none" stroke="currentColor" strokeWidth={2} viewBox="0 0 24 24" aria-hidden="true">
          <circle cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="2" fill="none" />
          <line x1="12" y1="7" x2="12" y2="12" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
          <circle cx="12" cy="15" r="0.6" fill="currentColor" />
        </svg>
        <p className="text-white text-xl font-semibold mb-2">Your browser is too small</p>
        <p className="text-white text-center">Resize your browser to be at least <span className="font-bold">900px</span> wide to get back into edit mode.</p>
      </div>
    </div>
  );
};
</file>

<file path="app/[slug]/[flow]/edit/components/SettingsModal.tsx">
import React, { useState, useEffect } from 'react';
import { useColors, useTheme } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';
import type { ThemeMode } from '@/app/theme/types';
import { useStrokeLinesStore } from '../store/strokeLinesStore';

interface SettingsModalProps {
  onClose: () => void;
}

export function SettingsModal({ onClose }: SettingsModalProps) {
  const colors = useColors();
  const { currentTheme, setTheme } = useTheme();
  const { allStrokeLinesVisible, toggleAllStrokeLines } = useStrokeLinesStore();

  // Handle reset to defaults
  const handleResetToDefaults = () => {
    setTheme('light');
    useStrokeLinesStore.getState().setAllStrokeLinesVisible(true);
  };

  return (
    <div 
      className="flex items-center justify-center p-8 h-full w-full"
      onClick={onClose}
    >
      {/* Backdrop */}
      <div className="absolute inset-0">
        <div 
          style={{ backgroundColor: colors['bg-overlay'] }}
          className="absolute inset-0 opacity-70" 
        />
      </div>

      {/* Modal content */}
      <div 
        className="relative z-10 w-[600px] max-h-[90vh] rounded-xl shadow-lg flex flex-col overflow-hidden border border-white/10"
        style={{ 
          backgroundColor: colors['bg-primary'],
          boxShadow: `0 10px 50px -12px ${colors['accent-primary']}30`
        }}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Close Button */}
        <ButtonNormal
          variant="tertiary"
          iconOnly
          size="small"
          className="absolute top-4 right-4"
          onClick={onClose}
          leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/x-close-icon.svg`}
        />

        {/* Modal header */}
        <div className="px-6 py-6 border-b"
          style={{ borderColor: colors['border-primary'] }}>
          <div>
            <h1 
              className="text-lg font-semibold"
              style={{ color: colors['text-primary'] }}
            >
              Appearance Settings
            </h1>
            <p 
              className="text-sm mt-1"
              style={{ color: colors['text-secondary'] }}
            >
              Customize the visual appearance of your workspace
            </p>
          </div>
        </div>

        {/* Content area with scrolling */}
        <div className="overflow-y-auto p-6 space-y-8 custom-scrollbar">
          {/* Interface Theme */}
          <div className="flex flex-col gap-1">
            <h3 className="text-md font-medium" style={{ color: colors['text-primary'] }}>
              Interface theme
            </h3>
            <p className="text-sm mb-4" style={{ color: colors['text-secondary'] }}>
              Customize your application theme
            </p>
            <div className="grid grid-cols-2 gap-4 max-w-md">
              {/* Light Theme Option */}
              <div 
                className="relative cursor-pointer group"
                onClick={() => setTheme('light')}
              >
                <div 
                  style={{ 
                    backgroundColor: colors['bg-primary'],
                    borderColor: currentTheme === 'light' ? colors['text-accent'] : colors['border-secondary']
                  }}
                  className="aspect-[4/3] rounded-xl border-2 overflow-hidden transition-all duration-200 hover:border-[#4761c4]"
                >
                  <div className="w-full h-full p-2">
                    <div className="w-full h-full rounded-lg bg-[#F9FAFB] overflow-hidden">
                      <div className="h-2 w-8 bg-[#D0D5DD] rounded-full m-2"></div>
                      <div className="space-y-1 px-2">
                        <div className="h-1 w-3/4 bg-[#D0D5DD] rounded-full"></div>
                        <div className="h-1 w-1/2 bg-[#D0D5DD] rounded-full"></div>
                        <div className="h-1 w-2/3 bg-[#D0D5DD] rounded-full"></div>
                      </div>
                    </div>
                  </div>
                </div>
                {currentTheme === 'light' && (
                  <div className="absolute -right-1 -top-1">
                    <div 
                      style={{ 
                        backgroundColor: colors['bg-primary'],
                        borderColor: colors['border-primary']
                      }}
                      className="w-6 h-6 rounded-full border-2 flex items-center justify-center"
                    >
                      <div className="w-4 h-4 rounded-full bg-[#4761c4] flex items-center justify-center">
                        <img
                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-white.svg`}
                          alt="Selected"
                          className="w-3 h-3"
                        />
                      </div>
                    </div>
                  </div>
                )}
                <p 
                  style={{ color: colors['text-primary'] }}
                  className="mt-2 text-sm font-medium text-center"
                >
                  Light
                </p>
              </div>

              {/* Dark Theme Option */}
              <div 
                className="relative cursor-pointer group"
                onClick={() => setTheme('dark')}
              >
                <div 
                  style={{ 
                    backgroundColor: colors['bg-primary'],
                    borderColor: currentTheme === 'dark' ? colors['text-accent'] : colors['border-secondary']
                  }}
                  className="aspect-[4/3] rounded-xl border-2 overflow-hidden transition-all duration-200 hover:border-[#4761c4]"
                >
                  <div className="w-full h-full p-2">
                    <div className="w-full h-full rounded-lg bg-[#1C1C1C] overflow-hidden">
                      <div className="h-2 w-8 bg-[#2C2C2C] rounded-full m-2"></div>
                      <div className="space-y-1 px-2">
                        <div className="h-1 w-3/4 bg-[#2C2C2C] rounded-full"></div>
                        <div className="h-1 w-1/2 bg-[#2C2C2C] rounded-full"></div>
                        <div className="h-1 w-2/3 bg-[#2C2C2C] rounded-full"></div>
                      </div>
                    </div>
                  </div>
                </div>
                {currentTheme === 'dark' && (
                  <div className="absolute -right-1 -top-1">
                    <div 
                      style={{ 
                        backgroundColor: colors['bg-primary'],
                        borderColor: colors['border-primary']
                      }}
                      className="w-6 h-6 rounded-full border-2 flex items-center justify-center"
                    >
                      <div className="w-4 h-4 rounded-full bg-[#4761c4] flex items-center justify-center">
                        <img
                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-white.svg`}
                          alt="Selected"
                          className="w-3 h-3"
                        />
                      </div>
                    </div>
                  </div>
                )}
                <p 
                  style={{ color: colors['text-primary'] }}
                  className="mt-2 text-sm font-medium text-center"
                >
                  Dark
                </p>
              </div>
            </div>
          </div>

          {/* Connecting lines */}
          <div className="flex flex-col gap-1">
            <h3 className="text-md font-medium" style={{ color: colors['text-primary'] }}>
              Connecting lines
            </h3>
            <p className="text-sm mb-4" style={{ color: colors['text-secondary'] }}>
              Toggle visibility of all stroke lines between blocks
            </p>
            <div className="flex items-center gap-3">
              <label className="relative inline-flex items-center cursor-pointer">
                <input
                  type="checkbox"
                  className="sr-only peer"
                  checked={allStrokeLinesVisible}
                  onChange={toggleAllStrokeLines}
                />
                <div className={`w-11 h-6 rounded-full peer ${allStrokeLinesVisible ? 'bg-pink-400' : 'bg-gray-300'} peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all`}></div>
              </label>
              <span className="text-sm" style={{ color: colors['text-secondary'] }}>
                {allStrokeLinesVisible ? 'Visible' : 'Hidden'}
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

export default SettingsModal;
</file>

<file path="app/[slug]/[flow]/edit/components/Sidebar.tsx">
import React, {
  useState,
  useRef,
  useMemo,
  useCallback,
  useEffect,
} from 'react';
import { createPortal } from 'react-dom';
import { useReactFlow } from '@xyflow/react';
import { Block, Path } from '../../types';
import { PathContainer } from './PathContainer';
import { usePathsStore } from '../store/pathsStore';
import { BlockEndType, BlockType } from '@/types/block';
import { useTheme, useColors } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';
import InputField from '@/app/components/InputFields';
import HelpCenterModal from '@/app/dashboard/components/HelpCenterModal';
import { DocumentationModal } from './DocumentationModal';
import SettingsModal from './SettingsModal';
import DynamicIcon from '@/utils/DynamicIcon';
import { User } from '@/types/user';
import { useEditModeStore } from '../store/editModeStore';
import Cookies from 'js-cookie';
import ChatContainer from '@/components/chat/ChatContainer';
import { CustomTooltip } from '@/app/components/CustomTooltip';

interface SidebarProps {
  workspaceId: string;
  workflowId: string;
}

// Add new interface for favorite blocks
interface FavoriteBlock {
  id: number;
  title: string;
  icon?: string;
  pathName: string;
}

// Update the useIsTextTruncated hook
const useIsTextTruncated = () => {
  const [isTruncated, setIsTruncated] = useState(false);
  const [showTooltip, setShowTooltip] = useState(false);
  const [tooltipPosition, setTooltipPosition] = useState({ x: 0, y: 0 });
  const textRef = useRef<HTMLSpanElement>(null);

  useEffect(() => {
    const checkTruncation = () => {
      if (textRef.current) {
        const { scrollWidth, clientWidth } = textRef.current;
        setIsTruncated(scrollWidth > clientWidth);
      }
    };

    checkTruncation();
    window.addEventListener('resize', checkTruncation);
    return () => window.removeEventListener('resize', checkTruncation);
  }, []);

  const handleMouseEnter = useCallback(() => {
    if (isTruncated && textRef.current) {
      const rect = textRef.current.getBoundingClientRect();
      setTooltipPosition({
        x: rect.right + 8,
        y: rect.top, // Align with the top of the element
      });
      setShowTooltip(true);
    }
  }, [isTruncated]);

  const handleMouseLeave = useCallback(() => {
    setShowTooltip(false);
  }, []);

  return {
    textRef,
    isTruncated,
    showTooltip,
    tooltipPosition,
    handleMouseEnter,
    handleMouseLeave,
  };
};

// Add this helper function at the top level of the file, after the imports
const formatDuration = (seconds?: number): string => {
  if (!seconds) return 'Not set';
  const days = Math.floor(seconds / 86400);
  const hours = Math.floor((seconds % 86400) / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);

  const parts = [];
  if (days > 0) parts.push(`${days}d`);
  if (hours > 0) parts.push(`${hours}h`);
  if (minutes > 0) parts.push(`${minutes}m`);

  return parts.length > 0 ? parts.join(' ') : '0m';
};

// Add this new component above Sidebar
interface SidebarBlockRowProps {
  block: any;
  isSelected: boolean;
  onClick: () => void;
  onMouseOver: (e: React.MouseEvent<HTMLDivElement>) => void;
  onMouseOut: (e: React.MouseEvent<HTMLDivElement>) => void;
  level: number;
  hasChildPaths: boolean;
  isPathCollapsed: boolean;
  colors: ReturnType<typeof useColors>;
  currentTheme: string;
  path: Path;
  togglePathVisibility: (pathId: number, event: React.MouseEvent) => void;
  formatDuration: (seconds?: number) => string;
}

const SidebarBlockRow: React.FC<SidebarBlockRowProps> = ({
  block,
  isSelected,
  onClick,
  onMouseOver,
  onMouseOut,
  level,
  hasChildPaths,
  isPathCollapsed,
  colors,
  currentTheme,
  path,
  togglePathVisibility,
  formatDuration,
}) => {
  const {
    textRef,
    isTruncated,
    showTooltip,
    tooltipPosition,
    handleMouseEnter,
    handleMouseLeave,
  } = useIsTextTruncated();

  return (
    <div
      key={block.id}
      className="w-full cursor-pointer transition-all duration-200 hover:scale-[1.02]"
      style={{
        backgroundColor: isSelected
          ? colors['brand-utility-600']
          : 'transparent',
      }}
      onClick={onClick}
      onMouseOver={onMouseOver}
      onMouseOut={onMouseOut}
    >
      <div
        className="flex items-center gap-2 h-8 w-full relative"
        style={{
          paddingLeft: level > 0 ? '40px' : '16px',
          paddingRight: '16px',
        }}
      >
        {level > 0 && !hasChildPaths && (
          <>
            <div
              className="absolute left-6 top-0 bottom-0 w-px"
              style={{
                backgroundColor: colors['border-secondary'],
              }}
            />
            <div
              className="absolute left-6 w-4 h-px"
              style={{
                backgroundColor: colors['border-secondary'],
                top: '50%',
              }}
            />
          </>
        )}
        {block.type === 'STEP' && (
          <>
            {hasChildPaths && (
              <div
                className="cursor-pointer"
                onClick={(e: React.MouseEvent) => {
                  e.stopPropagation();
                  togglePathVisibility(path.id, e);
                }}
              >
                <DynamicIcon
                  url={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${
                    isPathCollapsed ? 'chevron-right' : 'chevron-down'
                  }.svg`}
                  size={16}
                  variant="tertiary"
                  className="flex-shrink-0"
                />
              </div>
            )}
            <DynamicIcon
              url={
                block.icon
                  ? block.icon.startsWith('https://cdn.brandfetch.io/')
                    ? block.icon
                    : block.signedIconUrl
                  : `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/container.svg`
              }
              size={20}
              color="inherit"
              className="flex-shrink-0"
            />
          </>
        )}
        {block.type === 'DELAY' && (
          <DynamicIcon
            url={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${
              block.delay_type === 'WAIT_FOR_EVENT'
                ? 'calendar-clock-1.svg'
                : 'clock-stopwatch-1.svg'
            }`}
            size={20}
            color="inherit"
            className="flex-shrink-0"
          />
        )}
        <span
          ref={textRef}
          className="text-sm whitespace-nowrap overflow-hidden text-ellipsis font-medium flex-1"
          onMouseEnter={handleMouseEnter}
          onMouseLeave={handleMouseLeave}
          style={{
            color: isSelected
              ? currentTheme === 'light'
                ? colors['text-primary']
                : colors['text-white']
              : colors['text-primary'],
          }}
        >
          {block.type === 'DELAY'
            ? block.delay_type === 'WAIT_FOR_EVENT'
              ? `Wait for Event: ${block.delay_event || 'Not set'}`
              : `Duration Delay: ${formatDuration(block.delay_seconds || undefined)}`
            : block.title || `Block ${block.id}`}
        </span>
        {isTruncated && (
          <div
            style={{
              position: 'fixed',
              left: `${tooltipPosition.x}px`,
              top: `${tooltipPosition.y}px`,
              transform: 'none',
            }}
            className="pointer-events-none"
          >
            <CustomTooltip
              text={block.title || `Block ${block.id}`}
              show={showTooltip}
            />
          </div>
        )}
      </div>
    </div>
  );
};

export function Sidebar({ workspaceId, workflowId }: SidebarProps) {
  const { currentTheme } = useTheme();
  const colors = useColors();
  const { selectedNodeId, setEditMode } = useEditModeStore();
  const originalPaths = usePathsStore((state) => state.paths);
  const paths = useMemo(
    () =>
      originalPaths?.map((path) => ({
        ...path,
        blocks: path.blocks.map((block) => ({
          ...block,
          child_paths: block.child_paths
            ? block.child_paths.map((cp) => ({
                ...cp,
                path: { ...cp.path },
                block: { ...cp.block },
              }))
            : [],
          path: { ...path },
        })),
        parent_blocks:
          path.parent_blocks?.map((pb) => ({
            ...pb,
            block: { ...pb.block },
          })) ?? [],
      })) ?? [], // Return empty array if originalPaths is undefined
    [originalPaths]
  );
  const getLastOccurrenceIds = useMemo(() => {
    const lastOccurrenceIds: number[] = [];

    paths.forEach((path) => {
      // Check if any parent block is of type MERGE
      const hasMergeParent = path.parent_blocks.some((pb) =>
        paths.find((p) =>
          p.blocks.find((b) => b.id === pb.block_id && b.type === 'MERGE')
        )
      );

      if (hasMergeParent) {
        // Get the last parent block ID
        const lastParentBlockId =
          path.parent_blocks[path.parent_blocks.length - 1]?.block_id;
        if (lastParentBlockId) {
          lastOccurrenceIds.push(lastParentBlockId);
        }
      }
    });

    return lastOccurrenceIds;
  }, [paths]);
  const [isSidebarVisible, setIsSidebarVisible] = useState<boolean>(false);
  const [searchFilter, setSearchFilter] = useState<string>('');
  const [collapsedPaths, setCollapsedPaths] = useState<Set<number>>(new Set());
  const [sidebarWidth, setSidebarWidth] = useState<number>(300);
  const [isResizing, setIsResizing] = useState<boolean>(false);
  const [showHelpModal, setShowHelpModal] = useState<boolean>(false);
  const [showDocModal, setShowDocModal] = useState<boolean>(false);
  const [isSettingsModalOpen, setIsSettingsModalOpen] =
    useState<boolean>(false);
  const [showDocNotification, setShowDocNotification] = useState<boolean>(
    !Cookies.get('hasSeenDocumentation')
  );
  const [showStars, setShowStars] = useState<boolean>(false);
  const [favoriteBlocks, setFavoriteBlocks] = useState<FavoriteBlock[]>([]);
  const [showMenu, setShowMenu] = useState(false);
  const [showHistoryMenu, setShowHistoryMenu] = useState(false);
  const menuRef = useRef<HTMLDivElement>(null);
  const historyMenuRef = useRef<HTMLDivElement>(null);
  const menuButtonRef = useRef<HTMLDivElement>(null);
  const historyButtonRef = useRef<HTMLDivElement>(null);
  const sidebarRef = useRef<HTMLDivElement>(null);
  const { getNodes, setViewport } = useReactFlow();

  // Static URLs for the icons
  const navigationIconUrl = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/navigation-icon.svg`;
  const supportIconUrl = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/support-icon.svg`;
  const settingsIconUrl = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/settings-icon.svg`;
  const searchIconUrl = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/search-icon.svg`;
  const bookIconUrl = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/book-open-01.svg`;
  const starIconUrl = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/stars-01.svg`;

  // Add new handlers for menu toggling
  const handleHistoryMenuClick = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (showHistoryMenu) {
      setShowHistoryMenu(false);
    } else {
      setShowMenu(false);
      setShowHistoryMenu(true);
    }
  };

  const handleDotsMenuClick = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (showMenu) {
      setShowMenu(false);
    } else {
      setShowHistoryMenu(false);
      setShowMenu(true);
    }
  };

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      // Check if click is outside both the menu and its button
      if (
        menuRef.current &&
        !menuRef.current.contains(event.target as Node) &&
        menuButtonRef.current &&
        !menuButtonRef.current.contains(event.target as Node)
      ) {
        setShowMenu(false);
      }
      if (
        historyMenuRef.current &&
        !historyMenuRef.current.contains(event.target as Node) &&
        historyButtonRef.current &&
        !historyButtonRef.current.contains(event.target as Node)
      ) {
        setShowHistoryMenu(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const toggleSidebar = () => {
    setIsSidebarVisible((prev) => !prev);
    // Reset stars view when closing sidebar
    if (showStars) {
      setShowStars(false);
    }
  };

  const toggleHelpModal = () => {
    setShowHelpModal((prevState) => !prevState);
  };

  const toggleDocModal = () => {
    setShowDocModal((prevState) => !prevState);
  };

  const toggleSettingsModal = () => {
    setIsSettingsModalOpen((prevState) => !prevState);
  };

  // Toggle stars view
  const toggleStarsView = () => {
    setShowStars((prev) => !prev);
    // Ensure sidebar is visible when showing stars
    if (!isSidebarVisible) {
      setIsSidebarVisible(true);
    }
  };

  // Handle tab switch
  const handleTabSwitch = (tab: 'navigation' | 'stars') => {
    if (tab === 'navigation' && isSidebarVisible && !showStars) {
      // If clicking navigation tab while it's already active, close the sidebar
      setIsSidebarVisible(false);
    } else if (tab === 'stars' && isSidebarVisible && showStars) {
      // If clicking stars tab while it's already active, close the sidebar
      setIsSidebarVisible(false);
    } else {
      if (tab === 'navigation') {
        setShowStars(false);
      } else {
        setShowStars(true);
      }
      // Always ensure sidebar is visible when switching tabs
      if (!isSidebarVisible) {
        setIsSidebarVisible(true);
      }
    }
  };

  // Toggle favorite status for a block
  const toggleFavorite = (block: any, pathName: string) => {
    setFavoriteBlocks((prev) => {
      const exists = prev.some((fb) => fb.id === block.id);
      if (exists) {
        return prev.filter((fb) => fb.id !== block.id);
      } else {
        return [
          ...prev,
          {
            id: block.id,
            title: block.title || `Block ${block.id}`,
            icon: block.icon,
            pathName,
          },
        ];
      }
    });
  };

  // Check if a block is favorited
  const isFavorite = (blockId: number) => {
    return favoriteBlocks.some((fb) => fb.id === blockId);
  };

  // Render favorites content
  const renderFavoritesContent = () => {
    return (
      <div
        className="w-full h-full flex flex-col"
        style={{ backgroundColor: colors['bg-primary'] }}
      >
        {/* Header with action buttons */}
        <div
          className="sticky top-0 z-10 flex justify-end items-center gap-2 p-2 border-b"
          style={{ borderColor: colors['border-primary'] }}
        >
          <ButtonNormal
            variant="tertiary"
            iconOnly
            size="small"
            leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/plus-icon.svg`}
            onClick={() => {}}
            className="opacity-50 hover:opacity-100 transition-opacity"
          />
          <div className="relative">
            <div ref={historyButtonRef}>
              <ButtonNormal
                variant="tertiary"
                iconOnly
                size="small"
                leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/clock-rewind.svg`}
                onClick={handleHistoryMenuClick}
                className="opacity-50 hover:opacity-100 transition-opacity !w-8 !h-8 !p-0 flex items-center justify-center"
              />
            </div>
            {showHistoryMenu && (
              <div
                ref={historyMenuRef}
                className="absolute right-0 w-[192px] rounded-md border shadow-lg z-50"
                style={{
                  backgroundColor: colors['bg-primary'],
                  borderColor: colors['border-primary'],
                }}
              >
                <div
                  className="p-1.5 border-b"
                  style={{ borderColor: colors['border-primary'] }}
                >
                  <input
                    type="text"
                    placeholder="Search..."
                    className="w-full bg-transparent text-xs px-1.5 py-1"
                    style={{ color: colors['text-secondary'] }}
                  />
                </div>
                <div className="p-1.5 flex flex-col gap-1">
                  <div
                    className="group flex items-center justify-between w-full px-1.5 py-1.5 rounded text-xs transition-colors"
                    style={{ color: colors['text-secondary'] }}
                    onMouseEnter={(e) =>
                      (e.currentTarget.style.backgroundColor =
                        colors['bg-secondary'])
                    }
                    onMouseLeave={(e) =>
                      (e.currentTarget.style.backgroundColor = 'transparent')
                    }
                  >
                    <div className="flex-1 min-w-0">
                      <span className="block truncate">Create new paths</span>
                    </div>
                    <div className="hidden group-hover:flex items-center gap-2 flex-shrink-0 ml-2">
                      <ButtonNormal
                        variant="tertiary"
                        iconOnly
                        size="small"
                        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                        onClick={() => {}}
                        className="!bg-transparent hover:!bg-opacity-10 !w-3 !h-3 !p-0 flex items-center justify-center"
                      />
                      <ButtonNormal
                        variant="tertiary"
                        iconOnly
                        size="small"
                        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`}
                        onClick={() => {}}
                        className="!bg-transparent hover:!bg-opacity-10 !w-3 !h-3 !p-0 flex items-center justify-center"
                      />
                    </div>
                  </div>
                  <div
                    className="group flex items-center w-full px-1.5 py-1.5 rounded text-xs transition-colors"
                    style={{ color: colors['text-secondary'] }}
                    onMouseEnter={(e) =>
                      (e.currentTarget.style.backgroundColor =
                        colors['bg-secondary'])
                    }
                    onMouseLeave={(e) =>
                      (e.currentTarget.style.backgroundColor = 'transparent')
                    }
                  >
                    <div className="flex-1 min-w-0">
                      <span className="block truncate">
                        Build a specific path for HR
                      </span>
                    </div>
                    <div className="hidden group-hover:flex items-center gap-2 flex-shrink-0 ml-2">
                      <ButtonNormal
                        variant="tertiary"
                        iconOnly
                        size="small"
                        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                        onClick={() => {}}
                        className="!bg-transparent hover:!bg-opacity-10 !w-3 !h-3 !p-0 flex items-center justify-center"
                      />
                      <ButtonNormal
                        variant="tertiary"
                        iconOnly
                        size="small"
                        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`}
                        onClick={() => {}}
                        className="!bg-transparent hover:!bg-opacity-10 !w-3 !h-3 !p-0 flex items-center justify-center"
                      />
                    </div>
                  </div>
                  <div
                    className="group flex items-center justify-between w-full px-1.5 py-1.5 rounded text-xs transition-colors"
                    style={{ color: colors['text-secondary'] }}
                    onMouseEnter={(e) =>
                      (e.currentTarget.style.backgroundColor =
                        colors['bg-secondary'])
                    }
                    onMouseLeave={(e) =>
                      (e.currentTarget.style.backgroundColor = 'transparent')
                    }
                  >
                    <span>Optimize this process</span>
                    <div className="hidden group-hover:flex items-center gap-2">
                      <ButtonNormal
                        variant="tertiary"
                        iconOnly
                        size="small"
                        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                        onClick={() => {}}
                        className="!bg-transparent hover:!bg-opacity-10 !w-3 !h-3 !p-0 flex items-center justify-center"
                      />
                      <ButtonNormal
                        variant="tertiary"
                        iconOnly
                        size="small"
                        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`}
                        onClick={() => {}}
                        className="!bg-transparent hover:!bg-opacity-10 !w-3 !h-3 !p-0 flex items-center justify-center"
                      />
                    </div>
                  </div>
                  <div
                    className="group flex items-center justify-between w-full px-1.5 py-1.5 rounded text-xs transition-colors"
                    style={{ color: colors['text-secondary'] }}
                    onMouseEnter={(e) =>
                      (e.currentTarget.style.backgroundColor =
                        colors['bg-secondary'])
                    }
                    onMouseLeave={(e) =>
                      (e.currentTarget.style.backgroundColor = 'transparent')
                    }
                  >
                    <span>Add a delay between</span>
                    <div className="hidden group-hover:flex items-center gap-2">
                      <ButtonNormal
                        variant="tertiary"
                        iconOnly
                        size="small"
                        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                        onClick={() => {}}
                        className="!bg-transparent hover:!bg-opacity-10 !w-3 !h-3 !p-0 flex items-center justify-center"
                      />
                      <ButtonNormal
                        variant="tertiary"
                        iconOnly
                        size="small"
                        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`}
                        onClick={() => {}}
                        className="!bg-transparent hover:!bg-opacity-10 !w-3 !h-3 !p-0 flex items-center justify-center"
                      />
                    </div>
                  </div>
                  <div
                    className="group flex items-center justify-between w-full px-1.5 py-1.5 rounded text-xs transition-colors"
                    style={{ color: colors['text-secondary'] }}
                    onMouseEnter={(e) =>
                      (e.currentTarget.style.backgroundColor =
                        colors['bg-secondary'])
                    }
                    onMouseLeave={(e) =>
                      (e.currentTarget.style.backgroundColor = 'transparent')
                    }
                  >
                    <div className="flex-1 min-w-0">
                      <span className="block truncate">Create new paths</span>
                    </div>
                    <div className="hidden group-hover:flex items-center gap-2 flex-shrink-0 ml-2">
                      <ButtonNormal
                        variant="tertiary"
                        iconOnly
                        size="small"
                        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                        onClick={() => {}}
                        className="!bg-transparent hover:!bg-opacity-10 !w-3 !h-3 !p-0 flex items-center justify-center"
                      />
                      <ButtonNormal
                        variant="tertiary"
                        iconOnly
                        size="small"
                        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`}
                        onClick={() => {}}
                        className="!bg-transparent hover:!bg-opacity-10 !w-3 !h-3 !p-0 flex items-center justify-center"
                      />
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
          <div className="relative">
            <div ref={menuButtonRef}>
              <ButtonNormal
                variant="tertiary"
                iconOnly
                size="small"
                leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dots-horizontal.svg`}
                onClick={handleDotsMenuClick}
                className="menu-trigger opacity-50 hover:opacity-100 transition-opacity !w-8 !h-8 !p-0 flex items-center justify-center"
              />
            </div>
            {showMenu && (
              <div
                ref={menuRef}
                className="absolute right-0 w-[180px] rounded-md border shadow-lg z-50"
                style={{
                  backgroundColor: colors['bg-primary'],
                  borderColor: colors['border-primary'],
                }}
              >
                <div className="p-1.5 flex flex-col gap-1">
                  <button
                    className="flex items-center w-full px-1.5 py-1.5 rounded text-xs transition-colors"
                    style={{ color: colors['text-secondary'] }}
                    onMouseEnter={(e) =>
                      (e.currentTarget.style.backgroundColor =
                        colors['bg-secondary'])
                    }
                    onMouseLeave={(e) =>
                      (e.currentTarget.style.backgroundColor = 'transparent')
                    }
                    onClick={() => setShowMenu(false)}
                  >
                    Close all chats
                  </button>
                  <button
                    className="flex items-center w-full px-1.5 py-1.5 rounded text-xs transition-colors"
                    style={{ color: colors['text-secondary'] }}
                    onMouseEnter={(e) =>
                      (e.currentTarget.style.backgroundColor =
                        colors['bg-secondary'])
                    }
                    onMouseLeave={(e) =>
                      (e.currentTarget.style.backgroundColor = 'transparent')
                    }
                    onClick={() => setShowMenu(false)}
                  >
                    Report feedback
                  </button>
                  <button
                    className="flex items-center w-full px-1.5 py-1.5 rounded text-xs transition-colors"
                    style={{ color: colors['text-secondary'] }}
                    onMouseEnter={(e) =>
                      (e.currentTarget.style.backgroundColor =
                        colors['bg-secondary'])
                    }
                    onMouseLeave={(e) =>
                      (e.currentTarget.style.backgroundColor = 'transparent')
                    }
                    onClick={() => setShowMenu(false)}
                  >
                    Chats settings
                  </button>
                </div>
              </div>
            )}
          </div>
          <ButtonNormal
            variant="tertiary"
            iconOnly
            size="small"
            leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/x-close-icon.svg`}
            onClick={() => {
              setShowStars(false);
              setIsSidebarVisible(false);
            }}
            className="opacity-50 hover:opacity-100 transition-opacity"
          />
        </div>

        {/* Show ChatContainer directly */}
        <div className="flex-1 overflow-hidden">
          <ChatContainer />
        </div>
      </div>
    );
  };

  useEffect(() => {
    // Additional initialization logic if needed
  }, []);

  const handleDocModalOpen = () => {
    setShowDocModal(true);
    setShowDocNotification(false);

    // Set a session cookie (expires when browser is closed)
    Cookies.set('hasSeenDocumentation', 'true');
  };

  // Find the main path from filtered paths
  const mainPath = paths.find((path) => path.parent_blocks.length === 0);
  // Function to handle block click and zoom to node
  const handleBlockClick = useCallback(
    (blockId: number) => {
      // Set the selected node ID in the store
      setEditMode(true, blockId.toString());

      // Find the node and zoom to it
      const nodeId = `block-${blockId}`;
      const node = getNodes().find((n) => n.id === nodeId);
      if (node) {
        setViewport(
          {
            x: -(node.position.x - window.innerWidth / 2 + 400),
            y: -(node.position.y - window.innerHeight / 2 + 200),
            zoom: 1,
          },
          { duration: 800 }
        );
      }
    },
    [getNodes, setViewport, setEditMode]
  );

  const togglePathVisibility = (pathId: number, event: React.MouseEvent) => {
    event.stopPropagation(); // Prevent block click when clicking the toggle
    setCollapsedPaths((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(pathId)) {
        newSet.delete(pathId);
      } else {
        newSet.add(pathId);
      }
      return newSet;
    });
  };

  // Helper function to check if a block matches the search filter
  const blockMatchesSearch = (block: any) => {
    if (!searchFilter) return true;

    const searchTerm = searchFilter.toLowerCase();
    const blockTitle = (block.title || `Block ${block.id}`).toLowerCase();

    return blockTitle.includes(searchTerm);
  };

  // Helper function to check if a path or its children contain matching blocks
  const pathContainsMatchingBlocks = (path: Path): boolean => {
    if (!searchFilter) return true;

    // Check if any direct blocks match
    const hasMatchingBlocks = path.blocks.some(blockMatchesSearch);
    if (hasMatchingBlocks) return true;

    // Check child paths recursively
    const childPaths = path.blocks
      .filter((block) => block.type === 'MERGE' || block.type === 'PATH')
      .flatMap((block) => block.child_paths || [])
      .map((childPath) => paths.find((p) => p.id === childPath.path.id))
      .filter((p): p is Path => p !== undefined);

    return childPaths.some(pathContainsMatchingBlocks);
  };

  // Helper function to check if a block is selected
  const isBlockSelected = useCallback(
    (blockId: number) => {
      // Handle both formats: with and without 'block-' prefix
      return (
        selectedNodeId === `block-${blockId}` ||
        selectedNodeId === blockId.toString()
      );
    },
    [selectedNodeId]
  );

  const renderPathContent = (path: Path, level: number = 0) => {
    const isPathCollapsed = collapsedPaths.has(path.id);

    // Only render the path if it contains matching blocks or if there's no search filter
    if (!pathContainsMatchingBlocks(path)) {
      return null;
    }

    return (
      <div key={path.id} className="w-full">
        {/* BEGIN blocks */}
        {path.blocks
          .filter((block) => block.type === 'BEGIN')
          .map((block) => {
            const {
              textRef,
              isTruncated,
              showTooltip,
              tooltipPosition,
              handleMouseEnter,
              handleMouseLeave,
            } = useIsTextTruncated();
            return (
              <div
                key={block.id}
                className="w-full cursor-pointer transition-all duration-200 hover:scale-[1.02]"
                style={{
                  backgroundColor: isBlockSelected(block.id)
                    ? colors['brand-utility-600']
                    : 'transparent',
                }}
                onClick={() => handleBlockClick(block.id)}
                onMouseOver={(e) => {
                  if (!isBlockSelected(block.id)) {
                    e.currentTarget.style.backgroundColor =
                      colors['bg-secondary'];
                  }
                }}
                onMouseOut={(e) => {
                  if (!isBlockSelected(block.id)) {
                    e.currentTarget.style.backgroundColor = 'transparent';
                  }
                }}
              >
                <div
                  className="flex items-center gap-2 h-8 px-4 w-full"
                  onClick={(e) => {
                    e.stopPropagation();
                    togglePathVisibility(path.id, e);
                  }}
                >
                  <DynamicIcon
                    url={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${
                      isPathCollapsed ? 'chevron-right' : 'chevron-down'
                    }.svg`}
                    size={16}
                    variant="tertiary"
                    className="flex-shrink-0"
                  />
                  <DynamicIcon
                    url={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/git-branch-icon.svg`}
                    size={20}
                    variant="tertiary"
                    className="flex-shrink-0"
                  />
                  <span
                    ref={textRef}
                    className="text-sm whitespace-nowrap overflow-hidden text-ellipsis font-medium flex-1"
                    onMouseEnter={handleMouseEnter}
                    onMouseLeave={handleMouseLeave}
                    style={{
                      color: isBlockSelected(block.id)
                        ? colors['text-primary']
                        : colors['text-primary'],
                    }}
                  >
                    {path.name}
                  </span>
                  {isTruncated && (
                    <div
                      style={{
                        position: 'fixed',
                        left: `${tooltipPosition.x}px`,
                        top: `${tooltipPosition.y}px`,
                        transform: 'none',
                      }}
                      className="pointer-events-none"
                    >
                      <CustomTooltip text={path.name} show={showTooltip} />
                    </div>
                  )}
                </div>
              </div>
            );
          })}

        {/* Other blocks */}
        {!isPathCollapsed && (
          <div className="w-full">
            <div className="relative w-full">
              {/* Vertical line for the entire level */}
              {level > 0 && (
                <div
                  className="absolute left-6 top-0 bottom-0 w-px"
                  style={{ backgroundColor: colors['border-secondary'] }}
                />
              )}

              {path.blocks
                .filter(
                  (block) =>
                    block.type !== 'LAST' &&
                    block.type !== 'BEGIN' &&
                    blockMatchesSearch(block)
                )
                .map((block, index) => {
                  if (block.type === 'MERGE' || block.type === 'PATH') {
                    return block.child_paths?.map((childPathConnection) => {
                      const childPath = paths.find(
                        (p) => p.id === childPathConnection.path.id
                      );

                      if (childPath && pathContainsMatchingBlocks(childPath)) {
                        if (
                          block.type === 'MERGE' &&
                          !getLastOccurrenceIds.includes(block.id)
                        ) {
                          return null;
                        }
                        return (
                          <PathContainer
                            key={`${childPath.id}-${block.id}`}
                            path={childPath}
                            level={
                              block.type === 'MERGE'
                                ? Math.max(level - 2, -1)
                                : Math.max(level, 0) + 1
                            }
                            renderContent={renderPathContent}
                          />
                        );
                      }
                      return null;
                    });
                  }

                  const hasChildPaths =
                    block.child_paths && block.child_paths.length > 0;

                  return (
                    <SidebarBlockRow
                      key={block.id}
                      block={block}
                      isSelected={isBlockSelected(block.id)}
                      onClick={() => handleBlockClick(block.id)}
                      onMouseOver={(e) => {
                        if (!isBlockSelected(block.id)) {
                          e.currentTarget.style.backgroundColor =
                            colors['bg-secondary'];
                        }
                      }}
                      onMouseOut={(e) => {
                        if (!isBlockSelected(block.id)) {
                          e.currentTarget.style.backgroundColor = 'transparent';
                        }
                      }}
                      level={level}
                      hasChildPaths={!!hasChildPaths}
                      isPathCollapsed={isPathCollapsed}
                      colors={colors}
                      currentTheme={currentTheme}
                      path={path}
                      togglePathVisibility={togglePathVisibility}
                      formatDuration={formatDuration}
                    />
                  );
                })}
            </div>
          </div>
        )}
      </div>
    );
  };

  // Enhanced resize functionality similar to dashboard sidebar
  const startResizing = useCallback(
    (mouseDownEvent: React.MouseEvent) => {
      mouseDownEvent.preventDefault();
      setIsResizing(true);
      document.body.style.cursor = 'col-resize';

      const startWidth = sidebarWidth;
      const startX = mouseDownEvent.clientX;

      const handleMouseMove = (mouseMoveEvent: MouseEvent) => {
        const newWidth = startWidth + mouseMoveEvent.clientX - startX;
        setSidebarWidth(Math.max(250, Math.min(400, newWidth))); // Min 250px, max 400px
      };

      const handleMouseUp = () => {
        setIsResizing(false);
        document.body.style.cursor = '';
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };

      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    },
    [sidebarWidth, setIsResizing]
  );

  // Helper function to generate button IDs
  const generateButtonId = (name: string) =>
    `sidebar-button-${name}-${Math.random().toString(36).substring(2, 9)}`;

  // Button IDs for hover styling
  const navButtonId = generateButtonId('nav');
  const historyButtonId = generateButtonId('history');
  const supportButtonId = generateButtonId('support');
  const settingsButtonId = generateButtonId('settings');

  // Hover styles
  const hoverStyles = `
    ${navButtonId}:hover, ${historyButtonId}:hover, ${supportButtonId}:hover, ${settingsButtonId}:hover {
      background-color: ${colors['bg-secondary']} !important;
    }
  `;

  // Hover styles for resize handle
  const resizeHandleStyles = `
    .resize-handle:hover {
      background-color: ${colors['border-secondary']} !important;
      opacity: 0.5 !important;
    }
    .resize-handle.resizing {
      background-color: ${colors['accent-primary']} !important;
      opacity: 1 !important;
      box-shadow: 0 0 8px 1px ${colors['accent-primary']}80;
      transition: all 0.15s ease;
    }
  `;

  // Fix linter error by creating a mock user object that matches User type
  const mockUser: Partial<User> = {
    id: parseInt(workspaceId),
    auth_id: workspaceId,
    email: '',
    first_name: '',
    last_name: '',
    full_name: '',
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  };

  return (
    <>
      <style>{hoverStyles}</style>
      <style>{resizeHandleStyles}</style>
      {/* Custom styles for animation */}
      <style>{`
        @keyframes pulse {
          0% {
            transform: scale(0.95);
            box-shadow: 0 0 0 0 rgba(78, 107, 215, 0.7);
          }
          
          70% {
            transform: scale(1);
            box-shadow: 0 0 0 10px rgba(78, 107, 215, 0);
          }
          
          100% {
            transform: scale(0.95);
            box-shadow: 0 0 0 0 rgba(78, 107, 215, 0);
          }
        }
        
        .pulse {
          animation: pulse 2s infinite;
        }
      `}</style>
      <div
        className="fixed z-10 flex top-[56px] left-0 h-[calc(100vh-56px)]"
        style={{ backgroundColor: colors['bg-primary'] }}
      >
        {/* Sidebar with icons */}
        <div
          className="w-fit px-2 h-full flex flex-col justify-between border-r relative"
          style={{
            backgroundColor: colors['bg-primary'],
            borderColor: colors['border-primary'],
          }}
        >
          <div className="flex flex-col pt-4 items-center gap-2">
            <ButtonNormal
              variant={
                isSidebarVisible && !showStars ? 'secondary' : 'tertiary'
              }
              iconOnly
              size="medium"
              leadingIcon={navigationIconUrl}
              onClick={() => handleTabSwitch('navigation')}
              className="transition-all duration-200"
              style={{
                backgroundColor:
                  isSidebarVisible && !showStars
                    ? colors['bg-secondary']
                    : 'transparent',
              }}
            />
            <ButtonNormal
              variant={showStars ? 'secondary' : 'tertiary'}
              iconOnly
              size="medium"
              leadingIcon={starIconUrl}
              onClick={() => handleTabSwitch('stars')}
              className="transition-all duration-200 hidden"
              style={{
                backgroundColor: showStars
                  ? colors['bg-secondary']
                  : 'transparent',
              }}
            />
          </div>
          <div className="flex flex-col pb-6 items-center gap-2">
            {/* Button with notification */}
            <div className="relative">
              <ButtonNormal
                variant="tertiary"
                iconOnly
                size="medium"
                leadingIcon={bookIconUrl}
                onClick={handleDocModalOpen}
              />

              {showDocNotification && (
                <div
                  className="pulse"
                  style={{
                    position: 'absolute',
                    top: '-5px',
                    right: '-5px',
                    width: '12px',
                    height: '12px',
                    backgroundColor: '#4e6bd7',
                    borderRadius: '50%',
                    boxShadow: '0 0 10px 2px #4e6bd7',
                    zIndex: 9999,
                  }}
                />
              )}
            </div>
            <ButtonNormal
              variant="tertiary"
              iconOnly
              size="medium"
              leadingIcon={supportIconUrl}
              onClick={toggleHelpModal}
            />
            <ButtonNormal
              variant="tertiary"
              iconOnly
              size="medium"
              leadingIcon={settingsIconUrl}
              onClick={toggleSettingsModal}
            />
          </div>
        </div>

        {/* Main Sidebar Content */}
        {isSidebarVisible && (
          <div
            ref={sidebarRef}
            className="flex-1 flex flex-col relative border-r transform transition-all duration-300 ease-out animate-in slide-in-from-left-0"
            style={{
              width: sidebarWidth,
              minWidth: '250px',
              backgroundColor: colors['bg-primary'],
              borderColor: colors['border-primary'],
            }}
          >
            {/* Header Section - Only show when not in stars view */}
            {!showStars && (
              <div
                className="sticky top-0 z-10 px-4 pt-4 pb-4 border-b"
                style={{
                  backgroundColor: colors['bg-primary'],
                  borderColor: colors['border-primary'],
                }}
              >
                <div
                  className="text-base font-semibold mb-4"
                  style={{ color: colors['text-primary'] }}
                >
                  Navigation
                </div>
                {/* Search bar */}
                <div className="relative">
                  <InputField
                    type="icon-leading"
                    placeholder="Search"
                    value={searchFilter}
                    onChange={(value) => setSearchFilter(value)}
                    iconUrl={searchIconUrl}
                    size="small"
                    mode={currentTheme === 'light' ? 'light' : 'dark'}
                  />
                </div>
              </div>
            )}

            {/* Content Area with both x and y scrolling */}
            <div
              className="flex-1 overflow-auto"
              style={{ backgroundColor: colors['bg-primary'] }}
            >
              {showStars
                ? renderFavoritesContent()
                : mainPath && (
                    <PathContainer
                      key={mainPath.id}
                      path={mainPath}
                      level={0}
                      renderContent={renderPathContent}
                    />
                  )}
            </div>

            {/* Resize Handle */}
            <div
              style={{
                backgroundColor: isResizing
                  ? colors['accent-primary']
                  : 'transparent',
              }}
              className={`absolute right-0 top-0 bottom-0 w-[3px] cursor-col-resize resize-handle transition-all ${isResizing ? 'resizing' : ''}`}
              onMouseDown={startResizing}
            />
          </div>
        )}
      </div>

      {/* Help Center Modal */}
      {showHelpModal && createPortal(
        <div className="fixed inset-0 z-[10000]">
          <HelpCenterModal onClose={toggleHelpModal} user={mockUser as User} />
        </div>,
        document.body
      )}

      {/* Documentation Modal */}
      {showDocModal && createPortal(
        <div className="fixed inset-0 z-[10000]">
          <DocumentationModal onClose={toggleDocModal} />
        </div>,
        document.body
      )}

      {/* Settings Modal */}
      {isSettingsModalOpen && createPortal(
        <div className="fixed inset-0 z-[10000]">
          <SettingsModal onClose={toggleSettingsModal} />
        </div>,
        document.body
      )}
    </>
  );
}
</file>

<file path="app/[slug]/[flow]/edit/components/TextEditor.tsx">
import React, { useMemo } from 'react';

interface TextEditorProps {
  value: string;
  onChange: (value: string) => void;
  onBlur?: () => void;
  onKeyDown?: (e: React.KeyboardEvent) => void;
  readOnly?: boolean;
  className?: string;
  placeholder?: string;
  textColor?: string;
}

// Regular expression to match URLs
const URL_REGEX = /(https?:\/\/[^\s]+)/g;

export default function TextEditor({
  value,
  onChange,
  onBlur,
  onKeyDown,
  readOnly = false,
  className = '',
  placeholder = '',
  textColor,
}: TextEditorProps) {
  // Parse text into segments with links
  const segments = useMemo(() => {
    const parts = [];
    let lastIndex = 0;
    let match;
    
    while ((match = URL_REGEX.exec(value)) !== null) {
      // Add text before the link
      if (match.index > lastIndex) {
        parts.push({
          type: 'text',
          content: value.slice(lastIndex, match.index)
        });
      }
      
      // Add the link
      parts.push({
        type: 'link',
        content: match[0]
      });
      
      lastIndex = match.index + match[0].length;
    }
    
    // Add remaining text after last link
    if (lastIndex < value.length) {
      parts.push({
        type: 'text',
        content: value.slice(lastIndex)
      });
    }
    
    return parts.length > 0 ? parts : [{ type: 'text', content: value }];
  }, [value]);

  return (
    <div className={className}>
      {readOnly ? (
        <div 
          className="w-full h-full min-h-[80px] overflow-auto whitespace-pre-line"
          style={{ color: textColor }}
        >
          {segments.map((segment, index) => (
            segment.type === 'link' ? (
              <a
                key={index}
                href={segment.content}
                target="_blank"
                rel="noopener noreferrer"
                className="text-blue-500 hover:underline"
                onClick={(e) => {
                  e.stopPropagation();
                  e.preventDefault();
                  window.open(segment.content, '_blank', 'noopener,noreferrer');
                }}
              >
                {segment.content}
              </a>
            ) : (
              <span key={index}>{segment.content}</span>
            )
          ))}
        </div>
      ) : (
        <textarea
          value={value}
          onChange={(e) => onChange(e.target.value)}
          onBlur={onBlur}
          onKeyDown={onKeyDown}
          readOnly={readOnly}
          placeholder={placeholder}
          className="w-full h-full min-h-[80px] bg-transparent resize-none focus:outline-none"
          style={{ color: textColor }}
        />
      )}
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/edit/components/UpdatePathSelectionBox.tsx">
import React, { useEffect, useState } from 'react';
import { useUpdateModeStore } from '../store/updateModeStore';
import { usePathsStore } from '../store/pathsStore';
import { useColors } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';

interface UpdatePathSelectionBoxProps {
  workspaceId: string;
  workflowId: string;
}

export function UpdatePathSelectionBox({
  workspaceId,
  workflowId,
}: UpdatePathSelectionBoxProps) {
  const {
    selectedEndBlocks,
    mergePathId,
    reset,
    isUpdateMode,
    originalEndBlocks,
  } = useUpdateModeStore();
  const allPaths = usePathsStore((state) => state.paths);
  const [isUpdating, setIsUpdating] = useState(false);
  const colors = useColors();

  // Helper function to get end block ID for a path
  const getEndBlockId = (pathId: number) => {
    const path = allPaths.find((p) => p.id === pathId);
    return path?.blocks.find((b) => b.type === 'END' || b.type === 'LAST')?.id;
  };

  // Helper function to get path ID from end block ID
  const getPathIdFromEndBlock = (blockId: number) => {
    return allPaths.find((p) =>
      p.blocks.some(
        (b) => b.id === blockId && (b.type === 'END' || b.type === 'LAST')
      )
    )?.id;
  };

  // Monitor selectedEndBlocks changes
  useEffect(() => {
    // Blocks to connect: blocks in current selection that weren't in original list
    const parents_to_connect = selectedEndBlocks.filter(
      (blockId) => !originalEndBlocks.includes(blockId)
    );

    // Blocks to disconnect: blocks in original list that aren't in current selection
    const parents_to_disconnect = originalEndBlocks.filter(
      (blockId) => !selectedEndBlocks.includes(blockId)
    );
  }, [selectedEndBlocks, originalEndBlocks, allPaths]);

  // Don't render if update mode is not enabled
  if (!isUpdateMode) return null;

  const handleUpdate = async () => {
    setIsUpdating(true);
    try {
      if (!mergePathId) return;

      // Now we're working directly with end block IDs
      const parents_to_connect = selectedEndBlocks.filter(
        (blockId) => !originalEndBlocks.includes(blockId)
      );

      const parents_to_disconnect = originalEndBlocks.filter(
        (blockId) => !selectedEndBlocks.includes(blockId)
      );

      // Update the merge path connections
      await fetch(`/api/paths/merge/${mergePathId}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          parents_to_connect,
          parents_to_disconnect,
        }),
      });

      // Fetch updated paths with correct workspaceId and workflowId
      const pathsResponse = await fetch(
        `/api/workspace/${workspaceId}/paths?workflow_id=${workflowId}`
      );

      if (pathsResponse.ok) {
        const pathsData = await pathsResponse.json();
        window.dispatchEvent(
          new CustomEvent('updatePaths', {
            detail: pathsData.paths,
          })
        );
      }

      reset();
    } catch (error) {
      console.error('Error updating merge:', error);
    } finally {
      setIsUpdating(false);
    }
  };

  return (
    <div className="fixed bottom-4 left-1/2 -translate-x-1/2 w-[400px] flex items-center justify-between gap-2 px-2 py-2 rounded-lg shadow-lg border bg-gray-900 dark:bg-white border-gray-700 dark:border-gray-200">
      <div className="flex items-center gap-2">
        <span className="text-sm text-gray-300 dark:text-gray-600">
          {selectedEndBlocks.length} node
          {selectedEndBlocks.length > 1 ? 's' : ''} selected
        </span>
        <button
          onClick={reset}
          disabled={isUpdating}
          className={`p-1 rounded-full text-gray-300 dark:text-gray-600 hover:bg-gray-800 dark:hover:bg-gray-100 transition-colors ${
            isUpdating ? 'opacity-50 cursor-not-allowed' : ''
          }`}
        >
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path
              d="M6 18L18 6M6 6l12 12"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
            />
          </svg>
        </button>
      </div>
      <ButtonNormal
        onClick={handleUpdate}
        disabled={isUpdating}
        isLoading={isUpdating}
        loadingText="Updating..."
        variant="primary"
        size="small"
      >
        Update merge
      </ButtonNormal>
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/edit/components/ZoomBar.tsx">
import React, { useState, useEffect } from 'react';
import { useReactFlow, useStore } from '@xyflow/react';
import ZoomBarDropdownMenu from './ZoomBarDropdownMenu';
import { useColors, useThemeAssets } from '@/app/theme/hooks';

interface ZoomBarProps {
  className?: string;
}

const ZoomBar: React.FC<ZoomBarProps> = ({ className = '' }) => {
  const [isDropdownVisible, setIsDropdownVisible] = useState(false);
  const { zoomIn, zoomOut } = useReactFlow();
  const colors = useColors();
  const themeAssets = useThemeAssets();

  // Get the current zoom level from ReactFlow store
  const zoom = useStore((state) => state.transform[2]);
  const zoomPercentage = Math.round(zoom * 100);

  const handleZoomIn = () => {
    zoomIn();
  };

  const handleZoomOut = () => {
    zoomOut();
  };

  return (
    <div
      className={`h-10 overflow-hidden rounded-lg border justify-start items-start inline-flex shadow-[inset_0px_0px_0px_1px_rgba(16,24,40,0.18),inset_0px_-2px_0px_rgba(16,24,40,0.05),0px_1px_2px_rgba(16,24,40,0.05)] ${className}`}
      style={{ borderColor: colors['border-primary'] }}
    >
      {/* Zoom Out Button */}
      <div
        onClick={handleZoomOut}
        className="px-3 py-2 h-full justify-center items-center gap-2 flex cursor-pointer transition-all duration-200 ease-in-out"
        style={{ 
          backgroundColor: colors['bg-primary'],
          borderColor: colors['border-primary'],
          color: colors['text-primary'] 
        }}
        onMouseOver={(e) => {
          e.currentTarget.style.backgroundColor = colors['bg-primary_hover'];
        }}
        onMouseOut={(e) => {
          e.currentTarget.style.backgroundColor = colors['bg-primary'];
        }}
      >
        <img
          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/zoom-out.svg`}
          alt="Zoom Out"
          className="w-5 h-5"
        />
      </div>

      {/* Zoom Percentage Button */}
      <button
        onClick={() => setIsDropdownVisible(!isDropdownVisible)}
        className="px-3 py-2 h-full border-l border-r justify-center items-center gap-2 flex cursor-pointer transition-all duration-200 ease-in-out"
        style={{ 
          backgroundColor: colors['bg-primary'],
          borderColor: colors['border-primary']
        }}
        onMouseOver={(e) => {
          e.currentTarget.style.backgroundColor = colors['bg-primary_hover'];
        }}
        onMouseOut={(e) => {
          e.currentTarget.style.backgroundColor = colors['bg-primary'];
        }}
      >
        <span className="text-sm font-semibold" style={{ color: colors['text-secondary'] }}>
          {zoomPercentage}%
        </span>
      </button>

      {/* Zoom In Button */}
      <div
        onClick={handleZoomIn}
        className="px-3 py-2 h-full justify-center items-center gap-2 flex cursor-pointer transition-all duration-200 ease-in-out"
        style={{ 
          backgroundColor: colors['bg-primary'],
          borderColor: colors['border-primary'],
          color: colors['text-primary'] 
        }}
        onMouseOver={(e) => {
          e.currentTarget.style.backgroundColor = colors['bg-primary_hover'];
        }}
        onMouseOut={(e) => {
          e.currentTarget.style.backgroundColor = colors['bg-primary'];
        }}
      >
        <img
          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/zoom-in.svg`}
          alt="Zoom In"
          className="w-5 h-5"
        />
      </div>

      {/* Dropdown Menu */}
      {isDropdownVisible && (
        <ZoomBarDropdownMenu
          onClose={() => setIsDropdownVisible(false)}
          currentZoom={zoomPercentage}
        />
      )}
    </div>
  );
};

export default ZoomBar;
</file>

<file path="app/[slug]/[flow]/edit/components/ZoomBarDropdownMenu.tsx">
import React, { useEffect, useRef } from 'react';
import { useReactFlow, useStore } from '@xyflow/react';
import { useColors, useThemeAssets } from '@/app/theme/hooks';
import { motion } from 'framer-motion';

interface ZoomBarDropdownMenuProps {
  onClose: () => void;
  currentZoom: number;
}

const ZoomBarDropdownMenu: React.FC<ZoomBarDropdownMenuProps> = ({ onClose, currentZoom }) => {
  const { zoomTo, fitView } = useReactFlow();
  const reactFlowWrapper = useStore((state) => state.domNode);
  const colors = useColors();
  const themeAssets = useThemeAssets();
  const dropdownRef = useRef<HTMLDivElement>(null);
  
  // Close dropdown when clicking outside or on the canvas
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        onClose();
      }
    };
    
    // Handle clicks on document
    document.addEventListener('mousedown', handleClickOutside);
    
    // Handle clicks specifically on the React Flow canvas
    const flowCanvas = reactFlowWrapper?.querySelector('.react-flow__pane');
    if (flowCanvas) {
      flowCanvas.addEventListener('mousedown', onClose);
    }
    
    // Clean up
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      if (flowCanvas) {
        flowCanvas.removeEventListener('mousedown', onClose);
      }
    };
  }, [onClose, reactFlowWrapper]);
  
  const zoomOptions = [
    { label: 'Zoom to fit', value: 'fit' },
    { label: 'Zoom to 50%', value: '50' },
    { label: 'Zoom to 100%', value: '100' },
    { label: 'Zoom to 200%', value: '200' }
  ];

  // Supabase image URLs
  const zoomFitIcon = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/maximize-02.svg`;
  const zoomOutIcon = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/zoom-out.svg`;
  const zoomInIcon = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/zoom-in.svg`;
  const searchIcon = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/search-icon.svg`;

  const handleZoomSelect = (option: { label: string; value: string }) => {
    if (option.value === 'fit') {
      fitView({ duration: 200 });
    } else {
      const zoomLevel = parseInt(option.value) / 100;
      zoomTo(zoomLevel, { duration: 200 });
    }
    onClose();
  };

  const isActive = (value: string) => {
    return (value === 'fit' && currentZoom === 0) || 
           (value !== 'fit' && Math.round(currentZoom * 100) === parseInt(value));
  };

  const getIconForOption = (option: { value: string }) => {
    if (option.value === 'fit') return zoomFitIcon;
    if (option.value === '100') return searchIcon;
    if (option.value === '200') return zoomInIcon;
    return zoomOutIcon;
  };

  return (
    <motion.div 
      ref={dropdownRef}
      initial={{ opacity: 0, scale: 0.95, y: -10 }}
      animate={{ opacity: 1, scale: 1, y: 0 }}
      exit={{ opacity: 0, scale: 0.95, y: -10 }}
      transition={{ 
        duration: 0.15, 
        ease: [0.16, 1, 0.3, 1] // Custom easing for smooth feel
      }}
      className="absolute top-12 right-0 w-48 rounded-lg shadow-lg border z-[9999] overflow-hidden"
      style={{
        backgroundColor: colors['bg-primary'],
        borderColor: colors['border-primary'],
        boxShadow: '0px 4px 6px -2px rgba(16, 24, 40, 0.03), 0px 12px 16px -4px rgba(16, 24, 40, 0.08)'
      }}
    >
      <div className="py-1">
        {zoomOptions.map((option) => {
          const active = isActive(option.value);
          
          // Define dynamic styles
          const bgColor = active ? colors['bg-accent-subtle'] : 'transparent';
          const textColor = active ? colors['text-accent'] : colors['text-primary'];
          const hoverBgColor = colors['bg-quaternary'];
          
          return (
            <div key={option.value} className="px-1.5 py-px">
              <div 
                onClick={() => handleZoomSelect(option)}
                className="w-full text-left px-2.5 py-2 rounded-md flex items-center gap-2 cursor-pointer transition-colors duration-300"
                style={{
                  backgroundColor: bgColor,
                  color: textColor
                }}
                onMouseOver={(e) => {
                  e.currentTarget.style.backgroundColor = hoverBgColor;
                }}
                onMouseOut={(e) => {
                  e.currentTarget.style.backgroundColor = bgColor;
                }}
              >
                <div className="w-4 h-4 relative overflow-hidden">
                  <img
                    src={getIconForOption(option)}
                    alt={option.label}
                    className="w-4 h-4"
                    style={{
                      filter: active ? 'none' : 'opacity(0.75)'
                    }}
                  />
                </div>
                <span className="text-sm font-medium">
                  {option.label}
                </span>
              </div>
            </div>
          );
        })}
      </div>
    </motion.div>
  );
};

export default ZoomBarDropdownMenu;
</file>

<file path="app/[slug]/[flow]/edit/store/clipboardStore.ts">
import { create } from 'zustand';
import { Block } from '../../types';

interface ClipboardStore {
  copiedBlock: Block | null;
  setCopiedBlock: (block: Block | null) => void;
}

export const useClipboardStore = create<ClipboardStore>((set) => ({
  copiedBlock: null,
  setCopiedBlock: (block) => set({ copiedBlock: block }),
}));
</file>

<file path="app/[slug]/[flow]/edit/store/connectModeStore.ts">
import { create } from 'zustand';

interface ConnectModeStore {
  isConnectMode: boolean;
  sourceBlockId: string | null;
  targetBlockId: string | null;
  previewEdgeId: string | null;
  setIsConnectMode: (isConnectMode: boolean) => void;
  setSourceBlockId: (id: string | null) => void;
  setTargetBlockId: (id: string | null) => void;
  setPreviewEdgeId: (id: string | null) => void;
  reset: () => void;
}

export const useConnectModeStore = create<ConnectModeStore>((set) => ({
  isConnectMode: false,
  sourceBlockId: null,
  targetBlockId: null,
  previewEdgeId: null,
  setIsConnectMode: (isConnectMode) => set({ isConnectMode }),
  setSourceBlockId: (id) => set({ sourceBlockId: id }),
  setTargetBlockId: (id) => set({ targetBlockId: id }),
  setPreviewEdgeId: (id) => set({ previewEdgeId: id }),
  reset: () => set({
    isConnectMode: false,
    sourceBlockId: null,
    targetBlockId: null,
    previewEdgeId: null,
  }),
}));
</file>

<file path="app/[slug]/[flow]/edit/store/editModeStore.ts">
import { create } from 'zustand';

interface EditModeState {
  isEditMode: boolean;
  selectedNodeId: string | null;
  setEditMode: (isEditMode: boolean, nodeId?: string | null) => void;
}

export const useEditModeStore = create<EditModeState>((set) => ({
  isEditMode: false,
  selectedNodeId: null,
  setEditMode: (isEditMode, nodeId = null) => set({ isEditMode, selectedNodeId: nodeId }),
}));
</file>

<file path="app/[slug]/[flow]/edit/store/loadingStore.ts">
import { create } from 'zustand';

interface LoadingState {
  isLoading: boolean;
  setIsLoading: (loading: boolean) => void;
}

export const useLoadingStore = create<LoadingState>((set) => ({
  isLoading: false,
  setIsLoading: (loading) => set({ isLoading: loading }),
}));
</file>

<file path="app/[slug]/[flow]/edit/store/modalStore.ts">
import { create } from 'zustand';
import { NodeData, Path, StrokeLine } from '../../types';
import { Node } from '@xyflow/react';

interface ModalStore {
  showConnectModal: boolean;
  connectData: { 
    sourceNode: Node;
    targetNode?: Node;
  } | null;
  setShowConnectModal: (show: boolean) => void;
  setConnectData: (data: { sourceNode: Node; targetNode?: Node } | null) => void;
  showParallelPathModal: boolean;
  modalData: any; // Replace 'any' with proper type if available
  setShowModal: (show: boolean) => void;
  setModalData: (data: { path: Path; position: number; existingPaths: string[] }) => void;
  showEditLinksModal: boolean;
  editLinksData: {
    sourceNode: Node<NodeData>;
  } | null;
  setShowEditLinksModal: (show: boolean) => void;
  setEditLinksData: (data: { sourceNode: Node<NodeData> } | null) => void;
  onStrokeLinesUpdate?: React.Dispatch<React.SetStateAction<StrokeLine[]>>;
  setOnStrokeLinesUpdate: (fn: React.Dispatch<React.SetStateAction<StrokeLine[]>> | undefined) => void;
}

export const useModalStore = create<ModalStore>((set) => ({
  showConnectModal: false,
  connectData: null,
  setShowConnectModal: (show) => set({ showConnectModal: show }),
  setConnectData: (data) => set({ connectData: data }),
  showParallelPathModal: false,
  modalData: {
    path: null,
    position: 0,
    existingPaths: [],
  },
  setShowModal: (show) => set({ showParallelPathModal: show }),
  setModalData: (data) => set({ modalData: data }),
  showEditLinksModal: false,
  editLinksData: null,
  setShowEditLinksModal: (show) => set({ showEditLinksModal: show }),
  setEditLinksData: (data) => set({ editLinksData: data }),
  onStrokeLinesUpdate: undefined,
  setOnStrokeLinesUpdate: (fn) => set({ onStrokeLinesUpdate: fn }),
}));
</file>

<file path="app/[slug]/[flow]/edit/store/pathSelectionStore.ts">
import { create } from 'zustand';

interface PathSelectionStore {
  selectedPaths: number[];
  selectedEndBlocks: number[];
  parentBlockId: number | null;
  workflowId: number;
  mergeMode: boolean;
  updateMode: boolean;
  setSelectedPaths: (paths: number[]) => void;
  setParentBlockId: (id: number | null) => void;
  togglePathSelection: (pathId: number, endBlockId: number, parentBlockId: number) => void;
  setMergeMode: (enabled: boolean) => void;
  setUpdateMode: (mode: boolean) => void;
  reset: () => void;
}

export const usePathSelectionStore = create<PathSelectionStore>((set, get) => ({
  selectedPaths: [],
  selectedEndBlocks: [],
  parentBlockId: null,
  workflowId: (() => {
    const path = window.location.pathname;
    const lastPfIndex = path.lastIndexOf('--pf-');
    if (lastPfIndex === -1) return NaN;
    const workflowId = path.slice(lastPfIndex + 5).split('/')[0];
    return Number(workflowId) || NaN;
  })(),
  mergeMode: false,
  updateMode: false,
  setSelectedPaths: (paths) => set({ selectedPaths: paths }),
  setParentBlockId: (id) => set({ parentBlockId: id }),
  setMergeMode: (enabled) => set({ mergeMode: enabled }),
  setUpdateMode: (mode) => set({ updateMode: mode }),
  togglePathSelection: (pathId, endBlockId, parentBlockId) => {
    const { selectedPaths, selectedEndBlocks, parentBlockId: currentParentId } = get();
    
    if (selectedPaths.includes(pathId)) {
      // Deselecting
      const newPaths = selectedPaths.filter(id => id !== pathId);
      const newEndBlocks = selectedEndBlocks.filter(id => id !== endBlockId);
      
      set({ 
        selectedPaths: newPaths,
        selectedEndBlocks: newEndBlocks,
        parentBlockId: newPaths.length === 0 ? null : currentParentId,
        // Disable merge mode if no paths are selected
        mergeMode: newPaths.length > 0
      });
    } else {
      // Selecting
      set({ 
        selectedPaths: [...selectedPaths, pathId],
        selectedEndBlocks: [...selectedEndBlocks, endBlockId],
        parentBlockId: currentParentId || parentBlockId
      });
    }
  },
  reset: () => set({ 
    selectedPaths: [], 
    selectedEndBlocks: [], 
    parentBlockId: null,
    mergeMode: false,
    updateMode: false
  }),
}));
</file>

<file path="app/[slug]/[flow]/edit/store/pathsStore.ts">
import { create } from 'zustand';
import { Path } from '../../types';

interface PathsStore {
  paths: Path[];
  setPaths: (paths: Path[] | ((currentPaths: Path[]) => Path[])) => void;
}

export const usePathsStore = create<PathsStore>((set) => ({
  paths: [],
  setPaths: (paths) => set((state) => ({ 
    paths: typeof paths === 'function' ? paths(state.paths) : paths 
  })),
}));
</file>

<file path="app/[slug]/[flow]/edit/store/strokeLinesStore.ts">
import { create } from 'zustand';

interface StrokeLinesState {
  allStrokeLinesVisible: boolean;
  setAllStrokeLinesVisible: (visible: boolean) => void;
  toggleAllStrokeLines: () => void;
}

export const useStrokeLinesStore = create<StrokeLinesState>((set) => ({
  allStrokeLinesVisible: true,
  setAllStrokeLinesVisible: (visible) => set({ allStrokeLinesVisible: visible }),
  toggleAllStrokeLines: () => set((state) => ({ allStrokeLinesVisible: !state.allStrokeLinesVisible })),
}));
</file>

<file path="app/[slug]/[flow]/edit/store/updateModeStore.ts">
import { create } from 'zustand';

interface UpdateModeStore {
  isUpdateMode: boolean;
  mergePathId: number | null;
  selectedEndBlocks: number[];
  originalEndBlocks: number[];
  triggerPathId: number | null;
  setUpdateMode: (isUpdateMode: boolean) => void;
  setMergePathId: (mergePathId: number | null) => void;
  setSelectedEndBlocks: (selectedEndBlocks: number[]) => void;
  setOriginalEndBlocks: (originalEndBlocks: number[]) => void;
  setTriggerPathId: (triggerPathId: number | null) => void;
  toggleEndBlockSelection: (blockId: number) => void;
  reset: () => void;
}

export const useUpdateModeStore = create<UpdateModeStore>((set, get) => ({
  isUpdateMode: false,
  mergePathId: null,
  selectedEndBlocks: [],
  originalEndBlocks: [],
  triggerPathId: null,
  setUpdateMode: (isUpdateMode) => set({ isUpdateMode }),
  setMergePathId: (mergePathId) => set({ mergePathId }),
  setSelectedEndBlocks: (selectedEndBlocks) => set({ selectedEndBlocks }),
  setOriginalEndBlocks: (originalEndBlocks) => set({ originalEndBlocks }),
  setTriggerPathId: (triggerPathId) => set({ triggerPathId }),
  toggleEndBlockSelection: (blockId) => {
    const { selectedEndBlocks } = get();
    if (selectedEndBlocks.includes(blockId)) {
      set({ selectedEndBlocks: selectedEndBlocks.filter(id => id !== blockId) });
    } else {
      set({ selectedEndBlocks: [...selectedEndBlocks, blockId] });
    }
  },
  reset: () => set({
    isUpdateMode: false,
    mergePathId: null,
    selectedEndBlocks: [],
    originalEndBlocks: [],
    triggerPathId: null,
  }),
}));
</file>

<file path="app/[slug]/[flow]/edit/test/page.tsx">
'use client';

import React from 'react';
import { MiniMap, ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

const nodes = [
  { id: '1', type: 'default', position: { x: 0, y: 0 }, data: { label: 'A' } },
  {
    id: '2',
    type: 'default',
    position: { x: 100, y: 100 },
    data: { label: 'B' },
  },
];

export default function MiniMapTest() {
  return (
    <div style={{ width: 600, height: 400 }}>
      <ReactFlow nodes={nodes} edges={[]} fitView>
        <MiniMap nodeColor="#000" />
      </ReactFlow>
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/edit/utils/collectAllPathIds.ts">
import { Block } from "../../types";

export default function collectAllPathIds(
    path: { id: number; blocks: any[] },
    allPaths: { id: number; blocks: any[] }[]
  ): Set<number> {
    const visitedPathIds = new Set<number>();
    const queue: number[] = [path.id];

    while (queue.length > 0) {
      const currentPathId = queue.pop()!;
      if (visitedPathIds.has(currentPathId)) continue;
      visitedPathIds.add(currentPathId);

      // Find the path object by id
      const currentPath: { id: number; blocks: Block[] } | undefined =
        allPaths.find((p) => p.id === currentPathId);
      if (!currentPath) continue;

      for (const block of currentPath.blocks) {
        if (Array.isArray(block.child_paths)) {
          for (const child of block.child_paths) {
            if (child.path_id && !visitedPathIds.has(child.path_id)) {
              queue.push(child.path_id);
            }
          }
        }
      }
    }

    visitedPathIds.delete(path.id);
    return visitedPathIds;
  }
</file>

<file path="app/[slug]/[flow]/edit/utils/createChildPaths.ts">
import { Path } from '../../types';

interface CreateChildPathsResponse {
  paths: Path[];
}

/**
 * Creates minimal child paths and connects them to a parent block
 * @param pathNames Names for the new paths to create
 * @param workflowId ID of the workflow
 * @param parentPath The parent path to connect the new paths to
 * @returns Promise with the updated paths data
 */
export async function createChildPaths(
  pathNames: string[],
  workflowId: number,
  parentPath: Path
): Promise<void> {
  try {
  
    // Create minimal paths
    const createdPaths = await Promise.all(
      pathNames.map(async (name) => {
        const response = await fetch('/api/paths/minimal', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name,
            workflow_id: workflowId,
          }),
        });
        return response.json();
      })
    );

    // Connect paths to the parent path
    await fetch('/api/paths/connect', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        child_path_ids: createdPaths.map((path) => path.id),
        destination_path_id: parentPath.id,
      }),
    });


  } catch (error) {
    console.error('Error creating child paths:', error);
    throw error;
  }
}
</file>

<file path="app/[slug]/[flow]/edit/utils/createParallelPaths.ts">
import { Path, Block, PathParentBlock } from '../../types';
import { getBlocksAfterPosition } from './getBlocksAfterPosition';
import { getChildPathsIds } from './getChildPathsIds';
import { BlockEndType } from '@/types/block';
import { useLoadingStore } from '../store/loadingStore';
import { generatePublicUrl } from '@/app/api/utils/generatePublicUrl';

interface CreateParallelPathsOptions {
  paths_to_create?: string[];
  path_to_move?: number;
  pathblock_title?: string;
  pathblock_description?: string;
  pathblock_icon?: string;
}

function updateCreatedPaths(
  currentPaths: Path[],
  createdPaths: Path[],
  blocksToMove: Block[],
  path_move_idx: number,
  updatedLastBlockFromBackend: Block,
  childPathIdsToMove: number[]
): {paths: Path[], path_to_move: Path | null} {
  let path_to_move: Path | null = null;
  let paths = createdPaths.map((path, idx) => {
    if (idx === path_move_idx && blocksToMove.length > 0) {
      // Find begin and last blocks
      const beginBlock = path.blocks.find((b: Block) => b.type === 'BEGIN');
      let lastBlock = path.blocks.find((b: Block) => b.type === BlockEndType.LAST);

      // Prepare moved blocks with correct path_id and position, filter out BlockEndType
      const movedBlocks = blocksToMove
        .filter((b: Block) => b.type !== BlockEndType.LAST)
        .map((b, i) => ({
          ...b,
          path_id: path.id,
          position: i + 1,
        }));
 
      if (childPathIdsToMove.length > 0 && lastBlock) {
        lastBlock.child_paths = childPathIdsToMove.map((cpid) => ({
          path_id: cpid,
          block_id: lastBlock.id,
          created_at: new Date().toISOString(),
          path: currentPaths.find((p) => p.id === cpid) as Path,
          block: lastBlock,
        }));
        lastBlock.type = BlockEndType.PATH;
      }
      // Rebuild blocks: [BEGIN, ...movedBlocks, LAST]
      const newBlocks = [
        ...(beginBlock ? [beginBlock] : []),
        ...movedBlocks,
        ...(lastBlock ? [{ ...lastBlock, position: movedBlocks.length + 1 }] : []),
      ];

      path_to_move = {
        ...path,
        blocks: newBlocks,
        parent_blocks: updatedLastBlockFromBackend && updatedLastBlockFromBackend.child_paths
          ? updatedLastBlockFromBackend.child_paths.filter((cp: any) => cp.path_id === path.id)
          : [],
      };
      return path_to_move;
    }
    // All other paths: just update parent_blocks as before
    return {
      ...path,
      parent_blocks: updatedLastBlockFromBackend && updatedLastBlockFromBackend.child_paths
        ? updatedLastBlockFromBackend.child_paths.filter((cp: any) => cp.path_id === path.id)
        : [],
    };
  });
  return { paths, path_to_move };
}

function createOptimisticPaths(
  currentPaths: Path[],
  paths_to_create: string[],
  path_to_move_idx: number,
  blocksToMove: Block[],
  childPathIdsToMove: number[],
  parent_path: Path,
  parentEndBlock: Block,
  optimisticParentBlockId: number,
  now: number,
  nowStr: string
): {paths: Path[], path_to_move: Path | null} {
  let path_to_move: Path | null = null;
  let paths: Path[] = paths_to_create.map((branchName, idx) => {
    const fakePathId = now + idx; // fake unique ID
    const beginBlockId = -Math.floor(Math.random() * 1e9);
    const lastBlockId = -Math.floor(Math.random() * 1e9);

    // Default: BEGIN and LAST block
    const beginBlock: Block = {
      id: beginBlockId,
      type: 'BEGIN',
      position: 0,
      title: 'Begin',
      icon: null,
      description: null,
      image: null,
      original_image: null,
      image_description: null,
      average_time: null,
      task_type: null,
      delay_event: null,
      delay_type: null,
      workflow_id: parent_path.workflow_id,
      path_id: fakePathId,
      workflow: parent_path.workflow,
      path: {} as Path, // will be set later
      child_paths: [],
      created_at: nowStr,
      updated_at: nowStr,
      delay_seconds: null,
    };

    const lastBlock: Block = {
      ...beginBlock,
      id: lastBlockId,
      type: BlockEndType.LAST,
      position: 1, // will be updated below
      title: 'End',
    };

    // Restore parentBlockRel for default paths
    const parentBlockRel: PathParentBlock = {
      path_id: fakePathId,
      block_id: optimisticParentBlockId,
      created_at: nowStr,
      path: {} as Path,
      block: { ...parentEndBlock, id: optimisticParentBlockId },
    };

    if (idx === path_to_move_idx) {
      // Use fake blocks based on blocksToMove, positioned between BEGIN and LAST
      const movedBlocks = blocksToMove
        .filter((b: Block) => b.type !== BlockEndType.LAST)
        .map((b, i) => ({
          ...b,
          id: -Math.floor(Math.random() * 1e9), // negative fake id
          path_id: fakePathId,
          position: i + 1, // position after BEGIN
        }));

      if (childPathIdsToMove.length > 0) {
        const lastParentBlock = parent_path.blocks[parent_path.blocks.length - 1];
        lastBlock.child_paths = childPathIdsToMove.map((cpid) => ({
          path_id: cpid,
          block_id: lastBlock.id,
          created_at: nowStr,
          path: currentPaths.find((p) => p.id === cpid) as Path,
          block: lastBlock,
        }));
        lastBlock.type = BlockEndType.PATH;
        lastBlock.title = lastParentBlock.title;
        lastBlock.description = lastParentBlock.description;
        lastBlock.icon = lastParentBlock.icon;
      }
      // Set correct positions for begin and last
      path_to_move = {
        id: fakePathId,
        name: branchName,
        workflow_id: parent_path.workflow_id,
        workflow: parent_path.workflow,
        blocks: [
          beginBlock,
          ...movedBlocks,
          { ...lastBlock, position: movedBlocks.length + 1 }
        ],
        parent_blocks: [parentBlockRel], // will be set below
      };
      return path_to_move;
    }

    // Default: just BEGIN and LAST, with parentBlockRel
    return {
      id: fakePathId,
      name: branchName,
      workflow_id: parent_path.workflow_id,
      workflow: parent_path.workflow,
      blocks: [beginBlock, lastBlock],
      parent_blocks: [parentBlockRel], // restored here
    };
  });

  return { paths, path_to_move };

}

export async function createParallelPaths(
  currentPaths: Path[],
  parent_path: Path,
  position: number,
  options: CreateParallelPathsOptions = {},
  setPaths: (paths: Path[]) => void,
): Promise<{ updatedPaths: Path[], rollbackPaths: Path[], error?: any }> {
  // Set loading to true at the start
  const { 
    paths_to_create = ["If", "Else"],
    path_to_move = 0,
    pathblock_title = "If",
    pathblock_description = "",
    pathblock_icon = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dataflow-icon.svg`,
  } = options;
  
  if (path_to_move >= paths_to_create.length) {
    throw new Error('path_to_move index is out of bounds');
  }
  const blocksToMove = getBlocksAfterPosition(parent_path, position);
  const childPathIdsToMove = getChildPathsIds(parent_path);
  
  // Find any end-type block in parent path
  const parentEndBlock = parent_path.blocks.find(block => 
    Object.values(BlockEndType).includes(block.type as BlockEndType)
  );
  if (!parentEndBlock) throw new Error('No end-type block found in parent path');
  
  // --- OPTIMISTIC UPDATE LOGIC ---
  const nowStr = new Date().toISOString();
  const parentBlockId = parentEndBlock.id;
  const parentPathId = parent_path.id;

  // Simulate IDs for optimistic UI
  const now = Date.now();
  const optimisticParentBlockId = -Math.floor(Math.random() * 1e9);
  const { paths: optimisticPaths, path_to_move: optimisticPathToMove } = createOptimisticPaths(
    currentPaths,
    paths_to_create,
    path_to_move,
    blocksToMove,
    childPathIdsToMove,
    parent_path,
    parentEndBlock,
    optimisticParentBlockId,
    now,
    nowStr
  );

  // Add all these child_paths into the last block of the parent_path
  const newChildPaths: PathParentBlock[] = optimisticPaths.map((path) => ({
    path_id: path.id,
    block_id: optimisticParentBlockId,
    created_at: nowStr,
    path: path,
    block: parentEndBlock,
  }));

  const optimisticPathToMoveLastBlock = optimisticPathToMove?.blocks.find((b) => b.type === BlockEndType.PATH);
  // Return the updated paths array (for the path store)
  const updatedPaths = [
    ...currentPaths,
    ...optimisticPaths,
  ].map((p) => {
    if (p.id === parentPathId) {
      // Update the last block's child_paths
      const blocksToMoveIds = new Set(blocksToMove?.map(b => b.id) ?? []);
      const updatedBlocks = p.blocks
        .filter(b => !blocksToMoveIds.has(b.id))
        .map((b) =>
          b.id === parentBlockId
            ? { ...b, type: BlockEndType.PATH, child_paths: [...(b.child_paths || []), ...newChildPaths], id: optimisticParentBlockId, title: pathblock_title, description: pathblock_description, icon: pathblock_icon, signedIconUrl: generatePublicUrl(pathblock_icon) }
            : b
        );
      return { ...p, blocks: updatedBlocks };
    }
    else if (childPathIdsToMove.includes(p.id) && optimisticPathToMoveLastBlock) {
      const parentBlock = optimisticPathToMoveLastBlock.child_paths.find(
        (cp: PathParentBlock) => cp.path_id === p.id
      );
      return { ...p, parent_blocks: parentBlock ? [parentBlock] : [] };
    }
    return p;
  });

  // --- SET OPTIMISTIC PATHS BEFORE FETCHES ---
  setPaths(updatedPaths);
  
  // --- FETCHES (side effects) ---
  try {
    // 1. Create all parallel paths via API
    const createdPaths = await Promise.all(
      paths_to_create.map(async (branchName) => {
        const response = await fetch('/api/paths/minimal', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name: `${branchName}`,
            workflow_id: parent_path.workflow_id,
          }),
        });
        return response.json();
      })
    );

    // 2. Transform last block into a PATH block
    // await fetch('/api/blocks/'

    // 3. Move blocks to specified path
    if (blocksToMove.length > 0) {
      await fetch('/api/blocks/move', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          block_ids: blocksToMove.map(block => block.id),
          destination_path_id: createdPaths[path_to_move].id,
        }),
      });
    }

    const parentPathLastBlock = parent_path.blocks[parent_path.blocks.length - 1];
    // 4. Move child paths to specified path
    let updatedPathToMoveResponse = null;
    if (childPathIdsToMove.length > 0) {
      const response = await fetch('/api/paths/connect', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          child_path_ids: childPathIdsToMove,
          destination_path_id: createdPaths[path_to_move].id,
          pathblock_title: parentPathLastBlock.title,
          pathblock_description: parentPathLastBlock.description,
          pathblock_icon: parentPathLastBlock.icon,
        }),
      });

      updatedPathToMoveResponse = await response.json();
      
    }

    // 5. Link all parallel paths to parente path's END block
    const updatedParentPath = await fetch('/api/paths/connect', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        child_path_ids: createdPaths.map(path => path.id),
        destination_path_id: parent_path.id,
        pathblock_title: pathblock_title,
        pathblock_description: pathblock_description,
        pathblock_icon: pathblock_icon,
      }),
    });

    // After fetching updatedParentPath
    const updatedParentPathJson = await updatedParentPath.json();


    const parentBlocks = parent_path.blocks;
    const updatedBlocksFromBackend = updatedParentPathJson.blocks;
    const updatedLastBlockFromBackend = updatedBlocksFromBackend[updatedBlocksFromBackend.length - 1];
    // Map real created paths, setting parent_blocks to lastBlock.child_paths (filtered by path id)
    const { paths: updatedCreatedPaths, path_to_move: updatedPath } = updateCreatedPaths(
      currentPaths,
      createdPaths,
      blocksToMove,
      path_to_move,
      updatedLastBlockFromBackend,
      childPathIdsToMove
    );

    updatedCreatedPaths[path_to_move] = {...updatedCreatedPaths[path_to_move], ...updatedPathToMoveResponse};

    if (process.env.NODE_ENV === 'development') {
      console.log('updatedCreatedPaths', updatedCreatedPaths);
    }
    // Remove only optimistic paths (do NOT remove parent_path)

    const updatedPathToMoveLastBlock : Block | undefined = updatedPathToMoveResponse?.blocks.find((b: Block) => b.type === BlockEndType.PATH);
    // Find the last block in both parent_path and updatedParentPathJson

    const blocksToMoveIds = new Set(blocksToMove.map(b => b.id));
    const updatedParentBlocks = parentBlocks
      .filter(
        block =>
          // Remove if it's in blocksToMove AND is NOT a BlockEndType
          !(blocksToMoveIds.has(block.id) && !Object.values(BlockEndType).includes(block.type as BlockEndType))
      )
      .map((block, idx, arr) => {
        // Update the last block's child_paths as before
        if (idx === arr.length - 1) {
          return {
            ...block,
            type: BlockEndType.PATH,
            child_paths: updatedLastBlockFromBackend.child_paths,
            title: pathblock_title,
            description: pathblock_description,
            icon: pathblock_icon,
            signedIconUrl: generatePublicUrl(pathblock_icon),
          };
        }
        return block;
      });
    const updatedParentPathCp = { ...parent_path, blocks: updatedParentBlocks };

    const filteredPaths = currentPaths.filter(
      p => p.id !== parent_path.id
    ).map(p => {
      if (childPathIdsToMove.includes(p.id) && updatedPathToMoveLastBlock) {
        const parentBlock = updatedPathToMoveLastBlock.child_paths.find(
          (cp: PathParentBlock) => cp.path_id === p.id
        );
        return { ...p, parent_blocks: parentBlock ? [parentBlock] : [] };
      }
      return p;
    });
    // Add real created paths and the updated parent path
    const newPaths = [
      ...filteredPaths,
      ...updatedCreatedPaths,
      updatedParentPathCp,
    ];

    // Update the store
    setPaths(newPaths);

    // At the end, set loading to false
    return { updatedPaths: newPaths, rollbackPaths: currentPaths };
  } catch (error) {
    // On error, set loading to false
    if (setPaths) setPaths(currentPaths); // rollback
    return { updatedPaths: currentPaths, rollbackPaths: currentPaths, error };
  }
}
</file>

<file path="app/[slug]/[flow]/edit/utils/debounce.ts">
/**
 * Debounce utility function to prevent excessive function calls
 * @param func - The function to debounce
 * @param wait - The number of milliseconds to delay
 * @returns A debounced version of the function
 */
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout;
  
  return function executedFunction(...args: Parameters<T>) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
</file>

<file path="app/[slug]/[flow]/edit/utils/elkLayout.ts">
import ELK from 'elkjs/lib/elk.bundled.js';
import { Node, Edge } from '@xyflow/react';
import { CSSProperties } from 'react';
import { BlockEndType } from '@/types/block';
import { Block } from '@/types/block';
import { NodeData } from '../../types';

const elk = new ELK();

export async function createElkLayout(nodes: Node[], edges: Edge[]) {

  const nodeIds = new Set(nodes.map((node) => node.id));
  const validEdges = edges.filter(
    (edge) => nodeIds.has(edge.source) && nodeIds.has(edge.target)
  );

  const isEndTypeNode = (type: string | undefined) => 
    type && Object.values(BlockEndType).map(t => t.toLowerCase()).includes(type);


  const elkNodes = nodes.map((node) => ({
    id: node.id,
    width: node.type === 'begin' ? 
            (((node.data as NodeData)?.path?.parent_blocks?.length ?? 0) > 1 ? 12 : (((node.data as NodeData)?.path?.parent_blocks?.length ?? 0) > 0 ? 200 : 350)) :
            node.type === 'last' ? 32 :
            node.type === 'path' ? 481 :
            node.type === 'end' ? 290 :
            node.type === 'merge' ? 12 :
            node.type === 'eventDelay' ? 481 :
            node.type === 'fixedDelay' ? 481 :
            481,
    height: node.type === 'begin' ? 
             (((node.data as NodeData)?.path?.parent_blocks?.length ?? 0) > 1 ? 12 : 50) :
             node.type === 'last' ? 32 :
             node.type === 'path' ? 200 :
             node.type === 'end' ? 48 :
             node.type === 'merge' ? 12 :
             node.type === 'eventDelay' ? 223 :
             node.type === 'fixedDelay' ? 132 :
             ((node.data as NodeData)?.block as Block)?.image ? 387 : 120,
  }));

  const elkEdges = validEdges.map((edge) => ({
    id: edge.id,
    sources: [edge.source],
    targets: [edge.target],
  }));

  const elkGraph = {
    id: 'root',
    children: elkNodes,
    edges: elkEdges,
  };

  const layoutOptions = {
    'elk.algorithm': 'layered',
    'elk.direction': 'DOWN',
    'elk.spacing.nodeNode': '500',
    'elk.layered.spacing.nodeNodeBetweenLayers': '120',
    'elk.spacing.componentComponent': '80',
    'elk.edgeRouting': 'ORTHOGONAL',
    'elk.layered.crossingMinimization.strategy': 'LAYER_SWEEP',
    'elk.layered.nodePlacement.strategy': 'BRANDES_KOEPF',
    'elk.layered.layering.strategy': 'NETWORK_SIMPLEX',
    'elk.layered.spacing.edgeNodeBetweenLayers': '80',
    'elk.layered.mergeEdges': 'true',
    'elk.layered.priority.direction': '1',
    'elk.hierarchyHandling': 'INCLUDE_CHILDREN',
    'elk.alignment': 'CENTER',
    'elk.padding': '[top=50,left=50,bottom=50,right=50]',
    'elk.layered.crossingMinimization.semiInteractive': 'true',
    'elk.layered.spacing.baseValue': '80',
    'elk.separateConnectedComponents': 'true',
    'elk.layered.layering.wideNodesOnMultipleLayers': 'OFF',
    'elk.layered.nodePlacement.bk.fixedAlignment': 'BALANCED',
    'elk.layered.nodePlacement.favorStraightEdges': 'true',
    'elk.layered.crossingMinimization.forceNodeModelOrder': 'true',
    'elk.edges.routing': 'ORTHOGONAL',
    'elk.spacing.edgeEdge': '50',
    'elk.spacing.edgeNode': '50',
    'elk.edge.thickness': '2',
    'elk.edges.bendPoints': 'true',
    'elk.edges.sourcePoint': 'FREE',
    'elk.edges.targetPoint': 'FREE',
    'elk.portAlignment.default': 'CENTER',
    'elk.portConstraints': 'FREE',
    'elk.layered.feedbackEdges': 'true',
    'elk.layered.spacing.edgeEdgeBetweenLayers': '50',
    'elk.layered.considerModelOrder.strategy': 'NODES_AND_EDGES',
  };

  try {
    const layout = await elk.layout(elkGraph, { layoutOptions });

    if (!layout || !layout.children) {
      console.error('Invalid layout result:', layout);
      return nodes;
    }

    return nodes.map((node) => {
      const elkNode = layout.children?.find((n) => n.id === node.id);
      if (!elkNode || elkNode.x === undefined || elkNode.y === undefined) {
        console.error('Missing layout for node:', node.id);
        return node;
      }

      return {
        ...node,
        position: {
          x: elkNode.x,
          y: elkNode.y,
        },
        style: {
          ...node.style,
          zIndex: 1,
          visibility: 'visible' as CSSProperties['visibility'],
          opacity: 1,
        },
      } as Node;
    });
  } catch (error) {
    console.error('Error calculating layout:', error);
    return nodes;
  }
}
</file>

<file path="app/[slug]/[flow]/edit/utils/getBlocksAfterPosition.ts">
import { Block, Path } from '../../types';
import { BlockEndType } from '@/types/block';

/**
 * Returns all blocks at and after the specified position in a path, excluding end-type blocks
 * @param path The path containing the blocks
 * @param position The position from which to get blocks (inclusive)
 * @returns Array of blocks at and after the specified position, excluding end-type blocks
 */
export function getBlocksAfterPosition(path: Path, position: number): Block[] {
  if (!path || !Array.isArray(path.blocks)) {
    return [];
  }

  // Sort blocks by position to ensure correct order
  const sortedBlocks = [...path.blocks].sort((a, b) => a.position - b.position);
  
  // Filter blocks that have a position greater than or equal to the specified position
  // and are not end-type blocks
  return sortedBlocks.filter(block => 
    block.position >= position && !Object.values(BlockEndType).includes(block.type as BlockEndType)
  );
}
</file>

<file path="app/[slug]/[flow]/edit/utils/getChildPaths.ts">
import { Path } from '../../types';

/**
 * Returns all child paths connected to the last block of a given path
 * @param path The parent path
 * @param allPaths Array of all paths in the workflow (needed to get full path data)
 * @returns Array of child paths connected to the last block
 */
export function getChildPaths(path: Path, allPaths: Path[]): Path[] {
  if (!path || !Array.isArray(path.blocks) || path.blocks.length === 0) {
    return [];
  }

  const childPaths: Path[] = [];
  const lastBlock = path.blocks[path.blocks.length - 1];

  // Check child_paths relationships of the last block
  lastBlock.child_paths.forEach(childPathRelation => {
    // Find the full path data from allPaths
    const fullChildPath = allPaths.find(p => p.id === childPathRelation.path_id);
    if (fullChildPath) {
      childPaths.push(fullChildPath);
    }
  });

  return childPaths;
}
</file>

<file path="app/[slug]/[flow]/edit/utils/getChildPathsIds.ts">
import { Path } from '../../types';

/**
 * Returns all child path IDs connected to the last block of a given path
 * @param path The parent path
 * @returns Array of child path IDs from the last block
 */
export function getChildPathsIds(path: Path): number[] {
  if (!path || !Array.isArray(path.blocks) || path.blocks.length === 0) {
    return [];
  }

  const lastBlock = path.blocks[path.blocks.length - 1];
  
  // Extract path_ids from child_paths relationships
  return lastBlock.child_paths.map(childPathRelation => childPathRelation.path_id);
}
</file>

<file path="app/[slug]/[flow]/edit/utils/mergePaths.ts">
import { Path } from '../../types';

export async function mergePaths(paths: Path[], workflowId: number) {
  try {
    // Create merge path and parent relationships in a single transaction
    const response = await fetch('/api/paths/merge', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        name: 'Merge',
        workflow_id: workflowId,
        parent_blocks: paths.map(path => {
          const endBlock = path.blocks.find(block => 
            block.type === 'END' || block.type === 'LAST'
          );
          return endBlock?.id;
        }).filter(Boolean),
      }),
    });

    if (!response.ok) {
      throw new Error('Failed to create merge path');
    }

    const result = await response.json();
    return result;
  } catch (error) {
    console.error('Error merging paths:', error);
    throw error;
  }
}
</file>

<file path="app/[slug]/[flow]/edit/utils/processPath.ts">
import {
    Node,
    Edge,
  } from '@xyflow/react';
import { DelayType, Path } from '../../types';
import { BlockEndType } from '@/types/block';
import { usePathsStore } from '../store/pathsStore';

// Helper function to get all descendant path IDs for a child path
const getDescendantPathIds = (childPath: Path | undefined): number[] => {
  if (!childPath?.blocks || childPath.blocks.length === 0) return [];
  
  const lastBlock = childPath.blocks[childPath.blocks.length - 1];
  if (!lastBlock?.child_paths) return [];

  return lastBlock.child_paths.map(cp => cp.path.id);
};

// Helper function to check if two paths share any common children
const shareCommonChildren = (path1Id: number, path2Id: number, allPaths: Path[]): boolean => {
  const fullPath1 = allPaths.find(p => p.id === path1Id);
  const fullPath2 = allPaths.find(p => p.id === path2Id);
  
  const children1 = getDescendantPathIds(fullPath1);
  const children2 = getDescendantPathIds(fullPath2);
  return children1.some(id => children2.includes(id));
};

// Sort and group child paths that share common descendants
const sortChildPaths = (childPaths: { path: { id: number } }[], allPaths: Path[]) => {
  const groups: { path: { id: number } }[][] = [];
  const used = new Set<number>();

  childPaths.forEach((cp1, i) => {
    if (used.has(cp1.path.id)) return;

    const group = [cp1];
    used.add(cp1.path.id);

    // Find all other paths that share children with this one
    childPaths.forEach((cp2, j) => {
      if (i === j || used.has(cp2.path.id)) return;
      
      if (shareCommonChildren(cp1.path.id, cp2.path.id, allPaths)) {
        group.push(cp2);
        used.add(cp2.path.id);
      }
    });

    groups.push(group);
  });

  // Flatten groups back into a single array
  return groups.flat();
};

// Recursive function to process paths into nodes and edges
export function processPath(
  workspaceId: string,
  path: Path,
  nodes: Node[],
  edges: Edge[],
  handleDeleteBlock: (blockId: string) => void,
  handleAddBlockOnEdge: (position: number,
    path: Path,
    event?: { clientX: number; clientY: number }) => void,
  visitedPaths = new Set<string>(),
  handlePathsUpdate: (paths: Path[]) => void,
  handleStrokeLinesUpdate: (strokeLines: any[]) => void,
  updateStrokeLineVisibility: (blockId: number, isVisible: boolean) => void,
  strokeLineVisibilities: [number, boolean][],
  allPaths: Path[],
  hasSiblings: boolean = false,
  longestSiblingPath: number = 0,
): void {
  if (visitedPaths.has(path.id.toString())) return; // Avoid infinite loops
  visitedPaths.add(path.id.toString());

  const pathLength = path.blocks.length - 2;
  path.blocks.forEach((block, index) => {
    // If this is a merge node and there's a path length difference, add invisible nodes BEFORE the merge node
    if (block.type === BlockEndType.MERGE && longestSiblingPath > pathLength) {
      const numInvisibleBlocks = longestSiblingPath - pathLength;
      
      let previousNodeId = index > 0 ? `block-${path.blocks[index - 1].id}` : '';
      
      for (let i = 0; i < numInvisibleBlocks; i++) {
        const InvisibleBlockId = `invisible-${block.id}-${i}`;
        const InvisibleBlock = {
          id: InvisibleBlockId,
          type: 'invisible',
          position: { x: 0, y: 0 },
          data: {
            label: '',
            position: block.position - numInvisibleBlocks + i,
            type: 'invisible',
            pathId: block.path_id,
            path: path,
          },
        };
        
        // Insert invisible node before the merge node
        nodes.splice(nodes.length - 1, 0, InvisibleBlock);

        // Connect nodes
        edges.push({
          id: `edge-${previousNodeId}-${InvisibleBlockId}`,
          source: previousNodeId,
          target: InvisibleBlockId,
          type: 'smoothstepCustom',
          sourceHandle: 'bottom',
          targetHandle: 'top',
          style: { stroke: '#b1b1b7', opacity: 0 },
        });

        previousNodeId = InvisibleBlockId;
      }

      // Connect last invisible node to merge node
      if (numInvisibleBlocks > 0) {
        edges.push({
          id: `edge-${previousNodeId}-block-${block.id}`,
          source: previousNodeId,
          target: `block-${block.id}`,
          type: 'smoothstepCustom',
          sourceHandle: 'bottom',
          targetHandle: 'top',
          style: { stroke: '#b1b1b7', opacity: 0 },
        });
      }
    }

    const nodeId = `block-${block.id}`;
    const visibility = strokeLineVisibilities.find(([id]) => id === block.id)?.[1] ?? true;

    // Find end block and check for child paths
    const endBlock = path.blocks.find(block => 
      block.type === 'END' || block.type === 'LAST' || block.type === 'PATH' || block.type === 'MERGE'
    );
    const pathHasChildren = endBlock?.child_paths && endBlock.child_paths.length > 0;
    const pathIsMerged = endBlock?.child_paths && endBlock.child_paths.length  === 1;
    nodes.push({
      id: nodeId,
      type: block.type === 'BEGIN' 
        ? 'begin' 
        : block.type === BlockEndType.END
          ? 'end'
          : block.type === BlockEndType.LAST
            ? 'last'
            : block.type === BlockEndType.PATH
              ? 'path'
              : block.type === BlockEndType.MERGE
                ? 'merge'
                : block.type === 'DELAY'
                  ? block.delay_type === DelayType.FIXED_DURATION
                    ? 'fixedDelay'
                    : 'eventDelay'
                  : 'custom',
      position: { 
        x: 0,
        y: 0
      },
      data: {
        workspaceId,
        label: block.title || 'Block',
        position: block.position,
        type: block.type,
        onDelete: handleDeleteBlock,
        pathId: block.path_id,
        path: path,
        block: block,
        pathLength,
        handleAddBlockOnEdge,
        isLastInPath: true,
        pathName: block.type === 'BEGIN' ? path.name : undefined,
        eventName: block.delay_event,
        seconds: block.delay_seconds,
        delayType: block.delay_type,
        onPathsUpdate: handlePathsUpdate,
        onStrokeLinesUpdate: handleStrokeLinesUpdate,
        updateStrokeLineVisibility,
        strokeLinesVisible: visibility,
        hasSiblings,
        pathHasChildren,
        pathIsMerged,
        longestSiblingPath,
      },
    });
    
    // Link blocks sequentially within a path
    if (index > 0) {
      edges.push({
        id: `edge-${path.blocks[index - 1].id}-${block.id}`,
        source: `block-${path.blocks[index - 1].id}`,
        target: nodeId,
        type: 'smoothstepCustom',
        sourceHandle: 'bottom',
        targetHandle: 'top',
        style: { stroke: '#b1b1b7' },
        data: {
          workspaceId,
          blocks: path.blocks,
          handleAddBlockOnEdge,
          onPathsUpdate: handlePathsUpdate,
          path: path,
        },
      });
    }

    // Sort child paths before processing them
    const sortedChildPaths = sortChildPaths(block.child_paths, allPaths);
    
    // Find the longest blocks array among sibling paths
    let longestSiblingPathLength = 0;
    if (sortedChildPaths.length > 1) {
      longestSiblingPathLength = Math.max(
        ...sortedChildPaths.map(childPathRelation => {
          const fullPath = allPaths.find(p => p.id === childPathRelation.path.id);
          return fullPath?.blocks.length || 0;
        })
      ) - 2;
    }
    // Process each child path in the sorted order
    sortedChildPaths.forEach((childPathRelation) => {
      // Find the full path data from allPaths
      const fullChildPath = allPaths.find(p => p.id === childPathRelation.path.id);
      if (fullChildPath && fullChildPath.blocks.length > 0) {
        // Link parent blocks to the first block of child paths
        const parentBlocks = path.blocks
          .filter(b => fullChildPath.parent_blocks.some(pb => pb.block_id === b.id))
          .map(b => `block-${b.id}`);

        parentBlocks.forEach((parentBlockId) => {
          edges.push({
            id: `edge-${parentBlockId}-${fullChildPath.blocks[0].id}`,
            source: parentBlockId,
            target: `block-${fullChildPath.blocks[0].id}`,
            type: 'smoothstepCustomParent',
            sourceHandle: 'bottom',
            targetHandle: 'top',
            style: { stroke: '#b1b1b7' },
          });
        });
      }
      if (fullChildPath) {
        processPath(
          workspaceId,
          fullChildPath,
          nodes,
          edges,
          handleDeleteBlock,
          handleAddBlockOnEdge,
          visitedPaths,
          handlePathsUpdate,
          handleStrokeLinesUpdate,
          updateStrokeLineVisibility,
          strokeLineVisibilities,
          allPaths,
          block.child_paths.length > 1,
          longestSiblingPathLength
        );
      }
    });
  });
}
</file>

<file path="app/[slug]/[flow]/edit/utils/stroke-lines.ts">
import { toast } from 'sonner';

interface Point {
  x: number;
  y: number;
}

interface StrokeLineData {
  source_block_id: number;
  target_block_id: number;
  workflow_id: number;
  label: string;
  control_points?: Point[];
}

interface UpdateStrokeLineData extends StrokeLineData {
  id: number;
}

/**
 * Creates a new stroke line connection between blocks
 * @param data The stroke line data to create
 * @returns The created stroke line or null if creation failed
 */
export const addStrokeLine = async (data: StrokeLineData) => {
  try {
    const response = await fetch('/api/stroke-lines', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      const errorData = await response.json();
      toast.error(errorData.error || 'Failed to create stroke line');
      return null;
    }

    const strokeLine = await response.json();
    toast.success('Stroke line created successfully');
    return strokeLine;
  } catch (error) {
    console.error('Error creating stroke line:', error);
    toast.error('Failed to create stroke line');
    return null;
  }
};

/**
 * Updates an existing stroke line
 * @param data The stroke line data to update, including the ID
 * @returns The updated stroke line or null if update failed
 */
export const updateStrokeLine = async (data: UpdateStrokeLineData) => {
  try {
    const response = await fetch('/api/stroke-lines', {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      const errorData = await response.json();
      toast.error(errorData.error || 'Failed to update stroke line');
      return null;
    }

    const updatedStrokeLine = await response.json();
    toast.success('Link updated successfully');
    return updatedStrokeLine;
  } catch (error) {
    console.error('Error updating stroke line:', error);
    toast.error('Failed to update stroke line');
    return null;
  }
};

/**
 * Deletes a stroke line by its ID
 * @param id The ID of the stroke line to delete
 * @returns true if deletion was successful, false otherwise
 */
export const deleteStrokeLine = async (id: number) => {
  try {
    const response = await fetch(`/api/stroke-lines?id=${id}`, {
      method: 'DELETE',
    });

    if (!response.ok) {
      const errorData = await response.json();
      toast.error(errorData.error || 'Failed to delete stroke line');
      return false;
    }

    toast.success('Link deleted successfully');
    return true;
  } catch (error) {
    console.error('Error deleting stroke line:', error);
    toast.error('Failed to delete stroke line');
    return false;
  }
};

/**
 * Fetches all stroke lines for a specific workflow
 * @param workflowId The ID of the workflow
 * @returns Array of stroke lines or null if fetch failed
 */
export const getWorkflowStrokeLines = async (workflowId: number) => {
  try {
    const response = await fetch(`/api/stroke-lines?workflow_id=${workflowId}`);

    if (!response.ok) {
      const errorData = await response.json();
      toast.error(errorData.error || 'Failed to fetch stroke lines');
      return null;
    }

    return await response.json();
  } catch (error) {
    console.error('Error fetching stroke lines:', error);
    toast.error('Failed to fetch stroke lines');
    return null;
  }
};

/**
 * Updates control points for a stroke line
 * @param id The ID of the stroke line
 * @param controlPoints Array of control points with x,y coordinates
 * @returns The updated stroke line or null if update failed
 */
export const updateStrokeLineControlPoints = async (id: number, controlPoints: Point[]) => {
  try {
    const response = await fetch(`/api/stroke-lines?id=${id}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        control_points: controlPoints,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error('Failed to update control points:', errorData);
      return null;
    }

    return await response.json();
  } catch (error) {
    console.error('Error updating control points:', error);
    return null;
  }
};
</file>

<file path="app/[slug]/[flow]/edit/utils/toggleEndpoint.ts">
import { Block } from "../../types";

/**
 * Toggle the is_endpoint property for a block, update state, and optionally call a backend.
 * @param blockId The ID of the block to update.
 * @param newValue The new value for is_endpoint.
 * @param allPaths The current array of all paths.
 * @param setAllPaths Function to update all paths.
 * @param onPathsUpdate Optional callback to update paths in parent.
 * @returns void
 */
export async function handleToggleEndpoint(
  blockId: number,
  newValue: boolean,
  allPaths: any[],
  setAllPaths: (paths: any[]) => void,
  onPathsUpdate?: (paths: any[]) => void
) {
  try {
    const response = await fetch(`/api/blocks/${blockId}/toggle-endpoint`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ is_endpoint: newValue }),
    });

    if (!response.ok) {
      throw new Error('Failed to update is_endpoint');
    }

    // Optionally, get the updated block from the response
    // const updatedBlock = await response.json();

    // Update local state only after successful backend update
    const updatedPaths = allPaths.map((path) => ({
      ...path,
      blocks: path.blocks.map((block: Block) =>
        block.id === blockId ? { ...block, is_endpoint: newValue } : block
      ),
    }));
    setAllPaths(updatedPaths);
    if (onPathsUpdate) onPathsUpdate(updatedPaths);
  } catch (error) {
    // Optionally: show error to user
    console.error('Failed to update is_endpoint:', error);
  }
}
</file>

<file path="app/[slug]/[flow]/edit/page.tsx">
import { createClient } from '@/utils/supabase/server';
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';
import { ReactFlowPageClient } from './components/ReactFlowPageClient';
import { Metadata } from 'next';
import getBaseUrl from '@/app/utils/getBaseUrl';

interface PageParams {
  flow: string;
}

interface Workflow {
  id: number;
  name: string;
  icon: string;
  description: string;
  workspace_id: number;
  public_access_id: string;
  folder_id?: number;
  last_opened?: Date;
  updated_at: string;
  created_at: string;
}

export async function generateMetadata({
  params,
}: {
  params: Promise<PageParams>;
}): Promise<Metadata> {
  const resolvedParams = await params;

  // Decode the flow parameter
  const lastPfIndex = resolvedParams.flow.lastIndexOf('--pf-');
  const workflowName = resolvedParams.flow.slice(0, lastPfIndex);
  const workflowId = resolvedParams.flow.slice(lastPfIndex + 5);
  if (!workflowName || !workflowId) {
    return { title: 'ProcessFlow' };
  }
  const headers: HeadersInit = {};

  if (process.env.VERCEL_AUTOMATION_BYPASS_SECRET) {
    headers['x-vercel-protection-bypass'] =
      process.env.VERCEL_AUTOMATION_BYPASS_SECRET;
  }
  const baseUrl = getBaseUrl();

  const response = await fetch(`${baseUrl}/api/workflow/${workflowId}`, {
    headers,
  });

  if (!response.ok) {
    return { title: 'ProcessFlow' };
  }

  const workflow: Workflow = await response.json();
  return {
    title: `${workflow.name} | ProcessFlow`,
  };
}

export default async function ReactFlowPage({
  params,
}: {
  params: Promise<PageParams>;
}) {
  const resolvedParams = await params;

  // Decode the flow parameter
  const lastPfIndex = resolvedParams.flow.lastIndexOf('--pf-');
  const workflowName = resolvedParams.flow.slice(0, lastPfIndex);
  const workflowId = resolvedParams.flow.slice(lastPfIndex + 5);
  if (!workflowName || !workflowId) {
    redirect('/'); // Redirect to root if parameters are invalid
  }

  // Get workflow data from API using path parameter
  const baseUrl = getBaseUrl();
  const headers: HeadersInit = {};

  if (process.env.VERCEL_AUTOMATION_BYPASS_SECRET) {
    headers['x-vercel-protection-bypass'] =
      process.env.VERCEL_AUTOMATION_BYPASS_SECRET;
  }

  const response = await fetch(`${baseUrl}/api/workflow/${workflowId}`, {
    headers,
  });

  if (!response.ok) {
    // Handle unauthorized or not found cases
    let error: any = {};
    const contentType = response.headers.get('content-type');
    if (contentType && contentType.includes('application/json')) {
      error = await response.json();
    }
    if (response.status === 401) {
      redirect('/login');
    } else {
      redirect('/');
    }
  }

  const workflow: Workflow = await response.json();

  return (
    <ReactFlowPageClient
      workspaceId={workflow.workspace_id.toString()}
      workflowId={workflow.id.toString()}
    />
  );
}
</file>

<file path="app/[slug]/[flow]/edit/styles.css">
.connect-mode {
  background-color: rgb(17, 17, 17) !important;  /* Darker background */
}

/* Make sure the background change is smooth */
.react-flow {
  transition: background-color 0.3s ease;
}

.connect-mode .react-flow__node {
  opacity: 0.4;
  transition: opacity 0.3s;
}

.connect-mode .react-flow__edge {
  opacity: 0.4;
  transition: opacity 0.3s;
}

/* Source node and selected node stay visible */
.connect-mode .react-flow__node.source-node,
.connect-mode .react-flow__node.selected-node {
  opacity: 1;
}

/* Preview edge stays visible */
.connect-mode .react-flow__edge.preview-edge {
  opacity: 1;
}

/* Stroke Edge Animation */
.react-flow__edge-path.stroke-edge-animated {
  stroke-width: 2 !important;
  stroke: #FF69A3 !important;
  stroke-dasharray: 5 !important;
  pointer-events: none;
  animation: flowAnimation 30s linear infinite;
}

@keyframes flowAnimation {
  0% {
    stroke-dashoffset: 0;
  }
  100% {
    stroke-dashoffset: 1000;
  }
}
</file>

<file path="app/[slug]/[flow]/read/components/steps/BaseStep.ts">
import { Block, Path } from '../../../types';

export interface BaseStepProps {
  block: Block;
  isActive?: boolean;
  className?: string;
  defaultExpanded?: boolean;
  onToggle?: (isExpanded: boolean) => void;
  children?: React.ReactNode;
  stepRef?: React.RefObject<HTMLDivElement>;
  selectedOptionIds?: [number, number][];
  onOptionSelect?: (optionId: number, blockId: number, isMerge?: boolean) => void;
  isLastStep?: boolean;
  copyPaths?: Path[];
  variant?: 'default' | 'last';
  icon?: string | React.ReactNode;
}
</file>

<file path="app/[slug]/[flow]/read/components/steps/HorizontalDelay.tsx">
import React from 'react';
import { cn } from '@/lib/utils';
import { useColors } from '@/app/theme/hooks';
import { BaseStepProps } from './BaseStep';
import Image from 'next/image';
import { DelayType } from '../../../types';
import { motion, AnimatePresence } from 'framer-motion';

interface HorizontalDelayProps extends BaseStepProps {
  selectedOptionIds?: [number, number][];
  onOptionSelect?: (
    optionId: number,
    blockId: number,
    isMerge?: boolean
  ) => void;
}

export default function HorizontalDelay({
  block,
  selectedOptionIds,
  onOptionSelect,
}: HorizontalDelayProps) {
  const colors = useColors();

  const handleOptionSelect = (
    optionId: number,
    blockId: number,
    isMerge?: boolean
  ) => {
    onOptionSelect?.(optionId, blockId, isMerge);
  };

  const getDelayText = () => {
    if (block.delay_type === DelayType.WAIT_FOR_EVENT) {
      return block.delay_event;
    } else {
      const seconds = block.delay_seconds || 0;
      const days = Math.floor(seconds / 86400);
      const hours = Math.floor((seconds % 86400) / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);

      const parts = [];
      if (days > 0) parts.push(`${days} ${days === 1 ? 'day' : 'days'}`);
      if (hours > 0) parts.push(`${hours} ${hours === 1 ? 'hour' : 'hours'}`);
      if (minutes > 0)
        parts.push(`${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`);

      return parts.length > 0 ? parts.join(' and ') : '';
    }
  };

  const renderTitleWithLineBreaks = (title: string, chunkSize = 70) => {
    if (!title) return null;
    const chunks = [];
    for (let i = 0; i < title.length; i += chunkSize) {
      chunks.push(title.slice(i, i + chunkSize));
    }
    // Interleave <br /> except after the last chunk
    return chunks.map((chunk, idx) => (
      <React.Fragment key={idx}>
        {chunk}
        {idx < chunks.length - 1 && <br />}
      </React.Fragment>
    ));
  };
  
  const getDelayIcon = () => {
    if (block.delay_type === DelayType.WAIT_FOR_EVENT) {
      return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/calendar-clock-1.svg`;
    }
    return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/clock-stopwatch-1.svg`;
  };

  const getDelayTitle = () => {
    return block.delay_type === DelayType.WAIT_FOR_EVENT
      ? 'Event-Based Delay'
      : 'Fixed Duration';
  };

  const expirationText = () => {
    if (!block.delay_seconds) return '';
    const days = Math.floor(block.delay_seconds / 86400);
    const hours = Math.floor((block.delay_seconds % 86400) / 3600);
    const minutes = Math.floor((block.delay_seconds % 3600) / 60);

    const parts = [];
    if (days > 0) parts.push(`${days} ${days === 1 ? 'day' : 'days'}`);
    if (hours > 0) parts.push(`${hours} ${hours === 1 ? 'hour' : 'hours'}`);
    if (minutes > 0)
      parts.push(`${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`);

    return parts.length > 0 ? `${parts.join(' and ')}` : '';
  };

  if (block.delay_type === DelayType.FIXED_DURATION) {
    return (
      <div className="flex flex-col gap-4">
        <div className="flex flex-col gap-6">
          <div className="flex items-center gap-4">
            <div
              className={cn(
                'rounded-[6px] border shadow-sm flex items-center justify-center',
                'w-12 h-12'
              )}
              style={{
                backgroundColor: colors['bg-primary'],
                borderColor: colors['border-secondary'],
              }}
            >
              <Image src={getDelayIcon()} alt="Delay" width={24} height={24} />
            </div>
            <span
              className={cn('font-semibold', 'text-base')}
              style={{ color: colors['text-primary'] }}
            >
              {getDelayTitle()}
            </span>
          </div>

          <div
            className={cn(
              'flex items-center gap-2 p-3 rounded-lg bg-opacity-5'
            )}
            style={{ backgroundColor: colors['bg-secondary'] }}
          >
            <Image
              src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/pause-circle.svg`}
              alt="Info"
              width={20}
              height={20}
            />
            <span
              className={cn('text-sm whitespace-pre-line')}
              style={{ color: colors['text-secondary'] }}
            >
              Flow paused for {getDelayText()}
            </span>
          </div>

          {block.child_paths && block.child_paths.length > 0 && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.2, delay: 0.1 }}
              className="mt-4"
            >
              <p
                className="text-sm font-medium mb-4"
                style={{ color: colors['text-primary'] }}
              >
                Select an option
              </p>
              <div className="space-y-2">
                {block.child_paths.map((option, index) => (
                  <motion.button
                    key={option.path.id}
                    onClick={() =>
                      handleOptionSelect(option.path.id, block.id, false)
                    }
                    className={cn(
                      'w-full p-4 rounded-lg border transition-colors duration-200 will-change-transform',
                      'flex items-start gap-3 text-left',
                      selectedOptionIds?.some(
                        ([pathId, blockId]) =>
                          pathId === option.path.id && blockId === block.id
                      ) && 'border-brand'
                    )}
                    initial={{ opacity: 0, y: -10 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{
                      duration: 0.2,
                      delay: 0.1 + index * 0.05,
                    }}
                    whileHover={{ scale: 1.01 }}
                    whileTap={{ scale: 0.99 }}
                    style={{
                      backgroundColor: colors['bg-primary'],
                      borderColor: selectedOptionIds?.some(
                        ([pathId, blockId]) =>
                          pathId === option.path.id && blockId === block.id
                      )
                        ? colors['border-brand']
                        : colors['border-secondary'],
                      transform: 'translateZ(0)',
                    }}
                  >
                    <div
                      className="w-5 h-5 rounded-full border-2 flex-shrink-0 flex items-center justify-center"
                      style={{
                        borderColor: selectedOptionIds?.some(
                          ([pathId, blockId]) =>
                            pathId === option.path.id && blockId === block.id
                        )
                          ? colors['border-brand']
                          : colors['border-secondary'],
                        backgroundColor: selectedOptionIds?.some(
                          ([pathId, blockId]) =>
                            pathId === option.path.id && blockId === block.id
                        )
                          ? colors['bg-brand-solid']
                          : 'transparent',
                      }}
                    >
                      <AnimatePresence>
                        {selectedOptionIds?.some(
                          ([pathId, blockId]) =>
                            pathId === option.path.id && blockId === block.id
                        ) && (
                          <motion.div
                            className="w-2 h-2 bg-white rounded-full"
                            initial={{ scale: 0 }}
                            animate={{ scale: 1 }}
                            exit={{ scale: 0 }}
                            transition={{ duration: 0.2 }}
                          />
                        )}
                      </AnimatePresence>
                    </div>
                    <div className="flex flex-col gap-1">
                      <p
                        className="font-normal text-sm"
                        style={{ color: colors['text-primary'] }}
                      >
                        {option.path.name}
                      </p>
                    </div>
                  </motion.button>
                ))}
              </div>
            </motion.div>
          )}
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-4">
      <div className="flex flex-col gap-6">
        <div className="flex flex-col gap-4">
          <div className="flex items-center gap-4">
            <div
              className={cn(
                'rounded-[6px] border shadow-sm flex items-center justify-center',
                'w-12 h-12'
              )}
              style={{
                backgroundColor: colors['bg-primary'],
                borderColor: colors['border-secondary'],
              }}
            >
              <Image src={getDelayIcon()} alt="Delay" width={24} height={24} />
            </div>
            <span
              className={cn('font-semibold', 'text-base')}
              style={{ color: colors['text-primary'] }}
            >
              {getDelayTitle()}
            </span>
          </div>

          <div className="flex flex-col gap-2">
            <div className="flex items-center gap-2">
              <span
                className={cn('text-sm')}
                style={{ color: colors['text-secondary'] }}
              >
                Waiting for:
              </span>
              <span
                className={cn(
                  'text-sm whitespace-pre-line break-words line-clamp-2'
                )}
                style={{ color: colors['text-primary'] }}
              >
                {getDelayText()}
              </span>
            </div>

            {(block.delay_seconds ?? 0) > 0 && (
              <div className="flex items-center gap-2">
                <Image
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/hourglass-01.svg`}
                  alt="Clock"
                  width={16}
                  height={16}
                />
                <span
                  className={cn('text-sm')}
                  style={{ color: colors['text-secondary'] }}
                >
                  Expires after {expirationText()}
                </span>
              </div>
            )}
          </div>
        </div>

        <div
          className={cn('flex items-center gap-2 p-3 rounded-lg bg-opacity-5')}
          style={{ backgroundColor: colors['bg-secondary'] }}
        >
          <Image
            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/pause-circle.svg`}
            alt="Info"
            width={20}
            height={20}
          />
          <span
            className={cn('text-sm')}
            style={{ color: colors['text-secondary'] }}
          >
            {(block.delay_seconds ?? 0) > 0
              ? 'Flow paused until event occurs or time expires'
              : 'Flow paused until event occurs'}
          </span>
        </div>

        {block.child_paths && block.child_paths.length > 0 && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.2, delay: 0.1 }}
            className="mt-4"
          >
            <p
              className="text-sm font-medium mb-4"
              style={{ color: colors['text-primary'] }}
            >
              Select an option
            </p>
            <div className="space-y-2">
              {block.child_paths.map((option, index) => (
                <motion.button
                  key={option.path.id}
                  onClick={() =>
                    handleOptionSelect(option.path.id, block.id, false)
                  }
                  className={cn(
                    'w-full p-4 rounded-lg border transition-colors duration-200 will-change-transform',
                    'flex items-start gap-3 text-left',
                    selectedOptionIds?.some(
                      ([pathId, blockId]) =>
                        pathId === option.path.id && blockId === block.id
                    ) && 'border-brand'
                  )}
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{
                    duration: 0.2,
                    delay: 0.1 + index * 0.05,
                  }}
                  whileHover={{ scale: 1.01 }}
                  whileTap={{ scale: 0.99 }}
                  style={{
                    backgroundColor: colors['bg-primary'],
                    borderColor: selectedOptionIds?.some(
                      ([pathId, blockId]) =>
                        pathId === option.path.id && blockId === block.id
                    )
                      ? colors['border-brand']
                      : colors['border-secondary'],
                    transform: 'translateZ(0)',
                  }}
                >
                  <div
                    className="w-5 h-5 rounded-full border-2 flex-shrink-0 flex items-center justify-center"
                    style={{
                      borderColor: selectedOptionIds?.some(
                        ([pathId, blockId]) =>
                          pathId === option.path.id && blockId === block.id
                      )
                        ? colors['border-brand']
                        : colors['border-secondary'],
                      backgroundColor: selectedOptionIds?.some(
                        ([pathId, blockId]) =>
                          pathId === option.path.id && blockId === block.id
                      )
                        ? colors['bg-brand-solid']
                        : 'transparent',
                    }}
                  >
                    <AnimatePresence>
                      {selectedOptionIds?.some(
                        ([pathId, blockId]) =>
                          pathId === option.path.id && blockId === block.id
                      ) && (
                        <motion.div
                          className="w-2 h-2 bg-white rounded-full"
                          initial={{ scale: 0 }}
                          animate={{ scale: 1 }}
                          exit={{ scale: 0 }}
                          transition={{ duration: 0.2 }}
                        />
                      )}
                    </AnimatePresence>
                  </div>
                  <div className="flex flex-col gap-1">
                    <p
                      className="font-normal text-sm break-words line-clamp-2"
                      style={{ color: colors['text-primary'] }}
                    >
                      {renderTitleWithLineBreaks(option.path.name)}
                    </p>
                  </div>
                </motion.button>
              ))}
            </div>
          </motion.div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/read/components/steps/HorizontalLastStep.tsx">
import React from 'react';
import { useColors } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';
import { BaseStepProps } from './BaseStep';
import { cn } from '@/lib/utils';

interface HorizontalLastStepProps {
  onCopyLink: () => void;
  onRestart: () => void;
}

export default function HorizontalLastStep({
  onCopyLink,
  onRestart,
}: HorizontalLastStepProps) {
  const colors = useColors();

  return (
    <div className="flex flex-col items-center justify-center gap-4 h-full">
      <div
        className="flex-shrink-0 w-12 h-12 rounded-md flex items-center justify-center border"
        style={{
          backgroundColor: colors['bg-secondary'],
          borderColor: colors['border-secondary'],
        }}
      >
        <img
          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-circle.svg`}
          alt="Success"
          className="w-6 h-6"
        />
      </div>
      <h3
        className="text-xl font-medium"
        style={{ color: colors['text-primary'] }}
      >
        Congratulations! You've completed the process.
      </h3>
      <p
        className="text-base mb-4 text-center"
        style={{ color: colors['text-secondary'] }}
      >
        Share it with your team members!
      </p>
      <ButtonNormal
        variant="primary"
        size="small"
        onClick={onCopyLink}
        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/link-02-white.svg`}
      >
        Copy link
      </ButtonNormal>
      <ButtonNormal
        variant="tertiary"
        size="small"
        onClick={onRestart}
        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/refresh-cw-01.svg`}
      >
        Restart process
      </ButtonNormal>
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/read/components/steps/HorizontalStep.tsx">
import React, {
  useState,
  useEffect,
  useRef,
  useLayoutEffect,
  useMemo,
} from 'react';
import { useColors } from '@/app/theme/hooks';
import { BaseStepProps } from './BaseStep';
import DynamicIcon from '@/utils/DynamicIcon';
import { Block } from '../../../types';
import { motion, AnimatePresence } from 'framer-motion';
import { cn } from '@/lib/utils';
import { formatTime, isValidTime } from '../../utils/timeUtils';
import { generateWorkspaceURL } from '@/app/api/utils/generateWorkspaceURL';
// ... other imports

interface HorizontalStepProps extends BaseStepProps {
  isFirstStep?: boolean;
}

// Add a style tag to hide scrollbars globally
const HideScrollbarStyles = () => (
  <style jsx global>{`
    .hide-scrollbar {
      -ms-overflow-style: none; /* IE and Edge */
      scrollbar-width: none; /* Firefox */
    }
    .hide-scrollbar::-webkit-scrollbar {
      display: none; /* Chrome, Safari and Opera */
    }
  `}</style>
);

// Regular expression to match URLs
const URL_REGEX = /(https?:\/\/[^\s]+)/g;

export default function HorizontalStep({
  block,
  selectedOptionIds,
  onOptionSelect,
  isFirstStep = false,
}: HorizontalStepProps) {
  const colors = useColors();
  const [imageLoaded, setImageLoaded] = useState<boolean>(false);
  const [imageError, setImageError] = useState<boolean>(false);
  const contentRef = useRef<HTMLDivElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [scrollbarThumbHeight, setScrollbarThumbHeight] = useState<
    number | null
  >(null);
  const [contentHeight, setContentHeight] = useState<number>(0);
  const [containerHeight, setContainerHeight] = useState<number>(0);
  const [scrollTop, setScrollTop] = useState<number>(0);
  const [windowWidth, setWindowWidth] = useState<number>(0);
  const [windowHeight, setWindowHeight] = useState<number>(0);
  const [isImageFullscreen, setIsImageFullscreen] = useState(false);
  const [zoomLevel, setZoomLevel] = useState(1);
  const [isDragging, setIsDragging] = useState(false);
  const [dragPosition, setDragPosition] = useState({ x: 0, y: 0 });
  const imageContainerRef = useRef<HTMLDivElement>(null);
  const descriptionRef = useRef<HTMLDivElement>(null);
  const [descriptionHeight, setDescriptionHeight] = useState(0);

  // Generate image URL directly using generateWorkspaceURL
  const imageUrl = useMemo(() => {
    if (!block.image) return null;
    try {
      return generateWorkspaceURL(block.image);
    } catch (error) {
      console.error('Error generating workspace URL:', error);
      return null;
    }
  }, [block.image]);

  // Add null check for block
  if (!block) {
    return null;
  }

  // Check if the step has both image and options
  const hasBothImageAndOptions =
    block.image && block.child_paths && block.child_paths.length > 0;

  // Check if there's only description (no image or options)
  const hasOnlyDescription =
    !block.image && (!block.child_paths || block.child_paths.length === 0);

  // Reset scroll position when block changes
  useEffect(() => {
    if (contentRef.current) {
      contentRef.current.scrollTop = 0;
      setScrollTop(0);
    }
  }, [block.id]); // Use block.id to ensure we only reset on actual block changes

  // Update window size
  useEffect(() => {
    const updateWindowDimensions = () => {
      setWindowWidth(window.innerWidth);
      setWindowHeight(window.innerHeight);
    };

    // Initialize
    updateWindowDimensions();

    // Add event listener
    window.addEventListener('resize', updateWindowDimensions);

    // Clean up
    return () => {
      window.removeEventListener('resize', updateWindowDimensions);
    };
  }, []);

  // Update scrollbar thumb size based on content
  useEffect(() => {
    const updateScrollThumb = () => {
      if (contentRef.current && containerRef.current) {
        const contentScrollHeight = contentRef.current.scrollHeight;
        const containerClientHeight = containerRef.current.clientHeight;

        setContentHeight(contentScrollHeight);
        setContainerHeight(containerClientHeight);

        // If content is taller than container, calculate ratio for thumb
        if (contentScrollHeight > containerClientHeight) {
          const ratio = containerClientHeight / contentScrollHeight;
          const minThumbSize = Math.max(
            20,
            Math.min(30, containerClientHeight * 0.1)
          );
          const thumbHeight = Math.max(
            minThumbSize,
            containerClientHeight * ratio
          );
          setScrollbarThumbHeight(thumbHeight);
        } else {
          setScrollbarThumbHeight(null); // Hide scrollbar when not needed
        }
      }
    };

    updateScrollThumb();

    // Set up resize observer to detect content changes
    const resizeObserver = new ResizeObserver(updateScrollThumb);
    if (contentRef.current) {
      resizeObserver.observe(contentRef.current);
    }
    if (containerRef.current) {
      resizeObserver.observe(containerRef.current);
    }

    return () => {
      resizeObserver.disconnect();
    };
  }, [block, imageUrl, windowWidth, imageLoaded]);

  // Add scroll event listener to track scroll position
  useEffect(() => {
    const contentElement = contentRef.current;

    const handleScroll = () => {
      if (contentElement) {
        setScrollTop(contentElement.scrollTop);
      }
    };

    if (contentElement) {
      contentElement.addEventListener('scroll', handleScroll);
    }

    return () => {
      if (contentElement) {
        contentElement.removeEventListener('scroll', handleScroll);
      }
    };
  }, []);

  // Custom scrollbar click handler
  const handleScrollbarClick = (e: React.MouseEvent<HTMLDivElement>) => {
    if (contentRef.current) {
      const track = e.currentTarget;
      const trackRect = track.getBoundingClientRect();
      const clickPosition = e.clientY - trackRect.top;
      const percentage = clickPosition / trackRect.height;

      const scrollPosition = percentage * (contentHeight - containerHeight);
      contentRef.current.scrollTop = scrollPosition;
    }
  };

  // Calculate appropriate scrollbar width based on viewport
  const getScrollbarWidth = () => {
    if (windowWidth <= 640) {
      return 3; // 3px on small screens (mobile)
    } else if (windowWidth <= 1024) {
      return 4; // 4px on medium screens (tablet)
    } else {
      return 6; // 6px on large screens (desktop)
    }
  };

  const scrollbarWidth = getScrollbarWidth();

  // Calculate if scrollbar should be visible
  const showScrollbar = contentHeight > containerHeight;

  // Calculate thumb position
  const thumbPosition =
    contentHeight <= containerHeight
      ? 0
      : (scrollTop / (contentHeight - containerHeight)) *
        (containerHeight - (scrollbarThumbHeight || 0));

  const getIconPath = (block: Block) => {
    if (block.icon && block.signedIconUrl) {
      return `${block.signedIconUrl}`;
    }

    return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/container.svg`;
  };

  const getDisplayTitle = (block: Block) => {
    if (block.title) return block.title;

    // Convert block type from ALL_CAPS to Title Case
    const typeName = block.type
      .toLowerCase()
      .replace(/_/g, ' ')
      .split(' ')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');

    return `${typeName}`;
  };

  // Reset zoom and drag when closing fullscreen
  useEffect(() => {
    if (!isImageFullscreen) {
      setZoomLevel(1);
      setDragPosition({ x: 0, y: 0 });
    }
  }, [isImageFullscreen]);

  // Handle wheel event for zooming
  useEffect(() => {
    const handleWheel = (e: WheelEvent) => {
      if (!isImageFullscreen) return;
      e.preventDefault();
      if (e.deltaY < 0) {
        setZoomLevel((prev) => Math.min(prev + 0.1, 5));
      } else {
        setZoomLevel((prev) => Math.max(prev - 0.1, 0.5));
      }
    };
    const container = imageContainerRef.current;
    if (container) {
      container.addEventListener('wheel', handleWheel, { passive: false });
    }
    return () => {
      if (container) {
        container.removeEventListener('wheel', handleWheel);
      }
    };
  }, [isImageFullscreen, imageContainerRef]);

  // ESC key to close fullscreen
  useEffect(() => {
    const handleEscKey = (event: KeyboardEvent) => {
      if (event.key === 'Escape' && isImageFullscreen) {
        setIsImageFullscreen(false);
      }
    };
    window.addEventListener('keydown', handleEscKey);
    return () => {
      window.removeEventListener('keydown', handleEscKey);
    };
  }, [isImageFullscreen]);

  // Prevent body scroll when fullscreen
  useEffect(() => {
    if (isImageFullscreen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = '';
    }
    return () => {
      document.body.style.overflow = '';
    };
  }, [isImageFullscreen]);

  const toggleFullscreen = (e: React.MouseEvent) => {
    e.stopPropagation();
    setIsImageFullscreen(!isImageFullscreen);
  };
  const zoomIn = (e: React.MouseEvent) => {
    e.stopPropagation();
    setZoomLevel((prev) => Math.min(prev + 0.1, 5));
  };
  const zoomOut = (e: React.MouseEvent) => {
    e.stopPropagation();
    setZoomLevel((prev) => Math.max(prev - 0.1, 0.5));
  };
  const resetZoom = (e?: React.MouseEvent) => {
    if (e) e.stopPropagation();
    setZoomLevel(1);
    setDragPosition({ x: 0, y: 0 });
  };
  const handleMouseDown = (e: React.MouseEvent) => {
    if (zoomLevel <= 1) return;
    e.preventDefault();
    setIsDragging(true);
  };
  const handleMouseMove = (e: React.MouseEvent) => {
    if (!isDragging || zoomLevel <= 1) return;
    setDragPosition((prev) => ({
      x: prev.x + e.movementX,
      y: prev.y + e.movementY,
    }));
  };
  const handleMouseUp = () => {
    setIsDragging(false);
  };
  const handleDoubleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    resetZoom();
  };

  // Add this function to parse text into segments with links
  const parseTextWithLinks = (text: string) => {
    const parts = [];
    let lastIndex = 0;
    let match;

    while ((match = URL_REGEX.exec(text)) !== null) {
      // Add text before the link
      if (match.index > lastIndex) {
        parts.push({
          type: 'text',
          content: text.slice(lastIndex, match.index),
        });
      }

      // Add the link
      parts.push({
        type: 'link',
        content: match[0],
      });

      lastIndex = match.index + match[0].length;
    }

    // Add remaining text after last link
    if (lastIndex < text.length) {
      parts.push({
        type: 'text',
        content: text.slice(lastIndex),
      });
    }

    return parts.length > 0 ? parts : [{ type: 'text', content: text }];
  };

  // Helper function to split a string into chunks of N characters and render with <br />
  const renderTitleWithLineBreaks = (title: string, chunkSize = 50) => {
    if (!title) return null;
    const chunks = [];
    for (let i = 0; i < title.length; i += chunkSize) {
      chunks.push(title.slice(i, i + chunkSize));
    }
    // Interleave <br /> except after the last chunk
    return chunks.map((chunk, idx) => (
      <React.Fragment key={idx}>
        {chunk}
        {idx < chunks.length - 1 && <br />}
      </React.Fragment>
    ));
  };

  useLayoutEffect(() => {
    if (descriptionRef.current) {
      setDescriptionHeight(descriptionRef.current.offsetHeight);
    }
  }, [block.description, block.id]);

  return (
    <>
      <HideScrollbarStyles />
      <div
        ref={containerRef}
        className={cn('h-[472px] overflow-hidden relative flex flex-col')}
      >
        {/* Main scrollable container */}
        <div
          ref={contentRef}
          className={cn(
            'flex-1 overflow-y-auto overflow-x-hidden hide-scrollbar',
            hasOnlyDescription &&
              descriptionHeight <= windowHeight * 0.5 &&
              'flex items-center justify-center',
            !hasOnlyDescription && ''
          )}
        >
          <div
            className={cn(
              'w-full',
              hasOnlyDescription && descriptionHeight <= windowHeight * 0.5
                ? 'flex flex-col items-center justify-center px-5'
                : 'px-5 py-5'
            )}
          >
            {/* Header Section */}
            <div
              className={cn(
                hasOnlyDescription && descriptionHeight <= windowHeight * 0.5
                  ? ''
                  : 'w-full px-5 pt-5 pb-4'
              )}
            >
              {/* Step Header */}
              <div className="flex items-center gap-4 mb-4">
                {/* App Icon */}
                <div
                  className="flex-shrink-0 w-12 h-12 rounded-[6px] border shadow-sm flex items-center justify-center"
                  style={{
                    backgroundColor: colors['bg-primary'],
                    borderColor: colors['border-secondary'],
                  }}
                >
                  <div className="flex items-center justify-center">
                    {block.icon &&
                    block.icon.startsWith('https://cdn.brandfetch.io/') ? (
                      <img
                        src={block.icon}
                        alt="Step Icon"
                        className="w-6 h-6"
                        referrerPolicy="strict-origin-when-cross-origin"
                      />
                    ) : (
                      <img
                        src={getIconPath(block)}
                        alt="Step Icon"
                        className="w-6 h-6"
                        onError={(e) => {
                          e.currentTarget.src = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon-base.svg`;
                        }}
                      />
                    )}
                  </div>
                </div>
                {/* Step Title and Time */}
                <div className="flex-1 flex flex-col gap-2">
                  <div
                    className="flex items-center text-base font-semibold break-words line-clamp-2 whitespace-pre-line"
                    style={{ color: colors['text-primary'] }}
                  >
                    <span>
                      {renderTitleWithLineBreaks(getDisplayTitle(block))}
                    </span>
                  </div>
                  {/* Time Display - moved under title */}
                  {isValidTime(block.average_time) && (
                    <div className="flex items-center gap-1.5">
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/clock-stopwatch-1.svg`}
                        alt="Time"
                        className="w-3.5 h-3.5 opacity-60"
                      />
                      <span
                        className="text-xs font-medium"
                        style={{ color: colors['text-tertiary'] }}
                      >
                        {formatTime(block.average_time)}
                      </span>
                    </div>
                  )}
                </div>
              </div>

              {/* Description */}
              <div className="relative w-full">
                <p
                  ref={descriptionRef}
                  className="text-base whitespace-pre-line w-[460px] break-words"
                  style={{ color: colors['text-quaternary'] }}
                >
                  {parseTextWithLinks(block.description || '').map(
                    (segment, index) =>
                      segment.type === 'link' ? (
                        <a
                          key={index}
                          href={segment.content}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="text-blue-500 hover:underline break-all"
                          onClick={(e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            window.open(
                              segment.content,
                              '_blank',
                              'noopener,noreferrer'
                            );
                          }}
                        >
                          {segment.content}
                        </a>
                      ) : (
                        <span key={index}>{segment.content}</span>
                      )
                  )}
                </p>
              </div>
            </div>

            {/* Content Section */}
            {!hasOnlyDescription && (
              <div className="px-5 pb-16 w-full">
                <div className="space-y-6 w-full">
                  {/* Image Section */}
                  {block.image && (
                    <div
                      className="rounded-lg overflow-hidden w-full bg-[#fafafa] dark:bg-[#1c1c1c] mb-4 cursor-zoom-in"
                      onClick={toggleFullscreen}
                      aria-label="View image fullscreen"
                      style={{ backgroundColor: colors['bg-secondary'] }}
                    >
                      {imageUrl && !imageError ? (
                        <img
                          src={imageUrl}
                          alt="Step visualization"
                          className="w-full h-[500px] object-contain"
                          onLoad={() => setImageLoaded(true)}
                          onError={() => setImageError(true)}
                        />
                      ) : (
                        <div
                          className="w-full h-40 flex items-center justify-center"
                          style={{ backgroundColor: colors['bg-secondary'] }}
                        >
                          <div
                            className="w-8 h-8 rounded-full"
                            style={{ backgroundColor: colors['bg-tertiary'] }}
                          />
                        </div>
                      )}
                    </div>
                  )}

                  {/* Options Section */}
                  {block.child_paths && block.child_paths.length > 0 && (
                    <div className="w-full">
                      <p
                        className="text-sm font-medium mb-4"
                        style={{ color: colors['text-primary'] }}
                      >
                        Select an option
                      </p>
                      <div className="space-y-2">
                        {block.child_paths.map((option, index) => (
                          <div key={option.path.id} className="overflow-hidden">
                            <motion.button
                              onClick={() =>
                                onOptionSelect?.(
                                  option.path.id,
                                  block.id,
                                  false
                                )
                              }
                              className={cn(
                                'w-full p-4 rounded-lg border transition-all duration-200',
                                'flex items-center gap-3 text-left hover:bg-secondary active:bg-secondary',
                                selectedOptionIds?.some(
                                  ([pathId, blockId]) =>
                                    pathId === option.path.id &&
                                    blockId === block.id
                                ) && 'border-brand'
                              )}
                              initial={{ opacity: 0.4 }}
                              animate={{
                                opacity: 1,
                                transition: {
                                  duration: 0.2,
                                  ease: 'easeOut',
                                  delay: index * 0.05,
                                },
                              }}
                              style={{
                                backgroundColor: colors['bg-primary'],
                                borderColor: selectedOptionIds?.some(
                                  ([pathId, blockId]) =>
                                    pathId === option.path.id &&
                                    blockId === block.id
                                )
                                  ? colors['border-brand']
                                  : colors['border-secondary'],
                              }}
                            >
                              <div
                                className="w-5 h-5 rounded-full border-2 flex-shrink-0 flex items-center justify-center"
                                style={{
                                  borderColor: selectedOptionIds?.some(
                                    ([pathId, blockId]) =>
                                      pathId === option.path.id &&
                                      blockId === block.id
                                  )
                                    ? colors['border-brand']
                                    : colors['border-secondary'],
                                  backgroundColor: selectedOptionIds?.some(
                                    ([pathId, blockId]) =>
                                      pathId === option.path.id &&
                                      blockId === block.id
                                  )
                                    ? colors['bg-brand-solid']
                                    : 'transparent',
                                }}
                              >
                                <AnimatePresence>
                                  {selectedOptionIds?.some(
                                    ([pathId, blockId]) =>
                                      pathId === option.path.id &&
                                      blockId === block.id
                                  ) && (
                                    <motion.div
                                      className="w-2 h-2 bg-white rounded-full"
                                      initial={{ scale: 0 }}
                                      animate={{ scale: 1 }}
                                      exit={{ scale: 0 }}
                                      transition={{ duration: 0.2 }}
                                    />
                                  )}
                                </AnimatePresence>
                              </div>
                              <div className="flex flex-col gap-1">
                                <p
                                  className="font-normal text-sm break-words line-clamp-2"
                                  style={{ color: colors['text-primary'] }}
                                >
                                  {renderTitleWithLineBreaks(option.path.name)}
                                </p>
                              </div>
                            </motion.button>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              </div>
            )}
          </div>
        </div>

        {/* Custom scrollbar */}
        {showScrollbar && (
          <div
            className="absolute top-4 bottom-4 rounded-full cursor-pointer"
            style={{
              right: windowWidth <= 640 ? '2px' : '4px',
              width: `${scrollbarWidth}px`,
              backgroundColor: 'rgba(0,0,0,0.05)',
            }}
            onClick={handleScrollbarClick}
          >
            <div
              className="absolute rounded-full transition-all duration-100"
              style={{
                width: `${scrollbarWidth}px`,
                backgroundColor: colors['border-secondary'],
                height: `${scrollbarThumbHeight}px`,
                top: `${thumbPosition}px`,
                opacity: 0.8,
              }}
            />
          </div>
        )}
      </div>

      {/* Fullscreen Modal */}
      {isImageFullscreen && imageUrl && (
        <div
          className="fixed inset-0 z-[9999] bg-black/90 flex items-center justify-center"
          onClick={() => setIsImageFullscreen(false)}
          style={{ backdropFilter: 'blur(4px)' }}
        >
          {/* Close button */}
          <button
            className="absolute top-4 right-4 z-10 p-2 rounded-full bg-black/50 cursor-pointer hover:bg-black/70 transition-colors"
            onClick={() => setIsImageFullscreen(false)}
            aria-label="Close fullscreen view"
          >
            <svg
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M18 6L6 18M6 6L18 18"
                stroke="white"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              />
            </svg>
          </button>
          {/* Help tooltip */}
          <div className="absolute top-4 left-4 z-10 text-white font-normal text-sm bg-black/50 px-3 py-2 rounded-md">
            <span className="hidden sm:inline">
              Use mouse wheel to zoom  Double-click to reset {' '}
              {Math.round(zoomLevel * 100)}%
            </span>
            <span className="sm:hidden">{Math.round(zoomLevel * 100)}%</span>
          </div>
          {/* Zoom controls */}
          <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex space-x-2 bg-black/50 p-2 rounded-lg z-10">
            <button
              onClick={zoomOut}
              className="p-2 bg-gray-800 hover:bg-gray-700 rounded-full transition-colors"
              aria-label="Zoom out"
            >
              <svg
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M5 12H19"
                  stroke="white"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
              </svg>
            </button>
            <button
              onClick={resetZoom}
              className="p-2 bg-gray-800 hover:bg-gray-700 rounded-full transition-colors"
              aria-label="Reset zoom"
            >
              <svg
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M15 15L21 21M17 10C17 13.866 13.866 17 10 17C6.13401 17 3 13.866 3 10C3 6.13401 6.13401 3 10 3C13.866 3 17 6.13401 17 10Z"
                  stroke="white"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
              </svg>
            </button>
            <button
              onClick={zoomIn}
              className="p-2 bg-gray-800 hover:bg-gray-700 rounded-full transition-colors"
              aria-label="Zoom in"
            >
              <svg
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M12 5V19M5 12H19"
                  stroke="white"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
              </svg>
            </button>
          </div>
          {/* Image container with drag functionality */}
          <div
            ref={imageContainerRef}
            className={cn(
              'relative w-[90vw] h-[90vh] flex items-center justify-center overflow-hidden',
              zoomLevel > 1 ? 'cursor-grab' : '',
              isDragging && zoomLevel > 1 ? 'cursor-grabbing' : ''
            )}
            onClick={(e) => e.stopPropagation()}
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
            onDoubleClick={handleDoubleClick}
          >
            <div
              className="transition-all duration-200 ease-out"
              style={{
                transform: `scale(${zoomLevel}) translate(${dragPosition.x}px, ${dragPosition.y}px)`,
                transformOrigin: 'center center',
              }}
            >
              <img
                src={imageUrl}
                alt="Block Media Fullscreen"
                className="max-h-full max-w-full object-contain"
                style={{ pointerEvents: 'none' }}
                draggable="false"
              />
            </div>
          </div>
        </div>
      )}
    </>
  );
}
</file>

<file path="app/[slug]/[flow]/read/components/steps/VerticalDelay.tsx">
import React from 'react';
import { cn } from '@/lib/utils';
import { useColors } from '@/app/theme/hooks';
import { motion, AnimatePresence } from 'framer-motion';
import { BaseStepProps } from './BaseStep';
import Image from 'next/image';
import { DelayType } from '../../../types';

export default function VerticalDelay({
  block,
  isActive = false,
  className,
  isLastStep = false,
  selectedOptionIds,
  onOptionSelect,
}: BaseStepProps & {
  selectedOptionIds?: [number, number][];
  onOptionSelect?: (
    optionId: number,
    blockId: number,
    isMerge?: boolean
  ) => void;
}) {
  const colors = useColors();

  const slideUpVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0 },
  };

  const renderTitleWithLineBreaks = (title: string, chunkSize = 90) => {
    if (!title) return null;
    const chunks = [];
    for (let i = 0; i < title.length; i += chunkSize) {
      chunks.push(title.slice(i, i + chunkSize));
    }
    // Interleave <br /> except after the last chunk
    return chunks.map((chunk, idx) => (
      <React.Fragment key={idx}>
        {chunk}
        {idx < chunks.length - 1 && <br />}
      </React.Fragment>
    ));
  };

  const expirationText = () => {
    if (!block.delay_seconds) return '';
    const days = Math.floor(block.delay_seconds / 86400);
    const hours = Math.floor((block.delay_seconds % 86400) / 3600);
    const minutes = Math.floor((block.delay_seconds % 3600) / 60);

    const parts = [];
    if (days > 0) parts.push(`${days} ${days === 1 ? 'day' : 'days'}`);
    if (hours > 0) parts.push(`${hours} ${hours === 1 ? 'hour' : 'hours'}`);
    if (minutes > 0)
      parts.push(`${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`);

    return parts.length > 0 ? `${parts.join(' and ')}` : '';
  };

  const getDelayTitle = () => {
    return block.delay_type === DelayType.WAIT_FOR_EVENT
      ? 'Event-Based Delay'
      : 'Fixed Duration';
  };

  const getDelayIcon = () => {
    if (block.delay_type === DelayType.WAIT_FOR_EVENT) {
      return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/calendar-clock-1.svg`;
    }
    return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/clock-stopwatch-1.svg`;
  };

  const getDelayText = () => {
    if (block.delay_type === DelayType.WAIT_FOR_EVENT) {
      return block.delay_event;
    } else {
      const seconds = block.delay_seconds || 0;
      const days = Math.floor(seconds / 86400);
      const hours = Math.floor((seconds % 86400) / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);

      const parts = [];
      if (days > 0) parts.push(`${days} ${days === 1 ? 'day' : 'days'}`);
      if (hours > 0) parts.push(`${hours} ${hours === 1 ? 'hour' : 'hours'}`);
      if (minutes > 0)
        parts.push(`${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`);

      return parts.length > 0 ? parts.join(' and ') : '';
    }
  };

  const handleOptionSelect = (
    optionId: number,
    blockId: number,
    isMerge?: boolean
  ) => {
    onOptionSelect?.(optionId, blockId, isMerge);
  };

  if (block.delay_type === DelayType.FIXED_DURATION) {
    return (
      <div className={`relative ${className}`}>
        <motion.div
          className={cn(
            'max-w-[950px] min-w-[300px] rounded-lg overflow-hidden will-change-transform',
            'border transition-all duration-200',
            className
          )}
          variants={slideUpVariants}
          initial="hidden"
          animate="visible"
          transition={{ duration: 0.3 }}
          style={{
            backgroundColor: colors['bg-primary'],
            borderColor: isActive
              ? colors['border-brand']
              : colors['border-secondary'],
            transform: 'translateZ(0)',
          }}
        >
          <div
            className="w-full flex flex-col p-6 gap-4"
            style={{
              backgroundColor: colors['bg-primary'],
            }}
          >
            <div className="flex items-center gap-4">
              <div
                className="w-12 h-12 rounded-[6px] border shadow-sm flex items-center justify-center"
                style={{
                  backgroundColor: colors['bg-primary'],
                  borderColor: colors['border-secondary'],
                }}
              >
                <Image
                  src={getDelayIcon()}
                  alt="Delay"
                  width={24}
                  height={24}
                />
              </div>
              <span
                className={cn(
                  'text-base font-semibold',
                  isActive && 'font-semibold'
                )}
                style={{
                  color: colors['text-primary'],
                }}
              >
                {getDelayTitle()}
              </span>
            </div>

            <div
              className="flex items-center gap-2 p-3 rounded-lg bg-opacity-5"
              style={{ backgroundColor: colors['bg-secondary'] }}
            >
              <Image
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/pause-circle.svg`}
                alt="Info"
                width={20}
                height={20}
              />
              <span
                className="text-sm whitespace-pre-line"
                style={{ color: colors['text-secondary'] }}
              >
                Flow paused for {getDelayText()}
              </span>
            </div>

            {block.child_paths && block.child_paths.length > 0 && (
              <motion.div
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.2, delay: 0.1 }}
                className="mt-4"
              >
                <p
                  className="text-sm font-medium mb-4"
                  style={{ color: colors['text-primary'] }}
                >
                  Select an option
                </p>
                <div className="space-y-2">
                  {block.child_paths.map((option, index) => (
                    <motion.button
                      key={option.path.id}
                      onClick={() =>
                        handleOptionSelect(option.path.id, block.id, false)
                      }
                      className={cn(
                        'w-full p-4 rounded-lg border transition-colors duration-200 will-change-transform',
                        'flex items-start gap-3 text-left',
                        selectedOptionIds?.some(
                          ([pathId, blockId]) =>
                            pathId === option.path.id && blockId === block.id
                        ) && 'border-brand'
                      )}
                      initial={{ opacity: 0, y: -10 }}
                      animate={{ opacity: 1, y: 0 }}
                      transition={{
                        duration: 0.2,
                        delay: 0.1 + index * 0.05,
                      }}
                      whileHover={{ scale: 1.01 }}
                      whileTap={{ scale: 0.99 }}
                      style={{
                        backgroundColor: colors['bg-primary'],
                        borderColor: selectedOptionIds?.some(
                          ([pathId, blockId]) =>
                            pathId === option.path.id && blockId === block.id
                        )
                          ? colors['border-brand']
                          : colors['border-secondary'],
                        transform: 'translateZ(0)',
                      }}
                    >
                      <div
                        className="w-5 h-5 rounded-full border-2 flex-shrink-0 flex items-center justify-center"
                        style={{
                          borderColor: selectedOptionIds?.some(
                            ([pathId, blockId]) =>
                              pathId === option.path.id && blockId === block.id
                          )
                            ? colors['border-brand']
                            : colors['border-secondary'],
                          backgroundColor: selectedOptionIds?.some(
                            ([pathId, blockId]) =>
                              pathId === option.path.id && blockId === block.id
                          )
                            ? colors['bg-brand-solid']
                            : 'transparent',
                        }}
                      >
                        <AnimatePresence>
                          {selectedOptionIds?.some(
                            ([pathId, blockId]) =>
                              pathId === option.path.id && blockId === block.id
                          ) && (
                            <motion.div
                              className="w-2 h-2 bg-white rounded-full"
                              initial={{ scale: 0 }}
                              animate={{ scale: 1 }}
                              exit={{ scale: 0 }}
                              transition={{ duration: 0.2 }}
                            />
                          )}
                        </AnimatePresence>
                      </div>
                      <div className="flex flex-col gap-1">
                        <p
                          className="font-normal text-sm"
                          style={{ color: colors['text-primary'] }}
                        >
                          {option.path.name}
                        </p>
                      </div>
                    </motion.button>
                  ))}
                </div>
              </motion.div>
            )}
          </div>
        </motion.div>
        {!isLastStep && (
          <motion.div
            className="absolute left-4 bottom-0 w-[1px] h-20 -mb-20"
            initial={{ scaleY: 0 }}
            animate={{ scaleY: 1 }}
            transition={{ duration: 0.3 }}
            style={{ backgroundColor: colors['border-secondary'], originY: 0 }}
          />
        )}
      </div>
    );
  }

  return (
    <div className={`relative ${className}`}>
      <motion.div
        className={cn(
          'max-w-[950px] min-w-[300px] rounded-lg overflow-hidden will-change-transform',
          'border transition-all duration-200',
          className
        )}
        variants={slideUpVariants}
        initial="hidden"
        animate="visible"
        transition={{ duration: 0.3 }}
        style={{
          backgroundColor: colors['bg-primary'],
          borderColor: isActive
            ? colors['border-brand']
            : colors['border-secondary'],
          transform: 'translateZ(0)',
        }}
      >
        <div
          className="w-full flex flex-col p-6 gap-4"
          style={{
            backgroundColor: colors['bg-primary'],
          }}
        >
          <div className="flex flex-col gap-2">
            <div className="flex items-center gap-4">
              <div
                className="w-12 h-12 rounded-[6px] border shadow-sm flex items-center justify-center"
                style={{
                  backgroundColor: colors['bg-primary'],
                  borderColor: colors['border-secondary'],
                }}
              >
                <Image
                  src={getDelayIcon()}
                  alt="Delay"
                  width={24}
                  height={24}
                />
              </div>
              <span
                className={cn(
                  'text-base font-semibold',
                  isActive && 'font-semibold'
                )}
                style={{
                  color: colors['text-primary'],
                }}
              >
                {getDelayTitle()}
              </span>
            </div>

            <div className="flex flex-col gap-2">
              <div className="flex items-center gap-2">
                <span
                  className="text-sm"
                  style={{ color: colors['text-secondary'] }}
                >
                  Waiting for:
                </span>
                <span
                  className="text-sm whitespace-pre-line break-words line-clamp-2"
                  style={{ color: colors['text-primary'] }}
                >
                  {block.delay_event}
                </span>
              </div>

              {(block.delay_seconds ?? 0) > 0 && (
                <div className="flex items-center gap-2">
                  <Image
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/hourglass-01.svg`}
                    alt="Clock"
                    width={16}
                    height={16}
                  />
                  <span
                    className="text-sm"
                    style={{ color: colors['text-secondary'] }}
                  >
                    Expires after {expirationText()}
                  </span>
                </div>
              )}
            </div>
          </div>

          <div
            className="flex items-center gap-2 p-3 rounded-lg bg-opacity-5"
            style={{ backgroundColor: colors['bg-secondary'] }}
          >
            <Image
              src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/pause-circle.svg`}
              alt="Info"
              width={20}
              height={20}
            />
            <span
              className="text-sm whitespace-pre-line"
              style={{ color: colors['text-secondary'] }}
            >
              {(block.delay_seconds ?? 0) > 0
                ? 'Flow paused until event occurs or time expires'
                : 'Flow paused until event occurs'}
            </span>
          </div>

          {block.child_paths && block.child_paths.length > 0 && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.2, delay: 0.1 }}
              className="mt-4"
            >
              <p
                className="text-sm font-medium mb-4"
                style={{ color: colors['text-primary'] }}
              >
                Select an option
              </p>
              <div className="space-y-2">
                {block.child_paths.map((option, index) => (
                  <motion.button
                    key={option.path.id}
                    onClick={() =>
                      handleOptionSelect(option.path.id, block.id, false)
                    }
                    className={cn(
                      'w-full p-4 rounded-lg border transition-colors duration-200 will-change-transform',
                      'flex items-start gap-3 text-left',
                      selectedOptionIds?.some(
                        ([pathId, blockId]) =>
                          pathId === option.path.id && blockId === block.id
                      ) && 'border-brand'
                    )}
                    initial={{ opacity: 0, y: -10 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{
                      duration: 0.2,
                      delay: 0.1 + index * 0.05,
                    }}
                    whileHover={{ scale: 1.01 }}
                    whileTap={{ scale: 0.99 }}
                    style={{
                      backgroundColor: colors['bg-primary'],
                      borderColor: selectedOptionIds?.some(
                        ([pathId, blockId]) =>
                          pathId === option.path.id && blockId === block.id
                      )
                        ? colors['border-brand']
                        : colors['border-secondary'],
                      transform: 'translateZ(0)',
                    }}
                  >
                    <div
                      className="w-5 h-5 rounded-full border-2 flex-shrink-0 flex items-center justify-center"
                      style={{
                        borderColor: selectedOptionIds?.some(
                          ([pathId, blockId]) =>
                            pathId === option.path.id && blockId === block.id
                        )
                          ? colors['border-brand']
                          : colors['border-secondary'],
                        backgroundColor: selectedOptionIds?.some(
                          ([pathId, blockId]) =>
                            pathId === option.path.id && blockId === block.id
                        )
                          ? colors['bg-brand-solid']
                          : 'transparent',
                      }}
                    >
                      <AnimatePresence>
                        {selectedOptionIds?.some(
                          ([pathId, blockId]) =>
                            pathId === option.path.id && blockId === block.id
                        ) && (
                          <motion.div
                            className="w-2 h-2 bg-white rounded-full"
                            initial={{ scale: 0 }}
                            animate={{ scale: 1 }}
                            exit={{ scale: 0 }}
                            transition={{ duration: 0.2 }}
                          />
                        )}
                      </AnimatePresence>
                    </div>
                    <div className="flex flex-col gap-1">
                      <p
                        className="font-normal text-sm break-words line-clamp-2"
                        style={{ color: colors['text-primary'] }}
                      >
                        {renderTitleWithLineBreaks(option.path.name)}
                      </p>
                    </div>
                  </motion.button>
                ))}
              </div>
            </motion.div>
          )}
        </div>
      </motion.div>
      {!isLastStep && (
        <motion.div
          className="absolute left-4 bottom-0 w-[1px] h-20 -mb-20"
          initial={{ scaleY: 0 }}
          animate={{ scaleY: 1 }}
          transition={{ duration: 0.3 }}
          style={{ backgroundColor: colors['border-secondary'], originY: 0 }}
        />
      )}
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/read/components/steps/VerticalLastStep.tsx">
import React from 'react';
import { cn } from '@/lib/utils';
import { useColors } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';
import { motion } from 'framer-motion';
import { BaseStepProps } from './BaseStep';

interface VerticalLastStepProps {
  icon: string;
  onRestart: () => void;
  className?: string;
  onCopyLink: () => void;
}

export default function VerticalLastStep({
  onCopyLink,
  icon,
  onRestart,
  className,
}: VerticalLastStepProps) {
  const colors = useColors();

  const slideUpVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0 },
  };

  const renderIcon = () => {
    if (!icon) return null;

    return (
      <motion.div
        className="w-12 h-12 rounded-md border shadow-sm flex items-center justify-center will-change-transform"
        initial={{ scale: 0.9, opacity: 0 }}
        animate={{ scale: 1, opacity: 1 }}
        transition={{ duration: 0.3 }}
        style={{
          backgroundColor: colors['bg-primary'],
          borderColor: colors['border-secondary'],
          transform: 'translateZ(0)',
        }}
      >
        <img src={icon} alt="Success" className="w-6 h-6" />
      </motion.div>
    );
  };

  return (
    <div className="relative">
      <motion.div
        className="absolute left-4 -top-16 w-[1px] h-16"
        initial={{ scaleY: 0 }}
        animate={{ scaleY: 1 }}
        transition={{ duration: 0.3 }}
        style={{ backgroundColor: colors['border-secondary'], originY: 0 }}
      />
      <motion.div
        className={cn(
          'max-w-[950px] min-w-[300px] rounded-lg overflow-hidden will-change-transform',
          'border transition-all duration-200 p-6',
          className
        )}
        variants={slideUpVariants}
        initial="hidden"
        animate="visible"
        transition={{ duration: 0.3 }}
        style={{
          backgroundColor: colors['bg-primary'],
          borderColor: colors['border-secondary'],
          transform: 'translateZ(0)',
        }}
      >
        <div className="flex flex-col items-start text-left">
          {renderIcon()}
          <motion.h3
            className="text-md font-semibold mb-3 mt-6"
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.3, delay: 0.1 }}
            style={{ color: colors['text-primary'] }}
          >
            Congratulations! Your process has been completed.
          </motion.h3>
          <motion.p
            className="text-base mb-6"
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.3, delay: 0.2 }}
            style={{ color: colors['text-secondary'] }}
          >
            Share it with your team members!
          </motion.p>
          <motion.div
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.3, delay: 0.3 }}
          >
            <ButtonNormal
              variant="primary"
              size="small"
              onClick={onCopyLink}
              leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/link-02-white.svg`}
            >
              Copy link
            </ButtonNormal>
          </motion.div>
          <motion.div
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.3, delay: 0.4 }}
          ></motion.div>
        </div>
      </motion.div>
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/read/components/steps/VerticalStep.tsx">
import React, { useState, useRef, useEffect, useMemo } from 'react';
import { cn } from '@/lib/utils';
import { useColors } from '@/app/theme/hooks';
import Image from 'next/image';
import ButtonNormal from '@/app/components/ButtonNormal';
import { AnimatePresence, motion } from 'framer-motion';
import { Block } from '../../../types';
import { BaseStepProps } from './BaseStep';
import { BlockEndType, BlockType } from '@/types/block';
import { usePathsStore } from '../../store/pathsStore';
import { formatTime, isValidTime } from '../../utils/timeUtils';
import { generateWorkspaceURL } from '@/app/api/utils/generateWorkspaceURL';

// Regular expression to match URLs
const URL_REGEX = /(https?:\/\/[^\s]+)/g;

export default function VerticalStep({
  block,
  isActive = false,
  className,
  defaultExpanded = true,
  onToggle,
  children,
  stepRef,
  selectedOptionIds,
  onOptionSelect,
  isLastStep = false,
  variant = 'default',
  icon,
}: BaseStepProps) {
  const colors = useColors();
  const [isExpanded, setIsExpanded] = useState(defaultExpanded);
  const [isImageFullscreen, setIsImageFullscreen] = useState(false);
  const [zoomLevel, setZoomLevel] = useState(1);
  const [isDragging, setIsDragging] = useState(false);
  const [dragPosition, setDragPosition] = useState({ x: 0, y: 0 });
  const imageContainerRef = useRef<HTMLDivElement>(null);
  const descriptionRef = useRef<HTMLParagraphElement>(null);
  const paths = usePathsStore((state) => state.paths);

  // Generate image URL directly using generateWorkspaceURL
  const imageUrl = useMemo(() => {
    if (!block.image) return null;
    try {
      return generateWorkspaceURL(block.image);
    } catch (error) {
      console.error('Error generating workspace URL:', error);
      return null;
    }
  }, [block.image]);

  useEffect(() => {
    setIsExpanded(defaultExpanded);
  }, [defaultExpanded]);

  // Reset zoom level and position when fullscreen changes
  useEffect(() => {
    if (!isImageFullscreen) {
      setZoomLevel(1);
      setDragPosition({ x: 0, y: 0 });
    }
  }, [isImageFullscreen]);

  // Handle wheel event for zooming
  useEffect(() => {
    const handleWheel = (e: WheelEvent) => {
      if (!isImageFullscreen) return;

      e.preventDefault();

      // Zoom in or out based on scroll direction
      if (e.deltaY < 0) {
        // Zoom in (scroll up)
        setZoomLevel((prev) => Math.min(prev + 0.1, 5));
      } else {
        // Zoom out (scroll down)
        setZoomLevel((prev) => Math.max(prev - 0.1, 0.5));
      }
    };

    const container = imageContainerRef.current;
    if (container) {
      container.addEventListener('wheel', handleWheel, { passive: false });
    }

    return () => {
      if (container) {
        container.removeEventListener('wheel', handleWheel);
      }
    };
  }, [isImageFullscreen, imageContainerRef]);

  // Handle ESC key to close fullscreen
  useEffect(() => {
    const handleEscKey = (event: KeyboardEvent) => {
      if (event.key === 'Escape' && isImageFullscreen) {
        setIsImageFullscreen(false);
      }
    };

    window.addEventListener('keydown', handleEscKey);
    return () => {
      window.removeEventListener('keydown', handleEscKey);
    };
  }, [isImageFullscreen]);

  // Prevent body scrolling when fullscreen is active
  useEffect(() => {
    if (isImageFullscreen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = '';
    }

    return () => {
      document.body.style.overflow = '';
    };
  }, [isImageFullscreen]);

  const handleToggle = () => {
    // Only toggle if there's an image to show
    if (!block.image) return;

    const newState = !isExpanded;
    setIsExpanded(newState);
    onToggle?.(newState);

    // Enhanced scroll centering with top offset consideration
    if (stepRef?.current) {
      // If expanding, wait for the content to be visible before scrolling
      if (newState) {
        // Small delay to allow content to expand
        setTimeout(() => {
          const viewportHeight = window.innerHeight;
          const element = stepRef.current;

          if (!element) return;

          // Get the full height of the element including expanded content
          const elementRect = element.getBoundingClientRect();
          const elementHeight = elementRect.height;

          // Add offset from top (adjust this value based on your header height)
          const topOffset = 100; // Adjust this value based on your header height

          // Calculate the target scroll position that will center the element
          const targetScroll = Math.max(
            0,
            window.scrollY +
              elementRect.top -
              (viewportHeight - elementHeight) / 2 -
              topOffset
          );

          // Smooth scroll to the calculated position
          window.scrollTo({
            top: targetScroll,
            behavior: 'smooth',
          });
        }, 100); // Increased delay to ensure content has expanded
      } else {
        // If collapsing, scroll immediately
        const viewportHeight = window.innerHeight;
        const elementRect = stepRef.current.getBoundingClientRect();
        const elementHeight = elementRect.height;
        const topOffset = 100; // Same offset for consistency

        const targetScroll = Math.max(
          0,
          window.scrollY +
            elementRect.top -
            (viewportHeight - elementHeight) / 2 -
            topOffset
        );

        window.scrollTo({
          top: targetScroll,
          behavior: 'smooth',
        });
      }
    }
  };

  const toggleFullscreen = (e: React.MouseEvent) => {
    e.stopPropagation();
    setIsImageFullscreen(!isImageFullscreen);
  };

  const zoomIn = (e: React.MouseEvent) => {
    e.stopPropagation();
    setZoomLevel((prev) => Math.min(prev + 0.1, 5));
  };

  const zoomOut = (e: React.MouseEvent) => {
    e.stopPropagation();
    setZoomLevel((prev) => Math.max(prev - 0.1, 0.5));
  };

  const resetZoom = (e?: React.MouseEvent) => {
    if (e) e.stopPropagation();
    setZoomLevel(1);
    setDragPosition({ x: 0, y: 0 });
  };

  const handleMouseDown = (e: React.MouseEvent) => {
    if (zoomLevel <= 1) return;

    e.preventDefault();
    setIsDragging(true);
  };

  const handleMouseMove = (e: React.MouseEvent) => {
    if (!isDragging || zoomLevel <= 1) return;

    setDragPosition((prev) => ({
      x: prev.x + e.movementX,
      y: prev.y + e.movementY,
    }));
  };

  const handleMouseUp = () => {
    setIsDragging(false);
  };

  const handleDoubleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    resetZoom();
  };

  const handleOptionSelect = (
    optionId: number,
    blockId: number,
    isMerge?: boolean
  ) => {
    onOptionSelect?.(optionId, blockId, isMerge);
  };

  const slideUpVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0 },
  };

  const expandVariants = {
    collapsed: { opacity: 0, height: 0 },
    expanded: { opacity: 1, height: 'auto' },
  };

  // Helper function to get display title
  const getDisplayTitle = (block: Block) => {
    if (block.title) return block.title;

    // Convert block type from ALL_CAPS to Title Case
    const typeName = block.type
      .toLowerCase()
      .replace(/_/g, ' ')
      .split(' ')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');

    return `${typeName}`;
  };

  // Helper function to get icon path
  const getIconPath = (block: Block) => {
    if (block.icon && block.signedIconUrl) {
      return `${block.signedIconUrl}`;
    }

    switch (block.type) {
      case 'STEP':
        return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/git-commit.svg`;
      case 'PATH':
        return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dataflow-04.svg`;
      case 'DELAY':
        return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/clock-stopwatch-1.svg`;
      default:
        return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon-base.svg`;
    }
  };

  // Add this function to parse text into segments with links
  const parseTextWithLinks = (text: string) => {
    const parts = [];
    let lastIndex = 0;
    let match;

    while ((match = URL_REGEX.exec(text)) !== null) {
      // Add text before the link
      if (match.index > lastIndex) {
        parts.push({
          type: 'text',
          content: text.slice(lastIndex, match.index),
        });
      }

      // Add the link
      parts.push({
        type: 'link',
        content: match[0],
      });

      lastIndex = match.index + match[0].length;
    }

    // Add remaining text after last link
    if (lastIndex < text.length) {
      parts.push({
        type: 'text',
        content: text.slice(lastIndex),
      });
    }

    return parts.length > 0 ? parts : [{ type: 'text', content: text }];
  };

  // Helper function to split a string into chunks of N characters and render with <br />
  const renderTitleWithLineBreaks = (title: string, chunkSize = 50) => {
    if (!title) return null;
    const chunks = [];
    for (let i = 0; i < title.length; i += chunkSize) {
      chunks.push(title.slice(i, i + chunkSize));
    }
    // Interleave <br /> except after the last chunk
    return chunks.map((chunk, idx) => (
      <React.Fragment key={idx}>
        {chunk}
        {idx < chunks.length - 1 && <br />}
      </React.Fragment>
    ));
  };

  // Don't render anything for MERGE blocks except the line
  if (block.type === 'MERGE') {
    return (
      <div className="relative">
        <motion.div
          className="absolute left-4 bottom-0 w-[1px] h-20 -mb-20"
          initial={{ scaleY: 0 }}
          animate={{ scaleY: 1 }}
          transition={{ duration: 0.3 }}
          style={{ backgroundColor: colors['border-secondary'], originY: 0 }}
        />
      </div>
    );
  }

  return (
    <div className={`relative ${className}`} ref={stepRef}>
      <motion.div
        className={cn(
          'max-w-[950px] min-w-[300px] rounded-lg overflow-hidden will-change-transform',
          'border transition-all duration-200',
          className
        )}
        variants={slideUpVariants}
        initial="hidden"
        animate="visible"
        transition={{ duration: 0.3 }}
        style={{
          backgroundColor: colors['bg-primary'],
          borderColor: isActive
            ? colors['border-brand']
            : colors['border-secondary'],
          transform: 'translateZ(0)',
        }}
      >
        <button
          onClick={handleToggle}
          className={cn(
            'w-full flex flex-col',
            'p-6',
            'transition-colors duration-200 ease-in-out',
            block.image ? 'cursor-pointer' : 'cursor-default'
          )}
          style={{
            backgroundColor: colors['bg-primary'],
          }}
        >
          {/* Header with Icon and Title */}
          {
            <div className="flex items-center gap-4 flex-1 min-w-0 mb-3">
              <motion.div
                className="w-12 h-12 rounded-[6px] border shadow-sm flex items-center justify-center"
                style={{
                  backgroundColor: colors['bg-primary'],
                  borderColor: colors['border-secondary'],
                }}
              >
                {block.icon &&
                block.icon.startsWith('https://cdn.brandfetch.io/') ? (
                  <img
                    src={block.icon}
                    alt="Step Icon"
                    className="w-6 h-6"
                    referrerPolicy="strict-origin-when-cross-origin"
                  />
                ) : (
                  <img
                    src={getIconPath(block)}
                    alt={getDisplayTitle(block)}
                    className="w-6 h-6"
                    onError={(e) => {
                      e.currentTarget.src = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon-base.svg`;
                    }}
                  />
                )}
              </motion.div>
              <div className="flex flex-col gap-2 min-w-0 flex-1">
                <div className="flex items-center gap-2 min-w-0 whitespace-pre-line break-words">
                  <span
                    className={cn(
                      'text-left text-base font-semibold break-words line-clamp-2'
                    )}
                    style={{
                      color: colors['text-primary'],
                      wordBreak: 'break-word',
                    }}
                  >
                    {renderTitleWithLineBreaks(getDisplayTitle(block), 60)}
                  </span>
                </div>
                {/* Time Display - moved under title */}
                {isValidTime(block.average_time) && (
                  <div className="flex items-center gap-1.5">
                    <img
                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/clock-stopwatch-1.svg`}
                      alt="Time"
                      className="w-3.5 h-3.5 opacity-60"
                    />
                    <span
                      className="text-xs font-medium"
                      style={{ color: colors['text-tertiary'] }}
                    >
                      {formatTime(block.average_time)}
                    </span>
                  </div>
                )}
              </div>
              {block.image && (
                <motion.div
                  className="flex-shrink-0"
                  animate={{ rotate: isExpanded ? 180 : 0 }}
                  transition={{ duration: 0.3 }}
                >
                  <Image
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/chevron-down.svg`}
                    alt="Toggle content"
                    width={24}
                    height={24}
                    className="transition-transform duration-200"
                    style={{
                      filter: 'none',
                    }}
                  />
                </motion.div>
              )}
            </div>
          }

          {/* Description section - always displayed below icon and title */}
          {block.description ? (
            <div className="text-left w-full">
              <p
                ref={descriptionRef}
                className={cn(
                  'text-sm transition-all duration-200 break-words min-h-[1.5rem] whitespace-pre-line',
                  !isExpanded && 'line-clamp-2'
                )}
                style={{ color: colors['text-quaternary'] }}
              >
                {parseTextWithLinks(block.description || '').map(
                  (segment, index) =>
                    segment.type === 'link' ? (
                      <a
                        key={index}
                        href={segment.content}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-blue-500 hover:underline"
                        onClick={(e) => {
                          e.stopPropagation();
                          e.preventDefault();
                          window.open(
                            segment.content,
                            '_blank',
                            'noopener,noreferrer'
                          );
                        }}
                      >
                        {segment.content}
                      </a>
                    ) : (
                      <span key={index}>{segment.content}</span>
                    )
                )}
              </p>
            </div>
          ) : (
            <div className="text-left w-full ">
              <p
                ref={descriptionRef}
                className={cn(
                  'text-sm transition-all duration-200 break-words min-h-[1.5rem] whitespace-pre-line',
                  !isExpanded && 'line-clamp-2'
                )}
                style={{ color: colors['text-quaternary'] }}
              >
                {parseTextWithLinks('').map((segment, index) =>
                  segment.type === 'link' ? (
                    <a
                      key={index}
                      href={segment.content}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-blue-500 hover:underline"
                      onClick={(e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        window.open(
                          segment.content,
                          '_blank',
                          'noopener,noreferrer'
                        );
                      }}
                    >
                      {segment.content}
                    </a>
                  ) : (
                    <span key={index}>{segment.content}</span>
                  )
                )}
              </p>
            </div>
          )}
        </button>

        <AnimatePresence>
          {/* Image Section */}
          {isExpanded && imageUrl && (
            <motion.div
              key="image-section"
              className="px-4 pb-4 overflow-hidden will-change-transform"
              variants={expandVariants}
              initial="collapsed"
              animate="expanded"
              exit="collapsed"
              transition={{
                duration: 0.3,
                height: { duration: 0.3 },
                opacity: { duration: 0.2 },
              }}
              style={{ transform: 'translateZ(0)' }}
            >
              <div
                className="mb-4 rounded-lg overflow-hidden cursor-zoom-in"
                onClick={toggleFullscreen}
                aria-label="View image fullscreen"
                style={{ backgroundColor: colors['bg-secondary'] }}
              >
                <img
                  src={imageUrl}
                  alt="Block Media"
                  className="w-full h-[500px] object-contain"
                />
              </div>
            </motion.div>
          )}

          {/* Child Paths Section */}
          {isExpanded && block.child_paths && block.child_paths.length > 0 && (
            <motion.div
              key="child-paths-section"
              className="px-4 pb-4 overflow-hidden will-change-transform"
              variants={expandVariants}
              initial="collapsed"
              animate="expanded"
              exit="collapsed"
              transition={{
                duration: 0.3,
                height: { duration: 0.3 },
                opacity: { duration: 0.2 },
              }}
              style={{ transform: 'translateZ(0)' }}
            >
              {block.type.toString() === 'MERGE' ? (
                // For MERGE blocks, automatically select first child path
                <motion.div
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ duration: 0.2 }}
                ></motion.div>
              ) : (
                // For non-MERGE blocks, show options as before
                <motion.div
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 0.2, delay: 0.1 }}
                >
                  <p
                    className="text-sm font-medium mb-4"
                    style={{ color: colors['text-primary'] }}
                  >
                    Select an option
                  </p>
                  <div className="space-y-2">
                    {block.child_paths.map((option, index) => (
                      <motion.button
                        key={option.path.id}
                        onClick={() =>
                          handleOptionSelect(option.path.id, block.id, false)
                        }
                        className={cn(
                          'w-full p-4 rounded-lg border transition-colors duration-200 will-change-transform',
                          'flex items-start gap-3 text-left',
                          selectedOptionIds?.some(
                            ([pathId, blockId]) =>
                              pathId === option.path.id && blockId === block.id
                          ) && 'border-brand'
                        )}
                        initial={{ opacity: 0, y: -10 }}
                        animate={{ opacity: 1, y: 0 }}
                        transition={{
                          duration: 0.2,
                          delay: 0.1 + index * 0.05,
                        }}
                        whileHover={{ scale: 1.01 }}
                        whileTap={{ scale: 0.99 }}
                        style={{
                          backgroundColor: colors['bg-primary'],
                          borderColor: selectedOptionIds?.some(
                            ([pathId, blockId]) =>
                              pathId === option.path.id && blockId === block.id
                          )
                            ? colors['border-brand']
                            : colors['border-secondary'],
                          transform: 'translateZ(0)',
                        }}
                      >
                        <div
                          className="w-5 h-5 rounded-full border-2 flex-shrink-0 flex items-center justify-center"
                          style={{
                            borderColor: selectedOptionIds?.some(
                              ([pathId, blockId]) =>
                                pathId === option.path.id &&
                                blockId === block.id
                            )
                              ? colors['border-brand']
                              : colors['border-secondary'],
                            backgroundColor: selectedOptionIds?.some(
                              ([pathId, blockId]) =>
                                pathId === option.path.id &&
                                blockId === block.id
                            )
                              ? colors['bg-brand-solid']
                              : 'transparent',
                          }}
                        >
                          <AnimatePresence>
                            {selectedOptionIds?.some(
                              ([pathId, blockId]) =>
                                pathId === option.path.id &&
                                blockId === block.id
                            ) && (
                              <motion.div
                                className="w-2 h-2 bg-white rounded-full"
                                initial={{ scale: 0 }}
                                animate={{ scale: 1 }}
                                exit={{ scale: 0 }}
                                transition={{ duration: 0.2 }}
                              />
                            )}
                          </AnimatePresence>
                        </div>
                        <div className="flex flex-col gap-1 break-words line-clamp-2">
                          <p
                            className="font-normal text-sm"
                            style={{ color: colors['text-primary'] }}
                          >
                            {option.path.name}
                          </p>
                        </div>
                      </motion.button>
                    ))}
                  </div>
                </motion.div>
              )}
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>
      {/* Always display the vertical line, starting at the bottom of the card */}
      <motion.div
        className="absolute left-4 top-full w-[1px] h-20"
        initial={{ scaleY: 0 }}
        animate={{ scaleY: 1 }}
        transition={{ duration: 0.3 }}
        style={{ backgroundColor: colors['border-secondary'], originY: 0 }}
      />

      {/* Enhanced Fullscreen Image Viewer */}
      {isImageFullscreen && imageUrl && (
        <div
          className="fixed inset-0 z-[9999] bg-black/90 flex items-center justify-center"
          onClick={() => setIsImageFullscreen(false)}
          style={{ backdropFilter: 'blur(4px)' }}
        >
          {/* Close button */}
          <button
            className="absolute top-4 right-4 z-10 p-2 rounded-full bg-black/50 cursor-pointer hover:bg-black/70 transition-colors"
            onClick={() => setIsImageFullscreen(false)}
            aria-label="Close fullscreen view"
          >
            <svg
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M18 6L6 18M6 6L18 18"
                stroke="white"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              />
            </svg>
          </button>

          {/* Help tooltip */}
          <div className="absolute top-4 left-4 z-10 text-white font-normal text-sm bg-black/50 px-3 py-2 rounded-md">
            <span className="hidden sm:inline">
              Use mouse wheel to zoom  Double-click to reset {' '}
              {Math.round(zoomLevel * 100)}%
            </span>
            <span className="sm:hidden">{Math.round(zoomLevel * 100)}%</span>
          </div>

          {/* Zoom controls */}
          <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex space-x-2 bg-black/50 p-2 rounded-lg z-10">
            <button
              onClick={zoomOut}
              className="p-2 bg-gray-800 hover:bg-gray-700 rounded-full transition-colors"
              aria-label="Zoom out"
            >
              <svg
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M5 12H19"
                  stroke="white"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
              </svg>
            </button>
            <button
              onClick={resetZoom}
              className="p-2 bg-gray-800 hover:bg-gray-700 rounded-full transition-colors"
              aria-label="Reset zoom"
            >
              <svg
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M15 15L21 21M17 10C17 13.866 13.866 17 10 17C6.13401 17 3 13.866 3 10C3 6.13401 6.13401 3 10 3C13.866 3 17 6.13401 17 10Z"
                  stroke="white"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
              </svg>
            </button>
            <button
              onClick={zoomIn}
              className="p-2 bg-gray-800 hover:bg-gray-700 rounded-full transition-colors"
              aria-label="Zoom in"
            >
              <svg
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M12 5V19M5 12H19"
                  stroke="white"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
              </svg>
            </button>
          </div>

          {/* Image container with drag functionality */}
          <div
            ref={imageContainerRef}
            className={cn(
              'relative w-[90vw] h-[90vh] flex items-center justify-center overflow-hidden',
              zoomLevel > 1 ? 'cursor-grab' : '',
              isDragging && zoomLevel > 1 ? 'cursor-grabbing' : ''
            )}
            onClick={(e) => e.stopPropagation()}
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
            onDoubleClick={handleDoubleClick}
          >
            <div
              className="transition-all duration-200 ease-out"
              style={{
                transform: `scale(${zoomLevel}) translate(${dragPosition.x}px, ${dragPosition.y}px)`,
                transformOrigin: 'center center',
              }}
            >
              <img
                src={imageUrl}
                alt="Block Media Fullscreen"
                className="max-h-full max-w-full object-contain"
                style={{
                  pointerEvents: 'none',
                }}
                draggable="false"
              />
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/read/components/BreadCrumbs.tsx">
'use client';

import React from 'react';
import { useTheme, useColors } from '@/app/theme/hooks';
import { cn } from '@/lib/utils/cn';
import Link from 'next/link';

interface BreadCrumbItem {
  label: string;
  href?: string;
}

interface BreadCrumbsProps {
  items: BreadCrumbItem[];
  className?: string;
}

const BreadCrumbs: React.FC<BreadCrumbsProps> = ({ items, className }) => {
  const colors = useColors();

  return (
    <nav className={cn("h-7 justify-start items-center inline-flex", className)} aria-label="Breadcrumb">
      <div className="justify-start items-center gap-2 flex">
        {items.map((item, index) => (
          <React.Fragment key={index}>
            <div
              className={cn(
                "px-2 py-1 rounded-md justify-center items-center flex",
                "transition-colors duration-200",
                "text-sm font-['Inter'] leading-tight"
              )}
              style={{
                backgroundColor: index === items.length - 1 ? colors['breadcrumb-active-bg'] : 'transparent',
                color: index === items.length - 1 ? colors['breadcrumb-active-fg'] : colors['breadcrumb-inactive-fg'],
                fontWeight: index === items.length - 1 ? 600 : 500,
              }}
            >
              {item.href ? (
                <Link 
                  href={item.href} 
                  className="transition-opacity hover:opacity-75"
                >
                  {item.label}
                </Link>
              ) : (
                <span>{item.label}</span>
              )}
            </div>

            {index < items.length - 1 && (
              <div 
                className="w-5 h-5 flex items-center justify-center"
                style={{ color: colors['breadcrumb-separator'] }}
              >
                <img 
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/slash-divider.svg`}
                  alt="/"
                  width="16"
                  height="16"
                />
              </div>
            )}
          </React.Fragment>
        ))}
      </div>
    </nav>
  );
};

export default BreadCrumbs;
</file>

<file path="app/[slug]/[flow]/read/components/FeedbackSlideout.tsx">
/*
'use client';

import React, { useState, useContext } from 'react';
import { useTheme, useColors } from '@/app/theme/hooks';
import { cn } from '@/lib/utils/cn';
import ButtonNormal from '@/app/components/ButtonNormal';
import Image from 'next/image';
import { HeaderHeightContext } from './Header';

interface FeedbackMessage {
  id: string;
  user: {
    name: string;
    avatar: string;
    isOnline?: boolean;
  };
  message?: string;
  attachment?: {
    name: string;
    type: string;
    size: string;
  };
  timestamp: string;
  isYou?: boolean;
  status?: 'pending' | 'resolved';
  type?: 'feedback' | 'comment';
}

interface FeedbackSlideoutProps {
  isOpen: boolean;
  onClose: () => void;
  messages: FeedbackMessage[];
  onSendMessage: (message: string) => void;
}

const FeedbackContent: React.FC<{ messages: FeedbackMessage[]; colors: any }> = ({ messages, colors }) => {
  const feedbackMessages = messages.filter(m => !m.status || m.status === 'pending');
  return (
    <div className="flex-1 overflow-y-auto p-4 space-y-4" style={{ backgroundColor: colors['bg-secondary'] }}>
      {feedbackMessages.map((message) => (
        <MessageItem key={message.id} message={message} colors={colors} />
      ))}
    </div>
  );
};

const ResolvedContent: React.FC<{ messages: FeedbackMessage[]; colors: any }> = ({ messages, colors }) => {
  const resolvedMessages = messages.filter(m => m.status === 'resolved');
  return (
    <div className="flex-1 overflow-y-auto p-4 space-y-4" style={{ backgroundColor: colors['bg-secondary'] }}>
      {resolvedMessages.map((message) => (
        <MessageItem key={message.id} message={message} colors={colors} />
      ))}
      {resolvedMessages.length === 0 && (
        <div className="flex flex-col items-center justify-center h-full text-center" style={{ color: colors['text-secondary'] }}>
          <p className="text-sm">No resolved items yet</p>
        </div>
      )}
    </div>
  );
};

const CommentsContent: React.FC<{ messages: FeedbackMessage[]; colors: any }> = ({ messages, colors }) => {
  const comments = messages.filter(m => m.type === 'comment');
  return (
    <div className="flex-1 overflow-y-auto p-4 space-y-4" style={{ backgroundColor: colors['bg-secondary'] }}>
      {comments.map((message) => (
        <MessageItem key={message.id} message={message} colors={colors} />
      ))}
      {comments.length === 0 && (
        <div className="flex flex-col items-center justify-center h-full text-center" style={{ color: colors['text-secondary'] }}>
          <p className="text-sm">No comments yet</p>
        </div>
      )}
    </div>
  );
};

const MessageItem: React.FC<{ message: FeedbackMessage; colors: any }> = ({ message, colors }) => (
  <div className={cn("flex items-start gap-3", message.isYou && "flex-row-reverse")}>
    <div className="relative">
      <div className="w-8 h-8 rounded-full overflow-hidden" style={{ backgroundColor: colors['bg-tertiary'] }}>
        <Image
          src={message.user.avatar}
          alt={message.user.name}
          width={32}
          height={32}
          className="object-cover"
        />
      </div>
      {message.user.isOnline && (
        <div className="absolute bottom-0 right-0 w-2.5 h-2.5 rounded-full border-2"
          style={{ backgroundColor: colors['success'], borderColor: colors['bg-primary'] }}
        />
      )}
    </div>
    <div className={cn("flex flex-col max-w-[280px] p-3 rounded-lg", message.isYou ? "text-white" : "border")}
      style={{ 
        backgroundColor: message.isYou ? colors['bg-brand-solid'] : colors['bg-primary'],
        borderColor: message.isYou ? 'transparent' : colors['border-secondary'],
        color: message.isYou ? colors['text-inverse'] : colors['text-primary']
      }}
    >
      <div className="flex items-center gap-2 mb-1">
        <span className="font-medium text-sm">{message.user.name}</span>
        <span className="text-xs"
          style={{ color: message.isYou ? colors['text-inverse-secondary'] : colors['text-secondary'] }}
        >
          {message.timestamp}
        </span>
      </div>
      {message.message && <p className="text-sm">{message.message}</p>}
      {message.attachment && (
        <div className="mt-2 p-2 rounded flex items-center gap-2"
          style={{ backgroundColor: message.isYou ? colors['accent-secondary'] : colors['bg-secondary'] }}
        >
          <div className="w-8 h-8 flex items-center justify-center">
            <Image
              src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/pdf-icon.svg`}
              alt="PDF"
              width={24}
              height={24}
            />
          </div>
          <div className="flex-1">
            <p className="text-sm font-medium">{message.attachment.name}</p>
            <p className="text-xs"
              style={{ color: message.isYou ? colors['text-inverse-secondary'] : colors['text-secondary'] }}
            >
              {message.attachment.size}
            </p>
          </div>
        </div>
      )}
    </div>
  </div>
);

const FeedbackSlideout: React.FC<FeedbackSlideoutProps> = ({
  isOpen,
  onClose,
  messages,
  onSendMessage
}) => {
  const { getCssVariable } = useTheme();
  const colors = useColors();
  const headerHeight = useContext(HeaderHeightContext);
  const [activeTab, setActiveTab] = useState<'feedbacks' | 'resolved' | 'comments'>('feedbacks');
  const [newMessage, setNewMessage] = useState('');

  const handleSendMessage = () => {
    if (newMessage.trim()) {
      onSendMessage(newMessage);
      setNewMessage('');
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  const renderContent = () => {
    switch (activeTab) {
      case 'feedbacks':
        return <FeedbackContent messages={messages} colors={colors} />;
      case 'resolved':
        return <ResolvedContent messages={messages} colors={colors} />;
      case 'comments':
        return <CommentsContent messages={messages} colors={colors} />;
      default:
        return null;
    }
  };

  return (
    <div 
      className={cn(
        "fixed right-0 flex flex-col transition-transform duration-300 ease-in-out z-40",
        "border-l shadow-lg",
        isOpen ? "translate-x-0" : "translate-x-full"
      )}
      style={{ 
        backgroundColor: colors['bg-primary'],
        borderColor: colors['border-primary'],
        width: '400px',
        height: `calc(100vh - ${headerHeight}px)`,
        top: `${headerHeight}px`
      }}
    >
      {/* Header *//*
      <div className="flex items-center justify-between p-4">
        <h2 className="text-lg font-semibold" style={{ color: colors['text-primary'] }}>
          {activeTab === 'feedbacks' ? 'Feedbacks' : activeTab === 'resolved' ? 'Resolved' : 'Comments'}
        </h2>
        <button
          onClick={onClose}
          className="p-1 rounded-full transition-colors hover:opacity-80"
          style={{ backgroundColor: colors['bg-secondary'] }}
        >
          <Image
            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/x-close-icon.svg`}
            alt="Close"
            width={16}
            height={16}
          />
        </button>
      </div>

      {/* Tabs *//*
      <div className="flex px-4 border-b" style={{ borderColor: colors['border-secondary'] }}>
        {['Feedbacks', 'Resolved', 'Comments'].map((tab) => (
          <button
            key={tab}
            onClick={() => setActiveTab(tab.toLowerCase() as any)}
            className={cn(
              "py-3 px-4 text-sm font-medium relative transition-colors hover:opacity-80",
              activeTab === tab.toLowerCase() && "border-b-2"
            )}
            style={{
              color: activeTab === tab.toLowerCase() ? colors['text-brand-tertiary'] : colors['text-secondary'],
              borderColor: activeTab === tab.toLowerCase() ? colors['text-brand-tertiary'] : 'transparent'
            }}
          >
            {tab}
          </button>
        ))}
      </div>

      {/* Content *}/*
      {renderContent()}

      {/* Message Input *//*
      <div className="p-4 border-t"
        style={{ backgroundColor: colors['bg-primary'], borderColor: colors['border-secondary'] }}
      >
        <div className="flex items-center gap-2 p-2 rounded-lg"
          style={{ backgroundColor: colors['bg-secondary'] }}
        >
          <input
            type="text"
            value={newMessage}
            onChange={(e) => setNewMessage(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder={`Type your ${activeTab === 'comments' ? 'comment' : 'feedback'}...`}
            className="flex-1 bg-transparent border-none outline-none text-sm placeholder:text-secondary"
            style={{ color: colors['text-primary'] }}
          />
          <ButtonNormal
            variant="primary"
            size="small"
            onClick={handleSendMessage}
            disabled={!newMessage.trim()}
            iconOnly
            leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/send-01.svg`}
          />
        </div>
      </div>
    </div>
  );
};

export default FeedbackSlideout;*/
</file>

<file path="app/[slug]/[flow]/read/components/ProcessCanvas.tsx">
import React from 'react';
import { useColors } from '@/app/theme/hooks';
import { cn } from '@/lib/utils';

interface ProcessCanvasProps {
  children: React.ReactNode;
  className?: string;
}

export default function ProcessCanvas({ children, className }: ProcessCanvasProps) {
  const colors = useColors();
  
  return (
    <div
      className={cn(
        "relative pt-[120px] pb-6",
        className?.includes("absolute") ? "" : className?.includes("overflow-hidden") ? "h-screen" : "min-h-screen",
        className
      )}
      style={{ backgroundColor: colors['bg-secondary'] }}
    >
      {children}
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/read/components/ProcessCard.tsx">
'use client';

import { useColors } from '@/app/theme/hooks';
import { useState, useRef, useEffect, useLayoutEffect } from 'react';
import { cn } from '@/lib/utils';
import DynamicIcon from '@/utils/DynamicIcon';

interface Integration {
  name: string;
  icon?: string;
}

interface Owner {
  name: string;
  avatar?: string;
}

type ViewMode = 'vertical' | 'carousel';
interface ProcessCardProps {
  icon: string;
  workflow: {
    name: string;
    description?: string;
  };
  integrations: Integration[];
  owner?: Owner;
  review_date?: string;
  additionalNotes?: string;
  lastUpdate?: string;
  viewMode?: ViewMode;
}

// Utility to extract filename without extension from a path
function getFilenameWithoutExtension(path: string): string {
  const filename = path.split('/').pop() || path;
  // Remove everything after the first dot in the extension (e.g. .svg, .png, .jpg, .svg?foo=bar)
  return filename.replace(/\.[^/.]+.*/, '');
}

export default function ProcessCard({
  icon,
  workflow,
  integrations,
  owner,
  review_date,
  additionalNotes,
  lastUpdate,
  viewMode = 'vertical',
}: ProcessCardProps) {
  const colors = useColors();
  const [showPopover, setShowPopover] = useState(false);
  const popoverTimerRef = useRef<NodeJS.Timeout>();
  const descriptionRef = useRef<HTMLDivElement>(null);
  const notesRef = useRef<HTMLDivElement>(null);
  const [shouldCenter, setShouldCenter] = useState(true);

  const visibleIntegrations = integrations.slice(0, 5);
  const hiddenIntegrations = integrations.slice(5);
  const hasHiddenIntegrations = integrations.length > 5;

  const handleMouseEnter = () => {
    if (popoverTimerRef.current) {
      clearTimeout(popoverTimerRef.current);
    }
    setShowPopover(true);
  };

  const handleMouseLeave = () => {
    popoverTimerRef.current = setTimeout(() => {
      setShowPopover(false);
    }, 100); // 300ms delay before hiding
  };

  useEffect(() => {
    return () => {
      if (popoverTimerRef.current) {
        clearTimeout(popoverTimerRef.current);
      }
    };
  }, []);

  useLayoutEffect(() => {
    // Only run if either description or additionalNotes exists
    if (descriptionRef.current || notesRef.current) {
      const descHeight = descriptionRef.current?.offsetHeight || 0;
      const notesHeight = notesRef.current?.offsetHeight || 0;
      setShouldCenter(descHeight + notesHeight < 400);
    }
  }, [workflow.description, additionalNotes]);

  const IntegrationBadge = ({ integration }: { integration: Integration }) => (
    <div
      style={{
        backgroundColor: colors['bg-secondary'],
        borderColor: colors['border-secondary'],
      }}
      className="inline-flex items-center px-2 py-1 rounded-md border gap-1.5"
    >
      {integration.icon && (
        <img
          src={integration.icon}
          alt={integration.name}
          className="w-3.5 h-3.5 object-contain"
          referrerPolicy={
            integration.icon.startsWith('https://cdn.brandfetch.io/')
              ? 'strict-origin-when-cross-origin'
              : undefined
          }
        />
      )}
      <span
        style={{ color: colors['text-secondary'] }}
        className="text-xs leading-none font-medium"
      >
        {integration.icon
          ? getFilenameWithoutExtension(integration.icon)
          : integration.name}
      </span>
    </div>
  );

  return (
    <div
      style={{
        borderColor: colors['border-secondary'],
      }}
      className={cn(
        'rounded-xl flex flex-col transition-all duration-200 w-full h-full overflow-auto',
        viewMode === 'carousel' && shouldCenter && 'items-center justify-center'
      )}
    >
      <div className="flex gap-6">
        {/* Large Icon - keep original size */}
        <div
          style={{
            backgroundColor: colors['bg-secondary'],
          }}
          className="w-12 h-12 rounded-xl flex items-center justify-center flex-shrink-0"
        >
          {icon ? (
            icon.startsWith('https://cdn.brandfetch.io/') ? (
              <img
                src={icon}
                alt={workflow.name}
                className="w-10 h-10 object-contain"
                referrerPolicy="strict-origin-when-cross-origin"
              />
            ) : icon.startsWith(process.env.NEXT_PUBLIC_SUPABASE_URL || '') ? (
              <img
                src={icon}
                alt={workflow.name}
                className="w-10 h-10 object-contain"
                referrerPolicy="strict-origin-when-cross-origin"
              />
            ) : (
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`}
                alt="Default Icon"
                className="w-10 h-10 select-none"
                draggable="false"
              />
            )
          ) : (
            <img
              src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`}
              alt="Default Icon"
              className="w-10 h-10 select-none"
              draggable="false"
            />
          )}
        </div>

        {/* Content Container */}
        <div className="flex flex-col gap-4 flex-1">
          {/* Title and Description */}
          <div className="flex flex-col gap-1">
            <h3
              style={{ color: colors['text-primary'] }}
              className="font-semibold leading-[30px] text-xl"
            >
              {workflow.name}
            </h3>
            {workflow.description && (
              <div className="max-w-md" ref={descriptionRef}>
                <p
                  style={{ color: colors['text-secondary'] }}
                  className="text-sm font-medium mb-1"
                >
                  Why does this Flow exist?
                </p>
                <p
                  style={{ color: colors['text-quaternary'] }}
                  className="font-normal text-sm whitespace-pre-line break-words"
                >
                  {workflow.description}
                </p>
              </div>
            )}
          </div>

          {/* Integration Badges */}
          <div className="flex flex-wrap gap-2 items-center">
            {visibleIntegrations.map((integration, index) => (
              <IntegrationBadge key={index} integration={integration} />
            ))}

            {hasHiddenIntegrations && (
              <div
                className="relative"
                onMouseEnter={handleMouseEnter}
                onMouseLeave={handleMouseLeave}
              >
                <div
                  style={{
                    backgroundColor: colors['bg-secondary'],
                    borderColor: colors['border-secondary'],
                    color: colors['text-secondary'],
                  }}
                  className="inline-flex items-center px-2 py-1 rounded-md border gap-1.5 hover:bg-opacity-80 transition-all duration-200"
                >
                  <span className="text-xs leading-none font-medium">
                    +{hiddenIntegrations.length}
                  </span>
                </div>

                {/* Popover for additional integrations */}
                <div
                  style={{
                    backgroundColor: colors['bg-primary'],
                    borderColor: colors['border-secondary'],
                    boxShadow: `0px 4px 6px -2px ${colors['shadow-md_01']}, 0px 12px 16px -4px ${colors['shadow-md_02']}`,
                    opacity: showPopover ? 1 : 0,
                    visibility: showPopover ? 'visible' : 'hidden',
                  }}
                  className="absolute left-0 top-full mt-2 z-50 rounded-lg border p-3 min-w-[200px] max-w-[300px] transition-all duration-200"
                >
                  <div className="flex flex-col gap-2">
                    {hiddenIntegrations.map((integration, index) => (
                      <IntegrationBadge key={index} integration={integration} />
                    ))}
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* Footer: Owner, Review Date, and Last Update */}
          <div className="flex items-center gap-4 flex-wrap">
            {owner && owner.name && owner.name.trim() && (
              <>
                <div className="flex items-center gap-2">
                  {owner.avatar && (
                    <img
                      src={owner.avatar}
                      alt={owner.name}
                      className="rounded-full w-5 h-5"
                    />
                  )}
                  <span
                    style={{ color: colors['text-secondary'] }}
                    className="font-medium text-sm"
                  >
                    {owner.name}
                  </span>
                </div>
                {(review_date || lastUpdate) && (
                  <div
                    style={{ color: colors['text-tertiary'] }}
                    className="w-1 h-1 rounded-full bg-current"
                  />
                )}
              </>
            )}
            {review_date && (
              <div className="flex items-center gap-2">
                <span
                  style={{ color: colors['text-tertiary'] }}
                  className="text-sm"
                >
                  Review date: {review_date}
                </span>
              </div>
            )}
            {lastUpdate && (
              <div className="flex items-center gap-2">
                <span
                  style={{ color: colors['text-tertiary'] }}
                  className="text-sm"
                >
                  Last update: {lastUpdate}
                </span>
              </div>
            )}
          </div>

          {/* Additional Notes */}
          {additionalNotes && (
            <div className="mt-2 max-w-md" ref={notesRef}>
              <p
                style={{ color: colors['text-quaternary'] }}
                className="text-sm italic whitespace-pre-line break-words"
              >
                <span className="font-medium not-italic">
                  Additional notes:
                </span>{' '}
                {additionalNotes}
              </p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/read/components/Sidebar.tsx">
import React, { useMemo, useState, useRef } from 'react';
import { cn } from '@/lib/utils';
import { Workspace } from '@/types/workspace';
import { useColors } from '@/app/theme/hooks';
import { usePathsStore } from '../store/pathsStore';
import StepsContainer from './StepsContainer';
import { Path } from '../../types';
import { useRouter } from 'next/navigation';

interface SidebarProps {
  className?: string;
  workspace: Workspace;
  activeStepId: number;
  onStepClick: (stepId: number) => void;
  pathsToDisplay: Path[];
}

export default function Sidebar({
  className,
  workspace,
  activeStepId,
  onStepClick,
  pathsToDisplay,
}: SidebarProps) {
  const colors = useColors();
  const router = useRouter();
  const [searchFilter, setSearchFilter] = useState<string>('');
  const [collapsedPaths, setCollapsedPaths] = useState<Set<number>>(new Set());

  const renderPathContent = (
    path: Path,
    level: number = 0,
    renderedPaths: Set<number> = new Set()
  ) => {
    // Add current path to rendered set
    renderedPaths.add(path.id);
    const isPathCollapsed = collapsedPaths.has(path.id);

    return (
      <div key={path.id}>
        <StepsContainer
          path={path}
          activeStepId={activeStepId}
          onStepClick={onStepClick}
          level={level}
          isCollapsed={isPathCollapsed}
          onToggleCollapse={() => {
            setCollapsedPaths((prev) => {
              const newSet = new Set(prev);
              if (isPathCollapsed) {
                newSet.delete(path.id);
              } else {
                newSet.add(path.id);
              }
              return newSet;
            });
          }}
        />

        {!isPathCollapsed &&
          path.blocks
            .filter((block) => block.type !== 'LAST' && block.type !== 'BEGIN')
            .map((block) => {
              if (
                block.type === 'MERGE' ||
                block.type === 'PATH' ||
                block.type === 'STEP'
              ) {
                return block.child_paths?.map((childPathConnection) => {
                  // Skip if we've already rendered this path
                  if (renderedPaths.has(childPathConnection.path.id)) {
                    return null;
                  }

                  const childPath = pathsToDisplay.find(
                    (p) => p.id === childPathConnection.path.id
                  );
                  if (childPath) {
                    return (
                      <div key={`${childPath.id}-${block.id}`}>
                        {renderPathContent(
                          childPath,
                          block.type === 'MERGE'
                            ? Math.max(level - 2, 0)
                            : Math.max(level, 0) + 1,
                          renderedPaths
                        )}
                      </div>
                    );
                  }
                  return null;
                });
              }
              return null;
            })}
      </div>
    );
  };

  const mainPath = pathsToDisplay.find(
    (path) => path.parent_blocks.length === 0
  );

  return (
    <div
      className={cn(
        'w-64 h-full flex flex-col fixed left-0 top-0 border-r',
        className
      )}
      style={{
        backgroundColor: colors['bg-primary'],
        borderColor: colors['border-secondary'],
      }}
    >
      {/* Workspace Header */}
      <div className="w-full px-3 py-1 flex-col justify-start items-start inline-flex">
        <div 
          className="self-stretch px-3 py-2.5 rounded-md flex items-center gap-2 cursor-pointer hover:bg-opacity-80"
          onClick={() => router.push(`/`)}
          role="button"
          aria-label="Go to workspace dashboard"
        >
          <div className="relative w-8 h-8">
            {workspace.icon_url && (
              <img
                src={workspace.icon_url}
                alt={workspace.name}
                className="w-8 h-8 rounded-lg object-cover absolute inset-0"
                onError={(e) => {
                  e.currentTarget.style.display = 'none';
                }}
              />
            )}
            <div
              className="w-8 h-8 rounded-lg flex items-center justify-center text-white text-xs font-medium absolute inset-0"
              style={{
                backgroundColor:
                  workspace.background_colour || colors['bg-brand-primary'],
                display: 'flex',
                opacity: workspace.icon_url ? 0 : 1,
              }}
            >
              {workspace.name.charAt(0).toUpperCase()}
            </div>
          </div>
          <div className="relative flex flex-col px-0.5 min-w-0 flex-1">
            <div
              className="text-sm font-medium font-['Inter'] leading-tight truncate"
              style={{ color: colors['text-primary'] }}
            >
              {workspace.name}
            </div>
          </div>
        </div>
      </div>

      

      {/* Steps list */}
      <div className="flex-1 overflow-y-auto px-5">
        {mainPath && renderPathContent(mainPath, 0)}
      </div>
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/read/components/StepsContainer.tsx">
import React from 'react';
import { cn } from '@/lib/utils';
import { useColors } from '@/app/theme/hooks';
import { Path } from '../../types';

interface StepsContainerProps {
  path: Path;
  activeStepId: number;
  onStepClick: (stepId: number) => void;
  level?: number;
  isCollapsed?: boolean;
  onToggleCollapse?: () => void;
}

export default function StepsContainer({
  path,
  activeStepId,
  onStepClick,
  level = 0,
  isCollapsed = false,
  onToggleCollapse,
}: StepsContainerProps) {
  const colors = useColors();
  const blocks =
    path.blocks.filter(
      (block) => block.type === 'STEP' || block.type === 'DELAY'
    ) || [];

  // Helper function to get icon path for a block
  const getIconPath = (block: any) => {
    if (block.type === 'DELAY') {
      return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${
        block.delay_type === 'WAIT_FOR_EVENT'
          ? 'calendar-clock-1.svg'
          : 'clock-stopwatch-1.svg'
      }`;
    }
    if (block.icon && block.signedIconUrl) {
      return `${block.signedIconUrl}`;
    }
    return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/container.svg`;
  };

  // Helper function to format duration
  const formatDuration = (seconds?: number): string => {
    if (!seconds) return 'Not set';
    const days = Math.floor(seconds / 86400);
    const hours = Math.floor((seconds % 86400) / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);

    const parts = [];
    if (days > 0) parts.push(`${days}d`);
    if (hours > 0) parts.push(`${hours}h`);
    if (minutes > 0) parts.push(`${minutes}m`);

    return parts.length > 0 ? parts.join(' ') : '0m';
  };

  // Helper function to get block display text
  const getBlockDisplayText = (block: any) => {
    if (block.type === 'DELAY') {
      return block.delay_type === 'WAIT_FOR_EVENT'
        ? `Wait for Event: ${block.delay_event || 'Not set'}`
        : `Duration Delay: ${formatDuration(block.delay_seconds)}`;
    }
    return block.title || `Block ${block.id}`;
  };

  return (
    <div className="space-y-2" style={{ marginLeft: level * 16 }}>
      {/* Path header with collapse toggle */}
      <div
        className="flex items-center gap-2 p-2 rounded-md w-full hover-bg-custom cursor-pointer"
        style={
          {
            '--hover-bg': colors['bg-secondary'],
          } as React.CSSProperties
        }
        onClick={onToggleCollapse}
      >
        <img
          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/git-branch-icon.svg`}
          alt="Branch Icon"
          className="w-4 h-4"
        />
        <span
          className="text-sm truncate flex-1"
          style={{ color: colors['text-secondary'] }}
        >
          {path.name}
        </span>
        {onToggleCollapse && (
          <div
            className="p-1 rounded flex-shrink-0 hover-bg-custom"
            style={
              {
                '--hover-bg': colors['bg-secondary'],
              } as React.CSSProperties
            }
          >
            <img
              src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${
                isCollapsed ? 'chevron-right' : 'chevron-down'
              }.svg`}
              alt={isCollapsed ? 'Expand' : 'Collapse'}
              className="w-4 h-4"
            />
          </div>
        )}
      </div>

      {/* Blocks */}
      {!isCollapsed &&
        blocks.map((block) => (
          <button
            key={block.id}
            onClick={() => onStepClick(block.id)}
            className={cn(
              'w-full flex items-center gap-3 p-1 px-3 rounded-md text-sm max-w-full',
              'transition-colors duration-200 ease-in-out',
              'focus:outline-none cursor-pointer',
              activeStepId === block.id ? '' : 'hover-bg-custom'
            )}
            style={
              {
                backgroundColor:
                  activeStepId === block.id
                    ? colors['bg-brand-solid']
                    : 'transparent',
                '--hover-bg': colors['bg-secondary'],
              } as React.CSSProperties
            }
            role="link"
            aria-label={`Navigate to ${getBlockDisplayText(block)} section`}
          >
            {block.icon &&
            block.icon.startsWith('https://cdn.brandfetch.io/') ? (
              <img
                src={block.icon}
                alt="Step Icon"
                className="w-4 h-4"
                referrerPolicy="strict-origin-when-cross-origin"
              />
            ) : (
              <img
                src={getIconPath(block)}
                alt="Step Icon"
                className="w-4 h-4"
                onError={(e) => {
                  e.currentTarget.src = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon-base.svg`;
                }}
              />
            )}
            <span
              className={cn(
                'text-left text-sm truncate flex-1',
                activeStepId === block.id && 'font-medium'
              )}
              style={{
                color:
                  activeStepId === block.id
                    ? colors['text-white']
                    : colors['text-secondary'],
              }}
            >
              {getBlockDisplayText(block)}
            </span>
          </button>
        ))}

      <style jsx global>{`
        .hover-bg-custom:hover {
          background-color: var(--hover-bg);
        }
      `}</style>
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/read/components/ViewModeSwitch.tsx">
'use client';

import { useColors } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';

interface ViewModeSwitchProps {
  mode: 'vertical' | 'carousel';
  onModeChange: (mode: 'vertical' | 'carousel') => void;
}

export default function ViewModeSwitch({ mode, onModeChange }: ViewModeSwitchProps) {
  const colors = useColors();

  return (
    <div 
      className="inline-flex"
    >
      <ButtonNormal
        variant={mode === 'vertical' ? 'primary' : 'secondary'}
        size="small"
        iconOnly
        onClick={() => onModeChange('vertical')}
        className="!rounded-r-none"
        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/rows-01.svg`}
      />
      <ButtonNormal
        variant={mode === 'carousel' ? 'primary' : 'secondary'}
        size="small"
        iconOnly
        onClick={() => onModeChange('carousel')}
        className="!rounded-l-none !border-l-0"
        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/perspective-02.svg`}
      />
    </div>
  );
}
</file>

<file path="app/[slug]/[flow]/read/store/pathsStore.ts">
import { create } from 'zustand';
import { Block, Path } from '../../types';

interface PathsStore {
  paths: Path[];
  setPaths: (paths: Path[] | ((currentPaths: Path[]) => Path[])) => void;
}

export const usePathsStore = create<PathsStore>((set) => ({
  paths: [],
  setPaths: (paths) => set((state) => ({ 
    paths: typeof paths === 'function' ? paths(state.paths) : paths 
  })),
}));
</file>

<file path="app/[slug]/[flow]/read/utils/timeUtils.ts">
/**
 * Time utility functions for read mode
 */

/**
 * Formats time in minutes to human-readable format
 * @param minutes - Time in minutes as string or number
 * @returns Formatted time string (e.g., "5 min", "1h 30min", "2h")
 */
export function formatTime(minutes: string | number | null | undefined): string {
  if (!minutes) return '';
  
  const numMinutes = typeof minutes === 'string' ? parseInt(minutes, 10) : minutes;
  
  if (isNaN(numMinutes) || numMinutes <= 0) return '';
  
  if (numMinutes < 60) {
    return `${numMinutes} min`;
  }
  
  const hours = Math.floor(numMinutes / 60);
  const remainingMinutes = numMinutes % 60;
  
  if (remainingMinutes === 0) {
    return `${hours}h`;
  }
  
  return `${hours}h ${remainingMinutes}min`;
}

/**
 * Calculates total time from an array of blocks
 * @param blocks - Array of blocks with average_time property
 * @returns Total time in minutes
 */
export function calculateTotalTime(blocks: Array<{ average_time?: string | null }>): number {
  return blocks.reduce((total, block) => {
    if (!block.average_time) return total;
    
    const minutes = parseInt(block.average_time, 10);
    return isNaN(minutes) ? total : total + minutes;
  }, 0);
}

/**
 * Checks if a time value is valid
 * @param minutes - Time in minutes as string or number
 * @returns True if the time is valid and greater than 0
 */
export function isValidTime(minutes: string | number | null | undefined): boolean {
  if (!minutes) return false;
  
  const numMinutes = typeof minutes === 'string' ? parseInt(minutes, 10) : minutes;
  return !isNaN(numMinutes) && numMinutes > 0;
}
</file>

<file path="app/[slug]/[flow]/read/page.tsx">
import { redirect } from 'next/navigation';
import { Metadata } from 'next';
import ReadPageClient from './components/ReadPageClient';
import getBaseUrl from '@/app/utils/getBaseUrl';

interface PageParams {
  slug: string;
  flow: string;
}

interface PageProps {
  params: Promise<PageParams>;
}

interface Workflow {
  id: number;
  name: string;
  icon: string;
  description: string;
  workspace_id: number;
  public_access_id: string;
  folder_id?: number;
  last_opened?: Date;
  updated_at: string;
  created_at: string;
}

export async function generateMetadata({
  params,
}: {
  params: Promise<PageParams>;
}): Promise<Metadata> {
  // Decode the flow parameter
  const resolvedParams = await params;
  const lastPfIndex = resolvedParams.flow.lastIndexOf('--pf-');
  const workflowName = resolvedParams.flow.slice(0, lastPfIndex);
  const workflowId = resolvedParams.flow.slice(lastPfIndex + 5);
  if (!workflowName || !workflowId) {
    return { title: 'ProcessFlow' };
  }

  const headers: HeadersInit = {};

  if (process.env.VERCEL_AUTOMATION_BYPASS_SECRET) {
    headers['x-vercel-protection-bypass'] =
      process.env.VERCEL_AUTOMATION_BYPASS_SECRET;
  }
  // Get workflow data from API
  const baseUrl = getBaseUrl();
  const response = await fetch(`${baseUrl}/api/workflow/${workflowId}`, {
    headers,
  });

  if (!response.ok) {
    return { title: 'ProcessFlow' };
  }

  const workflow: Workflow = await response.json();
  return {
    title: `${workflow.name} | ProcessFlow`,
  };
}

export default async function ReadPage(props: PageProps) {
  // Decode the flow parameter
  const params = await props.params;
  const lastPfIndex = params.flow.lastIndexOf('--pf-');
  const workflowName = params.flow.slice(0, lastPfIndex);
  const workflowId = params.flow.slice(lastPfIndex + 5);
  if (!workflowName || !workflowId) {
    redirect('/'); // Redirect to root if parameters are invalid
  }

  // Get workflow data from API using path parameter
  const headers: HeadersInit = {};

  if (process.env.VERCEL_AUTOMATION_BYPASS_SECRET) {
    headers['x-vercel-protection-bypass'] =
      process.env.VERCEL_AUTOMATION_BYPASS_SECRET;
  }
  const baseUrl = getBaseUrl();
  const response = await fetch(`${baseUrl}/api/workflow/${workflowId}`, {
    headers,
  });

  if (!response.ok) {
    // Handle unauthorized or not found cases
    let error: any = {};
    const contentType = response.headers.get('content-type');
    if (contentType && contentType.includes('application/json')) {
      error = await response.json();
    }
    if (response.status === 401) {
      redirect('/login');
    } else {
      redirect('/');
    }
  }

  // You can pass workflow props here if needed
  // const workflow: Workflow = await response.json();

  return <ReadPageClient />;
}
</file>

<file path="app/[slug]/[flow]/utils/createLinks.ts">
import { WorkflowData } from "../types";

// Utility to sanitize workflow names for URLs
const sanitizeName = (name: string) =>
  name.replace(/\s+/g, '-');

export const createShareLink = (name: string, public_access_id: string) => {
  if (!name || !public_access_id) return;
  const sanitizedName = sanitizeName(name);
  const shareUrl = `${window.location.origin}/shared/${sanitizedName}--pf-${public_access_id}`;
  return shareUrl;
};

export const createEditLink = (name: string, workflowId: string, slug: string) => {
  const sanitizedName = sanitizeName(name);
  const shareUrl = `${window.location.origin}/${slug}/${sanitizedName}--pf-${workflowId}/edit`;
  return shareUrl;
};

export const createReadLink = (name: string, workflowId: string, slug: string) => {
  const sanitizedName = sanitizeName(name);
  const shareUrl = `${window.location.origin}/${slug}/${sanitizedName}--pf-${workflowId}/read`;
  return shareUrl;
};

export const createAndCopyShareLink = async (workflowId: number | string) => {
  try {
    const response = await fetch(`/api/workflow/${workflowId}`);
    if (!response.ok) throw new Error('Failed to fetch workflow');
    
    const workflow = await response.json();
    const shareUrl = createShareLink(workflow.name, workflow.public_access_id);
    
    if (!shareUrl) throw new Error('Could not create share link');
    
    await navigator.clipboard.writeText(shareUrl);
    return shareUrl;
  } catch (error) {
    throw error;
  }
};
</file>

<file path="app/[slug]/[flow]/utils/pathUtils.ts">
import { Path, Block } from '../types';
import { BlockEndType } from '@/types/block';

// Function to get the great grandparent path ID
export const getGreatGrandParentPathId = (path: Path, paths: Path[]): number | null => {
  // Get parent path
  const parentBlock = path.parent_blocks[0]?.block_id;
  if (!parentBlock) return null;

  // Find parent path
  const parentPath = paths.find((p) =>
    p.blocks.some((b) => b.id === parentBlock)
  );
  if (!parentPath) return null;

  // Get grandparent path
  const grandParentBlock = parentPath.parent_blocks[0]?.block_id;
  if (!grandParentBlock) return null;

  // Find grandparent path
  const grandParentPath = paths.find((p) =>
    p.blocks.some((b) => b.id === grandParentBlock)
  );
  if (!grandParentPath) return null;

  // Get great grandparent path
  const greatGrandParentBlock = grandParentPath.parent_blocks[0]?.block_id;
  if (!greatGrandParentBlock) return null;

  // Find and return great grandparent path ID
  const greatGrandParentPath = paths.find((p) =>
    p.blocks.some((b) => b.id === greatGrandParentBlock)
  );
  return greatGrandParentPath?.id ?? null;
};

export const organizePaths = (paths: Path[]) => {
  if (!paths || !Array.isArray(paths)) {
    return { mainPaths: [], mergePaths: [], paths: [] };
  }

  const mergeChildPaths = new Set<number>();
  const mainPathsArray: Path[] = [];
  const mergePathsArray: Path[] = [];

  if (!paths || paths.length === 0) {
    return { mainPaths: [], mergePaths: [] };
  }

  // Collect merge paths (avoiding duplicates)
  paths.forEach((path) => {
    path.blocks.forEach((block) => {
      if (block.type === 'MERGE') {
        const child_paths = paths.filter((p) =>
          block.child_paths?.some((childPath) => childPath.path.id === p.id)
        );
        child_paths.forEach((childPath) => {
          if (!mergeChildPaths.has(childPath.id)) {
            mergeChildPaths.add(childPath.id);
            mergePathsArray.push(childPath);
          }
        });
      }
    });
  });

  // Find first path
  paths.forEach((path) => {
    if (path.parent_blocks.length === 0) {
      mainPathsArray.push(path);
    }
  });

  // Process merge paths
  mergePathsArray.forEach((mergePath) => {
    const greatGrandParentId = getGreatGrandParentPathId(mergePath, paths);

    if (!greatGrandParentId) {
      mainPathsArray.push(mergePath);
    } else {
      // Find great grandparent path and add merge path to its last block's child_paths
      const greatGrandParent = paths.find((p) => p.id === greatGrandParentId);
      if (greatGrandParent) {
        const lastBlock = greatGrandParent.blocks[greatGrandParent.blocks.length - 1];
        if (!lastBlock.child_paths) {
          lastBlock.child_paths = [];
        }
        if (!lastBlock.child_paths.some((p) => p.path.id === mergePath.id)) {
          // Find parent path and process child paths
          const parent_path = paths.find((p) =>
            p.blocks.some((block) => block.id === mergePath.parent_blocks[0]?.block_id)
          );

          const grandparent_path = paths.find((p) =>
            p.blocks.some((block) => block.id === parent_path?.parent_blocks[0]?.block_id)
          );

          if (grandparent_path) {
            const grandparentIndex = lastBlock.child_paths.findIndex(
              (cp) => cp.path_id === grandparent_path.id
            );

            if (grandparentIndex !== -1) {
              // Process child paths movement
              const grandparent_last_block = grandparent_path.blocks[grandparent_path.blocks.length - 1];
              const childPathsToMove = grandparent_last_block.child_paths.filter(
                (childPath) =>
                  !mergePath.parent_blocks.some((pb) => {
                    const lastBlockOfChildPath = paths
                      .find((p) => p.id === childPath.path_id)
                      ?.blocks.slice(-1)[0];
                    return lastBlockOfChildPath?.id === pb.block_id;
                  })
              );

              // Update child paths
              grandparent_last_block.child_paths = grandparent_last_block.child_paths.filter(
                (cp) => !childPathsToMove.includes(cp)
              );

              lastBlock.child_paths.splice(grandparentIndex + 1, 0, {
                path: mergePath,
                path_id: mergePath.id,
                block_id: lastBlock.id,
                created_at: new Date().toISOString(),
                block: lastBlock,
              });

              // Update merge path's last block
              mergePath.blocks[mergePath.blocks.length - 1].type = BlockEndType.PATH;
              const mergePathLastBlock = mergePath.blocks[mergePath.blocks.length - 1];
              if (!mergePathLastBlock.child_paths) {
                mergePathLastBlock.child_paths = [];
              }
              mergePathLastBlock.child_paths.push(...childPathsToMove);
            }
          }
        }
      }
    }
  });

  return {
    mainPaths: mainPathsArray,
    mergePaths: mergePathsArray,
    paths,
  };
};
</file>

<file path="app/[slug]/[flow]/types.ts">
import { Workflow } from '@/types/workflow';
import { BlockEndType } from '@/types/block';

export interface NodeData {
  [key: string]: any;
  label: string;
  position: number;
  type: string;
  strokeLinesVisible?: boolean;
  updateStrokeLineVisibility?: (blockId: number, isVisible: boolean) => void;
  sourcePosition?: boolean;
  path?: Path;
  block: Block;
  onDelete?: (id: string) => void;
  onStrokeLinesUpdate?: (lines: any[]) => void;
  highlighted?: boolean;
  longestSiblingPath?: number;
  pathLength?: number;
  isLastInPath?: boolean;
  delayType?: DelayType;
  eventName?: string;
  seconds?: number;
  pathId?: number | null;
  pathName?: string;
  pathHasChildren?: boolean;
  workspaceId?: string;
  handleAddBlockOnEdge?: (
    position: number,
    path: Path,
    event?: { clientX: number; clientY: number }
  ) => void;
  onPathsUpdate?: (paths: Path[]) => void;
}

export interface EdgeData {
  blocks: Block[];
  path: Path;
  workspaceId: string;
  onPathsUpdate?: (paths: Path[]) => void;
  handleAddBlockOnEdge: (
    position: number,
    path: Path,
    event?: { clientX: number; clientY: number }
  ) => void;
}

export interface DropdownDatas {
  x: number;
  y: number;
  position: number;
  path: Path;
} 

// Interface for Path model
export interface Path {
  id: number;
  name: string;
  workflow_id: number;
  workflow: Workflow;  // Assuming a Workflow interface exists
  blocks: Block[];
  parent_blocks: PathParentBlock[];  // Assuming a PathParentBlock interface exists
}

export interface StrokeLine {
  id: number;
  source_block_id: number;
  target_block_id: number;
  label: string;
  control_points: { x: number; y: number }[];
}

export interface WorkflowData {
  id: string;
  name: string;
  is_public: boolean;
  public_access_id: string;
  workspace_id: string;
  workspace: {
    id: string;
    name: string;
  };
  category: {
    id: string;
    name: string;
  };
  icon?: string;
  signedIconUrl?: string;
  description?: string;
  process_owner?: string;
  review_date?: string;
  additional_notes?: string;
  author?: {
    full_name: string;
    avatar_url?: string;
    avatar_signed_url?: string;
  };
  folder?: {
    id: string;
    name: string;
    parent?: {
      id: string;
      name: string;
    };
  };
}

export enum DelayType {
  FIXED_DURATION = 'FIXED_DURATION',
  WAIT_FOR_EVENT = 'WAIT_FOR_EVENT'
}

// Interface for Block model
export interface Block {
  id: number;
  original_id?: number;
  created_at: string;  // DateTime
  updated_at: string;  // DateTime
  type: BlockType;  // Assuming a BlockType enum exists
  delay_seconds?: number | null;
  position: number;
  title?: string | null;
  icon?: string | null;
  signedIconUrl?: string | null;
  description?: string | null;
  image?: string | null;
  signedImageUrl?: string | null;
  original_image?: string | null;
  image_description?: string | null;
  average_time?: string | null;
  task_type?: TaskType | null;  // Assuming a TaskType enum exists
  delay_event?: string | null;
  delay_type?: DelayType | null;  // Assuming a DelayType enum exists
  workflow_id: number;
  path_id: number;
  workflow: Workflow;  // Assuming a Workflow interface exists
  path: Path;
  child_paths: PathParentBlock[];  // Assuming a PathParentBlock interface exists
  condition?: {
    name: string;
    title: string;
    description: string;
  };
  is_endpoint?: boolean;
}

// Assuming enums and other interfaces
export type BlockType = 'STEP' | 'DELAY' | 'BEGIN' | BlockEndType;
export type TaskType = 'TASK_TYPE_1' | 'TASK_TYPE_2';  // Example enum

export interface PathParentBlock {
  path_id: number;
  block_id: number;
  created_at: string;  // DateTime
  path: Path;
  block: Block;
}

// Add this interface if you're using custom node types
export interface CustomBlock extends Node {
  parentId?: string;
  expandParent?: boolean;
}
</file>

<file path="app/[slug]/page.tsx">
import { redirect } from 'next/navigation';
import prismaSingleton from '@/lib/prisma';
import { isVercel } from '@/app/api/utils/isVercel';
import { PrismaClient } from '@prisma/client';

interface PageParams {
  slug: string;
}

interface SearchParams {
  checkout?: string;
  session_id?: string;
}

// Valid checkout status types
const VALID_CHECKOUT_STATUSES = ['success', 'cancelled'] as const;
type CheckoutStatus = (typeof VALID_CHECKOUT_STATUSES)[number];

// Validate checkout status
function isValidCheckoutStatus(
  status: string | undefined
): status is CheckoutStatus {
  return (
    typeof status === 'string' &&
    VALID_CHECKOUT_STATUSES.includes(status as CheckoutStatus)
  );
}

// Configure page behavior
export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

interface PageProps {
  params: Promise<PageParams>;
  searchParams: Promise<SearchParams>;
}

export default async function WorkspaceSlugPage(props: PageProps) {
  // Await params before destructuring in Next.js 15
  const params = await props.params;
  const searchParams = await props.searchParams;

  const slug = params.slug;

  // Use a new PrismaClient on Vercel, otherwise use the singleton
  const prisma = isVercel() ? new PrismaClient() : prismaSingleton;

  if (!prisma) {
    throw new Error('Prisma client not initialized');
  }

  // Find the workspace by slug
  const workspace = await prisma.workspace.findUnique({
    where: { slug },
    select: { id: true },
  });

  if (!workspace) {
    return redirect('/');
  }

  // Build the target URL
  const baseUrl = '/';
  const workspaceParam = `workspace=${workspace.id}`;

  // Only add checkout param if it's from Stripe
  const checkoutParam = searchParams.checkout
    ? `&checkout=${searchParams.checkout}`
    : '';
  const sessionParam = searchParams.session_id
    ? `&session_id=${searchParams.session_id}`
    : '';

  if (checkoutParam || sessionParam) {
    const targetUrl = `${baseUrl}?${workspaceParam}${checkoutParam}${sessionParam}`;
    return redirect(targetUrl);
  }

  return redirect(baseUrl);
}
</file>

<file path="app/api/auth/check-onboarding/route.ts">
import { createClient } from '@/utils/supabase/server';
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

/**
 * @swagger
 * /api/auth/check-onboarding:
 *   get:
 *     summary: Check onboarding status for the authenticated user
 *     description: Returns the current onboarding step and whether onboarding is completed for the authenticated user.
 *     tags:
 *       - Auth
 *     security:
 *       - supabaseAuth: []
 *     responses:
 *       200:
 *         description: Onboarding status retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 onboardingStep:
 *                   type: string
 *                   example: PERSONAL_INFO
 *                 completed:
 *                   type: boolean
 *                   example: false
 *       401:
 *         description: Not authenticated
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Not authenticated
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal server error
 */
export async function GET(request: Request) {
  const supabase = await createClient();
  // Utiliser getUser() au lieu de getSession()
  const { data: { user }, error } = await supabase.auth.getUser();

  if (error || !user) {
    return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
  }

  // Choose the correct Prisma client
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const userInfo = await prisma_client.user.findUnique({
      where: { auth_id: user.id },
      select: {
        onboarding_step: true,
        onboarding_completed_at: true
      }
    });

    return NextResponse.json({
      onboardingStep: userInfo?.onboarding_step || 'PERSONAL_INFO',
      completed: !!userInfo?.onboarding_completed_at
    });
  } catch (error) {
    console.error('Error checking onboarding status:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/auth/clear-reset-cookies/route.ts">
import { NextResponse } from 'next/server';

/**
 * @swagger
 * /api/auth/clear-reset-cookies:
 *   post:
 *     summary: Clear password reset cookies
 *     description: Removes password reset-related cookies from the client.
 *     tags:
 *       - Auth
 *     responses:
 *       200:
 *         description: Cookies cleared successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Cookies cleared
 */

export async function POST() {
  const response = NextResponse.json({ message: 'Cookies cleared' });
  
  // Clear all reset-related cookies
  response.cookies.delete('password-reset-token');
  response.cookies.delete('reset-user-id');
  
  return response;
}
</file>

<file path="app/api/auth/confirm/route.ts">
import { createClient } from '@/utils/supabase/server';
import { NextResponse, type NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function GET(request: NextRequest) {
  const requestUrl = new URL(request.url);
  const token_hash = requestUrl.searchParams.get('token_hash');
  const type = requestUrl.searchParams.get('type');

  if (!token_hash || !type) {
    return NextResponse.redirect(new URL('/login?error=invalid_token', request.url));
  }

  const supabase = await createClient();

  // Choose the correct Prisma client
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { data, error } = await supabase.auth.verifyOtp({
      token_hash,
      type: 'email'
    });

    if (error) {
      console.error('Verification error:', error);
      return NextResponse.redirect(new URL(`/login?error=${error.message}`, request.url));
    }

    if (data?.user && data?.session) {
      try {
        const existingUser = await prisma_client.user.findUnique({
          where: { auth_id: data.user.id }
        });

        if (!existingUser) {
          await prisma_client.user.create({
            data: {
              auth_id: data.user.id,
              email: data.user.email || '',
              first_name: '',
              last_name: '',
              full_name: '',
            }
          });
        }

        const response = NextResponse.redirect(new URL('/onboarding', request.url));
        
        response.cookies.set('sb-access-token', data.session.access_token, {
          path: '/',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 7, // 7 jours
        });
        
        response.cookies.set('sb-refresh-token', data.session.refresh_token!, {
          path: '/',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 7, // 7 jours
        });

        return response;
      } catch (error) {
        console.error('Database error:', error);
        return NextResponse.redirect(new URL('/login?error=database', request.url));
      }
    }

    return NextResponse.redirect(new URL('/login?error=no_session', request.url));
  } catch (error) {
    console.error('Error during confirmation:', error);
    return NextResponse.redirect(new URL('/login?error=confirmation_failed', request.url));
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/auth/perform-password-reset/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/utils/supabase/server';

export async function POST(req: NextRequest) {
  const supabase = await createClient();
  const { password } = await req.json();

  // Get token_hash from cookies
  const token_hash = req.cookies.get('password-reset-token')?.value;
  if (!token_hash) {
    return NextResponse.json({ error: 'Missing reset token.' }, { status: 400 });
  }

  // Re-establish recovery session
  const { error: otpError } = await supabase.auth.verifyOtp({
    token_hash,
    type: 'recovery',
  });
  if (otpError) {
    return NextResponse.json({ error: otpError.message }, { status: 400 });
  }

  // Now update the password
  const { error } = await supabase.auth.updateUser({ password });
  if (error) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }

  // After updating the password
  const { error: signOutError } = await supabase.auth.signOut();
  if (signOutError) {
    // Optionally log or handle sign out error, but usually you can ignore it here
  }

  // Optionally clear the reset token cookie here

  return NextResponse.json({ message: 'Password reset successful.' });
}
</file>

<file path="app/api/auth/reset-password/route.ts">
// app/api/auth/reset-password/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/utils/supabase/server';

/**
 * @swagger
 * /api/auth/reset-password:
 *   post:
 *     summary: Request a password reset
 *     description: This endpoint sends a password reset email to the provided email address.
 *     tags:
 *       - Auth
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *             required:
 *               - email
 *     responses:
 *       200:
 *         description: Reset email sent successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *       400:
 *         description: Bad request - Invalid input or error sending email
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 */
export async function POST(req: NextRequest) {
  const supabase = await createClient();
  const { email } = await req.json();

  if (!email) {
    return NextResponse.json({ error: 'Email is required' }, { status: 400 });
  }

  // Dynamically determine the base URL
  const baseUrl =
    process.env.NEXT_PUBLIC_BASE_URL ||
    `${req.nextUrl.protocol}//${req.nextUrl.host}`;

 
  const { error } = await supabase.auth.resetPasswordForEmail(email, {
    redirectTo: `${baseUrl}`,
  });

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }

  return NextResponse.json({ message: 'Reset email sent.' }, { status: 200 });
}
</file>

<file path="app/api/auth-status/route.ts">
import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabaseServerClient';

export async function GET(request: Request) {
  // Get the origin from the request headers
  const origin = request.headers.get('origin') || '';
  
  // Allow requests from both the www and non-www versions of your domain
  const allowedOrigins = [
    'https://process-flow.io',
    'https://www.process-flow.io',
    'https://processflow02.webflow.io/'
  ];
  
  // Set the appropriate CORS header based on the request origin
  const corsHeaders = {
    'Access-Control-Allow-Origin': allowedOrigins.includes(origin) ? origin : allowedOrigins[0],
    'Access-Control-Allow-Credentials': 'true',
    'Access-Control-Allow-Methods': 'GET, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization'
  };
  
  const supabase = createClient();
  const { data: { user }, error } = await supabase.auth.getUser();
  
  return NextResponse.json(
    { authenticated: !!user },
    { headers: corsHeaders }
  );
}

export async function OPTIONS(request: Request) {
  // Get the origin from the request headers
  const origin = request.headers.get('origin') || '';
  
  // Allow requests from both the www and non-www versions of your domain
  const allowedOrigins = [
    'https://process-flow.io',
    'https://www.process-flow.io',
    'https://processflow02.webflow.io/'
  ];
  
  return NextResponse.json(
    {},
    {
      headers: {
        'Access-Control-Allow-Origin': allowedOrigins.includes(origin) ? origin : allowedOrigins[0],
        'Access-Control-Allow-Credentials': 'true',
        'Access-Control-Allow-Methods': 'GET, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization'
      },
    }
  );
}
</file>

<file path="app/api/batch-signed-urls/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { generatePublicUrl } from '../utils/generatePublicUrl';

/**
 * @swagger
 * /api/batch-signed-urls:
 *   post:
 *     summary: Get public URLs for multiple files in batch
 *     description: Generates public URLs for multiple files stored in the public Supabase storage bucket.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               paths:
 *                 type: array
 *                 items:
 *                   type: string
 *                 description: Array of file paths in the storage bucket.
 *                 example: ["step-icons/apps/app1.png", "step-icons/default-icons/icon1.svg"]
 *     responses:
 *       200:
 *         description: Successfully generated public URLs
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 signedUrls:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       path:
 *                         type: string
 *                       signedUrl:
 *                         type: string
 *                       error:
 *                         type: string
 *       400:
 *         description: Missing required paths parameter
 *       500:
 *         description: Internal server error
 */
export async function POST(req: NextRequest) {
  try {
    const { paths } = await req.json();

    if (!paths || !Array.isArray(paths) || paths.length === 0) {
      return NextResponse.json(
        { error: 'Paths array is required and must not be empty' },
        { status: 400 }
      );
    }

    // Generate public URLs for all paths
    const signedUrls = paths.map((path: string) => {
      try {
        const publicUrl = generatePublicUrl(path);
        return {
          path,
          signedUrl: publicUrl,
          error: null
        };
      } catch (error: any) {
        return {
          path,
          signedUrl: null,
          error: error.message || 'Unknown error'
        };
      }
    });

    return NextResponse.json({ signedUrls });
  } catch (error: any) {
    console.error('Error in batch public URLs:', error);
    return NextResponse.json(
      { error: error.message || 'Something went wrong' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/billing-info/route.ts">
/**
 * @swagger
 * /api/billing-info:
 *   get:
 *     summary: Get billing information for a workspace
 *     description: Returns billing information for a workspace if the user is authorized.
 *     tags:
 *       - Billing
 *     parameters:
 *       - in: query
 *         name: workspaceId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the workspace.
 *     responses:
 *       200:
 *         description: Billing information retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 billing_email:
 *                   type: string
 *                 billing_address:
 *                   type: string
 *                 address_line1:
 *                   type: string
 *                 address_line2:
 *                   type: string
 *                   nullable: true
 *                 city:
 *                   type: string
 *                 state:
 *                   type: string
 *                   nullable: true
 *                 postal_code:
 *                   type: string
 *                 country_code:
 *                   type: string
 *                 tax_rate:
 *                   type: number
 *                 vat_number:
 *                   type: string
 *                   nullable: true
 *                 payment_method:
 *                   type: object
 *                   nullable: true
 *                   properties:
 *                     brand:
 *                       type: string
 *                     last4:
 *                       type: string
 *                     expiry_month:
 *                       type: integer
 *                     expiry_year:
 *                       type: integer
 *       400:
 *         description: Missing or invalid parameters
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Unauthorized access to workspace
 *       404:
 *         description: Workspace not found
 *       500:
 *         description: Failed to fetch billing information
 *   post:
 *     summary: Create or update billing information for a workspace
 *     description: Creates or updates billing information for a workspace if the user is an admin.
 *     tags:
 *       - Billing
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - workspaceId
 *               - billing_email
 *               - address_line1
 *               - city
 *               - postal_code
 *               - country_code
 *             properties:
 *               workspaceId:
 *                 type: integer
 *               billing_email:
 *                 type: string
 *               billing_address:
 *                 type: string
 *               address_line1:
 *                 type: string
 *               address_line2:
 *                 type: string
 *                 nullable: true
 *               city:
 *                 type: string
 *               state:
 *                 type: string
 *                 nullable: true
 *               postal_code:
 *                 type: string
 *               country_code:
 *                 type: string
 *               tax_rate:
 *                 type: number
 *               vat_number:
 *                 type: string
 *                 nullable: true
 *     responses:
 *       200:
 *         description: Billing information updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 billing_email:
 *                   type: string
 *                 billing_address:
 *                   type: string
 *                 tax_rate:
 *                   type: number
 *                 vat_number:
 *                   type: string
 *                   nullable: true
 *                 address_line1:
 *                   type: string
 *                 address_line2:
 *                   type: string
 *                   nullable: true
 *                 city:
 *                   type: string
 *                 state:
 *                   type: string
 *                   nullable: true
 *                 postal_code:
 *                   type: string
 *                 country_code:
 *                   type: string
 *                 stripeUpdate:
 *                   type: object
 *                   properties:
 *                     success:
 *                       type: boolean
 *                     error:
 *                       type: string
 *                       nullable: true
 *       400:
 *         description: Missing required fields
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Unauthorized access to workspace
 *       404:
 *         description: Workspace or user not found
 *       500:
 *         description: Internal server error
 */
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { createClient } from '@/lib/supabaseServerClient';
import Stripe from 'stripe';
import { cookies } from 'next/headers';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

if (!process.env.STRIPE_SECRET_KEY) {
  throw new Error('STRIPE_SECRET_KEY is not defined');
}

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: '2025-02-24.acacia',
});

// Helper function to determine if we should log
const shouldLog = () => {
  const env = process.env.NODE_ENV;
  return env !== 'production';
};

// Helper function for conditional logging
const conditionalLog = (...args: any[]) => {
  if (shouldLog()) {
    console.log(...args);
  }
};

// Helper function for conditional error logging
const conditionalErrorLog = (...args: any[]) => {
  if (shouldLog()) {
    console.error(...args);
  }
};

interface BillingInfoRequest {
  workspaceId: number;
  billing_email: string;
  billing_address: string;
  address_line1: string;
  address_line2?: string;
  city: string;
  state?: string;
  postal_code: string;
  country_code: string;
  tax_rate: number;
  vat_number?: string;
}

// GET billing info for a workspace
export async function GET(req: Request) {
  // Choose the correct Prisma client
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Get the user session using Supabase
    const cookieStore = cookies();
    const supabase = createClient();
    const { data: { session }, error: authError } = await supabase.auth.getSession();

    if (!session || authError) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { searchParams } = new URL(req.url);
    const workspaceId = searchParams.get('workspaceId');

    if (!workspaceId) {
      return NextResponse.json({ error: 'Workspace ID required' }, { status: 400 });
    }

    // Find workspace and check if user has access
    const workspace = await prisma_client.workspace.findUnique({
      where: { id: parseInt(workspaceId) },
      include: {
        user_workspaces: {
          where: {
            user: {
              auth_id: session.user.id
            }
          }
        },
        billing_infos: true
      }
    });

    if (!workspace) {
      return NextResponse.json({ error: 'Workspace not found' }, { status: 404 });
    }

    if (workspace.user_workspaces.length === 0) {
      return NextResponse.json({ error: 'Unauthorized access to workspace' }, { status: 403 });
    }

    // If there's no Stripe customer ID, return empty billing info
    if (!workspace.stripe_customer_id) {
      return NextResponse.json({
        billing_email: '',
        billing_address: '',
        address_line1: '',
        city: '',
        postal_code: '',
        country_code: '',
        tax_rate: 0,
      });
    }

    try {
      // Get the latest customer details from Stripe
      const customer = await stripe.customers.retrieve(workspace.stripe_customer_id, {
        expand: ['tax_ids']
      }) as Stripe.Customer;

      if ('deleted' in customer) {
        throw new Error('Stripe customer has been deleted');
      }

      // Format the address components
      const address: Stripe.Address = customer.address || {
        line1: '',
        line2: null,
        city: '',
        state: '',
        postal_code: '',
        country: ''
      };
      
      // Update billing information in our database
      await prisma_client.workspace_billing_infos.upsert({
        where: {
          workspace_id: parseInt(workspaceId)
        },
        update: {
          billing_email: customer.email || '',
          billing_address: [
            address.line1,
            address.line2,
            address.city,
            address.state,
            address.postal_code,
            address.country,
          ].filter(Boolean).join('\n'),
          tax_rate: workspace.billing_infos?.tax_rate || 20.00, // Keep existing tax rate or use default
          vat_number: customer.tax_ids?.data[0]?.value || null,
        },
        create: {
          workspace_id: parseInt(workspaceId),
          billing_email: customer.email || '',
          billing_address: [
            address.line1,
            address.line2,
            address.city,
            address.state,
            address.postal_code,
            address.country,
          ].filter(Boolean).join('\n'),
          tax_rate: 20.00, // Default tax rate
          vat_number: customer.tax_ids?.data[0]?.value || null,
        },
      });

      // Get payment method if available
      let paymentMethod = null;
      const paymentMethods = await stripe.paymentMethods.list({
        customer: workspace.stripe_customer_id,
        type: 'card',
        limit: 1,
      });

      if (paymentMethods.data.length > 0) {
        const card = paymentMethods.data[0].card;
        if (card) {
          paymentMethod = {
            brand: card.brand,
            last4: card.last4,
            expiry_month: card.exp_month,
            expiry_year: card.exp_year,
          };
        }
      }

      // Return the formatted billing information
      return NextResponse.json({
        billing_email: customer.email || '',
        address_line1: address.line1 || '',
        address_line2: address.line2 || '',
        city: address.city || '',
        state: address.state || '',
        postal_code: address.postal_code || '',
        country_code: address.country || '',
        tax_rate: workspace.billing_infos?.tax_rate || 20.00,
        vat_number: customer.tax_ids?.data[0]?.value || null,
        payment_method: paymentMethod,
      });

    } catch (stripeError) {
      conditionalErrorLog('Error fetching Stripe customer details:', stripeError);
      // If there's an error with Stripe, return the local billing info if available
      if (workspace.billing_infos) {
        const addressParts = workspace.billing_infos.billing_address.split('\n');
        return NextResponse.json({
          billing_email: workspace.billing_infos.billing_email,
          address_line1: addressParts[0] || '',
          address_line2: addressParts[1] || '',
          city: addressParts[2] || '',
          state: addressParts[3] || '',
          postal_code: addressParts[4] || '',
          country_code: addressParts[5] || '',
          tax_rate: workspace.billing_infos.tax_rate,
          vat_number: workspace.billing_infos.vat_number,
        });
      }
      throw stripeError;
    } finally {
      if (isVercel()) {
        await prisma_client.$disconnect();
      }
    }
  } catch (error) {
    conditionalErrorLog('Error in billing-info endpoint:', error);
    return NextResponse.json(
      { error: 'Failed to fetch billing information' },
      { status: 500 }
    );
  }
}

// POST to create/update billing info
export async function POST(req: Request) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const supabase = createClient();
    const { data: { user }, error } = await supabase.auth.getUser();

    if (error || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const dbUser = await prisma_client.user.findUnique({
      where: { auth_id: user.id },
      select: { id: true }
    });

    if (!dbUser) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    const body: BillingInfoRequest = await req.json();
    const { 
      workspaceId, 
      billing_email, 
      billing_address,
      address_line1,
      address_line2,
      city,
      state,
      postal_code,
      country_code,
      tax_rate, 
      vat_number 
    } = body;

    if (!workspaceId || !billing_email || !address_line1 || !city || !postal_code || !country_code) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    // Check if user has access to this workspace
    const userWorkspace = await prisma_client.user_workspace.findFirst({
      where: {
        user_id: dbUser.id,
        workspace_id: workspaceId,
        role: 'ADMIN',
      },
      select: { id: true }
    });

    if (!userWorkspace) {
      return NextResponse.json({ error: 'Unauthorized access to workspace' }, { status: 403 });
    }

    // Get the workspace to access Stripe customer ID
    const workspace = await prisma_client.workspace.findUnique({
      where: { id: workspaceId },
      select: { stripe_customer_id: true }
    });

    if (!workspace) {
      return NextResponse.json({ error: 'Workspace not found' }, { status: 404 });
    }

    let stripeUpdateStatus: { success: boolean; error: string | null } = { 
      success: false, 
      error: null 
    };

    // If we have a Stripe customer ID, update their billing information in Stripe
    if (workspace.stripe_customer_id) {
      try {
        conditionalLog('Updating Stripe customer:', workspace.stripe_customer_id, {
          email: billing_email,
          address: {
            line1: address_line1,
            line2: address_line2,
            city,
            state,
            postal_code,
            country: country_code,
          }
        });

        // Update the customer's basic info
        const updatedCustomer = await stripe.customers.update(workspace.stripe_customer_id, {
          email: billing_email,
          address: {
            line1: address_line1,
            line2: address_line2 || undefined,
            city,
            state: state || undefined,
            postal_code,
            country: country_code,
          },
        });

        conditionalLog('Stripe customer update response:', updatedCustomer);

        // Handle VAT number for EU countries
        if (vat_number) {
          conditionalLog('Updating VAT number for customer:', workspace.stripe_customer_id);
          
          // First, list existing tax IDs
          const existingTaxIds = await stripe.customers.listTaxIds(workspace.stripe_customer_id);
          conditionalLog('Existing tax IDs:', existingTaxIds.data);
          
          // Delete existing EU VAT tax IDs
          for (const taxId of existingTaxIds.data) {
            if (taxId.type === 'eu_vat') {
              conditionalLog('Deleting existing VAT ID:', taxId.id);
              await stripe.customers.deleteTaxId(workspace.stripe_customer_id, taxId.id);
            }
          }
          
          // Create new tax ID
          const newTaxId = await stripe.customers.createTaxId(workspace.stripe_customer_id, {
            type: 'eu_vat',
            value: vat_number,
          });
          conditionalLog('Created new tax ID:', newTaxId);
        }

        stripeUpdateStatus.success = true;
      } catch (stripeError) {
        conditionalErrorLog('Error updating Stripe customer:', {
          error: stripeError,
          customerId: workspace.stripe_customer_id,
          requestData: {
            email: billing_email,
            address: {
              line1: address_line1,
              line2: address_line2,
              city,
              state,
              postal_code,
              country: country_code,
            },
            vatNumber: vat_number
          }
        });
        
        stripeUpdateStatus.error = stripeError instanceof Error ? stripeError.message : 'Unknown Stripe error';
      }
    }

    // Upsert billing info in database
    const billingInfo = await prisma_client.workspace_billing_infos.upsert({
      where: {
        workspace_id: workspaceId,
      },
      update: {
        billing_email,
        billing_address,
        tax_rate,
        vat_number,
      },
      create: {
        workspace_id: workspaceId,
        billing_email,
        billing_address,
        tax_rate,
        vat_number,
      },
    });

    return NextResponse.json({
      ...billingInfo,
      address_line1,
      address_line2,
      city,
      state,
      postal_code,
      country_code,
      stripeUpdate: stripeUpdateStatus
    });
  } catch (error) {
    conditionalErrorLog('Error updating billing info:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/blocks/[id]/toggle-endpoint/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';


export async function PATCH(request: NextRequest) {
  // Extract the block ID from the URL
  const { pathname } = request.nextUrl;
  const match = pathname.match(/\/blocks\/(\d+)\/toggle-endpoint/);
  const blockId = match ? Number(match[1]) : NaN;

  if (isNaN(blockId)) {
    return NextResponse.json({ error: 'Invalid block ID' }, { status: 400 });
  }

  // Choose the correct Prisma client
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Fetch the block with its path and all blocks in the path, ordered by position
    const block = await prisma_client.block.findUnique({
      where: { id: blockId },
      select: {
        id: true,
        is_endpoint: true,
        path_id: true,
        path: {
          select: {
            blocks: {
              select: { id: true },
              orderBy: { position: 'asc' },
            },
          },
        },
      },
    });

    if (!block) {
      return NextResponse.json({ error: 'Block not found' }, { status: 404 });
    }

    // Check if block is the source of any stroke lines (excluding self-referencing)
    const strokeLineCount = await prisma_client.stroke_line.count({
      where: {
        source_block_id: blockId,
      },
    });

    if (strokeLineCount === 0) {
      return NextResponse.json(
        { error: 'Block is not the source of any stroke lines.' },
        { status: 400 }
      );
    }

    const blocksInPath = block.path?.blocks ?? [];
    if (blocksInPath.length < 2) {
      return NextResponse.json(
        { error: 'Path does not have enough blocks to determine penultimate block.' },
        { status: 400 }
      );
    }

    // The penultimate block is at length - 2
    const penultimateBlock = blocksInPath[blocksInPath.length - 2];

    if (penultimateBlock.id !== blockId) {
      return NextResponse.json(
        { error: 'Block is not the penultimate block in its path.' },
        { status: 400 }
      );
    }

    // Toggle the is_endpoint value
    const updatedBlock = await prisma_client.block.update({
      where: { id: blockId },
      data: { is_endpoint: !block.is_endpoint },
    });

    return NextResponse.json(updatedBlock, { status: 200 });
  } catch (error) {
    console.error('Error toggling is_endpoint:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/blocks/delete-multiple/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { supabase } from '@/lib/supabaseClient';
import { deleteManyPaths } from '@/app/api/utils/paths/deleteMany';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

/**
 * @openapi
 * /api/blocks/delete-multiple:
 *   post:
 *     summary: Delete multiple blocks by IDs
 *     description: |
 *       Deletes multiple blocks by their IDs. 
 *       - If a block is of type `PATH`, its child paths are deleted and the block is converted to type `LAST`.
 *       - If a block has an image, the image is deleted from Supabase storage.
 *       - Only blocks of type `STEP` and `DELAY` are actually deleted from the database.
 *       - After deletion, positions of subsequent blocks in the same path are decremented.
 *     tags:
 *       - Blocks
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - blockIds
 *             properties:
 *               blockIds:
 *                 type: array
 *                 items:
 *                   type: integer
 *                 description: Array of block IDs to delete
 *           example:
 *             blockIds: [1, 2, 3]
 *     responses:
 *       '200':
 *         description: Blocks deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *       '500':
 *         description: Server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Failed to delete blocks
 */

export async function POST(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { blockIds } = await req.json();

    // Get blocks to handle image deletion and child_paths
    const blocks = await prisma_client.block.findMany({
      where: {
        id: {
          in: blockIds
        }
      },
      select: {
        id: true,
        type: true,
        path_id: true,
        image: true,
        position: true,
        child_paths: {
          select: { path_id: true }
        }
      }
    });

    // If no blocks found, just return success
    if (blocks.length === 0) {
      return NextResponse.json({ success: true });
    }

    // Path ID of the first deleted block
    const pathId = blocks[0].path_id;

    // Delete images from storage if they exist
    const bucketName = process.env.NEXT_PUBLIC_SUPABASE_PRIVATE_BUCKET;
    if (bucketName) {
      for (const block of blocks) {
        if (block.image) {
          const { error } = await supabase.storage
            .from(bucketName)
            .remove([block.image]);
          
          if (error) {
            console.error('Error deleting image:', error);
          }
        }
      }
    }

    // Handle PATH blocks: delete their child paths and convert to LAST
    for (const block of blocks) {
      if (block.type === 'PATH') {
        const childPathIds = block.child_paths.map(cp => cp.path_id);
        if (childPathIds.length > 0) {
          await deleteManyPaths(childPathIds);
        }
        // Convert block to LAST
        await prisma_client.block.update({
          where: { id: block.id },
          data: { type: 'LAST' }
        });
      }
    }

    // Delete only STEP and DELAY blocks
    await prisma_client.block.deleteMany({
      where: {
        id: {
          in: blockIds
        },
        type: {
          in: ['STEP', 'DELAY']
        }
      }
    });

    // Decrement positions of blocks with position > maxDeletedPosition
    const deletedPositions = blocks.map(b => b.position);
    const maxDeletedPosition = Math.max(...deletedPositions);
    const numDeleted = blocks.length;

    await prisma_client.block.updateMany({
      where: {
        path_id: pathId,
        position: { gt: maxDeletedPosition }
      },
      data: {
        position: { decrement: numDeleted }
      }
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error deleting blocks:', error);
    return NextResponse.json(
      { error: 'Failed to delete blocks' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/blocks/move/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { Prisma } from '@prisma/client';
import { BlockEndType, BlockType } from '@/types/block';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

interface MoveBlocksRequest {
  block_ids: number[];
  destination_path_id: number;
}

/**
 * @swagger
 * /api/blocks/move:
 *   post:
 *     summary: Move blocks to a destination path
 *     description: Moves specified blocks to a destination path, maintaining proper block ordering and ensuring END block remains last
 *     tags:
 *       - Blocks
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - block_ids
 *               - destination_path_id
 *             properties:
 *               block_ids:
 *                 type: array
 *                 items:
 *                   type: integer
 *                 description: Array of block IDs to move
 *               destination_path_id:
 *                 type: integer
 *                 description: ID of the destination path
 *     responses:
 *       200:
 *         description: Blocks successfully moved
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                 blocks:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                       position:
 *                         type: integer
 *                       type:
 *                         type: string
 *       400:
 *         description: Invalid input parameters
 *       404:
 *         description: Path or blocks not found
 *       500:
 *         description: Server error
 */

export async function POST(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const body: MoveBlocksRequest = await req.json();
    const { block_ids, destination_path_id } = body;

    // Validate input
    if (!Array.isArray(block_ids) || block_ids.length === 0 || !destination_path_id) {
      return NextResponse.json(
        { error: 'Invalid input: block_ids array and destination_path_id are required' },
        { status: 400 }
      );
    }

    // Use transaction to ensure all operations succeed or none do
    const result = await prisma_client.$transaction(async (tx) => {
      // Get destination path blocks to find END block and current positions
      const destinationBlocks = await tx.block.findMany({
        where: { path_id: destination_path_id },
        orderBy: { position: 'asc' },
      });

      // Find any end-type block
      const endBlock = destinationBlocks.find(block => 
        Object.values(BlockEndType).includes(block.type as BlockEndType)
      );

      if (!endBlock) {
        throw new Error('Destination path has no end-type block');
      }

      // Calculate position before END block
      const positionBeforeEnd = endBlock.position - 1;

      // Update all blocks in a single query for better performance
      await tx.block.updateMany({
        where: {
          id: {
            in: block_ids
          }
        },
        data: {
          path_id: destination_path_id,
        }
      });

      // First, put the Begin block to position 0
        await tx.block.updateMany({
          where: {
            path_id: destination_path_id,
            type: { 
              in: [BlockType.BEGIN]
            }
          },
          data: {
            position: 0
          }
        });

      // Update positions of moved blocks
      const updates = block_ids.map((blockId, index) => {
        return tx.block.update({
          where: { id: blockId },
          data: { 
            position: index + 1
          }
        });
      });

      // Execute all position updates in parallel
      await Promise.all(updates);

      // Ensure END block is at the last position
      await tx.block.update({
        where: { id: endBlock.id },
        data: { 
          position: block_ids.length + 1
        }
      });

      // Get the updated path with all blocks
      const updatedPath = await tx.path.findUnique({
        where: { id: destination_path_id },
        include: {
          blocks: {
            orderBy: { position: 'asc' },
            include: {
              child_paths: {
                include: {
                  path: true
                }
              }
            }
          }
        }
      });

      return updatedPath;
    });

    return NextResponse.json(result);

  } catch (error) {
    console.error('Error moving blocks:', error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      // Handle specific Prisma errors
      if (error.code === 'P2025') {
        return NextResponse.json(
          { error: 'Record not found' },
          { status: 404 }
        );
      }
    }

    return NextResponse.json(
      { error: 'Failed to move blocks' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/blocks/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { formatTitle } from '../utils/formatTitle';
import { isVercel } from '@/app/api/utils/isVercel';

enum DelayType {
  FIXED_DURATION = 'FIXED_DURATION',
  WAIT_FOR_EVENT = 'WAIT_FOR_EVENT'
}
/**
 * @swagger
 * /api/blocks:
 *   post:
 *     summary: Create a new block
 *     description: Creates a new block in the specified workflow and path. Supports STEP, PATH, and DELAY block types.
 *     tags:
 *       - Blocks
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - type
 *               - position
 *               - workflow_id
 *               - path_id
 *             properties:
 *               type:
 *                 type: string
 *                 enum: [STEP, PATH, DELAY]
 *                 description: The type of block to create.
 *               position:
 *                 type: integer
 *                 description: The position of the block within the path.
 *               icon:
 *                 type: string
 *                 nullable: true
 *                 description: URL or path to the block's icon.
 *               delay_seconds:
 *                 type: integer
 *                 nullable: true
 *                 description: Delay time in seconds (only for DELAY blocks).
 *               delay_type:
 *                 type: string
 *                 nullable: true
 *                 description: Delay type for DELAY blocks.
 *               delay_event:
 *                 type: string
 *                 nullable: true
 *                 description: Delay event for DELAY blocks.
 *               description:
 *                 type: string
 *                 nullable: true
 *                 description: A short description of the block.
 *               workflow_id:
 *                 type: integer
 *                 description: The ID of the workflow the block belongs to.
 *               path_id:
 *                 type: integer
 *                 description: The ID of the path the block belongs to.
 *               path_options:
 *                 type: array
 *                 items:
 *                   type: string
 *                 description: List of new paths to create within the PATH block.
 *               imageUrl:
 *                 type: string
 *                 nullable: true
 *                 description: URL for an image associated with the block.
 *     responses:
 *       201:
 *         description: Successfully created a block.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *       400:
 *         description: Invalid input data.
 *       500:
 *         description: Internal server error.
 */
export async function POST(req: NextRequest) {
  const {
    title,
    type,
    position,
    icon,
    delay_seconds,
    delay_type,
    delay_event,
    description,
    workflow_id,
    path_id,
    path_options,
    imageUrl,
  } = await req.json();
  const prisma_client = isVercel() ? new PrismaClient() : prisma;

  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }

  const formattedTitle = formatTitle(title);
  const formattedDelayEvent = delay_event ? formatTitle(delay_event) : undefined;

  if (!['STEP', 'PATH', 'DELAY'].includes(type)) {
    return NextResponse.json(
      { error: 'Invalid block type. Expected STEP, PATH, or DELAY.' },
      { status: 400 }
    );
  }

  if (!path_id) {
    return NextResponse.json(
      { error: 'Path ID is required to create a block.' },
      { status: 400 }
    );
  }

  if (type === 'DELAY') {
    if (!delay_type) {
      return NextResponse.json(
        { error: 'Delay type is required for DELAY blocks.' },
        { status: 400 }
      );
    }
    if (
      delay_type === DelayType.FIXED_DURATION &&
      (delay_seconds === undefined || delay_seconds < 0)
    ) {
      return NextResponse.json(
        {
          error:
            'A valid delay value (non-negative number) is required for fixed duration delays.',
        },
        { status: 400 }
      );
    }
    if (delay_type === DelayType.WAIT_FOR_EVENT && !delay_event) {
      return NextResponse.json(
        { error: 'Event name is required for event-based delays.' },
        { status: 400 }
      );
    }
    // For event-based delays, seconds is optional but must be non-negative if provided
    if (
      delay_type === DelayType.WAIT_FOR_EVENT &&
      delay_seconds !== undefined &&
      delay_seconds < 0
    ) {
      return NextResponse.json(
        { error: 'If provided, expiration time must be non-negative.' },
        { status: 400 }
      );
    }
  }

  try {
    // Choose the correct Prisma client
    const result = await prisma_client.$transaction(async (prisma) => {
      // Find the current max position in the path
      const maxBlock = await prisma.block.findFirst({
        where: { path_id },
        orderBy: { position: 'desc' },
        select: { position: true }
      });
      const maxPosition = maxBlock ? maxBlock.position : 0;

      if (process.env.NODE_ENV !== 'production') {
        console.debug('maxPosition', maxPosition);
      }
      const cappedPosition = Math.max(1, Math.min(position, maxPosition));

      // Update positions of existing blocks
      await prisma.block.updateMany({
        where: { workflow_id, path_id, position: { gte: cappedPosition } },
        data: { position: { increment: 1 } },
      });

      // Create the new block
      const blockData = {
        title: formattedTitle,
        type,
        position: cappedPosition,
        icon,
        description,
        image: imageUrl || null,
        workflow: { connect: { id: workflow_id } },
        path: { connect: { id: path_id } },
        delay_seconds: type === 'DELAY' ? delay_seconds : null,
        delay_type: type === 'DELAY' ? (delay_type as DelayType) : null,
        delay_event: type === 'DELAY' ? formattedDelayEvent : null,
      };

      const newBlock = await prisma.block.create({
        data: blockData,
        include: {
          child_paths: {
            include: {
              path: true
            }
          }
        }
      });

      return newBlock;
    });

    return NextResponse.json(result, { status: 201 });
  } catch (error) {
    console.error('Failed to create block:', error);
    return NextResponse.json(
      { error: 'Failed to create block' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/clear-password-reset-cookie/route.ts">
// app/api/clear-password-reset-cookie/route.ts
import { NextResponse } from 'next/server';

/**
 * @swagger
 * /api/clear-password-reset-cookie:
 *   post:
 *     summary: Clears the password reset required cookie
 *     description: Removes the "password-reset-required" cookie by setting its expiration date to the past.
 *     responses:
 *       200:
 *         description: Successfully cleared the cookie
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 */
export async function POST() {
  const response = NextResponse.json({ success: true });
  response.cookies.set('password-reset-required', '', {
    path: '/',
    expires: new Date(0), // Expire the cookie immediately
  });
  return response;
}
</file>

<file path="app/api/cron/send-scheduled-emails/route.ts">
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { sendReactEmail } from '@/lib/email';
import { FeatureUpdateEmail } from '@/emails/templates/ShareRoadmap';
import { WelcomeEmail } from '@/emails/templates/WelcomeEmail';
import { FeedbackRequestEmail } from '@/emails/templates/FeedbackRequestEmail';
import { ProcessLimitEmail } from '@/emails/templates/ProcessLimitEmail';
import { SenderType } from '@/lib/email';
import { CancellationFollowUpEmail } from '@/emails/templates/CancellationFollowUpEmail';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

// Define types for email templates
type EmailTemplateConfig = {
  Component: React.ComponentType<any>;
  subject: string;
  sender: SenderType;
};

// Map of email types to their corresponding templates and subjects
const EMAIL_TEMPLATES: Record<string, EmailTemplateConfig> = {
  'WELCOME': {
    Component: WelcomeEmail,
    subject: 'Welcome to ProcessFlow - Here\'s how to start decently',
    sender: 'jean',
  },
  'FEATURE_UPDATE': {
    Component: FeatureUpdateEmail,
    subject: 'Sneak peek: new ProcessFlow features you\'ll love',
    sender: 'jean',
  },
  'FEEDBACK_REQUEST': {
    Component: FeedbackRequestEmail,
    subject: 'How is your experience with ProcessFlow going? ',
    sender: 'jean',
  },
  'PROCESS_LIMIT_REACHED': {
    Component: ProcessLimitEmail,
    subject: 'Process limit reached - Here\'s a tip to get more ',
    sender: 'contact',
  },
  'CANCELLATION_FOLLOW_UP': {
    Component: CancellationFollowUpEmail,
    subject: "We're sorry to see you go ",
    sender: 'contact',
  },
  // Add more email types as needed
};

// Function to get only the whitelisted public URLs needed for emails
function getSafePublicUrls() {
  // Only include public-facing URLs that are needed for email templates
  return {
    supabasePublicUrl: process.env.NEXT_PUBLIC_SUPABASE_URL || '',
    supabaseStoragePath: process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH || '',
    // Add social media URLs
    producthuntUrl: process.env.NEXT_PUBLIC_PRODUCTHUNT_URL || 'https://www.producthunt.com',
    linkedinUrl: process.env.NEXT_PUBLIC_LINKEDIN_URL || 'https://www.linkedin.com/company/processflow1/',
    xUrl: process.env.NEXT_PUBLIC_X_URL || 'https://x.com',
  };
}

// Constants for retry mechanism
const MAX_RETRY_COUNT = 5;
const RETRY_DELAY_BASE_MINUTES = 15; // Base delay in minutes

// Calculate next retry time with exponential backoff
function calculateNextRetryTime(retryCount: number): Date {
  // Exponential backoff: 15min, 30min, 1h, 2h, 4h
  const delayMinutes = RETRY_DELAY_BASE_MINUTES * Math.pow(2, retryCount);
  const nextRetry = new Date();
  nextRetry.setMinutes(nextRetry.getMinutes() + delayMinutes);
  return nextRetry;
}

// Check if a user has created at least one flow
async function hasUserCreatedFlow(userId: number, prisma_client: typeof prisma): Promise<boolean> {
  try {
    if (!prisma_client) {
      throw new Error('Prisma client not initialized');
    }
    // Count workflows in workspaces where the user is a member
    const userWorkspaces = await prisma_client.user_workspace.findMany({
      where: {
        user_id: userId,
      },
      select: {
        workspace_id: true,
      },
    });

    const workspaceIds = userWorkspaces.map(uw => uw.workspace_id);
    
    // Count workflows in these workspaces
    const workflowCount = await prisma_client.workflow.count({
      where: {
        workspace_id: {
          in: workspaceIds,
        },
      },
    });

    return workflowCount > 0;
  } catch (error) {
    console.error(`Error checking if user ${userId} has created flows:`, error);
    // Default to false if there's an error
    return false;
  }
}

export const dynamic = 'force-dynamic';
export const revalidate = 0;

export async function GET(request: Request) {
  // Choose the correct Prisma client
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Check for authorization header (optional, but recommended for security)
    const authHeader = request.headers.get('authorization');
    if (process.env.CRON_SECRET && (!authHeader || authHeader !== `Bearer ${process.env.CRON_SECRET}`)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Get current time
    const now = new Date();
    
    // Find all scheduled emails that are due to be sent
    const scheduledEmails = await prisma_client.scheduled_email.findMany({
      where: {
        scheduled_for: {
          lte: now,
        },
        status: 'PENDING',
        sent: false,
      },
      include: {
        user: true,
      },
      take: 50, // Process in batches to avoid timeouts
    });

    if (process.env.NODE_ENV === 'development') {
      console.log(`Found ${scheduledEmails.length} emails to send`);
    }
    
    // Log process limit emails specifically
    const processLimitEmails = scheduledEmails.filter(email => email.email_type === 'PROCESS_LIMIT_REACHED');
    if (processLimitEmails.length > 0) {
      if (process.env.NODE_ENV === 'development') {
        console.log(`Found ${processLimitEmails.length} PROCESS_LIMIT_REACHED emails to send`);
      }
    }

    const results = [];
    
    // Get safe public URLs for email templates
    const safePublicUrls = getSafePublicUrls();

    // Process each scheduled email
    for (const email of scheduledEmails) {
      try {
        // Get the email template configuration
        const templateConfig = EMAIL_TEMPLATES[email.email_type];
        
        if (!templateConfig) {
          console.error(`Unknown email type: ${email.email_type}`);
          
          // Update the email status to FAILED
          await prisma_client.scheduled_email.update({
            where: { id: email.id },
            data: {
              status: 'FAILED',
              error: `Unknown email type: ${email.email_type}`,
              retry_count: email.retry_count + 1,
            },
          });
          
          results.push({ id: email.id, status: 'failed', reason: 'Unknown email type' });
          continue;
        }

        // Get the metadata from the scheduled email
        const metadata = email.metadata as Record<string, any> || {};
        
        // Special handling for FEEDBACK_REQUEST emails
        if (email.email_type === 'FEEDBACK_REQUEST' && metadata.requiresFlowCheck) {
          // Check if the user has created at least one flow
          const hasCreatedFlow = await hasUserCreatedFlow(email.user_id, prisma_client);
          
          if (!hasCreatedFlow) {
            // User hasn't created a flow yet, so don't send the email
            // Mark as cancelled instead of failed
            await prisma_client.scheduled_email.update({
              where: { id: email.id },
              data: {
                status: 'CANCELLED',
                error: 'User has not created any flows yet',
              },
            });
            
            results.push({ 
              id: email.id, 
              status: 'cancelled', 
              reason: 'User has not created any flows yet' 
            });
            
            if (process.env.NODE_ENV === 'development') {
              console.log(`Feedback request email ${email.id} cancelled: User ${email.user_id} has not created any flows`);
            }
            continue;
          }
          
          // User has created flows, so we can proceed with sending the email
          if (process.env.NODE_ENV === 'development') {
            console.log(`User ${email.user_id} has created flows, proceeding with feedback request email`);
          }
        }
        
        // Special logging for PROCESS_LIMIT_REACHED emails
        if (email.email_type === 'PROCESS_LIMIT_REACHED') {
          if (process.env.NODE_ENV === 'development') {
            console.log(`Processing PROCESS_LIMIT_REACHED email for user: ${email.user.email}`);
          }
        }
        
        // Send the email
        const sendResult = await sendReactEmail({
          to: email.user.email,
          subject: templateConfig.subject,
          Component: templateConfig.Component,
          props: {
            ...metadata,
            firstName: email.user.first_name,
            // Pass only the safe public URLs instead of raw environment variables
            publicUrls: safePublicUrls,
          },
          sender: templateConfig.sender,
        });

        if (sendResult.success) {
          // Update the email status to SENT
          await prisma_client.scheduled_email.update({
            where: { id: email.id },
            data: {
              status: 'SENT',
              sent: true,
              sent_at: new Date(),
            },
          });
          
          results.push({ id: email.id, status: 'sent', messageId: sendResult.messageId });
          
          if (email.email_type === 'PROCESS_LIMIT_REACHED') {
            if (process.env.NODE_ENV === 'development') {
              console.log(`Successfully sent PROCESS_LIMIT_REACHED email to ${email.user.email}`);
            }
          }
        } else {
          // Handle failed email with retry mechanism
          const newRetryCount = email.retry_count + 1;
          
          if (newRetryCount >= MAX_RETRY_COUNT) {
            // Max retries reached, mark as permanently failed
            await prisma_client.scheduled_email.update({
              where: { id: email.id },
              data: {
                status: 'FAILED',
                error: `Failed after ${MAX_RETRY_COUNT} attempts. Last error: ${String(sendResult.error)}`,
                retry_count: newRetryCount,
              },
            });
            
            results.push({ 
              id: email.id, 
              status: 'permanently_failed', 
              reason: `Max retry count (${MAX_RETRY_COUNT}) reached. Last error: ${String(sendResult.error)}` 
            });
          } else {
            // Calculate next retry time with exponential backoff
            const nextRetryTime = calculateNextRetryTime(newRetryCount - 1);
            
            // Update for retry
            await prisma_client.scheduled_email.update({
              where: { id: email.id },
              data: {
                status: 'PENDING', // Keep as pending for next attempt
                error: String(sendResult.error),
                retry_count: newRetryCount,
                scheduled_for: nextRetryTime, // Reschedule with backoff
              },
            });
            
            results.push({ 
              id: email.id, 
              status: 'retry_scheduled', 
              reason: String(sendResult.error),
              nextRetry: nextRetryTime,
              attemptNumber: newRetryCount
            });
            
            if (process.env.NODE_ENV === 'development') {
              console.log(`Scheduled retry #${newRetryCount} for email ${email.id} at ${nextRetryTime}`);
            }
          }
        }
      } catch (error) {
        // Handle unexpected errors with retry mechanism
        const newRetryCount = email.retry_count + 1;
        const errorMessage = error instanceof Error ? error.message : String(error);
        
        if (newRetryCount >= MAX_RETRY_COUNT) {
          // Max retries reached, mark as permanently failed
          await prisma_client.scheduled_email.update({
            where: { id: email.id },
            data: {
              status: 'FAILED',
              error: `Failed after ${MAX_RETRY_COUNT} attempts due to exception: ${errorMessage}`,
              retry_count: newRetryCount,
            },
          });
          
          results.push({ 
            id: email.id, 
            status: 'permanently_failed', 
            reason: `Max retry count (${MAX_RETRY_COUNT}) reached. Error: ${errorMessage}` 
          });
        } else {
          // Calculate next retry time with exponential backoff
          const nextRetryTime = calculateNextRetryTime(newRetryCount - 1);
          
          // Update for retry
          await prisma_client.scheduled_email.update({
            where: { id: email.id },
            data: {
              status: 'PENDING', // Keep as pending for next attempt
              error: errorMessage,
              retry_count: newRetryCount,
              scheduled_for: nextRetryTime, // Reschedule with backoff
            },
          });
          
          results.push({ 
            id: email.id, 
            status: 'retry_scheduled', 
            reason: errorMessage,
            nextRetry: nextRetryTime,
            attemptNumber: newRetryCount
          });
          
          if (process.env.NODE_ENV === 'development') {
            console.log(`Scheduled retry #${newRetryCount} for email ${email.id} at ${nextRetryTime} after error: ${errorMessage}`);
          }
        }
      }
    }

    return NextResponse.json({
      success: true,
      processed: scheduledEmails.length,
      results,
    });
  } catch (error) {
    console.error('Error processing scheduled emails:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/docs/route.ts">
// app/api/docs/route.ts
import { NextResponse } from 'next/server';
import swaggerSpec from '@/lib/swagger';

export async function GET() {
  return NextResponse.json(swaggerSpec);
}
</file>

<file path="app/api/email/send-subscription-email/route.ts">
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function POST(req: Request) {
  // Choose the correct Prisma client
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { workspaceId } = await req.json();
    
    if (!workspaceId) {
      return NextResponse.json({ error: 'Missing workspaceId' }, { status: 400 });
    }
    
    // Find the workspace
    const workspace = await prisma_client.workspace.findUnique({
      where: { id: workspaceId },
      include: { subscription: true },
    });
    
    if (!workspace) {
      return NextResponse.json({ error: 'Workspace not found' }, { status: 404 });
    }
    
    // Find active users for this workspace
    const users = await prisma_client.user.findMany({
      where: { active_workspace_id: workspaceId },
    });
    
    if (users.length === 0) {
      return NextResponse.json({ error: 'No active users found for this workspace' }, { status: 404 });
    }
    
    // Send emails to all active users
    const results = [];
    
    for (const user of users) {
      try {
        const response = await fetch(`${process.env.NEXT_PUBLIC_APP_URL}/api/email/subscription-activated`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            userId: user.id,
            workspaceId,
          }),
        });
        
        const result = await response.json();
        results.push({ user: user.email, result });
      } catch (error) {
        results.push({ user: user.email, error: 'Failed to send email' });
      }
    }
    
    return NextResponse.json({ success: true, results });
  } catch (error) {
    console.error('Error sending subscription emails:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/email/subscription-activated/route.ts">
import { NextResponse } from 'next/server';
import { sendReactEmail } from '@/lib/email';
import SubscriptionActivatedEmail from '@/emails/templates/SubscriptionActivatedEmail';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

/**
 * @swagger
 * /api/email/subscription-activated:
 *   post:
 *     summary: Send a subscription activated email
 *     description: Sends an email notification when a user's Early Adopter subscription is activated
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               userId:
 *                 type: number
 *                 description: The ID of the user who activated the subscription
 *                 example: 1
 *               workspaceId:
 *                 type: number
 *                 description: The ID of the workspace with the activated subscription
 *                 example: 1
 *     responses:
 *       200:
 *         description: Subscription activated email successfully sent
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Subscription activated email sent!"
 *       400:
 *         description: Missing required fields in the request
 *       404:
 *         description: User or workspace not found
 *       500:
 *         description: Internal server error
 */
export async function POST(req: Request) {
  // Choose the correct Prisma client
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { userId, workspaceId } = await req.json();

    if (!userId || !workspaceId) {
      return NextResponse.json(
        { error: 'Missing required fields: userId, workspaceId' },
        { status: 400 }
      );
    }

    // Get user information
    const user = await prisma_client.user.findUnique({
      where: { id: userId },
    });

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    // Get workspace and subscription information
    const workspace = await prisma_client.workspace.findUnique({
      where: { id: workspaceId },
      include: { subscription: true },
    });

    if (!workspace) {
      return NextResponse.json(
        { error: 'Workspace not found' },
        { status: 404 }
      );
    }

    // Verify this is an Early Adopter subscription
    if (!workspace.subscription || workspace.subscription.plan_type !== 'EARLY_ADOPTER') {
      return NextResponse.json(
        { error: 'Not an Early Adopter subscription' },
        { status: 400 }
      );
    }

    // Check if we already have a scheduled email for this user and type
    const existingEmail = await prisma_client.scheduled_email.findFirst({
      where: {
        user_id: userId,
        email_type: 'SUBSCRIPTION_ACTIVATED',
        status: 'SENT',
      },
    });

    if (existingEmail) {
      return NextResponse.json(
        { message: 'Subscription activated email already sent to this user' },
        { status: 200 }
      );
    }

    // Send the email
    const emailResult = await sendReactEmail({
      to: user.email,
      subject: 'ProcessFlow Early Adopter activated - Now, you\'re limitless ',
      Component: SubscriptionActivatedEmail,
      props: {
        firstName: user.first_name,
      },
      sender: 'contact',
    });

    if (emailResult.success) {
      // Record the email as sent in the scheduled_email table
      await prisma_client.scheduled_email.create({
        data: {
          user_id: userId,
          email_type: 'SUBSCRIPTION_ACTIVATED',
          scheduled_for: new Date(),
          status: 'SENT',
          sent: true,
          sent_at: new Date(),
          metadata: {
            workspaceId,
            subscriptionId: workspace.subscription_id,
          },
        },
      });

      return NextResponse.json(
        { success: true, message: 'Subscription activated email sent!' },
        { status: 200 }
      );
    } else {
      return NextResponse.json(
        { error: 'Failed to send subscription activated email', details: emailResult.error },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error(' Error sending subscription activated email:', error);
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/email/route.ts">
// app/api/email/route.ts
import { render } from '@react-email/render';
import { WelcomeEmail } from '@/emails/templates/WelcomeEmail'; // Changed from default to named import
import { sendEmail } from '@/app/utils/mail'; // The utility function you already have
import React from 'react';

/**
 * @swagger
 * /api/email:
 *   post:
 *     summary: Send a welcome email
 *     description: Sends a welcome email to a new user using a predefined email template.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *                 description: The recipient's email address.
 *                 example: "user@example.com"
 *               firstName:
 *                 type: string
 *                 description: The first name of the recipient.
 *                 example: "John"
 *     responses:
 *       200:
 *         description: Welcome email successfully sent
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Welcome email sent!"
 *       400:
 *         description: Missing required fields in the request
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Missing required fields: email, firstName"
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 */
export async function POST(req: Request) {
  try {
    const { email, firstName } = await req.json();

    if (!email || !firstName) {
      return new Response(
        JSON.stringify({ error: 'Missing required fields: email, firstName' }),
        { status: 400 }
      );
    }

    // Render the email content using the WelcomeEmail component with explicit React.createElement
    const emailHtml = await render(
      React.createElement(WelcomeEmail, { 
        firstName, 
        jeanRdvLink: process.env.NEXT_PUBLIC_BASE_URL || 'https://process-flow.io',
        sender: 'jean'
      })
    );

    // Send the welcome email using the sendEmail utility
    const emailResponse = await sendEmail(
      email,
      'Bienvenue sur ProcessFlow!',
      emailHtml // Pass the rendered HTML from WelcomeEmail
    );

    if (emailResponse.success) {
      return new Response(
        JSON.stringify({ success: true, message: 'Welcome email sent!' }),
        { status: 200 }
      );
    } else {
      return new Response(
        JSON.stringify({ error: 'Failed to send welcome email' }),
        { status: 500 }
      );
    }
  } catch (error) {
    console.error(' Error sending email:', error);
    return new Response(JSON.stringify({ error: 'Internal Server Error' }), {
      status: 500,
    });
  }
}
</file>

<file path="app/api/get-signed-url/route.ts">
// app/api/get-signed-url/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { generatePublicUrl } from '../utils/generatePublicUrl';

/**
 * @swagger
 * /api/get-signed-url:
 *   get:
 *     summary: Get a public URL for a file in the public Supabase bucket
 *     description: Generates a public URL for accessing a file stored in the public Supabase storage bucket.
 *     parameters:
 *       - in: query
 *         name: path
 *         required: true
 *         schema:
 *           type: string
 *         description: The path of the file in the storage bucket.
 *         example: "folder/file.png"
 *     responses:
 *       200:
 *         description: Successfully generated public URL
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 signedUrl:
 *                   type: string
 *                   description: The public URL for accessing the file.
 *                   example: "https://fshqhpophyrgrvhzyrto.supabase.co/storage/v1/object/public/user-assets/folder/file.png"
 *       400:
 *         description: Missing required path parameter
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Path is required"
 *       500:
 *         description: Internal server error or environment variable issue
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Supabase URL or storage path is not defined in the environment variables"
 */
export async function GET(req: NextRequest) {
  // Parse the query parameters
  const { searchParams } = new URL(req.url);
  const path = searchParams.get('path');

  if (!path) {
    return NextResponse.json({ error: 'Path is required' }, { status: 400 });
  }

  try {
    // Generate the public URL using the utility function
    const publicUrl = generatePublicUrl(path);

    return NextResponse.json({ signedUrl: publicUrl });
  } catch (error: any) {
    return NextResponse.json(
      { error: error.message || 'Something went wrong' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/get-subscription/route.ts">
import { createClient } from '@supabase/supabase-js';
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const userId = searchParams.get('userId');

  if (!userId) {
    return NextResponse.json({ error: 'User ID is required' }, { status: 400 });
  }

  try {
    
    
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!,
      {
        auth: {
          persistSession: false
        }
      }
    );

    // First get the workspace ID for the user
    const { data: workspace, error: workspaceError } = await supabase
      .from('workspace')
      .select('id')
      .eq('user_id', userId)
      .single();

  

    if (workspaceError || !workspace) {
      return NextResponse.json({ error: 'No workspace found' }, { status: 404 });
    }

    // Then get the subscription for that workspace
    const { data: subscription, error: subscriptionError } = await supabase
      .from('subscription')
      .select('*')
      .eq('workspace_id', workspace.id)
      .single();

    if (subscriptionError) {
      return NextResponse.json({ error: 'Error fetching subscription' }, { status: 500 });
    }

    if (!subscription) {
      return NextResponse.json({ 
        plan_type: 'free',
        status: 'active'
      });
    }

    return NextResponse.json({
      plan_type: subscription.plan_type,
      status: subscription.status,
      current_period_end: subscription.current_period_end,
      stripe_subscription_id: subscription.stripe_subscription_id
    });
  } catch (error) {
    console.error('Error:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
</file>

<file path="app/api/hello/route.ts">
import { NextResponse } from 'next/server'

export async function GET(req: Request) {
  return NextResponse.json({ message: 'Hello from API' })
}
</file>

<file path="app/api/invoices/route.ts">
import { NextResponse } from 'next/server';
import { stripe } from '@/lib/stripe';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { createClient } from '@/lib/supabaseServerClient';
import { cookies } from 'next/headers';

export async function GET(request: Request) {
  // Choose the correct Prisma client
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Get user session using Supabase
    const cookieStore = cookies();
    const supabase = await createClient();
    const { data: { session }, error: authError } = await supabase.auth.getSession();

    if (!session || authError) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Get workspace ID from query params
    const { searchParams } = new URL(request.url);
    const workspaceId = searchParams.get('workspaceId');
    if (!workspaceId) {
      return NextResponse.json({ error: 'Workspace ID is required' }, { status: 400 });
    }

    // Check if user has access to workspace
    const workspace = await prisma_client.workspace.findFirst({
      where: {
        id: parseInt(workspaceId),
        user_workspaces: {
          some: {
            user: {
              auth_id: session.user.id
            }
          }
        }
      },
      select: {
        id: true,
        stripe_customer_id: true
      }
    });

    if (!workspace) {
      return NextResponse.json({ error: 'Workspace not found' }, { status: 404 });
    }

    if (!workspace.stripe_customer_id) {
      return NextResponse.json({ invoices: [] });
    }

    // Fetch invoices from Stripe
    const invoices = await stripe.invoices.list({
      customer: workspace.stripe_customer_id,
      limit: 100, // Adjust as needed
    });

    // Format invoices for response
    const formattedInvoices = invoices.data.map(invoice => ({
      id: invoice.id,
      number: invoice.number,
      created: invoice.created,
      status: invoice.status,
      amount: invoice.amount_paid,
      currency: invoice.currency,
      pdfUrl: invoice.invoice_pdf,
      hostedUrl: invoice.hosted_invoice_url,
      plan: invoice.lines.data[0]?.plan?.nickname || 'Early Adopter'
    }));

    return NextResponse.json({ invoices: formattedInvoices });
  } catch (error) {
    console.error('Error fetching invoices:', error);
    return NextResponse.json(
      { error: 'Failed to fetch invoices' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/logo-search/route.ts">
import { NextRequest, NextResponse } from 'next/server';

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const q = searchParams.get('q');
  if (!q) {
    return NextResponse.json({ error: 'Missing query' }, { status: 400 });
  }

  // If it's already a domain-like string, use it directly
  if (q.includes('.')) {
    const domain = q.toLowerCase()
      .replace(/^https?:\/\//, '')
      .replace(/^www\./, '')
      .split('/')[0];

    // Request a high quality image with specific dimensions
    const iconUrl = `https://cdn.brandfetch.io/${domain}/icon?h=192&q=100&c=1idr1bVveqwYDg79PNN`;
    return NextResponse.json({ 
      icon: iconUrl,
      domain: domain 
    }, { 
      headers: {
        'Referrer-Policy': 'strict-origin-when-cross-origin',
        'Cache-Control': 'public, max-age=31536000, immutable'
      }
    });
  }

  // If it's a brand name, search for it first
  try {
    const searchRes = await fetch(`https://api.brandfetch.io/v2/search/${encodeURIComponent(q)}`, {
      headers: {
        'Authorization': 'Bearer 1idr1bVveqwYDg79PNN'
      }
    });

    if (!searchRes.ok) {
      throw new Error('Search failed');
    }

    const searchData = await searchRes.json();
    
    // Get the first result's domain
    if (searchData && searchData.length > 0 && searchData[0].domain) {
      const domain = searchData[0].domain;
      const iconUrl = `https://cdn.brandfetch.io/${domain}/icon?h=192&q=100&c=1idr1bVveqwYDg79PNN`;
      
      return NextResponse.json({ 
        icon: iconUrl,
        domain: domain 
      }, { 
        headers: {
          'Referrer-Policy': 'strict-origin-when-cross-origin',
          'Cache-Control': 'public, max-age=31536000, immutable'
        }
      });
    }

    return NextResponse.json({ error: 'Brand not found' }, { status: 404 });
  } catch (error) {
    console.error('BrandFetch API error:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
</file>

<file path="app/api/onboarding/create-default-workflow/route.ts">
import { NextResponse } from 'next/server';
import { createDefaultWorkflows } from '@/app/api/utils/create-default-workflow';
import { createClient } from '@/utils/supabase/server';
import { cookies } from 'next/headers';

/**
 * API route to create a default workflow by duplicating an existing workflow
 * This will copy a template workflow (id: 257 from workspace: 52) to the specified workspace
 */
export async function POST() {
  try {
    // Get the Supabase client
    const supabase = await createClient();
    
    // Get the authenticated user
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    
    if (userError || !user) {
      return NextResponse.json(
        { error: 'User not authenticated' },
        { status: 401 }
      );
    }
    
    // Get the user's workspace
    const { data: workspaces, error: workspaceError } = await supabase
      .from('workspaces')
      .select('id')
      .eq('user_id', user.id)
      .limit(1);
    
    if (workspaceError || !workspaces || workspaces.length === 0) {
      return NextResponse.json(
        { error: 'No workspace found for user' },
        { status: 404 }
      );
    }
    
    // Convert to number type to match the expected interface
    const workspaceId = Number(workspaces[0].id);
    const userId = Number(user.id);
    
    // Create the default workflows
    const results = await createDefaultWorkflows({ workspaceId, userId });
    // Only access warnings on objects that have it
    const warnings = results.flatMap(r => 'warnings' in r && r.warnings ? r.warnings : []);
    const success = results.every(r => r.success);
    if (!success) {
      return NextResponse.json(
        {
          error: 'Failed to create all default workflows',
          results,
          warnings: warnings.length > 0 ? warnings : undefined,
        },
        { status: 500 }
      );
    }
    // Only access workflow on objects that have it
    const workflowIds = results.map(r => 'workflow' in r && r.workflow?.id).filter(Boolean);
    return NextResponse.json({
      success: true,
      workflowIds,
      warnings: warnings.length > 0 ? warnings : undefined,
    });
  } catch (error) {
    console.error('Error creating default workflow:', error);
    return NextResponse.json(
      { error: 'Failed to create default workflow' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/onboarding/force-complete/route.ts">
import { createClient } from '@/utils/supabase/server';
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import * as Sentry from '@sentry/nextjs';

/**
 * API route to force completion of the onboarding process
 * This is a fallback mechanism for situations where users get stuck in the onboarding flow
 */
export async function POST(request: Request) {
  // Choose the correct Prisma client
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Check authentication
    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Check if the user exists in the database
    const dbUser = await prisma_client.user.findUnique({
      where: { auth_id: user.id },
    });

    if (!dbUser) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Log this event for monitoring
    console.warn(`User ${dbUser.id} (${dbUser.email}) is force-completing onboarding`);
    Sentry.captureMessage(`Force-completing onboarding for user ${dbUser.id}`, 'warning');

    // Get active workspace
    let activeWorkspaceId = dbUser.active_workspace_id;
    
    // If no active workspace is set, find one from user-workspace relationships
    if (!activeWorkspaceId) {
      // Query for workspaces directly via the join table
      const userWorkspaces = await prisma_client.user_workspace.findMany({
        where: { user_id: dbUser.id },
        orderBy: { id: 'desc' },
        take: 1,
        include: { workspace: true }
      });
      
      if (userWorkspaces.length > 0 && userWorkspaces[0].workspace_id) {
        activeWorkspaceId = userWorkspaces[0].workspace_id;
      }
    }
    
    // At this point if no workspace is available, this request is invalid
    if (!activeWorkspaceId) {
      return NextResponse.json({ 
        error: 'Cannot complete onboarding without a workspace' 
      }, { status: 400 });
    }

    // Update the user record in the database
    await prisma_client.user.update({
      where: { id: dbUser.id },
      data: {
        onboarding_step: 'COMPLETED',
        onboarding_completed_at: new Date(),
        active_workspace_id: activeWorkspaceId,
        temp_industry: null,
        temp_company_size: null
      }
    });

    // Update Supabase user metadata
    await supabase.auth.updateUser({
      data: {
        onboarding_status: {
          current_step: 'completed',
          completed_at: new Date().toISOString()
        },
        temp_workspace_id: null // Clear temp workspace ID
      }
    });

    return NextResponse.json({ 
      success: true, 
      message: 'Onboarding has been marked as completed',
      activeWorkspaceId
    });
  } catch (error) {
    console.error('Error forcing onboarding completion:', error);
    Sentry.captureException(error);
    
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to force complete onboarding' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/paths/[id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { supabase } from '@/lib/supabaseClient';
import { deleteOnePath } from '@/app/api/utils/paths/deleteOne';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function GET(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const url = new URL(req.url);
    const id = url.searchParams.get('id');
    const pathId = parseInt(id!, 10);

    if (!id || isNaN(pathId)) {
      return NextResponse.json(
        { error: 'Invalid path ID' },
        { status: 400 }
      );
    }

    const path = await prisma_client.path.findUnique({
      where: { id: pathId },
      include: {
        blocks: {
          orderBy: {
            position: 'asc',
          },
        },
        parent_blocks: true,
      },
    });

    if (!path) {
      return NextResponse.json(
        { error: 'Path not found' },
        { status: 404 }
      );
    }

    return NextResponse.json(path);
  } catch (error) {
    console.error('Error fetching path:', error);
    return NextResponse.json(
      { error: 'Failed to fetch path' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
): Promise<NextResponse> {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const params = await props.params;
    const id = parseInt(params.id);
    const { name } = await req.json();

    if (!name) {
      return NextResponse.json(
        { error: 'Name is required' },
        { status: 400 }
      );
    }

    const updatedPath = await prisma_client.path.update({
      where: { id },
      data: { name },
      select: {
        id: true,
        name: true,
      }
    });

    return NextResponse.json(updatedPath);
  } catch (error) {
    console.error('Error updating path:', error);
    return NextResponse.json(
      { error: 'Failed to update path' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

export async function DELETE(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const id = req.nextUrl.pathname.split('/')[3];
    const pathId = parseInt(id);

    // Get the path and its blocks to handle image deletion
    const path = await prisma_client.path.findUnique({
      where: { id: pathId },
      include: {
        blocks: true,
        parent_blocks: true,
      },
    });

    if (!path) {
      return NextResponse.json({ error: 'Path not found' }, { status: 404 });
    }

    // Delete images from storage if they exist
    const bucketName = process.env.NEXT_PUBLIC_SUPABASE_PRIVATE_BUCKET;
    if (bucketName) {
      for (const block of path.blocks) {
        if (block.image) {
          const { error } = await supabase.storage
            .from(bucketName)
            .remove([block.image]);
          
          if (error) {
            console.error('Error deleting image:', error);
          }
        }
      }
    }

    // Use the new deleteOnePath logic
    try {
      await deleteOnePath(pathId);
    } catch (err: any) {
      return NextResponse.json(
        { error: err.message || 'Failed to delete path' },
        { status: 409 }
      );
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error deleting path:', error);
    return NextResponse.json(
      { error: 'Failed to delete path' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/paths/connect/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { Prisma } from '@prisma/client';
import { BlockEndType } from '@/types/block';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

interface ConnectPathsRequest {
  child_path_ids: number[];
  destination_path_id: number;
  pathblock_title?: string;
  pathblock_description?: string;
  pathblock_icon?: string;
}

export async function POST(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const body: ConnectPathsRequest = await req.json();
    const { child_path_ids, destination_path_id, pathblock_title, pathblock_description, pathblock_icon } = body;

    // Validate input
    if (!Array.isArray(child_path_ids) || child_path_ids.length === 0 || !destination_path_id) {
      return NextResponse.json(
        { error: 'Invalid input: child_path_ids array and destination_path_id are required' },
        { status: 400 }
      );
    }

    // Use transaction to ensure all operations succeed or none do
    const result = await prisma_client.$transaction(async (tx) => {
      // Find any end-type block of the destination path
      const destinationEndBlock = await tx.block.findFirst({
        where: {
          path_id: destination_path_id,
          type: {
            in: Object.values(BlockEndType)
          }
        }
      });

      if (!destinationEndBlock) {
        throw new Error('Destination path has no end-type block');
      }

      // Update block type to PATH if it isn't already
      if (destinationEndBlock.type !== BlockEndType.PATH || pathblock_title || pathblock_description || pathblock_icon) {
        await tx.block.update({
          where: { id: destinationEndBlock.id },
          data: { type: BlockEndType.PATH, title: pathblock_title, description: pathblock_description, icon: pathblock_icon }
        });
      }

      // Delete existing parent block relationships for the child paths
      await tx.path_parent_block.deleteMany({
        where: {
          path_id: {
            in: child_path_ids
          }
        }
      });

      // Create new relationships with the destination path's END block
      const newRelationships = child_path_ids.map(pathId => ({
        path_id: pathId,
        block_id: destinationEndBlock.id
      }));

      await tx.path_parent_block.createMany({
        data: newRelationships
      });

      // Get the updated destination path with all its relationships
      const updatedPath = await tx.path.findUnique({
        where: { id: destination_path_id },
        include: {
          blocks: {
            orderBy: { position: 'asc' },
            include: {
              child_paths: {
                include: {
                  path: {
                    include: {
                      blocks: {
                        orderBy: { position: 'asc' },
                        include: {
                          child_paths: {
                            include: {
                              path: true
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      });

      return updatedPath;
    });

    return NextResponse.json(result);

  } catch (error) {
    console.error('Error connecting paths:', error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      // Handle specific Prisma errors
      if (error.code === 'P2025') {
        return NextResponse.json(
          { error: 'Record not found' },
          { status: 404 }
        );
      }
    }

    return NextResponse.json(
      { error: 'Failed to connect paths' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

/**
 * @swagger
 * /api/paths/connect:
 *   post:
 *     summary: Connect child paths to a destination path's END block
 *     description: Disconnects child paths from their current parent blocks and connects them to the END block of the destination path
 *     tags:
 *       - Paths
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - child_path_ids
 *               - destination_path_id
 *             properties:
 *               child_path_ids:
 *                 type: array
 *                 items:
 *                   type: integer
 *                 description: Array of path IDs to connect as children
 *               destination_path_id:
 *                 type: integer
 *                 description: ID of the destination path
 *     responses:
 *       200:
 *         description: Paths successfully connected
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                 blocks:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                       child_paths:
 *                         type: array
 *                         items:
 *                           type: object
 *       400:
 *         description: Invalid input parameters
 *       404:
 *         description: Path or END block not found
 *       500:
 *         description: Server error
 */
</file>

<file path="app/api/paths/merge/[id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

interface UpdateMergePathRequest {
  parents_to_connect: number[];
  parents_to_disconnect: number[];
}

export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const params = await props.params;
    const { id } = params;
    const mergePathId = parseInt(id);
    
    const { parents_to_connect, parents_to_disconnect } = await req.json();

    // Use transaction to ensure all operations succeed or none do
    const result = await prisma_client.$transaction(async (tx) => {
      // Delete specified relationships
      if (parents_to_disconnect.length > 0) {
        await tx.path_parent_block.deleteMany({
          where: {
            path_id: mergePathId,
            block_id: {
              in: parents_to_disconnect
            }
          }
        });

        // For each disconnected block, check if it has no more child paths
        for (const blockId of parents_to_disconnect) {
          const block = await tx.block.findUnique({
            where: { id: blockId },
            include: { child_paths: true }
          });

          if (block && 
              block.child_paths.length === 0 && 
              block.type !== 'LAST' && 
              block.type !== 'END') {
            await tx.block.update({
              where: { id: blockId },
              data: { type: 'LAST' }
            });
          }
        }
      }

      // Create new relationships
      if (parents_to_connect.length > 0) {
        await tx.path_parent_block.createMany({
          data: parents_to_connect.map((blockId: number) => ({
            path_id: mergePathId,
            block_id: blockId,
          })),
          skipDuplicates: true,
        });

        // Update connected blocks to type 'MERGE'
        await tx.block.updateMany({
          where: {
            id: {
              in: parents_to_connect
            }
          },
          data: { type: 'MERGE' }
        });
      }

      // Check if path has any parent blocks left
      const updatedPath = await tx.path.findUnique({
        where: { id: mergePathId },
        include: {
          blocks: true,
          parent_blocks: true,
        },
      });

      // If no parent blocks remain, delete the path and its blocks
      if (updatedPath && updatedPath.parent_blocks.length === 0) {
        // Delete all blocks in the path
        await tx.block.deleteMany({
          where: {
            path_id: mergePathId
          }
        });

        // Delete the path itself
        await tx.path.delete({
          where: {
            id: mergePathId
          }
        });

        return null; // Indicate path was deleted
      }

      return updatedPath;
    });

    return NextResponse.json(result);
  } catch (error) {
    console.error('Error updating merge path:', error);
    return NextResponse.json(
      { error: 'Failed to update merge path' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/paths/merge/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { BlockEndType } from '@/types/block';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

interface MergePathRequest {
  name: string;
  workflow_id: number;
  parent_blocks: number[];
}

export async function POST(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const body: MergePathRequest = await req.json();
    const { name, workflow_id, parent_blocks } = body;

    // Validate input
    if (!name || !workflow_id || !parent_blocks.length) {
      return NextResponse.json(
        { error: 'Invalid input: name, workflow_id and parent_blocks are required' },
        { status: 400 }
      );
    }

    // Use transaction to ensure all operations succeed or none do
    const result = await prisma_client.$transaction(async (tx) => {
      // Create new path
      const newPath = await tx.path.create({
        data: {
          name,
          workflow_id,
        }
      });

      // Create BEGIN block
      const beginBlock = await tx.block.create({
        data: {
          type: 'BEGIN',
          position: 0,
          icon: '/step-icons/default-icons/begin.svg',
          description: '',
          workflow_id,
          path_id: newPath.id,
        }
      });

      // Create LAST block
      await tx.block.create({
        data: {
          type: BlockEndType.LAST,
          position: 1,
          icon: '/step-icons/default-icons/end.svg',
          description: '',
          workflow_id,
          path_id: newPath.id,
        }
      });

      // Create parent block relationships
      await tx.path_parent_block.createMany({
        data: parent_blocks.map(blockId => ({
          block_id: blockId,
          path_id: newPath.id,
        })),
      });

      // Get the created path with its blocks and parent relationships
      const createdPath = await tx.path.findUnique({
        where: { id: newPath.id },
        include: {
          blocks: {
            orderBy: { position: 'asc' },
            include: {
              child_paths: {
                include: {
                  path: true
                }
              }
            }
          },
          parent_blocks: {
            include: {
              block: true
            }
          }
        }
      });

      return createdPath;
    });

    return NextResponse.json(result);

  } catch (error) {
    console.error('Error creating merge path:', error);
    return NextResponse.json(
      { error: 'Failed to create merge path' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/paths/minimal/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { Prisma } from '@prisma/client';
import { BlockEndType } from '@/types/block';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

interface CreateMinimalPathRequest {
  name: string;
  workflow_id: number;
}

export async function POST(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const body: CreateMinimalPathRequest = await req.json();
    const { name, workflow_id } = body;

    // Validate input
    if (!name || !workflow_id) {
      return NextResponse.json(
        { error: 'Invalid input: name and workflow_id are required' },
        { status: 400 }
      );
    }

    // Use transaction to ensure all operations succeed or none do
    const result = await prisma_client.$transaction(async (tx) => {
      // Create new path
      const newPath = await tx.path.create({
        data: {
          name,
          workflow_id,
        }
      });

      // Create BEGIN block
      await tx.block.create({
        data: {
          type: 'BEGIN',
          position: 0,
          icon: '/step-icons/default-icons/begin.svg',
          description: '',
          workflow_id,
          path_id: newPath.id,
        }
      });

      // Create LAST block instead of END block
      await tx.block.create({
        data: {
          type: BlockEndType.LAST,
          position: 1, // Position 1 since there's only BEGIN before it
          icon: '/step-icons/default-icons/end.svg',
          description: '',
          workflow_id,
          path_id: newPath.id,
        }
      });

      // Get the created path with its blocks
      const createdPath = await tx.path.findUnique({
        where: { id: newPath.id },
        include: {
          blocks: {
            orderBy: { position: 'asc' },
            include: {
              child_paths: {
                include: {
                  path: true
                }
              }
            }
          }
        }
      });

      return createdPath;
    });

    return NextResponse.json(result);

  } catch (error) {
    console.error('Error creating minimal path:', error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2002') {
        return NextResponse.json(
          { error: 'Path with this name already exists' },
          { status: 409 }
        );
      }
    }

    return NextResponse.json(
      { error: 'Failed to create path' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

/**
 * @swagger
 * /api/paths/minimal:
 *   post:
 *     summary: Create a minimal path with only BEGIN and END blocks
 *     description: Creates a new path with just BEGIN and END blocks, without the default STEP block
 *     tags:
 *       - Paths
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - workflow_id
 *             properties:
 *               name:
 *                 type: string
 *                 description: Name of the new path
 *               workflow_id:
 *                 type: integer
 *                 description: ID of the workflow this path belongs to
 *     responses:
 *       200:
 *         description: Path successfully created
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                 name:
 *                   type: string
 *                 blocks:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                       type:
 *                         type: string
 *                         enum: [BEGIN, END]
 *                       position:
 *                         type: integer
 *       400:
 *         description: Invalid input parameters
 *       409:
 *         description: Path with this name already exists
 *       500:
 *         description: Server error
 */
</file>

<file path="app/api/paths/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function POST(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const body = await req.json();
    const { name, workflow_id } = body;

    if (!name || !workflow_id) {
      return NextResponse.json(
        { error: 'Name and workflow_id are required' },
        { status: 400 }
      );
    }

    // Create the path
    const path = await prisma_client.path.create({
      data: {
        name,
        workflow_id,
      },
    });

    // Create default blocks (BEGIN, STEP, END)
    await prisma_client.block.createMany({
      data: [
        {
          type: 'BEGIN',
          position: 0,
          workflow_id,
          path_id: path.id,
          icon: '/step-icons/default-icons/begin.svg',
          description: '',
        },
        {
          type: 'STEP',
          position: 1,
          workflow_id,
          path_id: path.id,
          icon: '/step-icons/default-icons/container.svg',
          description: '',
        },
        {
          type: 'LAST',
          position: 2,
          workflow_id,
          path_id: path.id,
          icon: '/step-icons/default-icons/end.svg',
          description: '',
        },
      ],
    });

    // Return the path with its blocks
    const pathWithBlocks = await prisma_client.path.findUnique({
      where: { id: path.id },
      include: {
        blocks: {
          orderBy: { position: 'asc' },
        },
        parent_blocks: true,
      },
    });

    return NextResponse.json(pathWithBlocks);
  } catch (error) {
    console.error('Error creating path:', error instanceof Error ? error.message : 'Unknown error');
    
    return NextResponse.json(
      { error: 'Failed to create path' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

export async function PATCH(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const body = await req.json();
    const { id, name } = body;

    if (!id || !name) {
      return NextResponse.json(
        { error: 'ID and name are required' },
        { status: 400 }
      );
    }

    const updatedPath = await prisma_client.path.update({
      where: { id },
      data: { name },
      include: {
        blocks: {
          orderBy: { position: 'asc' },
          include: {
            child_paths: {
              include: {
                path: true
              }
            }
          }
        }
      }
    });

    return NextResponse.json(updatedPath);
  } catch (error) {
    console.error('Error updating path:', error);
    return NextResponse.json(
      { error: 'Failed to update path' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/step-icons/route.ts">
// app/api/step-icons/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/lib/supabaseClient';

/**
 * @swagger
 * /api/step-icons:
 *   get:
 *     summary: Retrieve step icons from Supabase storage
 *     description: Fetches lists of application icons and default step icons stored in a Supabase bucket.
 *     responses:
 *       200:
 *         description: Successfully retrieved lists of step icons.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 applist:
 *                   type: array
 *                   items:
 *                     type: string
 *                   description: List of application icons.
 *                   example: ["app1.png", "app2.svg"]
 *                 iconlist:
 *                   type: array
 *                   items:
 *                     type: string
 *                   description: List of default step icons.
 *                   example: ["icon1.png", "icon2.svg"]
 *       500:
 *         description: Internal server error, possibly due to missing configuration or failed file retrieval from Supabase.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Failed to retrieve files"
 */
export async function GET(req: NextRequest) {
  try {
    // Retrieve the bucket name from the environment variable
    const bucketName = process.env.NEXT_PUBLIC_SUPABASE_PUBLIC_BUCKET;

    if (!bucketName) {
      console.error('Bucket name is not defined in the environment variables.');
      return NextResponse.json(
        { error: 'Bucket name is not configured' },
        { status: 500 }
      );
    }

    // Define the folder paths within the bucket
    const appsFolder = 'step-icons/apps';
    const iconsFolder = 'step-icons/default-icons';

    // Fetch the file lists from the Supabase bucket
    const [appsResponse, iconsResponse] = await Promise.all([
      supabase.storage.from(bucketName).list(appsFolder),
      supabase.storage.from(bucketName).list(iconsFolder),
    ]);

    // Check for errors in the responses
    if (appsResponse.error || iconsResponse.error) {
      console.error('Error retrieving files from Supabase:', {
        appsError: appsResponse.error,
        iconsError: iconsResponse.error,
      });
      return NextResponse.json(
        { error: 'Failed to retrieve files from Supabase' },
        { status: 500 }
      );
    }

    // Extract file names from the responses
    const applist = appsResponse.data?.map((file) => file.name) || [];
    const iconlist = iconsResponse.data?.map((file) => file.name) || [];

    // Return the lists as JSON
    return NextResponse.json({ applist, iconlist });
  } catch (error) {
    console.error('Error retrieving files:', error);
    return NextResponse.json(
      { error: 'Failed to retrieve files' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/stripe/customer-portal/route.ts">
import { NextResponse } from 'next/server';
import { createClient } from '@/utils/supabase/server';
import prisma from '@/lib/prisma';
import { createStripePortalSession } from '@/lib/stripe';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function POST(request: Request) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { workspaceId } = await request.json();

    if (!workspaceId) {
      return NextResponse.json({ error: 'Workspace ID is required' }, { status: 400 });
    }

    // Get authenticated user
    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Get workspace and verify user has access
    const workspace = await prisma_client.workspace.findUnique({
      where: { id: workspaceId },
      include: { user_workspaces: {
        include: { user: true }
      }}
    });

    if (!workspace) {
      return NextResponse.json({ error: 'Workspace not found' }, { status: 404 });
    }

    const hasAccess = workspace.user_workspaces.some(uw => uw.user.auth_id === user.id);
    if (!hasAccess) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });
    }

    if (!workspace.stripe_customer_id) {
      return NextResponse.json({ error: 'No Stripe customer ID found' }, { status: 400 });
    }

    // Create Stripe Portal session
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL;
    if (!baseUrl) {
      throw new Error('NEXT_PUBLIC_APP_URL environment variable is not set');
    }

    const returnUrl = `${baseUrl}/`;
    const session = await createStripePortalSession({
      customerId: workspace.stripe_customer_id,
      returnUrl
    });

    return NextResponse.json({ url: session.url });
  } catch (error) {
    console.error('Error creating customer portal session:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/stripe/webhook.ts">
// pages/api/webhook.ts
import { NextApiRequest, NextApiResponse } from "next";
import Stripe from "stripe";

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: "2025-02-24.acacia" });

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const sig = req.headers["stripe-signature"] as string;

  let event;
  try {
    event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET!);
  } catch (err) {
    return res.status(400).send(`Webhook Error: ${(err as Error).message}`);
  }

  if (event.type === "checkout.session.completed") {
    if (process.env.NODE_ENV !== 'production') {
      console.log("Subscription successful!", event);
    }
  }

  res.status(200).json({ received: true });
}
</file>

<file path="app/api/subscription/cancel/route.ts">
import { NextResponse } from 'next/server';
import { stripe, cancelStripeSubscription } from '@/lib/stripe';
import prisma from '@/lib/prisma';
import { createClient } from '@/utils/supabase/server';
import { cookies } from 'next/headers';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function POST(req: Request) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Get the user session using Supabase
    const cookieStore = cookies();
    const supabase = await createClient();
    const { data: { session }, error: authError } = await supabase.auth.getSession();

    if (!session || authError) {
      return NextResponse.json(
        { error: 'Authentication required', details: authError?.message },
        { status: 401 }
      );
    }

    // Get workspace ID from the request body
    const { workspaceId } = await req.json();

    if (!workspaceId) {
      return NextResponse.json(
        { error: 'Missing required fields', details: 'Workspace ID is required' },
        { status: 400 }
      );
    }

    // Find workspace by ID
    const workspace = await prisma_client.workspace.findUnique({
      where: { id: workspaceId },
      include: { subscription: true },
    });

    if (!workspace) {
      return NextResponse.json(
        { error: 'Workspace not found', details: `No workspace found with ID ${workspaceId}` },
        { status: 404 }
      );
    }

    // Check if the workspace has a subscription
    if (!workspace.subscription) {
      return NextResponse.json(
        { error: 'No subscription found', details: 'This workspace does not have an active subscription' },
        { status: 400 }
      );
    }

    try {
      // Cancel the subscription in Stripe
      const canceledSubscription = await cancelStripeSubscription(workspace.subscription.stripe_subscription_id);
      
      // Update the subscription in the database
      await prisma_client.subscription.update({
        where: { id: workspace.subscription.id },
        data: {
          status: 'CANCELED',
          canceled_at: new Date(),
        },
      });

      return NextResponse.json({
        success: true,
        message: 'Subscription canceled successfully',
        subscription: {
          status: 'CANCELED',
          canceled_at: new Date(),
        },
      });
    } catch (stripeError: any) {
      console.error('Error canceling Stripe subscription:', stripeError);
      return NextResponse.json(
        { error: 'Failed to cancel subscription', details: stripeError.message },
        { status: 500 }
      );
    }
  } catch (error: any) {
    console.error('Subscription cancellation error:', error);
    return NextResponse.json(
      { error: 'Error canceling subscription', details: error.message },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/subscription/update/route.ts">
import { NextResponse } from 'next/server';
import { stripe, updateStripeSubscriptionPlan, STRIPE_PRICE_IDS } from '@/lib/stripe';
import prisma from '@/lib/prisma';
import { createClient } from '@/utils/supabase/server';
import { cookies } from 'next/headers';
import { subscriptionRateLimiter } from '@/lib/rateLimit';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function POST(req: Request) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Apply rate limiting
    const rateLimitResponse = await subscriptionRateLimiter(req);
    if (rateLimitResponse) return rateLimitResponse;
    
    // Get the user session using Supabase
    const cookieStore = cookies();
    const supabase = await createClient();
    const { data: { session }, error: authError } = await supabase.auth.getSession();

    if (!session || authError) {
      return NextResponse.json(
        { error: 'Authentication required', details: authError?.message },
        { status: 401 }
      );
    }

    // Parse the request body
    const { workspaceId, billingPeriod } = await req.json();

    if (!workspaceId || !billingPeriod || !['monthly', 'annual'].includes(billingPeriod)) {
      return NextResponse.json(
        { error: 'Missing or invalid required fields', details: 'Workspace ID and valid billing period (monthly/annual) are required' },
        { status: 400 }
      );
    }

    // Find workspace and subscription
    const workspace = await prisma_client.workspace.findUnique({
      where: { id: parseInt(workspaceId) },
      include: { subscription: true }
    });

    if (!workspace) {
      return NextResponse.json(
        { error: 'Workspace not found' },
        { status: 404 }
      );
    }

    if (!workspace.subscription) {
      return NextResponse.json(
        { error: 'No active subscription found' },
        { status: 400 }
      );
    }

    // Get the appropriate price ID based on selected billing period
    const newPriceId = billingPeriod === 'monthly' 
      ? STRIPE_PRICE_IDS.EARLY_ADOPTER.MONTHLY 
      : STRIPE_PRICE_IDS.EARLY_ADOPTER.ANNUAL;

    try {
      if (process.env.NODE_ENV !== 'production') {
        // Log the subscription details before update
        console.log('Attempting to update subscription:', {
          workspaceId,
          subscriptionId: workspace.subscription.stripe_subscription_id,
          currentPriceId: await stripe.subscriptions.retrieve(workspace.subscription.stripe_subscription_id)
            .then(sub => sub.items.data[0]?.price.id)
            .catch(e => {
              console.error('Error retrieving current subscription:', e);
              return null;
            }),
          newPriceId,
          environment: process.env.NODE_ENV,
          stripeMode: process.env.STRIPE_SECRET_KEY?.startsWith('sk_test_') ? 'test' : 'live'
        });
      }

      // Update the subscription in Stripe
      const updatedSubscription = await updateStripeSubscriptionPlan(
        workspace.subscription.stripe_subscription_id,
        newPriceId
      );

      // Get the current subscription details for comparison
      const oldPriceId = await stripe.subscriptions.retrieve(workspace.subscription.stripe_subscription_id)
        .then(sub => sub.items.data[0]?.price.id)
        .catch(() => null);

      // Determine if this was an upgrade (monthly to annual) or downgrade (annual to monthly)
      const isUpgrade = billingPeriod === 'annual';
      const changePeriod = isUpgrade ? 'annual' : 'monthly';
      const changeType = isUpgrade ? 'upgraded' : 'switched';

      // Update the subscription record in our database
      await prisma_client.subscription.update({
        where: { id: workspace.subscription.id },
        data: {
          // Update the current period end based on Stripe's response
          current_period_end: new Date(updatedSubscription.current_period_end * 1000),
        }
      });

      return NextResponse.json({
        success: true,
        message: `Successfully ${changeType} to ${changePeriod} billing`,
        details: `Your subscription has been ${changeType} to ${changePeriod} billing.`,
        current_period_end: new Date(updatedSubscription.current_period_end * 1000),
        billing_period: billingPeriod,
        is_upgrade: isUpgrade
      });
    } catch (stripeError: any) {
      console.error('Stripe subscription update error:', stripeError);
      return NextResponse.json(
        { error: 'Failed to update subscription', details: stripeError.message },
        { status: 500 }
      );
    } finally {
      if (isVercel()) {
        await prisma_client.$disconnect();
      }
    }
  } catch (error: any) {
    console.error('Subscription update error:', error);
    return NextResponse.json(
      { error: 'Error updating subscription', details: error.message },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/subscription/route.ts">
import { NextResponse } from 'next/server';
import { stripe, createStripeCheckoutSession, createStripePortalSession } from '@/lib/stripe';
import prisma from '@/lib/prisma';
import { createClient } from '@/utils/supabase/server';
import { cookies } from 'next/headers';
import { subscriptionRateLimiter } from '@/lib/rateLimit';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

interface UserWorkspace {
  user: {
    id: number;
    email: string;
    name: string | null;
  };
}

interface WorkspaceWithDetails {
  id: number;
  subscription: {
    stripe_subscription_id: string;
    plan_type: string;
    status: string;
    current_period_end: Date;
  } | null;
  user_workspaces: UserWorkspace[];
}

export async function POST(req: Request) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Apply rate limiting
    const rateLimitResponse = await subscriptionRateLimiter(req);
    if (rateLimitResponse) return rateLimitResponse;
    
    // Get the user session using Supabase
    const cookieStore = cookies();
    const supabase = await createClient();
    const { data: { session }, error: authError } = await supabase.auth.getSession();

    if (!session || authError) {
      return NextResponse.json(
        { error: 'Authentication required', details: authError?.message },
        { status: 401 }
      );
    }

    const { priceId, workspaceId, workspaceSlug } = await req.json();

    if (!priceId || (!workspaceId && !workspaceSlug)) {
      return NextResponse.json(
        { error: 'Missing required fields', details: 'Price ID and either Workspace ID or Slug are required' },
        { status: 400 }
      );
    }

    // Find workspace by ID or slug
    const workspace = await prisma_client.workspace.findFirst({
      where: workspaceId ? { id: workspaceId } : { slug: workspaceSlug },
      include: { user_workspaces: true },
    });

    if (!workspace) {
      return NextResponse.json(
        { error: 'Workspace not found', details: `No workspace found with ${workspaceId ? 'ID ' + workspaceId : 'slug ' + workspaceSlug}` },
        { status: 404 }
      );
    }

    // Calculate number of seats based on workspace members
    const quantity = workspace.user_workspaces.length || 1; // Ensure at least 1 seat

    let customerId = workspace.stripe_customer_id;

    if (!customerId) {
      try {
        // Create a new customer in Stripe
        const customer = await stripe.customers.create({
          email: session.user.email!,
          metadata: {
            workspaceId: workspace.id.toString(),
          },
        });
        customerId = customer.id;

        // Update workspace with Stripe customer ID
        await prisma_client.workspace.update({
          where: { id: workspace.id },
          data: { stripe_customer_id: customerId },
        });
      } catch (stripeError: any) {
        console.error('Stripe customer creation error:', stripeError);
        return NextResponse.json(
          { error: 'Failed to create Stripe customer', details: stripeError.message },
          { status: 500 }
        );
      }
    }

    try {
      const baseUrl = process.env.NEXT_PUBLIC_APP_URL;
      if (!baseUrl) {
        throw new Error('NEXT_PUBLIC_APP_URL environment variable is not set');
      }

      // Use dedicated checkout routes instead of workspace slug
      const successUrl = `${baseUrl}/checkout/success?session_id={CHECKOUT_SESSION_ID}&workspace=${workspace.id}`;
      const cancelUrl = `${baseUrl}/checkout/cancel?workspace=${workspace.id}`;

      const checkoutSession = await createStripeCheckoutSession({
        priceId,
        customerId,
        quantity,
        successUrl,
        cancelUrl,
        metadata: {
          workspaceId: workspace.id.toString(),
          planType: 'EARLY_ADOPTER',
        },
      });

      return NextResponse.json({ url: checkoutSession.url });
    } catch (stripeError: any) {
      console.error('Stripe checkout session creation error:', stripeError);
      return NextResponse.json(
        { error: 'Failed to create checkout session', details: stripeError.message },
        { status: 500 }
      );
    }
  } catch (error: any) {
    console.error('Subscription creation error:', error);
    return NextResponse.json(
      { error: 'Error creating subscription', details: error.message },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

export async function GET(req: Request) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Get the user session using Supabase
    const cookieStore = cookies();
    const supabase = await createClient();
    const { data: { session }, error: authError } = await supabase.auth.getSession();

    if (!session || authError) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { searchParams } = new URL(req.url);
    const workspaceId = searchParams.get('workspaceId');

    if (!workspaceId) {
      return NextResponse.json({ error: 'Workspace ID required' }, { status: 400 });
    }

    const workspace = await prisma_client.workspace.findUnique({
      where: { id: parseInt(workspaceId) },
      include: {
        subscription: true,
        user_workspaces: {
          select: {
            user: {
              select: {
                id: true,
                email: true
              }
            }
          }
        }
      }
    });

    if (!workspace) {
      return NextResponse.json({ error: 'Workspace not found' }, { status: 404 });
    }

    // If there's no active subscription, return free plan
    if (!workspace.subscription || !['ACTIVE', 'TRIALING'].includes(workspace.subscription.status)) {
      return NextResponse.json({
        plan_type: 'FREE',
        status: null,
        current_period_end: null,
        price_id: null,
        users: workspace.user_workspaces.map(uw => ({
          id: uw.user.id,
          email: uw.user.email
        }))
      });
    }

    // For active subscriptions, fetch additional details from Stripe
    try {
      // Get the subscription details from Stripe to get the price ID
      const stripeSubscription = await stripe.subscriptions.retrieve(
        workspace.subscription.stripe_subscription_id
      );
      
      // Get the current price ID from the subscription
      const priceId = stripeSubscription.items.data[0]?.price.id || null;
      
      // Get the next payment amount from the upcoming invoice
      let nextPaymentAmount = null;
      try {
        const upcomingInvoice = await stripe.invoices.retrieveUpcoming({
          subscription: workspace.subscription.stripe_subscription_id,
        });
        nextPaymentAmount = upcomingInvoice.total;
      } catch (invoiceError) {
        console.error('Failed to fetch upcoming invoice:', invoiceError);
      }
      
      return NextResponse.json({
        plan_type: workspace.subscription.plan_type,
        status: workspace.subscription.status,
        current_period_end: workspace.subscription.current_period_end,
        price_id: priceId,
        next_payment_amount: nextPaymentAmount,
        users: workspace.user_workspaces.map(uw => ({
          id: uw.user.id,
          email: uw.user.email
        }))
      });
    } catch (stripeError) {
      console.error('Failed to fetch Stripe subscription details:', stripeError);
      
      // Return basic info without price ID if Stripe fetch fails
      return NextResponse.json({
        plan_type: workspace.subscription.plan_type,
        status: workspace.subscription.status,
        current_period_end: workspace.subscription.current_period_end,
        price_id: null,
        users: workspace.user_workspaces.map(uw => ({
          id: uw.user.id,
          email: uw.user.email
        }))
      });
    }

  } catch (error) {
    console.error('Subscription status error:', error);
    return NextResponse.json(
      { error: 'Error fetching subscription status' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/test/send-feature-update/route.ts">
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { createClient } from '@/utils/supabase/server';
import { sendReactEmail } from '@/lib/email';
import { FeatureUpdateEmail } from '@/emails/templates/ShareRoadmap';
import { generateRoadmapLinkForEmail } from '@/lib/roadmapAuth';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

// GET endpoint for easier testing via browser
export async function GET(request: Request) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Only allow in development or staging environments
    if (process.env.NODE_ENV === 'production') {
      return NextResponse.json({ error: 'Not available in production' }, { status: 403 });
    }

    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.error('Auth error:', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Get user from database
    const dbUser = await prisma_client.user.findUnique({
      where: { auth_id: user.id },
    });

    if (!dbUser) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Generate the roadmap link with authentication
    const roadmapLink = await generateRoadmapLinkForEmail(
      dbUser.id,
      dbUser.email,
      dbUser.first_name,
      dbUser.last_name,
      dbUser.avatar_url || undefined
    );

    // Get safe public URLs for email templates
    const safePublicUrls = {
      supabasePublicUrl: process.env.NEXT_PUBLIC_SUPABASE_URL || '',
      supabaseStoragePath: process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH || '',
      producthuntUrl: process.env.NEXT_PUBLIC_PRODUCTHUNT_URL || 'https://www.producthunt.com',
      linkedinUrl: process.env.NEXT_PUBLIC_LINKEDIN_URL || 'https://www.linkedin.com/company/processflow1/',
      xUrl: process.env.NEXT_PUBLIC_X_URL || 'https://x.com',
    };

    // Send the feature update email immediately
    const result = await sendReactEmail({
      to: dbUser.email,
      subject: 'Sneak peek: new ProcessFlow features you\'ll love',
      Component: FeatureUpdateEmail,
      props: {
        firstName: dbUser.first_name,
        roadmapLink,
        publicUrls: safePublicUrls,
      },
      sender: 'jean',
    });

    return NextResponse.json({ 
      success: result.success, 
      message: result.success ? 'Feature update email with logo sent successfully' : 'Failed to send feature update email',
      result,
    });
  } catch (error) {
    console.error('Error sending feature update email:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to send feature update email' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

export async function POST(request: Request) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Only allow in development or staging environments
    if (process.env.NODE_ENV === 'production') {
      return NextResponse.json({ error: 'Not available in production' }, { status: 403 });
    }

    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.error('Auth error:', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Get user from database
    const dbUser = await prisma_client.user.findUnique({
      where: { auth_id: user.id },
    });

    if (!dbUser) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Generate the roadmap link with authentication
    const roadmapLink = await generateRoadmapLinkForEmail(
      dbUser.id,
      dbUser.email,
      dbUser.first_name,
      dbUser.last_name,
      dbUser.avatar_url || undefined
    );

    // Get safe public URLs for email templates
    const safePublicUrls = {
      supabasePublicUrl: process.env.NEXT_PUBLIC_SUPABASE_URL || '',
      supabaseStoragePath: process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH || '',
      producthuntUrl: process.env.NEXT_PUBLIC_PRODUCTHUNT_URL || 'https://www.producthunt.com',
      linkedinUrl: process.env.NEXT_PUBLIC_LINKEDIN_URL || 'https://www.linkedin.com/company/processflow1/',
      xUrl: process.env.NEXT_PUBLIC_X_URL || 'https://x.com',
    };

    // Send the feature update email immediately
    const result = await sendReactEmail({
      to: dbUser.email,
      subject: 'Sneak peek: new ProcessFlow features you\'ll love',
      Component: FeatureUpdateEmail,
      props: {
        firstName: dbUser.first_name,
        roadmapLink,
        publicUrls: safePublicUrls,
      },
      sender: 'jean',
    });

    return NextResponse.json({ 
      success: result.success, 
      message: result.success ? 'Feature update email with logo sent successfully' : 'Failed to send feature update email',
      result,
    });
  } catch (error) {
    console.error('Error sending feature update email:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to send feature update email' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/test/send-feature-update-test/route.ts">
import { NextResponse } from 'next/server';
import { sendReactEmail } from '@/lib/email';
import { FeatureUpdateEmail } from '@/emails/templates/ShareRoadmap';

export async function GET(request: Request) {
  try {
    // Only allow in development or staging environments
    if (process.env.NODE_ENV === 'production') {
      return NextResponse.json({ error: 'Not available in production' }, { status: 403 });
    }

    // Get the email from the query parameter or use a default
    const url = new URL(request.url);
    const email = url.searchParams.get('email') || process.env.TEST_EMAIL || 'your-email@example.com';
    
    // Use a mock roadmap link
    const roadmapLink = 'https://features.vote/processflow?token=test-token';

    // Get safe public URLs for email templates
    const safePublicUrls = {
      supabasePublicUrl: process.env.NEXT_PUBLIC_SUPABASE_URL || '',
      supabaseStoragePath: process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH || '',
      producthuntUrl: process.env.NEXT_PUBLIC_PRODUCTHUNT_URL || 'https://www.producthunt.com',
      linkedinUrl: process.env.NEXT_PUBLIC_LINKEDIN_URL || 'https://www.linkedin.com/company/processflow1/',
      xUrl: process.env.NEXT_PUBLIC_X_URL || 'https://x.com',
    };

    // Send the feature update email immediately
    const result = await sendReactEmail({
      to: email,
      subject: 'TEST: Sneak peek: new ProcessFlow features you\'ll love',
      Component: FeatureUpdateEmail,
      props: {
        firstName: 'Test User',
        roadmapLink,
        publicUrls: safePublicUrls,
      },
      sender: 'jean',
    });

    return NextResponse.json({ 
      success: result.success, 
      message: result.success ? `Feature update email with logo sent successfully to ${email}` : 'Failed to send feature update email',
      result,
    });
  } catch (error) {
    console.error('Error sending feature update email:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to send feature update email' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/upload/workspace-logo/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/utils/supabase/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

// Maximum file size (1MB)
const MAX_FILE_SIZE = 1 * 1024 * 1024;
// Allowed file types
const ALLOWED_FILE_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/svg+xml'];

export async function POST(request: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const supabase = await createClient();
    
    // Check if user is authenticated
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (!user || authError) {
      return NextResponse.json({ error: 'You must be logged in to upload a logo' }, { status: 401 });
    }
    
    // Parse the multipart form data
    const formData = await request.formData();
    const file = formData.get('file') as File;
    const workspaceId = formData.get('workspaceId') as string;
    
    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }
    
    if (!workspaceId) {
      return NextResponse.json({ error: 'No workspace ID provided' }, { status: 400 });
    }
    
    // Validate file type
    if (!ALLOWED_FILE_TYPES.includes(file.type)) {
      return NextResponse.json({ 
        error: 'Invalid file type. Please use JPEG, PNG, GIF, or SVG images.' 
      }, { status: 400 });
    }
    
    // Validate file size
    if (file.size > MAX_FILE_SIZE) {
      return NextResponse.json({ 
        error: 'File is too large. Maximum size is 1MB.' 
      }, { status: 400 });
    }
    
    // Get the user from the database
    const dbUser = await prisma_client.user.findUnique({
      where: { auth_id: user.id },
    });
    
    if (!dbUser) {
      return NextResponse.json({ error: 'User not found in database' }, { status: 404 });
    }
    
    // Check if the user has access to the workspace
    const userWorkspace = await prisma_client.user_workspace.findFirst({
      where: {
        user_id: dbUser.id,
        workspace_id: parseInt(workspaceId),
      },
    });
    
    if (!userWorkspace) {
      return NextResponse.json({ 
        error: 'Workspace not found or you do not have access to it' 
      }, { status: 404 });
    }
    
    // Generate a filename following the same pattern as onboarding
    const fileName = `workspace-logo-${user.id}-${Date.now()}`;
    
    // Upload the file to Supabase Storage using the same bucket and path as onboarding
    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('user-assets')
      .upload(`workspaces_logo/${fileName}`, file, {
        cacheControl: '3600',
        upsert: false
      });
      
    if (uploadError) {
      console.error('Error uploading file:', uploadError);
      throw new Error('Failed to upload logo');
    }
    
    // Get the public URL using the same method as onboarding
    const { data: { publicUrl } } = supabase.storage
      .from('user-assets')
      .getPublicUrl(`workspaces_logo/${fileName}`);
    
    // Update the workspace in the database with the new logo URL
    await prisma_client.workspace.update({
      where: { 
        id: parseInt(workspaceId) 
      },
      data: { 
        icon_url: publicUrl 
      }
    });
    
    return NextResponse.json({ url: publicUrl });
  } catch (error) {
    console.error('Error in workspace logo upload:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json({ 
      error: `Internal server error: ${errorMessage}` 
    }, { status: 500 });
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/user/generate-token.ts">
import type { NextApiRequest, NextApiResponse } from 'next';

const FEATURES_VOTE_SECRET_KEY = process.env.FEATURES_VOTE_SECRET_KEY || '';

interface GenerateTokenRequestBody {
  email: string;
  id: string;
  name?: string;
  avatarUrl?: string;
}

interface GenerateTokenResponse {
  token?: string;
  error?: string;
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<GenerateTokenResponse>
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    // Vrification des paramtres
    const { email, id, name, avatarUrl } = req.body as GenerateTokenRequestBody;

    if (!email || !id) {
      return res.status(400).json({ error: 'Missing required fields: email or id' });
    }

    // Prparer la requte pour l'API externe
    const response = await fetch('https://features.vote/api/public/user-token', {
      method: 'POST',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        apiSecretKey: FEATURES_VOTE_SECRET_KEY,
        slug: 'processflow', // Remplace par ton slug spcifique
        user_data: {
          user_email: email,
          app_user_id: id,
          user_name: name,
          img_url: avatarUrl,
        },
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Error from features.vote API:', errorText);
      throw new Error(`Failed to generate token: ${errorText}`);
    }

    // Rcupration du token depuis la rponse de l'API
    const data = await response.json();
    const { token } = data;

    if (!token) {
      throw new Error('No token received from features.vote API');
    }

    // Retourner le token au frontend
    return res.status(200).json({ token });
  } catch (error) {
    console.error('Error in /api/generate-token:', error);
    return res.status(500).json({ error: 'Failed to generate token' });
  }
}
</file>

<file path="app/api/user/route.ts">
// app/api/user/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/utils/supabase/server'; // Import your Supabase client
import prisma from '@/lib/prisma'; // Import your Prisma client
import { supabase } from '@/lib/supabaseClient'; // Already imported in your signed url util
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { generatePublicUrl } from '../utils/generatePublicUrl';
import { generateUserUrl } from '../utils/generateUserUrl';

/**
 * @swagger
 * /api/user:
 *   get:
 *     summary: Get authenticated user details
 *     description: Retrieves the authenticated user's details from Supabase and matches it with the Prisma user record. If the user's email in Supabase differs, it updates the Prisma record.
 *     tags:
 *       - User
 *     responses:
 *       200:
 *         description: User retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 auth_id:
 *                   type: string
 *                   example: "7f9c47d1-1234-4f86-9b98-b76d8f4d57a1"
 *                 email:
 *                   type: string
 *                   example: "user@example.com"
 *                 first_name:
 *                   type: string
 *                   example: "John"
 *                 last_name:
 *                   type: string
 *                   example: "Doe"
 *                 full_name:
 *                   type: string
 *                   example: "John Doe"
 *                 avatar_url:
 *                   type: string
 *                   nullable: true
 *                   example: "https://example.com/avatar.jpg"
 *                 active_workspace:
 *                   type: integer
 *                   nullable: true
 *                   example: 3
 *       400:
 *         description: No email found in Supabase user data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "No email found in Supabase user data"
 *       401:
 *         description: User not authenticated.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "User not authenticated"
 *       404:
 *         description: User not found in Prisma database.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "User not found"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 */
export async function GET(req: NextRequest) {
  const supabase = await createClient();

  // Get the user from Supabase Auth
  const { data: userData, error: userError } = await supabase.auth.getUser();

  if (userError || !userData || !userData.user) {
    return NextResponse.json(
      { error: 'User not authenticated' },
      { status: 401 }
    );
  }

  const supabaseUser = userData.user;
  const userId = supabaseUser.id; // Supabase UID
  const supabaseEmail = supabaseUser.email;

  if (!supabaseEmail) {
    return NextResponse.json(
      { error: 'No email found in Supabase user data' },
      { status: 400 }
    );
  }

  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Fetch the Prisma user based on the Supabase UID
    const user = await prisma_client.user.findUnique({
      where: {
        auth_id: userId,
      },
    });

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    let avatar_signed_url: string | null = null;
    if (user.avatar_url && !user.avatar_url.startsWith('http')) {
      try {
        avatar_signed_url = generateUserUrl(user.avatar_url);
      } catch (error) {
        console.error('Error generating public URL for avatar:', error);
      }
    }

    // If the email differs, update the Prisma user record
    if (user.email !== supabaseEmail) {
      const updatedUser = await prisma_client.user.update({
        where: { auth_id: userId },
        data: {
          email: supabaseEmail,
        },
      });
      // Add avatar_signed_url to updatedUser before returning
      return NextResponse.json({ ...updatedUser, avatar_signed_url });
    }

    return NextResponse.json({ ...user, avatar_signed_url });
  } catch (dbError) {
    console.error('Error fetching or updating user from Prisma:', dbError);
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/user_workspace/[user_id]/route.ts">
// app/api/workspace/[user_id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { createSignedIconUrlsForWorkspaces } from '@/utils/createSignedUrls';

/**
 * @swagger
 * /api/workspace/{user_id}:
 *   get:
 *     summary: Retrieve all workspaces for a user
 *     description: Fetches the workspaces associated with a specific user, including related folders and workflows. If no workspaces are found, a default workspace named "My Workspace" is created.
 *     tags:
 *       - Workspace
 *     parameters:
 *       - in: path
 *         name: user_id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user
 *     responses:
 *       200:
 *         description: Successfully retrieved the user's workspaces
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   name:
 *                     type: string
 *                     example: "My Workspace"
 *                   folders:
 *                     type: array
 *                     items:
 *                       type: object
 *                       properties:
 *                         id:
 *                           type: integer
 *                           example: 1
 *                         name:
 *                           type: string
 *                           example: "Folder Name"
 *                   workflows:
 *                     type: array
 *                     items:
 *                       type: object
 *                       properties:
 *                         id:
 *                           type: integer
 *                           example: 1
 *                         name:
 *                           type: string
 *                           example: "Workflow Name"
 *       404:
 *         description: User not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "User not found"
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 */
export async function GET(req: NextRequest, props: { params: Promise<{ user_id: string }> }) {
  const params = await props.params;
  const userId = parseInt(params.user_id); // Use the user_id from the URL

  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }

  try {
    // Fetch user's workspaces with all necessary relations
    console.time('prisma.user_workspace.findMany');
    const userWorkspaces = await prisma_client.user_workspace.findMany({
      where: {
        user_id: userId,
      },
      include: {
        workspace: {
          include: {
            folders: {
              orderBy: {
                id: 'asc',
              },
            },
            workflows: {
              orderBy: {
                id: 'asc',
              },
            },
            user_workspaces: {
              include: {
                user: true,
              },
            },
            subscription: true,
          },
        },
      },
    });
    console.timeEnd('prisma.user_workspace.findMany');

    // Extract workspaces from the user_workspaces relation
    const workspaces = userWorkspaces.map(uw => uw.workspace);

    if (!workspaces || workspaces.length === 0) {
      // Dfinir une couleur de fond par dfaut
      const defaultBackgroundColor = '#4299E1';

      // Create the default workspace and include folders (which will be empty)
      console.time('prisma.workspace.create');
      const newWorkspace = await prisma_client.workspace.create({
        data: {
          name: 'My Workspace',
          background_colour: defaultBackgroundColor,
          created_at: new Date(), // Date de cration
          updated_at: new Date(), // Date de mise  jour
          user_workspaces: {
            create: {
              user_id: userId,
              role: 'ADMIN',
            },
          },
        },
        include: {
          folders: {
            orderBy: {
              id: 'asc',
            },
          },
          workflows: {
            orderBy: {
              id: 'asc',
            },
          },
          user_workspaces: {
            include: {
              user: true,
            },
          },
          subscription: true,
        },
      });
      console.timeEnd('prisma.workspace.create');

      // Mettre  jour l'active_workspace_id de l'utilisateur
      console.time('prisma.user.update');
      await prisma_client.user.update({
        where: { id: userId },
        data: {
          active_workspace_id: newWorkspace.id,
        },
      });
      console.timeEnd('prisma.user.update');

      return NextResponse.json([newWorkspace]);
    }

    const workspacesWithSignedIcons = await createSignedIconUrlsForWorkspaces(workspaces);

    return NextResponse.json(workspacesWithSignedIcons);
  } catch (error) {
    console.error('Error fetching workspaces:', error);
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/utils/blocks/addOne.ts">
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function addOneBlock(data: any) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    return await prisma_client.block.create({ data, include: { child_paths: { include: { path: true } } } });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/utils/blocks/editOne.ts">
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function editOneBlock(id: number | string, data: any) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    return await prisma_client.block.update({
      where: { id: typeof id === 'string' ? parseInt(id, 10) : id },
      data,
    });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/utils/paths/addOne.ts">
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function addOnePath(data: any) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma; 
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Adjust 'Path' and 'data' type as per your Prisma schema
    return await prisma_client.path.create({ data });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/utils/paths/deleteMany.ts">
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { supabase } from '@/lib/supabaseClient';

/**
 * Recursively deletes paths, their blocks, and associated images from storage.
 * @param pathIds Array of path IDs to delete
 */
export async function deleteManyPaths(pathIds: number[]): Promise<void> {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    if (!Array.isArray(pathIds) || pathIds.length === 0) return;

    // Fetch all paths with their blocks and child_paths
    const paths = await prisma_client.path.findMany({
      where: { id: { in: pathIds } },
      select: {
        id: true,
        blocks: {
          select: {
            id: true,
            child_paths: {
              select: {
                path_id: true,
              },
            },
            image: true,
          },
        },
      },
    });

    const bucketName = process.env.NEXT_PUBLIC_SUPABASE_PRIVATE_BUCKET;

    for (const path of paths) {
      for (const block of path.blocks) {
        // Delete image from storage if exists
        if (bucketName && block.image) {
          const { error } = await supabase.storage
            .from(bucketName)
            .remove([block.image]);
          if (error) {
            console.error(`Error deleting image for block ${block.id}:`, error);
          }
        }

        // Recursively delete child paths if any
        if (block.child_paths && block.child_paths.length > 0) {
          const childPathIds = block.child_paths.map((cp: any) => cp.path_id);
          await deleteManyPaths(childPathIds);
        }
      }

      // Delete the path itself
      await prisma_client.path.delete({
        where: { id: path.id },
      });
    }
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/utils/paths/deleteOne.ts">
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { deleteOneBlock } from '../blocks/deleteOne';
import { deleteManyPaths } from './deleteMany';

export async function deleteOnePath(id: number | string) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const pathId = typeof id === 'string' ? parseInt(id, 10) : id;

    // Get parent blocks of the path
    const parentBlocks = await prisma_client.path_parent_block.findMany({
      where: { path_id: pathId },
      select: { block_id: true },
    });

    // Only perform the child_paths check if there is exactly one parent block
    if (parentBlocks.length === 1) {
      const parentBlockId = parentBlocks[0].block_id;
      const childPaths = await prisma_client.path_parent_block.findMany({
        where: { block_id: parentBlockId },
        select: { path_id: true },
      });

      // If deleting this path would leave only one child path, abort
      if (childPaths.length === 2) {
        throw new Error(
          'Cannot delete this path: its parent block would be left with only one child path.'
        );
      }
    }

    // Proceed with deletion
    await prisma_client.path_parent_block.deleteMany({
      where: { path_id: pathId },
    });

    // Delete each block in the path using deleteOneBlock
    const blocks = await prisma_client.block.findMany({
      where: { path_id: pathId },
      select: { id: true, child_paths: { select: { path_id: true } } },
    });
    for (const block of blocks) {
      if (block.child_paths.length > 0) {
        const pathIds = block.child_paths.map((path) => path.path_id);
        await deleteManyPaths(pathIds);
      }
      await deleteOneBlock(block.id);
    }

    return prisma_client.path.delete({
      where: { id: pathId },
    });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/utils/paths/editOne.ts">
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function editOnePath(id: number | string, data: any) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    return await prisma_client.path.update({
      where: { id: typeof id === 'string' ? parseInt(id, 10) : id },
      data,
    });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/utils/paths/Pathutils.ts">
import prisma from '@/lib/prisma'; // Adjust the import path if your prisma client is elsewhere
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

/**
 * Checks if the path with the given ID is a root path (has no parent).
 * @param id - The ID of the path to check.
 * @returns Promise<boolean> - True if the path has no parent, false otherwise.
 */
export async function IsFirstPath(id: string | number): Promise<boolean> {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const path = await prisma_client.path.findUnique({
      where: { id: typeof id === 'string' ? parseInt(id, 10) : id },
      select: { parent_blocks: true },
    });

    if (!path) {
      throw new Error('Path not found');
    }

    // Adjust this check if your schema uses null/undefined for root paths
    return !path.parent_blocks || path.parent_blocks.length === 0;
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/utils/workflows/addOne.ts">
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function addOneWorkflow(data: any) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    return await prisma_client.workflow.create({ data });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/utils/workflows/deleteOne.ts">
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function deleteOneWorkflow(id: number | string) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    return await prisma_client.workflow.delete({
      where: { id: typeof id === 'string' ? parseInt(id, 10) : id },
    });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/utils/workflows/editOne.ts">
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function editOneWorkflow(id: number | string, data: any) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    return await prisma_client.workflow.update({
      where: { id: typeof id === 'string' ? parseInt(id, 10) : id },
      data,
    });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/utils/workspaces/addOne.ts">
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { checkWorkspaceName } from '@/app/utils/checkNames';

export async function addOneWorkspace(data: any) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    if (data.name) {
      const nameError = checkWorkspaceName(data.name);
      if (nameError) {
        throw new Error(nameError.description);
      }
    }
    return await prisma_client.workspace.create({ data });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/utils/workspaces/deleteOne.ts">
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function deleteOneWorkspace(id: number | string) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    return await prisma_client.workspace.delete({
      where: { id: typeof id === 'string' ? parseInt(id, 10) : id },
    });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/utils/workspaces/editOne.ts">
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { checkWorkspaceName } from '@/app/utils/checkNames';

export async function editOneWorkspace(id: number | string, data: any) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    if (data.name) {
      const nameError = checkWorkspaceName(data.name);
      if (nameError) {
        throw new Error(nameError.description);
      }
    }
    return await prisma_client.workspace.update({
      where: { id: typeof id === 'string' ? parseInt(id, 10) : id },
      data,
    });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/utils/create-default-workflow.ts">
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { generatePublicAccessId } from '../workflow/utils';

export interface CreateDefaultWorkflowOptions {
  workspaceId: number;
  userId?: number;
}

export interface CreateDefaultWorkflowsOptions {
  workspaceId: number;
  userId?: number;
}

export async function createDefaultWorkflows({ workspaceId, userId }: CreateDefaultWorkflowsOptions) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Get workflow IDs from env or fallback
    const workflowIds = process.env.LOCAL_WORKFLOW_TEMPLATE_IDS
      ? process.env.LOCAL_WORKFLOW_TEMPLATE_IDS.split(',').map((id) => parseInt(id.trim(), 10))
      : [300, 305, 321];
    const SOURCE_WORKSPACE_ID = 110;

    // Map of custom names by template ID
    const customNames: Record<number, string> = {
      321: 'Customer support ticket process with Zendesk',
      300: 'Employee Onboarding',
      305: 'Freelance Client Onboarding Process',
    };

    const results = [];
    for (const workflowId of workflowIds) {
      try {
        const result = await createDefaultWorkflow({
          workspaceId,
          userId,
          sourceWorkflowId: workflowId,
          sourceWorkspaceId: SOURCE_WORKSPACE_ID,
          customName: customNames[workflowId],
        }, prisma_client);
        results.push(result);
      } catch (error) {
        results.push({ success: false, error: error instanceof Error ? error.message : error });
      }
    }
    return results;
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}

export async function createDefaultWorkflow(
  { workspaceId, userId, sourceWorkflowId, sourceWorkspaceId, customName }: { workspaceId: number; userId?: number; sourceWorkflowId?: number; sourceWorkspaceId?: number; customName?: string },
  prisma_client?: PrismaClient
) {
  const _prisma = prisma_client || (isVercel() ? new PrismaClient() : prisma);
  if (!_prisma) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const SOURCE_WORKFLOW_ID = sourceWorkflowId ?? (process.env.LOCAL_WORKFLOW_TEMPLATE_ID ? parseInt(process.env.LOCAL_WORKFLOW_TEMPLATE_ID) : 257);
    const SOURCE_WORKSPACE_ID = sourceWorkspaceId ?? (process.env.LOCAL_WORKFLOW_TEMPLATE_ID ? parseInt(process.env.LOCAL_WORKFLOW_TEMPLATE_ID) : 110);

    // Get the source workflow with all related components
    const sourceWorkflow = await _prisma.workflow.findUnique({
      where: {
        id: SOURCE_WORKFLOW_ID,
        workspace_id: SOURCE_WORKSPACE_ID,
      },
      include: {
        paths: {
          include: {
            blocks: {
              include: {
                child_paths: true,
              },
              orderBy: {
                position: 'asc',
              },
            },
            parent_blocks: true,
          },
        },
        stroke_lines: true,
      },
    });

    if (!sourceWorkflow) {
      throw new Error(
        `Source workflow not found: ID ${SOURCE_WORKFLOW_ID} in workspace ${SOURCE_WORKSPACE_ID}`
      );
    }

    // Check if target workspace exists
    const targetWorkspace = await _prisma.workspace.findUnique({
      where: { id: workspaceId },
    });

    if (!targetWorkspace) {
      throw new Error(`Target workspace not found: ID ${workspaceId}`);
    }

    // Generate a unique name for the new workflow
    let newWorkflowName = customName || "Getting Started with ProcessFlow";
    let counter = 1;
    let nameIsUnique = false;

    while (!nameIsUnique) {
      const existingWorkflow = await _prisma.workflow.findUnique({
        where: {
          name_workspace_id: {
            name: newWorkflowName,
            workspace_id: workspaceId,
          },
        },
      });

      if (!existingWorkflow) {
        nameIsUnique = true;
      } else {
        newWorkflowName = `${customName || "Getting Started with ProcessFlow"} (${counter})`;
        counter++;
      }
    }

    // Track progress and errors that don't prevent completion
    const progressSteps = {
      workflow: false,
      paths: false,
      blocks: false,
      parentBlocks: false,
      strokeLines: false
    };

    const nonFatalErrors = [];
    let newWorkflow;

    // 1. Create the new workflow in the target workspace
    newWorkflow = await _prisma.workflow.create({
      data: {
        name: newWorkflowName,
        description: sourceWorkflow.description,
        icon: sourceWorkflow.icon,
        is_public: sourceWorkflow.is_public,
        status: sourceWorkflow.status,
        public_access_id: await generatePublicAccessId(newWorkflowName, 0, workspaceId),
        workspace: {
          connect: { id: workspaceId },
        },
        author: userId ? {
          connect: { id: userId },
        } : undefined,
      },
    });
    progressSteps.workflow = true;

    // 2. Map for tracking old path IDs to new path IDs
    const pathIdMap = new Map();

    // 3. Create paths
    try {
      for (const sourcePath of sourceWorkflow.paths) {
        const newPath = await _prisma.path.create({
          data: {
            name: sourcePath.name,
            workflow: {
              connect: { id: newWorkflow.id },
            },
          },
        });

        pathIdMap.set(sourcePath.id, newPath.id);
      }
      progressSteps.paths = true;
    } catch (error) {
      nonFatalErrors.push({
        step: 'paths',
        error: error instanceof Error ? error.message : 'Unknown error creating paths'
      });
    }

    // 4. Map for tracking old block IDs to new block IDs
    const blockIdMap = new Map();

    // 5. Create blocks for each path
    try {
      for (const sourcePath of sourceWorkflow.paths) {
        const newPathId = pathIdMap.get(sourcePath.id);

        if (!newPathId) {
          nonFatalErrors.push({
            step: 'blocks',
            error: `Path ID ${sourcePath.id} not found in map`
          });
          continue;
        }

        for (const sourceBlock of sourcePath.blocks) {
          try {
            const newBlock = await _prisma.block.create({
              data: {
                type: sourceBlock.type,
                position: sourceBlock.position,
                title: sourceBlock.title,
                icon: sourceBlock.icon,
                description: sourceBlock.description,
                image: sourceBlock.image,
                original_image: sourceBlock.original_image,
                image_description: sourceBlock.image_description,
                average_time: sourceBlock.average_time,
                task_type: sourceBlock.task_type,
                delay_seconds: sourceBlock.delay_seconds,
                delay_event: sourceBlock.delay_event,
                delay_type: sourceBlock.delay_type,
                workflow: {
                  connect: { id: newWorkflow.id },
                },
                path: {
                  connect: { id: newPathId },
                },
              },
            });

            blockIdMap.set(sourceBlock.id, newBlock.id);
          } catch (blockError) {
            nonFatalErrors.push({
              step: 'block',
              error: `Error creating block ${sourceBlock.id}: ${blockError instanceof Error ? blockError.message : 'Unknown error'}`
            });
          }
        }
      }
      progressSteps.blocks = true;
    } catch (error) {
      nonFatalErrors.push({
        step: 'blocks',
        error: error instanceof Error ? error.message : 'Unknown error creating blocks'
      });
    }

    // 6. Create path_parent_block relationships
    try {
      for (const sourcePath of sourceWorkflow.paths) {
        const newPathId = pathIdMap.get(sourcePath.id);

        if (!newPathId) continue;

        for (const parentBlock of sourcePath.parent_blocks) {
          const newBlockId = blockIdMap.get(parentBlock.block_id);

          if (newBlockId && newPathId) {
            try {
              await _prisma.path_parent_block.create({
                data: {
                  path_id: newPathId,
                  block_id: newBlockId,
                },
              });
            } catch (parentBlockError) {
              nonFatalErrors.push({
                step: 'parentBlock',
                error: `Error creating parent block relationship: ${parentBlockError instanceof Error ? parentBlockError.message : 'Unknown error'}`
              });
            }
          }
        }
      }
      progressSteps.parentBlocks = true;
    } catch (error) {
      nonFatalErrors.push({
        step: 'parentBlocks',
        error: error instanceof Error ? error.message : 'Unknown error creating parent blocks'
      });
    }

    // 7. Create stroke lines
    try {
      for (const sourceStrokeLine of sourceWorkflow.stroke_lines) {
        const newSourceBlockId = blockIdMap.get(sourceStrokeLine.source_block_id);
        const newTargetBlockId = blockIdMap.get(sourceStrokeLine.target_block_id);

        if (newSourceBlockId && newTargetBlockId) {
          try {
            await _prisma.stroke_line.create({
              data: {
                label: sourceStrokeLine.label,
                control_points: sourceStrokeLine.control_points || undefined,
                source_block: {
                  connect: { id: newSourceBlockId },
                },
                target_block: {
                  connect: { id: newTargetBlockId },
                },
                workflow: {
                  connect: { id: newWorkflow.id },
                },
              },
            });
          } catch (strokeLineError) {
            nonFatalErrors.push({
              step: 'strokeLine',
              error: `Error creating stroke line: ${strokeLineError instanceof Error ? strokeLineError.message : 'Unknown error'}`
            });
          }
        }
      }
      progressSteps.strokeLines = true;
    } catch (error) {
      nonFatalErrors.push({
        step: 'strokeLines',
        error: error instanceof Error ? error.message : 'Unknown error creating stroke lines'
      });
    }

    return {
      success: true,
      workflow: newWorkflow,
      progress: progressSteps,
      warnings: nonFatalErrors.length > 0 ? nonFatalErrors : undefined,
    };
  } finally {
    if (!prisma_client && isVercel()) await _prisma.$disconnect();
  }
}
</file>

<file path="app/api/utils/formatTitle.ts">
/**
 * Removes all line breaks and trims the string to the first 150 characters.
 * @param title The input string to format.
 * @returns The formatted string.
 */
export function formatTitle(title: string | undefined): string | undefined {
  if (!title) return undefined;
  // Remove all line breaks (\r, \n) and trim to 120 characters
  return title.replace(/[\r\n]+/g, ' ').slice(0, 120);
}
</file>

<file path="app/api/utils/generateUserUrl.ts">
import { generateWorkspaceURL } from './generateWorkspaceURL';

/**
 * Generates a public URL for a file in the Supabase storage bucket
 * @param path - The path of the file in the storage bucket
 * @returns The complete public URL for the file
 * @throws Error if required environment variables are missing
 */
export function generateUserUrl(path: string): string {
  // Get the environment variables
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const storagePath = process.env.NEXT_PUBLIC_SUPABASE_USER_STORAGE_PATH;

  if (!supabaseUrl) {
    throw new Error('NEXT_PUBLIC_SUPABASE_URL is not defined in the environment variables');
  }

  if (!storagePath) {
    throw new Error('NEXT_PUBLIC_SUPABASE_STORAGE_PATH is not defined in the environment variables');
  }

  if (!path) {
    throw new Error('Path is required to generate public URL');
  }

  // If the path contains 'step-icons/custom', use generateWorkspaceURL instead
  if (path.includes('step-icons/custom')) {
    if (process.env.NODE_ENV === 'development') {
      console.log('Using generateWorkspaceURL for path:', path);
    }
    return generateWorkspaceURL(path);
  }

  // Remove leading slash from path if present to avoid double slashes
  const cleanPath = path.startsWith('/') ? path.slice(1) : path;

  // Build and return the public URL
  return `${supabaseUrl}${storagePath}/${cleanPath}`;
}
</file>

<file path="app/api/utils/isVercel.ts">
export function isVercel() {
    return process.env.VERCEL === '1';
  }
</file>

<file path="app/api/webhooks/stripe/route.ts">
import { headers } from 'next/headers';
import { NextResponse } from 'next/server';
import { stripe, mapStripeStatusToDbStatus } from '@/lib/stripe';
import prisma from '@/lib/prisma';
import Stripe from 'stripe';
import { webhookRateLimiter } from '@/lib/rateLimit';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

// Validate webhook secret is configured
const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!;
if (!webhookSecret) {
  throw new Error('STRIPE_WEBHOOK_SECRET is not set in environment variables');
}

// Add type for customer metadata
interface CustomerMetadata {
  workspaceId: string;
}

async function handleSubscriptionCreated(subscription: Stripe.Subscription, prisma_client: PrismaClient) {
  try {
    // Get the customer to find the workspace
    const customer = await stripe.customers.retrieve(subscription.customer as string) as Stripe.Customer;
    const workspaceId = (customer.metadata as unknown as CustomerMetadata).workspaceId;

    if (!workspaceId) {
      throw new Error('No workspace ID found in customer metadata');
    }

    // Get customer's billing details from Stripe
    const customerDetails = await stripe.customers.retrieve(subscription.customer as string, {
      expand: ['tax_ids']
    }) as Stripe.Customer;

    // Start a transaction to ensure data consistency
    const result = await prisma_client.$transaction(async (tx) => {
      // Create subscription record
      const sub = await tx.subscription.create({
        data: {
          workspace_id: parseInt(workspaceId),
          stripe_subscription_id: subscription.id,
          plan_type: 'EARLY_ADOPTER',
          quantity_seats: 1,
          current_period_start: new Date(subscription.current_period_start * 1000),
          current_period_end: new Date(subscription.current_period_end * 1000),
          trial_end_date: subscription.trial_end ? new Date(subscription.trial_end * 1000) : null,
          status: subscription.status === 'trialing' ? 'TRIALING' : 'ACTIVE',
        },
      });

      // Create or update billing information
      const defaultTaxRate = 20.00; // Default tax rate, adjust as needed
      await tx.workspace_billing_infos.upsert({
        where: {
          workspace_id: parseInt(workspaceId),
        },
        update: {
          billing_email: customerDetails.email || '',
          billing_address: [
            customerDetails.address?.line1,
            customerDetails.address?.line2,
            customerDetails.address?.city,
            customerDetails.address?.state,
            customerDetails.address?.postal_code,
            customerDetails.address?.country,
          ].filter(Boolean).join('\n'),
          tax_rate: defaultTaxRate,
          vat_number: customerDetails.tax_ids?.data[0]?.value || null,
        },
        create: {
          workspace_id: parseInt(workspaceId),
          billing_email: customerDetails.email || '',
          billing_address: [
            customerDetails.address?.line1,
            customerDetails.address?.line2,
            customerDetails.address?.city,
            customerDetails.address?.state,
            customerDetails.address?.postal_code,
            customerDetails.address?.country,
          ].filter(Boolean).join('\n'),
          tax_rate: defaultTaxRate,
          vat_number: customerDetails.tax_ids?.data[0]?.value || null,
        },
      });

      // Update workspace subscription ID
      await tx.workspace.update({
        where: { id: parseInt(workspaceId) },
        data: { subscription_id: sub.id },
      });

      return sub;
    });

    return result;
  } catch (error) {
    return NextResponse.json(
      { 
        received: true, 
        success: false,
        error: 'Webhook processing error'
      },
      { status: 200 }
    );
  }
}

async function handleSubscriptionUpdated(subscription: Stripe.Subscription, prisma_client: PrismaClient) {
  const mappedStatus = mapStripeStatusToDbStatus(subscription.status);
  
  await prisma_client.subscription.update({
    where: {
      stripe_subscription_id: subscription.id,
    },
    data: {
      quantity_seats: subscription.items.data[0].quantity || 1,
      current_period_start: new Date(subscription.current_period_start * 1000),
      current_period_end: new Date(subscription.current_period_end * 1000),
      status: mappedStatus,
      canceled_at: subscription.cancel_at ? new Date(subscription.cancel_at * 1000) : null,
    },
  });
}

async function handleSubscriptionDeleted(subscription: Stripe.Subscription, prisma_client: PrismaClient) {
  await prisma_client.subscription.update({
    where: {
      stripe_subscription_id: subscription.id,
    },
    data: {
      status: 'CANCELED',
      canceled_at: new Date(),
    },
  });
}

async function handleInvoicePaid(invoice: Stripe.Invoice, prisma_client: PrismaClient) {
  if (!invoice.subscription) return;

  const subscription = await prisma_client.subscription.findUnique({
    where: {
      stripe_subscription_id: invoice.subscription as string,
    },
  });

  if (!subscription) return;

  await prisma_client.billing.create({
    data: {
      subscription_id: subscription.id,
      workspace_id: subscription.workspace_id,
      stripe_invoice_id: invoice.id,
      amount_net: invoice.amount_due,
      tax_amount: invoice.tax || 0,
      amount_gross: invoice.total,
      currency: invoice.currency,
      invoice_date: new Date(invoice.created * 1000),
      due_date: new Date(invoice.due_date! * 1000),
      paid_at: invoice.paid ? new Date() : null,
    },
  });
}

async function handleInvoicePaymentFailed(invoice: Stripe.Invoice, prisma_client: PrismaClient) {
  // Remove console.error - implement actual error handling if needed
  // For now just return silently
  return;
}

async function handleCustomerUpdated(customer: Stripe.Customer, prisma_client: PrismaClient) {

  try {
    // Get the full customer details with expanded tax_ids
    const customerDetails = await stripe.customers.retrieve(customer.id, {
      expand: ['tax_ids']
    }) as Stripe.Customer;

    // Find the workspace associated with this customer
    const workspace = await prisma_client.workspace.findFirst({
      where: { stripe_customer_id: customer.id },
    });

    if (!workspace) {
      console.error('No workspace found for Stripe customer:', customer.id);
      return;
    }

    // Format the billing address
    const address: Stripe.Address = customerDetails.address || {
      line1: '',
      line2: null,
      city: '',
      state: '',
      postal_code: '',
      country: ''
    };

    const formattedAddress = [
      address.line1,
      address.line2,
      address.city,
      address.state,
      address.postal_code,
      address.country,
    ].filter(Boolean).join('\n');

    // Update billing information
    return await prisma_client.workspace_billing_infos.upsert({
      where: {
        workspace_id: workspace.id,
      },
      update: {
        billing_email: customerDetails.email || '',
        billing_address: formattedAddress,
        vat_number: customerDetails.tax_ids?.data[0]?.value || null,
      },
      create: {
        workspace_id: workspace.id,
        billing_email: customerDetails.email || '',
        billing_address: formattedAddress,
        tax_rate: 20.00, // Default tax rate
        vat_number: customerDetails.tax_ids?.data[0]?.value || null,
      },
    });
  } catch (error) {
    throw error;
  }
}

export async function POST(req: Request) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const rateLimitResponse = await webhookRateLimiter(req);
    if (rateLimitResponse) {
      return rateLimitResponse;
    }
    
    if (!webhookSecret) {
      throw new Error('STRIPE_WEBHOOK_SECRET is not configured');
    }

    const body = await req.text();
    const headersList = await headers();
    const signature = headersList.get('stripe-signature');

    if (!signature) {
      throw new Error('No stripe signature found');
    }

    let event;
    try {
      event = stripe.webhooks.constructEvent(body, signature, webhookSecret);
    } catch (err) {
      return NextResponse.json(
        { error: 'Webhook signature verification failed' },
        { status: 400 }
      );
    }

    try {
      switch (event.type) {
        case 'customer.subscription.created':
          await handleSubscriptionCreated(event.data.object as Stripe.Subscription, prisma_client);
          break;
        case 'customer.subscription.updated':
          await handleSubscriptionUpdated(event.data.object as Stripe.Subscription, prisma_client);
          break;
        case 'customer.subscription.deleted':
          await handleSubscriptionDeleted(event.data.object as Stripe.Subscription, prisma_client);
          break;
        case 'customer.updated':
          await handleCustomerUpdated(event.data.object as Stripe.Customer, prisma_client);
          break;
        case 'invoice.paid':
          await handleInvoicePaid(event.data.object as Stripe.Invoice, prisma_client);
          break;
        case 'invoice.payment_failed':
          await handleInvoicePaymentFailed(event.data.object as Stripe.Invoice, prisma_client);
          break;
      }

      // Handle the event
      if (event.type === 'customer.subscription.created' || event.type === 'customer.subscription.updated') {
        const subscription = event.data.object as Stripe.Subscription;
        
        // Check if this is an Early Adopter plan
        const earlyAdopterMonthlyPriceId = process.env.NEXT_PUBLIC_STRIPE_EARLY_ADOPTER_MONTHLY_PRICE_ID;
        const earlyAdopterAnnualPriceId = process.env.NEXT_PUBLIC_STRIPE_EARLY_ADOPTER_ANNUAL_PRICE_ID;
        
        const isEarlyAdopterPlan = subscription.items.data.some(item => 
          item.price.id === earlyAdopterMonthlyPriceId || 
          item.price.id === earlyAdopterAnnualPriceId
        );
        
        if (isEarlyAdopterPlan && subscription.status === 'active') {
          // Find the workspace with this subscription
          const workspace = await prisma_client.workspace.findFirst({
            where: { stripe_customer_id: subscription.customer as string },
          });
          
          if (workspace) {
            // Find the active users for this workspace
            const activeUsers = await prisma_client.user.findMany({
              where: { active_workspace_id: workspace.id },
            });
            
            if (activeUsers.length > 0) {
              // Send the subscription activated email to each active user
              for (const user of activeUsers) {
                if (process.env.NODE_ENV !== 'production') {
                  console.log(`Sending subscription activated email to user ${user.id} (${user.email})`);
                }
                
                try {
                  const response = await fetch(`${process.env.NEXT_PUBLIC_APP_URL}/api/email/subscription-activated`, {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                      userId: user.id,
                      workspaceId: workspace.id,
                    }),
                  });
                  
                  if (!response.ok) {
                    console.error(`Failed to send subscription activated email to ${user.email}:`, await response.text());
                  } else if (process.env.NODE_ENV !== 'production') {
                    console.log(`Successfully sent subscription activated email to ${user.email}`);
                  }
                } catch (error) {
                  console.error(`Error sending subscription activated email to ${user.email}:`, error);
                }
              }
            } else if (process.env.NODE_ENV !== 'production') {
              console.log(`No active users found for workspace ${workspace.id}`);
            }
          } else if (process.env.NODE_ENV !== 'production') {
            console.log(`No workspace found for Stripe customer ${subscription.customer}`);
          }
        }
      }
    } catch (processingError) {
      return NextResponse.json({ 
        received: true, 
        success: false, 
        error: 'Error processing webhook event'
      });
    }

    return NextResponse.json({ received: true, success: true });
  } catch (error) {
    return NextResponse.json(
      { 
        received: true, 
        success: false,
        error: 'Webhook processing error'
      },
      { status: 200 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/workflow/[workflow_id]/title/route.ts">
// app/api/workflow/[workflow_id]/title/route.ts
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma'; // Adjust the path to where you initialize Prisma in your project
import { isVercel } from '@/app/api/utils/isVercel';
import { PrismaClient } from '@prisma/client';

/**
 * @swagger
 * /api/workflow/{workflow_id}/title:
 *   get:
 *     summary: Get workflow title
 *     description: Fetches the title of a workflow by its ID.
 *     tags:
 *       - Workflow
 *     parameters:
 *       - in: path
 *         name: workflow_id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the workflow
 *     responses:
 *       200:
 *         description: Successfully retrieved workflow title.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 title:
 *                   type: string
 *                   example: "Project Alpha"
 *       400:
 *         description: Invalid workflow ID.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Invalid workflow ID"
 *       404:
 *         description: Workflow not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Workflow not found"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 *   put:
 *     summary: Update workflow title
 *     description: Updates the title of a workflow by its ID.
 *     tags:
 *       - Workflow
 *     parameters:
 *       - in: path
 *         name: workflow_id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the workflow
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               title:
 *                 type: string
 *                 example: "New Workflow Title"
 *     responses:
 *       200:
 *         description: Successfully updated workflow title.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 title:
 *                   type: string
 *                   example: "New Workflow Title"
 *       400:
 *         description: Invalid workflow ID.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Invalid workflow ID"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 */
export async function GET(req: Request, props: { params: Promise<{ workflow_id: string }> }) {
  const params = await props.params;
  const workflow_id = parseInt(params.workflow_id);

  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }

  if (isNaN(workflow_id)) {
    return NextResponse.json({ error: 'Invalid workflow ID' }, { status: 400 });
  }

  try {
    const workflow = await prisma_client.workflow.findUnique({
      where: {
        id: workflow_id,
      },
      select: {
        name: true,
      },
    });

    if (!workflow) {
      return NextResponse.json(
        { error: 'Workflow not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({ title: workflow.name });
  } catch (error) {
    console.error('Error fetching workflow title:', error);
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}

export async function PUT(req: Request, props: { params: Promise<{ workflow_id: string }> }) {
  const params = await props.params;
  const workflow_id = parseInt(params.workflow_id);
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }

  if (isNaN(workflow_id)) {
    return NextResponse.json({ error: 'Invalid workflow ID' }, { status: 400 });
  }

  try {
    const { title } = await req.json();

    const updatedWorkflow = await prisma_client.workflow.update({
      where: {
        id: workflow_id,
      },
      data: {
        name: title,
      },
    });

    return NextResponse.json({ title: updatedWorkflow.name });
  } catch (error) {
    console.error('Error updating workflow title:', error);
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/workflow/public/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { generatePublicUrl } from '../../utils/generatePublicUrl';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function GET(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { searchParams } = new URL(req.url);
    const public_access_id = searchParams.get('public_access_id');

    if (!public_access_id) {
      return NextResponse.json(
        { error: 'Public access ID is required' },
        { status: 400 }
      );
    }

    const workflow: any = await prisma_client.workflow.findFirst({
      where: {
        public_access_id,
        is_public: true,
      },
      include: {
        workspace: {
          select: {
            id: true,
            name: true,
          },
        },
        folder: {
          select: {
            id: true,
            name: true,
            parent: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        },
        author: {
          select: {
            full_name: true,
            avatar_url: true,
          },
        },
      },
    });

    if (!workflow) {
      return NextResponse.json(
        { error: 'Workflow not found or not public' },
        { status: 404 }
      );
    }
    
    if (
      workflow.author?.avatar_url &&
      !workflow.author.avatar_url.startsWith('http')
    ) {
      try {
        workflow.author.avatar_signed_url = generatePublicUrl(workflow.author.avatar_url);
      } catch (error) {
        console.error('Error generating public URL for author avatar:', error);
      }
    }
    if (workflow.icon && !workflow.icon.startsWith('http')) {
      try {
        workflow.signedIconUrl = generatePublicUrl(workflow.icon);
      } catch (error) {
        console.error('Error generating public URL for icon:', error);
      }
    }
    return NextResponse.json(workflow);
  } catch (error) {
    console.error('Error fetching public workflow:', error);
    return NextResponse.json(
      { error: 'Failed to fetch workflow' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/workflow/updateLastOpened/route.ts">
// app/api/workflow/updateLastOpened/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma'; // Adjust the path to where you initialize Prisma in your project
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

/**
 * @swagger
 * /api/workflow/updateLastOpened:
 *   patch:
 *     summary: Update the last opened timestamp of a workflow
 *     description: Updates the `last_opened` field of a workflow to the current timestamp.
 *     tags:
 *       - Workflow
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               workflowId:
 *                 type: integer
 *                 example: 123
 *     responses:
 *       200:
 *         description: Successfully updated the last opened timestamp.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Last opened updated"
 *                 workflow:
 *                   type: object
 *                   properties:
 *                     id:
 *                       type: integer
 *                       example: 123
 *                     last_opened:
 *                       type: string
 *                       format: date-time
 *                       example: "2025-02-16T12:34:56.789Z"
 *       400:
 *         description: Missing workflow ID.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Missing workflowId"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal server error"
 */
export async function PATCH(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { workflowId } = await req.json();

    if (!workflowId) {
      return NextResponse.json(
        { error: 'Missing workflowId' },
        { status: 400 }
      );
    }

    const updatedWorkflow = await prisma_client.workflow.update({
      where: { id: workflowId },
      data: { last_opened: new Date() },
    });

    return NextResponse.json({
      message: 'Last opened updated',
      workflow: updatedWorkflow,
    });
  } catch (error) {
    console.error('Error updating last_opened:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/workflow/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

/**
 * @swagger
 * /api/workflow:
 *   post:
 *     summary: Create a new workflow
 *     description: Creates a new workflow within a specified workspace.
 *     tags:
 *       - Workflow
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - description
 *               - workspaceId
 *             properties:
 *               name:
 *                 type: string
 *                 example: "New Workflow"
 *               description:
 *                 type: string
 *                 example: "This is a description of the workflow."
 *               workspaceId:
 *                 type: integer
 *                 example: 123
 *     responses:
 *       200:
 *         description: Successfully created a new workflow.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 name:
 *                   type: string
 *                   example: "New Workflow"
 *                 description:
 *                   type: string
 *                   example: "This is a description of the workflow."
 *                 workspaceId:
 *                   type: integer
 *                   example: 123
 *       400:
 *         description: Missing required fields.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Name and description are required"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Failed to create workflow"
 */
export async function POST(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { name, description, workspaceId } = await req.json();

    // Ensure both `name` and `description` are provided
    if (!name || !description) {
      return NextResponse.json(
        { error: 'Name and description are required' },
        { status: 400 }
      );
    }

    // Get workspace with subscription info and workflow count
    const workspace = await prisma_client.workspace.findUnique({
      where: { id: workspaceId },
      include: {
        subscription: true,
        workflows: {
          select: { id: true },
        },
      },
    });

    if (!workspace) {
      return NextResponse.json(
        { error: 'Workspace not found' },
        { status: 404 }
      );
    }

    // Check if workspace is on free plan and has reached the limit
    const isFreePlan = !workspace.subscription || workspace.subscription.plan_type === 'FREE';
    const hasReachedLimit = workspace.workflows.length >= 5;

    if (isFreePlan && hasReachedLimit) {
      return NextResponse.json(
        {
          error: 'Free plan is limited to 5 workflows',
          title: 'Workflow Limit Reached',
          description: 'Your free plan is limited to 5 workflows. Upgrade to create more workflows.',
          status: 403
        },
        { status: 403 }
      );
    }

    // Create a new workflow
    const newWorkflow = await prisma_client.workflow.create({
      data: {
        name,
        description,
        workspace: {
          connect: { id: workspaceId },
        },
      },
    });

    return NextResponse.json(newWorkflow);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to create workflow' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/workflow/utils.ts">
import prisma from '@/lib/prisma';
import crypto from 'crypto';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function generatePublicAccessId(
  workflowName: string,
  workflowId: number,
  workspaceId: number
): Promise<string> {
  const timestamp = Date.now();
  
  // Create a base string combining all elements
  const baseString = `${timestamp}-${workflowName}-${workflowId}-${workspaceId}`;
  
  // Generate a hash of the base string
  const hash = crypto.createHash('sha256').update(baseString).digest('hex');
  
  // Take first 12 characters of the hash and combine with a readable prefix
  const publicId = `${hash.substring(0, 12)}`;
  
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Check if this ID already exists
    const existingWorkflow = await prisma_client.workflow.findFirst({
      where: {
        public_access_id: publicId,
      },
    });

    if (existingWorkflow) {
      // If ID exists, recursively try again
      return generatePublicAccessId(workflowName, workflowId, workspaceId);
    }
    return publicId;
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/workspace/[id]/access/route.ts">
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { NextRequest } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function GET(
  request: NextRequest,
  props: { params: Promise<{ id: string }> } // Handle params as a Promise
) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const params = await props.params; // Await the params
    const workspaceId = parseInt(params.id); // Convert to number

    const { searchParams } = new URL(request.url);
    const authId = searchParams.get('userId'); // This is actually the auth_id
   

    if (!authId) {
      return new NextResponse(null, { status: 400 });
    }

    // First, find the user by auth_id
    const user = await prisma_client.user.findUnique({
      where: {
        auth_id: authId,
      },
    });

    if (!user) {
     
      return new NextResponse(null, { status: 404 });
    }

    // Then check workspace access using the user's id
    const userWorkspace = await prisma_client.user_workspace.findFirst({
      where: {
        workspace_id: workspaceId,
        user_id: user.id, // Using the actual user id here
      },
      include: {
        user: true,
      },
    });

    if (!userWorkspace) {
    
      return new NextResponse(null, { status: 403 });
    }

  
    return NextResponse.json(userWorkspace);
  } catch (error) {
    console.error('Error checking workspace access:', error);
    return new NextResponse(null, { status: 500 });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/workspace/[id]/blocks/route.ts">
// app/api/workspace/[id]/blocks/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient, Prisma } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

/**
 * @swagger
 * /api/workspace/{id}/blocks:
 *   get:
 *     summary: Retrieve paths and blocks for a given workflow in a workspace
 *     description: Fetches all paths and their associated blocks for a given workflow in a workspace. If no paths exist, it creates a default path.
 *     tags:
 *       - Workspace
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the workspace
 *       - in: query
 *         name: workflow_id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the workflow
 *     responses:
 *       200:
 *         description: Successfully retrieved paths and blocks
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 paths:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         example: 1
 *                       name:
 *                         type: string
 *                         example: "First Path"
 *                       workflow_id:
 *                         type: integer
 *                         example: 123
 *                       blocks:
 *                         type: array
 *                         items:
 *                           type: object
 *                           properties:
 *                             id:
 *                               type: integer
 *                               example: 10
 *                             position:
 *                               type: integer
 *                               example: 1
 *                             path_block:
 *                               type: object
 *                               nullable: true
 *                               properties:
 *                                 id:
 *                                   type: integer
 *                                   example: 5
 *                                 paths:
 *                                   type: array
 *                                   items:
 *                                     type: object
 *                                     properties:
 *                                       id:
 *                                         type: integer
 *                                         example: 20
 *                                       name:
 *                                         type: string
 *                                         example: "Nested Path"
 *                             step_block:
 *                               type: object
 *                               nullable: true
 *                               properties:
 *                                 id:
 *                                   type: integer
 *                                   example: 15
 *                                 step_data:
 *                                   type: string
 *                                   example: "Step details"
 *       400:
 *         description: Missing or invalid workflow_id or workspaceId
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "workflow_id and valid workspaceId are required"
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Failed to fetch or create paths and blocks"
 */
export async function GET(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  const params = await props.params;
  const url = new URL(req.url);
  const workflow_id = url.searchParams.get('workflow_id');
  const workspaceId = parseInt(params.id);
    const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }

  // Validate workflow_id and workspaceId
  if (!workflow_id || isNaN(workspaceId)) {
    return NextResponse.json(
      { error: 'workflow_id and valid workspaceId are required' },
      { status: 400 }
    );
  }

  try {
    // Convert workflow_id to a number for further processing
    const parsedworkflow_id = parseInt(workflow_id);

    if (isNaN(parsedworkflow_id)) {
      return NextResponse.json(
        { error: 'Invalid workflow_id' },
        { status: 400 }
      );
    }

    // Log the request data
   

    // Fetch or create paths with blocks for the given workflow_id
    const result = await prisma_client.$transaction(
      async (prisma: Prisma.TransactionClient) => {
        // Fetch paths for the given workflow_id
        const existingPaths = await prisma.path.findMany({
          where: {
            workflow_id: parsedworkflow_id,
          },
          include: {
            blocks: {
              orderBy: {
                position: 'asc',
              },
              include: {
                child_paths: {
                  include: {
                    path: {
                      include: {
                        blocks: {
                          orderBy: {
                            position: 'asc',
                          },
                          include: {
                            child_paths: {
                              include: {
                                path: {
                                  include: {
                                    blocks: {
                                      orderBy: {
                                        position: 'asc',
                                      },
                                      include: {
                                        child_paths: {
                                          include: {
                                            path: {
                                              include: {
                                                blocks: {
                                                  include: {
                                                    child_paths: true
                                                  },
                                                },
                                              },
                                            },
                                          },
                                        },
                                      },
                                    },
                                  },
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
        });

        // If no paths are found, create a new Path without linking to a path_block
        if (existingPaths.length === 0) {
          const newPath = await prisma.path.create({
            data: {
              name: 'First Path',
              workflow_id: parsedworkflow_id,
            },
            include: {
              blocks: {
                include: {
                  child_paths: {
                    include: {
                      path: true
                    }
                  }
                },
              },
            },
          });

          return { paths: [newPath] };
        }

        // Return existing paths
        return { paths: existingPaths };
      }
    );

    return NextResponse.json(result);
  } catch (error) {
    console.error('Error fetching or creating paths and blocks:', error);
    return NextResponse.json(
      { error: 'Failed to fetch or create paths and blocks' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/workspace/[id]/paths/[path_id]/route.ts">
// app/api/workspace/[id]/paths/[path_id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma'; // Adjust the import path according to your setup
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

/**
 * @swagger
 * /api/workspace/{id}/paths/{path_id}:
 *   get:
 *     summary: Retrieve a specific path and its blocks within a workspace
 *     description: Fetches details of a specific path, including its blocks, path_block, step_block, and delay_block, filtered by workflow_id.
 *     tags:
 *       - Workspace
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the workspace
 *       - in: path
 *         name: path_id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the path
 *       - in: query
 *         name: workflow_id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the workflow to filter the blocks
 *     responses:
 *       200:
 *         description: Successfully retrieved path data
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 name:
 *                   type: string
 *                   example: "Sample Path"
 *                 blocks:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         example: 10
 *                       position:
 *                         type: integer
 *                         example: 1
 *                       path_block:
 *                         type: object
 *                         nullable: true
 *                         properties:
 *                           id:
 *                             type: integer
 *                             example: 5
 *                       step_block:
 *                         type: object
 *                         nullable: true
 *                         properties:
 *                           id:
 *                             type: integer
 *                             example: 15
 *                           step_data:
 *                             type: string
 *                             example: "Step details"
 *                       delay_block:
 *                         type: object
 *                         nullable: true
 *                         properties:
 *                           id:
 *                             type: integer
 *                             example: 20
 *                           delay_time:
 *                             type: integer
 *                             example: 300
 *       400:
 *         description: Missing or invalid workspaceId, path_id, or workflow_id
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Valid workspaceId, path_id, and workflow_id are required"
 *       404:
 *         description: Path not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Path not found"
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 */
export async function GET(
  req: NextRequest,
  props: { params: Promise<{ id: string; path_id: string }> }
) {
  const params = await props.params;
  const url = new URL(req.url);
  const workflow_id = url.searchParams.get('workflow_id');
  const workspaceId = parseInt(params.id);
  const path_id = parseInt(params.path_id);
  const prisma_client = isVercel() ? new PrismaClient() : prisma;

  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }

  // Validate inputs
  if (!workflow_id || isNaN(workspaceId) || isNaN(path_id)) {
    return NextResponse.json(
      { error: 'workflow_id, valid workspaceId and path_id are required' },
      { status: 400 }
    );
  }

  try {
    const parsedworkflow_id = parseInt(workflow_id);

    if (isNaN(parsedworkflow_id)) {
      return NextResponse.json(
        { error: 'Invalid workflow_id' },
        { status: 400 }
      );
    }

    // Fetch blocks for the workflow
    const blocks = await prisma_client.block.findMany({
      where: { workflow_id: parsedworkflow_id },
      include: {
        child_paths: {
          include: {
            path: true
          }
        }
      },
    });

    return NextResponse.json(blocks);
  } catch (error) {
    console.error('Error fetching blocks:', error);
    return NextResponse.json(
      { error: 'Failed to fetch blocks' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/workspace/[id]/workflows/[workflowId]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

/**
 * @swagger
 * /api/workspace/{id}/workflows/{workflowId}:
 *   get:
 *     summary: Retrieve a specific workflow
 *     description: Fetches a single workflow by its ID within a specific workspace
 *     tags:
 *       - Workspace
 *       - Workflow
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the workspace
 *       - in: path
 *         name: workflowId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the workflow
 *     responses:
 *       200:
 *         description: Successfully retrieved the workflow
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 name:
 *                   type: string
 *                   example: "My Workflow"
 *                 description:
 *                   type: string
 *                   example: "A detailed workflow description"
 *                 workspace_id:
 *                   type: integer
 *                   example: 1
 *                 created_at:
 *                   type: string
 *                   format: date-time
 *                   example: "2024-03-20T12:00:00Z"
 *                 updated_at:
 *                   type: string
 *                   format: date-time
 *                   example: "2024-03-20T12:00:00Z"
 *       400:
 *         description: Invalid workspace ID or workflow ID
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Invalid workspace ID or workflow ID"
 *       404:
 *         description: Workflow not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Workflow not found"
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal server error"
 */
export async function GET(
  req: NextRequest,
  props: { params: Promise<{ id: string; workflowId: string }> }
) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const params = await props.params;
    const workspace_id = parseInt(params.id);
    const workflow_id = parseInt(params.workflowId);

    if (isNaN(workspace_id) || isNaN(workflow_id)) {
      return NextResponse.json(
        { error: 'Invalid workspace ID or workflow ID' },
        { status: 400 }
      );
    }

    const workflow = await prisma_client.workflow.findFirst({
      where: {
        id: workflow_id,
        workspace_id: workspace_id,
      },
      include: {
        workspace: true,
        folder: {
          include: {
            parent: true
          }
        }
      }
    });

    if (!workflow) {
      return NextResponse.json(
        { error: 'Workflow not found' },
        { status: 404 }
      );
    }

    return NextResponse.json(workflow);
  } catch (error) {
    console.error('Error fetching workflow:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/workspace/[id]/workflows/route.ts">
// app/api/workspace/[id]/workflows/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

/**
 * @swagger
 * /api/workspace/{id}/workflows:
 *   get:
 *     summary: Retrieve all workflows for a specific workspace
 *     description: Fetches all workflows associated with the specified workspace by its `id`.
 *     tags:
 *       - Workspace
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the workspace
 *     responses:
 *       200:
 *         description: Successfully retrieved workflows
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   name:
 *                     type: string
 *                     example: "Workflow Name"
 *                   description:
 *                     type: string
 *                     example: "This is a description of the workflow"
 *                   workspace_id:
 *                     type: integer
 *                     example: 1
 *       400:
 *         description: Invalid workspace ID
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Invalid workspace ID"
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Failed to retrieve workflows"
 */
export async function GET(req: NextRequest, props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  const workspace_id = parseInt(params.id);
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const workflows = await prisma_client.workflow.findMany({
      where: {
        workspace_id,
      },
    });
    return NextResponse.json(workflows);
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/workspace/check-slug/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function GET(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { searchParams } = new URL(req.url);
    const slug = searchParams.get('slug');

    if (!slug) {
      return NextResponse.json(
        { error: 'Slug parameter is required' },
        { status: 400 }
      );
    }

    // Check if a workspace with this slug exists
    const existingWorkspace = await prisma_client.workspace.findFirst({
      where: { slug },
    });

    return NextResponse.json({
      available: !existingWorkspace,
      message: existingWorkspace 
        ? 'This workspace URL is already taken' 
        : 'This workspace URL is available'
    });
  } catch (error) {
    console.error('Error checking workspace slug:', error);
    return NextResponse.json(
      { error: 'Failed to check workspace slug availability' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/workspace/create/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/utils/supabase/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { checkWorkspaceName } from '@/app/utils/checkNames';

export async function POST(request: NextRequest) {
  const supabase = await createClient();
  
  // Check authentication
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  
  if (authError || !user) {
    return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
  }

  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }

  try {
    // Check if the request is multipart/form-data or JSON
    const contentType = request.headers.get('content-type');
    
    let formData: any;

    if (contentType?.includes('multipart/form-data')) {
      // Process as multipart/form-data (with file)
      const requestFormData = await request.formData();
      
      // Get the JSON data
      const dataString = requestFormData.get('data') as string;
      formData = JSON.parse(dataString);
      
      // Process the logo file if present
      const logoFile = requestFormData.get('logo') as File;
      
      if (logoFile) {
        // Upload the logo to Supabase Storage
        const fileName = `workspace-logo-${user.id}-${Date.now()}`;
        const { data: uploadData, error: uploadError } = await supabase.storage
          .from('user-assets')
          .upload(`workspaces_logo/${fileName}`, logoFile, {
            cacheControl: '3600',
            upsert: false
          });
        
        if (uploadError) {
          console.error('Error uploading logo:', uploadError);
          throw new Error('Failed to upload logo');
        }
        
        // Get the public URL of the logo
        const { data: { publicUrl } } = supabase.storage
          .from('user-assets')
          .getPublicUrl(`workspaces_logo/${fileName}`);
        
        // Add the logo URL to the workspace data
        formData.icon_url = publicUrl;
      }
    } else {
      // Process as JSON (without file)
      formData = await request.json();
    }

    // Get the user from the database
    const dbUser = await prisma_client.user.findUnique({
      where: { auth_id: user.id },
    });

    if (!dbUser) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Validate required fields
    if (!formData.name) {
      return NextResponse.json({ error: 'Workspace name is required' }, { status: 400 });
    }
    
    const nameError = checkWorkspaceName(formData.name);
    if (nameError) {
      return NextResponse.json({ 
        error: 'Invalid workspace name',
        ...nameError 
      }, { status: 400 });
    }

    // Create a workspace
    const workspace = await prisma_client.workspace.create({
      data: {
        name: formData.name,
        slug: formData.slug || generateSlug(formData.name),
        icon_url: formData.icon_url || null,
        industry: formData.industry || null,
        company_size: formData.company_size || null,
        // Create a relationship with the user
        user_workspaces: {
          create: {
            user_id: dbUser.id,
            role: 'ADMIN'
          }
        }
      }
    });
    
    // Return the created workspace in a format the frontend expects
    return NextResponse.json({ workspace });
  } catch (error) {
    console.error('Error processing request:', error);
    return NextResponse.json({ 
      error: error instanceof Error ? error.message : 'Internal server error' 
    }, { status: 500 });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}

// Helper function to generate a slug
function generateSlug(name: string): string {
  return name
    .toLowerCase()
    .replace(/\s+/g, '-')       // Replace spaces with hyphens
    .replace(/[^a-z0-9-]/g, '') // Remove any non-alphanumeric characters
    .replace(/-+/g, '-')        // Replace multiple hyphens with a single one
    .replace(/^-|-$/g, '');     // Remove leading/trailing hyphens
}
</file>

<file path="app/api/workspace/folders/update-position/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

/**
 * @swagger
 * /api/workspace/folders/update-position:
 *   post:
 *     summary: Update folder position and/or parent
 *     description: Updates a folder's position and/or changes its parent
 *     tags:
 *       - Workspace
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               folderId:
 *                 type: integer
 *                 example: 1
 *               newParentId:
 *                 type: integer
 *                 example: 2
 *               newPosition:
 *                 type: integer
 *                 example: 3
 *     responses:
 *       200:
 *         description: Folder position updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Folder position updated successfully"
 *                 folder:
 *                   type: object
 *       404:
 *         description: Folder not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Folder not found"
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal server error"
 */
export async function POST(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { folderId, newParentId, newPosition } = await req.json();

    if (!folderId) {
      return NextResponse.json(
        { error: 'Folder ID is required' },
        { status: 400 }
      );
    }

    // Check if folder exists
    const folder = await prisma_client.folder.findUnique({
      where: { id: Number(folderId) },
    });

    if (!folder) {
      return NextResponse.json({ error: 'Folder not found' }, { status: 404 });
    }

    // Get the workspace ID from the folder
    const workspaceId = folder.workspace_id;

    // Get all folders in the same group (same parent) to reorder them
    const isFolderMovingToNewParent = folder.parent_id !== newParentId;
    
    // Find siblings of the target position (folders with the same parent)
    const siblingFolders = await prisma_client.folder.findMany({
      where: {
        workspace_id: workspaceId,
        parent_id: newParentId === undefined ? folder.parent_id : newParentId,
        id: { not: Number(folderId) }, // Exclude the folder being moved
      },
      orderBy: { position: 'asc' },
    });
    
    // Update all positions in a transaction to ensure consistency
    const updatedFolder = await prisma_client.$transaction(async (tx) => {
      // If folder is moving to a new parent, just update its parent and position
      if (isFolderMovingToNewParent) {
        // If moving to a new parent, shift all siblings in the new parent whose position
        // is greater than or equal to the new position
        if (newParentId !== null) {
          await tx.folder.updateMany({
            where: {
              workspace_id: workspaceId,
              parent_id: newParentId,
              position: { gte: newPosition },
            },
            data: {
              position: { increment: 1 },
            },
          });
        }

        // Update the moved folder's parent and position
        return await tx.folder.update({
          where: { id: Number(folderId) },
          data: {
            parent_id: newParentId === null ? null : Number(newParentId),
            position: newPosition !== undefined ? Number(newPosition) : 0,
          },
        });
      } else {
        // If folder is staying in the same parent but changing position
        const oldPosition = folder.position;
        const targetPosition = Number(newPosition);

        // Reorder siblings based on whether we're moving up or down
        if (targetPosition < oldPosition) {
          // Moving up: Increment positions of folders between target and old position
          await tx.folder.updateMany({
            where: {
              workspace_id: workspaceId,
              parent_id: folder.parent_id,
              id: { not: Number(folderId) },
              position: { gte: targetPosition, lt: oldPosition },
            },
            data: {
              position: { increment: 1 },
            },
          });
        } else if (targetPosition > oldPosition) {
          // Moving down: Decrement positions of folders between old and target position
          await tx.folder.updateMany({
            where: {
              workspace_id: workspaceId,
              parent_id: folder.parent_id,
              id: { not: Number(folderId) },
              position: { gt: oldPosition, lte: targetPosition },
            },
            data: {
              position: { decrement: 1 },
            },
          });
        } else {
          // Position didn't change, do nothing
          return folder;
        }

        // Update the moved folder's position
        return await tx.folder.update({
          where: { id: Number(folderId) },
          data: {
            position: targetPosition,
          },
        });
      }
    });

    return NextResponse.json({
      message: 'Folder position updated successfully',
      folder: updatedFolder,
    }, { status: 200 });
  } catch (error) {
    console.error('Error updating folder position:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/workspace/folders/route.ts">
// app/api/workspace/folders/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { checkFolderName } from '@/app/utils/checkNames';

/**
 * @swagger
 * /api/workspace/folders:
 *   post:
 *     summary: Create a new folder
 *     description: Creates a new folder within a workspace. The folder will be created at the top-level (no parent).
 *     tags:
 *       - Workspace
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 example: "New Folder"
 *               workspace_id:
 *                 type: integer
 *                 example: 1
 *               icon_url:
 *                 type: string
 *                 example: "/path/to/icon.svg"
 *               emote:
 *                 type: string
 *                 example: ":smile:"
 *     responses:
 *       201:
 *         description: Folder created successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 name:
 *                   type: string
 *                   example: "New Folder"
 *                 workspace_id:
 *                   type: integer
 *                   example: 1
 *                 icon_url:
 *                   type: string
 *                   example: "/path/to/icon.svg"
 *                 emote:
 *                   type: string
 *                   example: ":smile:"
 *                 parent_id:
 *                   type: integer
 *                   example: null
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Failed to add folder"
 */
export async function POST(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { name, workspace_id, icon_url, emote, position } = await req.json();

    // Validate folder name
    const nameError = checkFolderName(name);
    if (nameError) {
      return NextResponse.json({ 
        error: 'Invalid folder name',
        ...nameError 
      }, { status: 400 });
    }

    // Create a new folder with no parent (top-level)
    const newFolder = await prisma_client.folder.create({
      data: {
        name,
        workspace_id: Number(workspace_id),
        icon_url: icon_url,
        emote: emote,
        parent_id: null,
        position: position ? Number(position) : 0,
      },
    });

    return NextResponse.json(newFolder, { status: 201 });
  } catch (error) {
    console.error('Error adding folder:', error);
    return NextResponse.json(
      { error: 'Failed to add folder' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/workspace/subfolders/route.ts">
// app/api/workspace/subfolders/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

/**
 * @swagger
 * /api/workspace/subfolders:
 *   post:
 *     summary: Create a new subfolder within a workspace
 *     description: Creates a new subfolder within a workspace, optionally inside a parent folder.
 *     tags:
 *       - Workspace
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 example: "New Subfolder"
 *               workspace_id:
 *                 type: integer
 *                 example: 1
 *               parent_id:
 *                 type: integer
 *                 example: 2
 *               icon_url:
 *                 type: string
 *                 example: "https://example.com/icon.png"
 *               emote:
 *                 type: string
 *                 example: ""
 *     responses:
 *       201:
 *         description: Subfolder created successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 name:
 *                   type: string
 *                   example: "New Subfolder"
 *                 workspace_id:
 *                   type: integer
 *                   example: 1
 *                 parent_id:
 *                   type: integer
 *                   example: 2
 *                 icon_url:
 *                   type: string
 *                   example: "https://example.com/icon.png"
 *                 emote:
 *                   type: string
 *                   example: ""
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Failed to add subfolder"
 */
export async function POST(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { name, workspace_id, parent_id, icon_url, emote, position } =
      await req.json();

    // Create a new subfolder with the specified parent folder
    const newSubfolder = await prisma_client.folder.create({
      data: {
        name,
        workspace_id: Number(workspace_id),
        icon_url: icon_url,
        emote: emote,
        parent_id: parent_id ? Number(parent_id) : null,
        position: position ? Number(position) : 0,
      },
    });

    return NextResponse.json(newSubfolder, { status: 201 });
  } catch (error) {
    console.error('Error adding subfolder:', error);
    return NextResponse.json(
      { error: 'Failed to add subfolder' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/checkout/cancel/page.tsx">
import { redirect } from 'next/navigation';
import { headers } from 'next/headers';

// Mark as dynamic to ensure it's not cached
export const dynamic = 'force-dynamic';

interface SearchParams {
  workspace?: string;
}

interface PageProps {
  searchParams: Promise<SearchParams>;
}

export default async function CheckoutCancelPage(props: PageProps) {
  // Await searchParams before using in Next.js 15
  const searchParams = await props.searchParams;
  
  // Get the workspace ID from the resolved params
  const workspaceId = searchParams.workspace;

  if (!workspaceId) {
    console.error('No workspace ID provided');
    throw redirect('/');
  }

  // Redirect to the dashboard with cancelled parameter
  throw redirect(`/&checkout=cancelled`);
}
</file>

<file path="app/checkout/success/layout.tsx">
import React from 'react';

// Special layout for checkout success page that disables PostHog
// This prevents the "Cannot redefine property: adoptedStyleSheets" error
export default function CheckoutSuccessLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <>
      {/* Render children directly without PostHog wrapper */}
      {children}
    </>
  );
}
</file>

<file path="app/components/Avatar.tsx">
import React from 'react';

interface AvatarProps {
  url: string;
  index: number; // Index will determine the position of each avatar
}

const Avatar: React.FC<AvatarProps> = ({ url, index }) => {
  return (
    <div
      className="w-6 h-6 rounded-full border border-white justify-center items-center flex absolute"
      style={{ left: `${index * 17}px` }} // Reduce the overlap to 2px for less overlap
    >
      <div className="w-6 h-6 relative rounded-full border border-black/10">
        <img
          src={url}
          alt={`Avatar ${index}`}
          className="w-full h-full rounded-full"
        />
      </div>
    </div>
  );
};

export default Avatar;
</file>

<file path="app/components/AvatarGroup.tsx">
import React from 'react';
import Avatar from './Avatar';

interface AvatarGroupProps {
  urls: string[];
}

const AvatarGroup: React.FC<AvatarGroupProps> = ({ urls }) => {
  return (
    <div className="relative w-20 h-6 flex items-center justify-start gap-1.5">
      {urls.map((url, index) => (
        <Avatar key={index} url={url} index={index} />
      ))}
    </div>
  );
};

export default AvatarGroup;
</file>

<file path="app/components/BreadcrumbButtonBase.tsx">
import React from 'react';

interface BreadcrumbButtonBaseProps {
  text: string;
  bgColor?: string;
  textColor?: string;
  fontWeight?: string;
}

const BreadcrumbButtonBase: React.FC<BreadcrumbButtonBaseProps> = ({
  text,
  bgColor = '#edf0fb',
  textColor = '#374c99',
  fontWeight = 'font-semibold',
}) => {
  return (
    <div
      className={`px-2 py-1 rounded-md justify-center items-center flex`}
      style={{ backgroundColor: bgColor }}
    >
      <div
        className={`text-sm leading-tight font-['Inter'] ${fontWeight}`}
        style={{ color: textColor }}
      >
        {text}
      </div>
    </div>
  );
};

export default BreadcrumbButtonBase;
</file>

<file path="app/components/Breadcrumbs.tsx">
import React, { useEffect, useState } from 'react';
import BreadcrumbButtonBase from './BreadcrumbButtonBase';
import { supabasePublicClient } from '@/lib/supabasePublicClient';

interface BreadcrumbsProps {
  first_text: string;
  second_text: string;
  onSecondTextClick?: () => void;
}

const Breadcrumbs: React.FC<BreadcrumbsProps> = ({
  first_text,
  second_text,
  onSecondTextClick,
}) => {
  const [dividerUrl, setDividerUrl] = useState<string | null>(null);

  useEffect(() => {
    const fetchDividerUrl = async () => {
      const { data } = supabasePublicClient.storage
        .from('public-assets')
        .getPublicUrl('assets/shared_components/slash-divider.svg');
      setDividerUrl(data?.publicUrl || null);
    };

    fetchDividerUrl();
  }, []);

  return (
    <div className="h-7 justify-start items-center inline-flex">
      <div className="justify-start items-center gap-2 flex">
        {/* First Breadcrumb */}
        <BreadcrumbButtonBase
          text={first_text}
          bgColor="transparent"
          textColor="#475467"
          fontWeight="font-medium"
        />
        {/* Divider */}
        {dividerUrl && (
          <img src={dividerUrl} alt="Divider" className="w-5 h-5" />
        )}
        {/* Ellipsis */}
        <BreadcrumbButtonBase
          text="..."
          bgColor="transparent"
          textColor="#475467"
          fontWeight="font-medium"
        />
        {/* Divider */}
        {dividerUrl && (
          <img src={dividerUrl} alt="Divider" className="w-5 h-5" />
        )}
        {/* Second Breadcrumb */}
        <div onClick={onSecondTextClick} className="cursor-pointer">
          <BreadcrumbButtonBase
            text={second_text}
            bgColor="#edf0fb"
            textColor="#374c99"
            fontWeight="font-semibold"
          />
        </div>
      </div>
    </div>
  );
};

export default Breadcrumbs;
</file>

<file path="app/components/ButtonDestructive.tsx">
'use client';

import { ButtonHTMLAttributes } from 'react';
import { cn } from '@/lib/utils/cn';
import DynamicIcon from '../../utils/DynamicIcon';
import { useTheme } from '@/app/theme/hooks';
import { ButtonTokens } from '@/app/theme/types';
import React from 'react';

interface ButtonDestructiveProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'tertiary' | 'link';
  isLoading?: boolean;
  size?: 'small' | 'medium' | 'large';
  leadingIcon?: string;
  trailingIcon?: string;
  iconOnly?: boolean;
  iconColor?: string;
}

const ButtonDestructive: React.FC<ButtonDestructiveProps> = ({
  variant = 'primary',
  isLoading = false,
  size = 'medium',
  className,
  children,
  leadingIcon,
  trailingIcon,
  iconColor = 'currentColor',
  iconOnly = false,
  ...props
}) => {
  const { getCssVariable } = useTheme();
  
  const baseStyles = variant === 'link' 
      ? 'flex items-center'
      : 'font-semibold rounded-lg flex items-center justify-center';
  const disabledStyles = 'opacity-50 saturate-50 cursor-not-allowed hover:bg-transparent hover:text-inherit hover:border-inherit';
  const linkStyles = 'font-normal transition-all self-stretch';

  const sizeStyles = {
    small: iconOnly ? 'p-2 w-8 h-8 flex items-center justify-center' : variant === 'link' ? 'text-sm font-normal gap-1' : 'px-3 py-2 text-sm gap-1 font-normal rounded-md',
    medium: iconOnly ? 'p-2.5 w-10 h-10 flex items-center justify-center' : variant === 'link' ? 'text-base font-medium gap-1' : 'px-3.5 py-2.5 text-base gap-1 font-medium rounded-md',
    large: iconOnly ? 'p-3 w-12 h-12 flex items-center justify-center' : variant === 'link' ? 'text-lg font-semibold gap-2' : 'px-4 py-2.5 text-lg gap-2 font-semibold rounded-md',
  };

  const getButtonToken = (variant: string, type: 'bg' | 'fg' | 'border', state: 'normal' | 'hover' = 'normal'): keyof ButtonTokens => {
    const suffix = state === 'hover' ? '-hover' : '';
    return `button-destructive-${variant}-${type}${suffix}` as keyof ButtonTokens;
  };

  const getVariantStyles = () => {
    const variantMap = {
      'primary': 'primary',
      'secondary': 'secondary',
      'tertiary': 'tertiary',
      'link': 'tertiary'
    } as const;

    const mappedVariant = variantMap[variant];
    const buttonId = `btn-destructive-${variant}`;

    // Special handling for link variants
    if (variant === 'link') {
      return {
        id: buttonId,
        style: {
          backgroundColor: 'transparent',
          color: getCssVariable(getButtonToken('tertiary', 'fg')),
          borderWidth: '0',
          padding: '0',
        },
        hoverStyle: `
          #${buttonId}:not(:disabled):hover {
            color: ${getCssVariable(getButtonToken('tertiary', 'fg', 'hover'))} !important;
            background-color: transparent !important;
          }
        `
      };
    }

    const normalBg = getCssVariable(getButtonToken(mappedVariant, 'bg'));
    const normalColor = getCssVariable(getButtonToken(mappedVariant, 'fg'));
    const normalBorder = getCssVariable(getButtonToken(mappedVariant, 'border'));
    const hoverBg = getCssVariable(getButtonToken(mappedVariant, 'bg', 'hover'));
    const hoverColor = getCssVariable(getButtonToken(mappedVariant, 'fg', 'hover'));
    const hoverBorder = getCssVariable(getButtonToken(mappedVariant, 'border', 'hover'));

    return {
      id: buttonId,
      style: {
        backgroundColor: normalBg,
        color: normalColor,
        borderColor: normalBorder,
        borderWidth: mappedVariant !== 'tertiary' ? '1px' : '0',
      },
      hoverStyle: `
        #${buttonId}:not(:disabled):hover {
          background-color: ${hoverBg} !important;
          color: ${hoverColor} !important;
          border-color: ${hoverBorder} !important;
        }
      `
    };
  };

  const { id, style, hoverStyle } = getVariantStyles();

  // Map button variants to icon variants
  const getIconVariant = () => {
    // Since we're using currentColor, we can use 'default' for most cases
    // This allows the icon to inherit the button's text color properly
    const variantMap: Record<string, 'default' | 'primary' | 'secondary' | 'tertiary' | 'tertiary-color' | 'success' | 'warning' | 'error' | 'info'> = {
      'primary': 'default',
      'secondary': 'default', 
      'tertiary': 'default',
      'link': 'default',
    };
    return variantMap[variant] || 'default';
  };
  
  const iconVariant = getIconVariant();

  // Add hover state tracking
  const [isHovered, setIsHovered] = React.useState(false);

  // Determine icon color based on variant
  const getIconDisplayColor = () => {
    // If a custom iconColor is provided and it's not 'currentColor', use it
    if (iconColor !== 'currentColor') {
      return iconColor;
    }
    // For all variants, use 'currentColor' to inherit the button's text color
    return 'currentColor';
  };

  // Add transition override to button style
  const buttonStyle = {
    ...style,
    transition: 'none !important',
  };

  return (
    <>
      <style>{hoverStyle}</style>
      <button
        id={id}
        onMouseDown={(e) => e.preventDefault()}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
        className={cn(
          baseStyles,
          variant === 'link' ? linkStyles : sizeStyles[size],
          className,
          (isLoading || props.disabled) && disabledStyles,
          'transform transition-all duration-200 ease-in-out hover:scale-[0.98] active:scale-[0.96]'
        )}
        style={buttonStyle}
        disabled={isLoading || props.disabled}
        {...props}
      >
        {isLoading ? (
          <div className="flex items-center gap-2">
            <svg
              className="animate-spin h-4 w-4"
              style={{ color: getCssVariable('button-loading-spinner') }}
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
            >
              <circle
                className="opacity-25"
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                strokeWidth="4"
              />
              <path
                className="opacity-75"
                fill="currentColor"
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
              />
            </svg>
            {!iconOnly && <span>Loading...</span>}
          </div>
        ) : (
          <>
            {leadingIcon && !iconOnly && (
              <DynamicIcon 
                url={leadingIcon} 
                color={getIconDisplayColor()} 
                variant={iconVariant}
                size={20}
                isHovered={isHovered}
              />
            )}
            {!iconOnly && <span>{children}</span>}
            {trailingIcon && !iconOnly && (
              <DynamicIcon 
                url={trailingIcon} 
                color={getIconDisplayColor()} 
                variant={iconVariant}
                size={20}
                isHovered={isHovered}
              />
            )}
            {iconOnly && leadingIcon && (
              <DynamicIcon 
                url={leadingIcon} 
                color={getIconDisplayColor()} 
                variant={iconVariant}
                size={size === 'small' ? 16 : size === 'medium' ? 20 : 24}
                isHovered={isHovered}
                className="flex-shrink-0"
              />
            )}
          </>
        )}
      </button>
    </>
  );
};

export default ButtonDestructive;
</file>

<file path="app/components/ButtonNormal.tsx">
'use client';

import { ButtonHTMLAttributes } from 'react';
import { cn } from '@/lib/utils/cn';
import DynamicIcon from '../../utils/DynamicIcon';
import { useTheme } from '@/app/theme/hooks';
import { ButtonTokens } from '@/app/theme/types';
import React from 'react';

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'secondary-color' | 'tertiary' | 'tertiary-color' | 'link' | 'link-color';
  isLoading?: boolean;
  loadingText?: string;
  size?: 'small' | 'medium' | 'large';
  leadingIcon?: string;
  trailingIcon?: string;
  iconOnly?: boolean;
  iconColor?: string;
}

const ButtonNormal: React.FC<ButtonProps> = ({
  variant = 'primary',
  isLoading = false,
  loadingText = 'Loading...',
  size = 'medium',
  className,
  children,
  leadingIcon,
  trailingIcon,
  iconColor = 'currentColor',
  iconOnly = false,
  ...props
}) => {
  const { getCssVariable } = useTheme();
  
  const baseStyles = variant.startsWith('link') 
      ? 'flex items-center'
      : 'font-semibold rounded-lg flex items-center justify-center';
  const disabledStyles = 'opacity-50 saturate-50 cursor-not-allowed hover:bg-transparent hover:text-inherit hover:border-inherit';
  const linkStyles = 'font-normal';

  const sizeStyles = {
    small: iconOnly ? 'p-2 w-8 h-8 flex items-center justify-center' : variant.startsWith('link') ? 'text-sm font-normal gap-1' : 'px-3 py-2 text-sm gap-1 font-normal rounded-md',
    medium: iconOnly ? 'p-2.5 w-10 h-10 flex items-center justify-center' : variant.startsWith('link') ? 'text-base font-medium gap-1' : 'px-3.5 py-2.5 text-base gap-1 font-medium rounded-md',
    large: iconOnly ? 'p-3 w-12 h-12 flex items-center justify-center' : variant.startsWith('link') ? 'text-lg font-semibold gap-2' : 'px-4 py-2.5 text-lg gap-2 font-semibold rounded-md',
  };

  const getButtonToken = (variant: string, type: 'bg' | 'fg' | 'border', state: 'normal' | 'hover' = 'normal'): keyof ButtonTokens => {
    const suffix = state === 'hover' ? '-hover' : '';
    return `button-${variant}-${type}${suffix}` as keyof ButtonTokens;
  };

  const getVariantStyles = () => {
    const variantMap = {
      'primary': 'primary',
      'secondary': 'secondary',
      'secondary-color': 'secondary-color',
      'tertiary': 'tertiary',
      'tertiary-color': 'tertiary-color',
      'link': 'tertiary',
      'link-color': 'tertiary-color'
    } as const;

    const mappedVariant = variantMap[variant];
    const buttonId = `btn-${variant}`;

    // Special handling for link variants
    if (variant.startsWith('link')) {
      return {
        id: buttonId,
        style: {
          backgroundColor: 'transparent',
          color: variant === 'link' 
            ? getCssVariable(getButtonToken('tertiary', 'fg'))
            : getCssVariable(getButtonToken('tertiary-color', 'fg')),
          borderWidth: '0',
          padding: '0',
        },
        hoverStyle: `
          #${buttonId}:not(:disabled):hover {
            color: ${variant === 'link' 
              ? getCssVariable(getButtonToken('tertiary', 'fg', 'hover'))
              : getCssVariable(getButtonToken('tertiary-color', 'fg', 'hover'))} !important;
            background-color: transparent !important;
          }
        `
      };
    }

    const normalBg = getCssVariable(getButtonToken(mappedVariant, 'bg'));
    const normalColor = getCssVariable(getButtonToken(mappedVariant, 'fg'));
    const normalBorder = getCssVariable(getButtonToken(mappedVariant, 'border'));
    const hoverBg = getCssVariable(getButtonToken(mappedVariant, 'bg', 'hover'));
    const hoverColor = getCssVariable(getButtonToken(mappedVariant, 'fg', 'hover'));
    const hoverBorder = getCssVariable(getButtonToken(mappedVariant, 'border', 'hover'));

    return {
      id: buttonId,
      style: {
        backgroundColor: normalBg,
        color: normalColor,
        borderColor: normalBorder,
        borderWidth: variant !== 'tertiary' && variant !== 'tertiary-color' ? '1px' : '0',
      },
      hoverStyle: `
        #${buttonId}:not(:disabled):hover {
          background-color: ${hoverBg} !important;
          color: ${hoverColor} !important;
          border-color: ${hoverBorder} !important;
        }
      `
    };
  };

  const { id, style, hoverStyle } = getVariantStyles();

  // Map button variants to icon variants
  const getIconVariant = () => {
    // For tertiary and tertiary-color, use the exact same variant
    if (variant === 'tertiary' || variant === 'tertiary-color') {
      return variant;
    }
    
    const variantMap: Record<string, 'default' | 'primary' | 'secondary' | 'tertiary' | 'tertiary-color' | 'success' | 'warning' | 'error' | 'info'> = {
      'primary': 'primary',
      'secondary': 'secondary',
      'secondary-color': 'secondary',
      'link': 'tertiary',
      'link-color': 'tertiary-color',
    };
    return variantMap[variant] || 'default';
  };
  
  const iconVariant = getIconVariant();

  // Add hover state tracking
  const [isHovered, setIsHovered] = React.useState(false);

  // Determine icon color based on variant
  const getIconDisplayColor = () => {
    if (variant === 'primary') {
      return 'white';
    }
    return iconColor !== 'currentColor' ? iconColor : undefined;
  };

  // Add transition override to button style
  const buttonStyle = {
    ...style,
    transition: 'none !important',
  };

  return (
    <>
      <style>{hoverStyle}</style>
      <button
        id={id}
        onMouseDown={(e) => e.preventDefault()}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
        className={cn(
          baseStyles,
          variant.startsWith('link') ? linkStyles : sizeStyles[size],
          className,
          (isLoading || props.disabled) && disabledStyles,
          'transform transition-all duration-200 ease-in-out hover:scale-[0.98] active:scale-[0.96]'
        )}
        style={buttonStyle}
        disabled={isLoading || props.disabled}
        {...props}
      >
        {isLoading ? (
          <div className="flex items-center gap-2">
            <svg
              className="animate-spin h-4 w-4"
              style={{ color: getCssVariable('button-loading-spinner') }}
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
            >
              <circle
                className="opacity-25"
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                strokeWidth="4"
              />
              <path
                className="opacity-75"
                fill="currentColor"
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
              />
            </svg>
            {!iconOnly && <span>{loadingText}</span>}
          </div>
        ) : (
          <>
            {leadingIcon && !iconOnly && (
              <DynamicIcon 
                url={leadingIcon} 
                color={getIconDisplayColor()} 
                variant={iconVariant}
                size={20}
                isHovered={isHovered}
              />
            )}
            {!iconOnly && <span>{children}</span>}
            {trailingIcon && !iconOnly && (
              <DynamicIcon 
                url={trailingIcon} 
                color={getIconDisplayColor()} 
                variant={iconVariant}
                size={20}
                isHovered={isHovered}
              />
            )}
            {iconOnly && leadingIcon && (
              <DynamicIcon 
                url={leadingIcon} 
                color={getIconDisplayColor()} 
                variant={iconVariant}
                size={size === 'small' ? 16 : size === 'medium' ? 20 : 24}
                isHovered={isHovered}
                className="flex-shrink-0"
              />
            )}
          </>
        )}
      </button>
    </>
  );
};

export default ButtonNormal;
</file>

<file path="app/components/CheckoutButton.tsx">
"use client";

import React, { useState } from 'react';
import { loadStripe } from "@stripe/stripe-js";
import { useTheme } from '@/app/theme/hooks';
import { cn } from '@/lib/utils/cn';
import ButtonNormal from './ButtonNormal';
import { useRouter } from 'next/navigation';
import { useWorkspace } from '@/hooks/useWorkspace';

const stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!);

interface CheckoutButtonProps {
  priceId: string;
  variant?: 'primary' | 'secondary';
  size?: 'small' | 'medium' | 'large';
  fullWidth?: boolean;
  disabled?: boolean;
  isCurrentPlan?: boolean;
  children: React.ReactNode;
}

export default function CheckoutButton({
  priceId,
  variant = 'primary',
  size = 'medium',
  fullWidth = false,
  disabled = false,
  isCurrentPlan = false,
  children,
}: CheckoutButtonProps) {
  const { getCssVariable } = useTheme();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();
  const { workspace } = useWorkspace();

  const baseStyles = 'font-semibold transition-colors duration-200 rounded-lg flex items-center justify-center gap-2';
  const disabledStyles = 'opacity-50 saturate-50 cursor-not-allowed hover:bg-transparent hover:text-inherit hover:border-inherit';
  
  const sizeStyles = {
    small: 'px-3 py-2 text-sm gap-1 font-normal rounded-md',
    medium: 'px-3.5 py-2.5 text-base gap-1 font-medium rounded-md',
    large: 'px-4 py-2.5 text-lg gap-2 font-semibold rounded-md',
  };

  const getButtonToken = (type: 'bg' | 'fg' | 'border', state: 'normal' | 'hover' = 'normal'): string => {
    const suffix = state === 'hover' ? '-hover' : '';
    return getCssVariable(`button-primary-${type}${suffix}`);
  };

  const buttonId = 'btn-checkout';
  const style = {
    backgroundColor: getButtonToken('bg'),
    color: getButtonToken('fg'),
    borderColor: getButtonToken('border'),
    borderWidth: '1px',
    width: fullWidth ? '100%' : 'auto'
  };

  const hoverStyle = `
    #${buttonId}:not(:disabled):hover {
      background-color: ${getButtonToken('bg', 'hover')} !important;
      color: ${getButtonToken('fg', 'hover')} !important;
      border-color: ${getButtonToken('border', 'hover')} !important;
    }
  `;

  const handleCheckout = async () => {
    try {
      setIsLoading(true);
      setError(null);

      if (!workspace?.id) {
        throw new Error('No workspace selected');
      }

      if (isCurrentPlan) {
        // Redirect to billing portal for current plan management
        const response = await fetch(`/api/subscription?workspaceId=${workspace.id}`);
        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.details || data.error || 'Failed to access billing portal');
        }

        if (data.url) {
          // Use router.push for client-side navigation within the app
          // Use window.location.href for external URLs (like Stripe)
          if (data.url.startsWith(process.env.NEXT_PUBLIC_APP_URL || '')) {
            router.push(data.url);
          } else {
            window.location.href = data.url;
          }
        } else {
          throw new Error('No redirect URL received');
        }
        return;
      }

      // Create new checkout session
      const response = await fetch('/api/subscription', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          priceId,
          workspaceId: workspace.id,
          workspaceSlug: workspace.slug,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.details || data.error || 'Failed to create checkout session');
      }

      if (data.url) {
        // Always use window.location.href for Stripe URLs
        window.location.href = data.url;
      } else {
        throw new Error('No checkout URL received');
      }
    } catch (error) {
      console.error('Checkout error:', error);
      setError(error instanceof Error ? error.message : 'An unexpected error occurred');
    } finally {
      setIsLoading(false);
    }
  };

  const planMap: { [key: string]: 'free' | 'earlyAdopter' } = {
    'price_1R3uKPP37Y7Hw4JwKoY0yiMq': 'earlyAdopter', // Monthly price
    'price_1R3uKPP37Y7Hw4JweazfX4vg': 'earlyAdopter', // Annual price
  };

  return (
    <div className="flex flex-col gap-2">
      <style>{hoverStyle}</style>
      <ButtonNormal
        variant={variant}
        size={size}
        disabled={disabled || isLoading}
        onClick={handleCheckout}
      >
        {isLoading ? 'Loading...' : children}
      </ButtonNormal>
      {error && (
        <div className="text-red-500 text-sm mt-1">
          {error}
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/components/CustomTooltip.tsx">
import React from 'react';

interface CustomTooltipProps {
  /** The text content to display in the tooltip */
  text: string;
  /** Controls the visibility of the tooltip */
  show?: boolean;
  /** Optional CSS class name for additional styling */
  className?: string;
  /** Direction of the tooltip arrow */
  direction?: 'left' | 'right';
}

/**
 * A reusable tooltip component that adapts to the current theme.
 * Displays a message in a floating box with an arrow pointing to the target element.
 */
export const CustomTooltip: React.FC<CustomTooltipProps> = ({
  text,
  show = false,
  className = '',
  direction = 'right',
}) => {
  if (!show) return null;

  return (
    <div
      role="tooltip"
      aria-label={text}
      className={`
        absolute px-4 py-2.5
        text-sm text-white leading-5
        bg-[#1D2939] rounded-lg
        shadow-[0px_4px_6px_-2px_rgba(16,24,40,0.03),0px_12px_16px_-4px_rgba(16,24,40,0.08)]
        w-fit whitespace-nowrap
        ${className}
      `}
      style={{
        zIndex: 9999,
        transform: 'translateY(-25%)',
      }}
    >
      <div
        className={`
          absolute ${direction === 'right' ? 'right-full' : 'left-full'} top-[25%]
          border-[6px] border-transparent ${direction === 'right' ? 'border-r-[#1D2939]' : 'border-l-[#1D2939]'}
        `}
        aria-hidden="true"
      />
      {text}
    </div>
  );
};

export default CustomTooltip;
</file>

<file path="app/components/DatePicker.tsx">
'use client';

import React, { useState, useRef, useEffect } from 'react';
import { useColors, useTheme } from '@/app/theme/hooks';
import { InputTokens } from '@/app/theme/types';
import { cn } from '@/lib/utils';
import ButtonNormal from './ButtonNormal';

interface DatePickerProps {
  label?: string;
  required?: boolean;
  value?: string;
  onChange?: (value: string) => void;
  placeholder?: string;
  disabled?: boolean;
  errorMessage?: string;
  className?: string;
}

const getInputToken = (
  state: 'normal' | 'hover' | 'focus',
  type: 'bg' | 'fg' | 'border',
  destructive: boolean = false,
  disabled: boolean = false
): keyof InputTokens => {
  if (disabled) {
    return `input-disabled-${type}` as keyof InputTokens;
  }

  const prefix = destructive ? 'input-destructive-' : 'input-';
  const suffix = state === 'normal' ? '' : `-${state}`;
  return `${prefix}${type}${suffix}` as keyof InputTokens;
};

const MONTHS = [
  'January',
  'February',
  'March',
  'April',
  'May',
  'June',
  'July',
  'August',
  'September',
  'October',
  'November',
  'December',
];

const DAYS = ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'];

/**
 * A custom date picker component that matches the Figma design
 */
const DatePicker: React.FC<DatePickerProps> = ({
  label,
  required = false,
  value = '',
  onChange,
  placeholder = 'Select dates',
  disabled = false,
  errorMessage = '',
  className = '',
}) => {
  const colors = useColors();
  const { getCssVariable } = useTheme();
  const [isFocused, setIsFocused] = useState(false);
  const [isOpen, setIsOpen] = useState(false);
  const [currentDate, setCurrentDate] = useState(new Date());
  const [selectedDate, setSelectedDate] = useState<Date | null>(
    value ? new Date(value) : null
  );
  const [inputValue, setInputValue] = useState('');
  const [tempSelectedDate, setTempSelectedDate] = useState<Date | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLButtonElement>(null);

  const destructive = !!errorMessage;

  useEffect(() => {
    if (value) {
      const date = new Date(value);
      setSelectedDate(date);
      setInputValue(formatDate(date));
    }
  }, [value]);

  useEffect(() => {
    setInputValue(formatDate(selectedDate));
  }, [selectedDate]);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        containerRef.current &&
        !containerRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
        setIsFocused(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleInputClick = () => {
    if (!disabled) {
      setTempSelectedDate(selectedDate);
      setIsOpen(!isOpen);
      setIsFocused(true);
    }
  };

  const handleInputFocus = () => {
    setIsFocused(true);
  };

  const handleInputBlur = () => {
    setTimeout(() => {
      if (!isOpen) {
        setIsFocused(false);
      }
    }, 150);
  };

  const handleCalendarInputKeyDown = (
    e: React.KeyboardEvent<HTMLInputElement>
  ) => {
    if (e.key === 'Enter' && tempSelectedDate) {
      selectDate(tempSelectedDate);
    }
  };

  const handleCalendarInputChange = (
    e: React.ChangeEvent<HTMLInputElement>
  ) => {
    const newValue = e.target.value;

    // Try to parse the input value in real-time for calendar preview
    if (newValue.trim()) {
      const parsedDate = parseInputDate(newValue);
      if (parsedDate) {
        setTempSelectedDate(parsedDate);
        setCurrentDate(parsedDate);
      }
    } else {
      setTempSelectedDate(null);
    }
  };

  const selectDate = (date: Date) => {
    setTempSelectedDate(date);
    // Automatically apply the date selection
    setSelectedDate(date);
    setInputValue(formatDate(date));
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const dateString = `${year}-${month}-${day}`;
    if (onChange) {
      onChange(dateString);
    }
    setIsOpen(false);
    setIsFocused(false);
  };

  const selectToday = () => {
    const today = new Date();
    setTempSelectedDate(today);
    setCurrentDate(today);
    // Automatically apply today's date selection
    setSelectedDate(today);
    setInputValue(formatDate(today));
    const year = today.getFullYear();
    const month = String(today.getMonth() + 1).padStart(2, '0');
    const day = String(today.getDate()).padStart(2, '0');
    const dateString = `${year}-${month}-${day}`;
    if (onChange) {
      onChange(dateString);
    }
    setIsOpen(false);
    setIsFocused(false);
  };

  const resetDate = () => {
    setSelectedDate(null);
    setTempSelectedDate(null);
    setInputValue('');
    if (onChange) {
      onChange('');
    }
    setIsOpen(false);
    setIsFocused(false);
  };

  const parseInputDate = (input: string): Date | null => {
    // Try to parse various date formats
    const trimmed = input.trim();

    // Try MM/DD/YYYY format
    const mmddyyyy = trimmed.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if (mmddyyyy) {
      const [, month, day, year] = mmddyyyy;
      const date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
      if (
        date.getFullYear() == parseInt(year) &&
        date.getMonth() == parseInt(month) - 1 &&
        date.getDate() == parseInt(day)
      ) {
        return date;
      }
    }

    // Try MMM DD, YYYY format (like "Jan 12, 2024")
    const shortMonth = trimmed.match(/^([A-Za-z]{3})\s+(\d{1,2}),?\s+(\d{4})$/);
    if (shortMonth) {
      const [, monthStr, day, year] = shortMonth;
      const monthIndex = MONTHS.findIndex((m) =>
        m.toLowerCase().startsWith(monthStr.toLowerCase())
      );
      if (monthIndex !== -1) {
        const date = new Date(parseInt(year), monthIndex, parseInt(day));
        if (
          date.getFullYear() == parseInt(year) &&
          date.getMonth() == monthIndex &&
          date.getDate() == parseInt(day)
        ) {
          return date;
        }
      }
    }

    // Try YYYY-MM-DD format
    const iso = trimmed.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
    if (iso) {
      const [, year, month, day] = iso;
      const date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
      if (
        date.getFullYear() == parseInt(year) &&
        date.getMonth() == parseInt(month) - 1 &&
        date.getDate() == parseInt(day)
      ) {
        return date;
      }
    }

    // Try just year (will set to January 1st)
    const yearOnly = trimmed.match(/^(\d{4})$/);
    if (yearOnly) {
      const year = parseInt(yearOnly[1]);
      if (year >= 1900 && year <= 2100) {
        return new Date(year, 0, 1);
      }
    }

    return null;
  };

  const formatDate = (date: Date | null) => {
    if (!date) return '';
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
    });
  };

  const navigateMonth = (direction: 'prev' | 'next') => {
    setCurrentDate((prev) => {
      const newDate = new Date(prev);
      if (direction === 'prev') {
        newDate.setMonth(newDate.getMonth() - 1);
      } else {
        newDate.setMonth(newDate.getMonth() + 1);
      }
      return newDate;
    });
  };

  const getDaysInMonth = () => {
    const year = currentDate.getFullYear();
    const month = currentDate.getMonth();
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const daysInMonth = lastDay.getDate();
    const startDay = (firstDay.getDay() + 6) % 7; // Convert Sunday=0 to Monday=0

    const days = [];

    // Previous month's trailing days
    const prevMonth = month === 0 ? 11 : month - 1;
    const prevYear = month === 0 ? year - 1 : year;
    const daysInPrevMonth = new Date(prevYear, prevMonth + 1, 0).getDate();

    for (let i = startDay - 1; i >= 0; i--) {
      const day = daysInPrevMonth - i;
      const prevDate = new Date(prevYear, prevMonth, day);
      days.push({
        date: prevDate,
        isCurrentMonth: false,
        isToday: false,
        isSelected: false,
      });
    }

    // Current month's days
    for (let day = 1; day <= daysInMonth; day++) {
      const date = new Date(year, month, day);
      const today = new Date();
      const isToday = date.toDateString() === today.toDateString();
      const isSelected =
        tempSelectedDate &&
        date.toDateString() === tempSelectedDate.toDateString();

      days.push({
        date,
        isCurrentMonth: true,
        isToday,
        isSelected,
      });
    }

    // Next month's leading days to fill the grid
    const remainingCells = 42 - days.length; // 6 weeks  7 days
    const nextMonth = month === 11 ? 0 : month + 1;
    const nextYear = month === 11 ? year + 1 : year;

    for (let day = 1; day <= remainingCells; day++) {
      const nextDate = new Date(nextYear, nextMonth, day);
      days.push({
        date: nextDate,
        isCurrentMonth: false,
        isToday: false,
        isSelected: false,
      });
    }

    return days;
  };

  const inputStyle = {
    width: '100%',
    padding: '8px 12px',
    fontSize: 16,
    lineHeight: '24px',
    fontFamily: 'Inter',
    borderRadius: 8,
    border: `1px solid ${
      destructive
        ? getCssVariable('input-destructive-border')
        : isFocused
          ? getCssVariable(
              getInputToken('focus', 'border', destructive, disabled)
            )
          : getCssVariable(
              getInputToken('normal', 'border', destructive, disabled)
            )
    }`,
    backgroundColor: disabled
      ? getCssVariable('input-disabled-bg')
      : getCssVariable(getInputToken('normal', 'bg', destructive, disabled)),
    color: disabled
      ? getCssVariable('input-disabled-fg')
      : inputValue
        ? getCssVariable(getInputToken('normal', 'fg', destructive, disabled))
        : getCssVariable('input-placeholder'),
    outline: 'none',
    transition: 'border-color 0.2s, box-shadow 0.2s',
    boxShadow: isFocused
      ? destructive
        ? '0px 0px 0px 4px rgba(253, 139, 139, 0.12)'
        : '0px 0px 0px 4px rgba(78, 107, 215, 0.12)'
      : '0px 1px 2px rgba(16, 24, 40, 0.05)',
    cursor: disabled ? 'not-allowed' : 'pointer',
    textAlign: 'left' as const,
    display: 'flex',
    alignItems: 'center',
    gap: '8px',
  };

  return (
    <div ref={containerRef} className={cn('relative w-full', className)}>
      {label && (
        <div className="flex gap-0.5 items-center mb-1.5">
          <span
            style={{
              color: errorMessage
                ? getCssVariable('input-destructive-label')
                : disabled
                  ? getCssVariable('input-disabled-label')
                  : getCssVariable('input-label'),
              fontSize: 14,
              fontWeight: 600,
              lineHeight: '20px',
              fontFamily: 'Inter',
            }}
          >
            {label}
          </span>
          {required && (
            <span
              style={{
                color: colors['text-accent'],
                fontSize: 14,
                fontWeight: 600,
              }}
            >
              *
            </span>
          )}
        </div>
      )}

      <div className="relative">
        <button
          ref={inputRef}
          onClick={handleInputClick}
          onFocus={handleInputFocus}
          onBlur={handleInputBlur}
          disabled={disabled}
          style={inputStyle}
          className="w-full transition-all duration-200"
        >
          {/* Calendar Icon */}
          <svg
            width="16"
            height="16"
            viewBox="0 0 16 16"
            fill="none"
            style={{
              color: disabled
                ? getCssVariable('input-disabled-fg')
                : getCssVariable('input-icon'),
              flexShrink: 0,
            }}
          >
            <path
              d="M14 2.66667H2C1.26362 2.66667 0.666667 3.26362 0.666667 4V14C0.666667 14.7364 1.26362 15.3333 2 15.3333H14C14.7364 15.3333 15.3333 14.7364 15.3333 14V4C15.3333 3.26362 14.7364 2.66667 14 2.66667Z"
              stroke="currentColor"
              strokeWidth="1.33333"
              strokeLinecap="round"
              strokeLinejoin="round"
            />
            <path
              d="M11.3333 1.33334V4.00001"
              stroke="currentColor"
              strokeWidth="1.33333"
              strokeLinecap="round"
              strokeLinejoin="round"
            />
            <path
              d="M4.66667 1.33334V4.00001"
              stroke="currentColor"
              strokeWidth="1.33333"
              strokeLinecap="round"
              strokeLinejoin="round"
            />
            <path
              d="M0.666667 6.66667H15.3333"
              stroke="currentColor"
              strokeWidth="1.33333"
              strokeLinecap="round"
              strokeLinejoin="round"
            />
          </svg>

          {/* Text */}
          <span style={{ flex: 1 }}>{inputValue || placeholder}</span>

          {/* Dropdown Arrow */}
          <svg
            width="16"
            height="16"
            viewBox="0 0 16 16"
            fill="none"
            style={{
              color: disabled
                ? getCssVariable('input-disabled-fg')
                : getCssVariable('input-icon'),
              flexShrink: 0,
              transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)',
              transition: 'transform 0.2s',
            }}
          >
            <path
              d="M4 6L8 10L12 6"
              stroke="currentColor"
              strokeWidth="1.33333"
              strokeLinecap="round"
              strokeLinejoin="round"
            />
          </svg>
        </button>
      </div>

      {/* Custom Calendar Dropdown */}
      {isOpen && (
        <div
          style={{
            position: 'absolute',
            top: '100%',
            left: 0,
            right: 0,
            backgroundColor: colors['bg-primary'],
            border: `1px solid ${colors['border-secondary']}`,
            borderRadius: 12,
            marginTop: 4,
            zIndex: 1000,
            boxShadow:
              '0px 8px 8px -4px rgba(16, 24, 40, 0.03), 0px 20px 24px -4px rgba(16, 24, 40, 0.08)',
            width: 280,
          }}
          onClick={(e) => e.stopPropagation()}
        >
          {/* Calendar Header */}
          <div className="p-4 pb-3">
            <div className="flex justify-between items-center mb-3">
              <button
                onClick={() => navigateMonth('prev')}
                className="p-1.5 rounded-lg transition-colors"
                style={{
                  backgroundColor: 'transparent',
                  color: colors['text-secondary'],
                }}
              >
                <svg width="16" height="16" viewBox="0 0 20 20" fill="none">
                  <path
                    d="M12.5 15L7.5 10L12.5 5"
                    stroke="currentColor"
                    strokeWidth="1.66667"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                  />
                </svg>
              </button>

              <span
                style={{
                  color: colors['text-primary'],
                  fontSize: 16,
                  fontWeight: 600,
                  fontFamily: 'Inter',
                }}
              >
                {MONTHS[currentDate.getMonth()]} {currentDate.getFullYear()}
              </span>

              <button
                onClick={() => navigateMonth('next')}
                className="p-1.5 rounded-lg transition-colors"
                style={{
                  backgroundColor: 'transparent',
                  color: colors['text-secondary'],
                }}
              >
                <svg width="16" height="16" viewBox="0 0 20 20" fill="none">
                  <path
                    d="M7.5 15L12.5 10L7.5 5"
                    stroke="currentColor"
                    strokeWidth="1.66667"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                  />
                </svg>
              </button>
            </div>

            {/* Input field and Today button */}
            <div className="flex gap-2 mb-3">
              <div className="flex-1">
                <input
                  type="text"
                  value={formatDate(tempSelectedDate)}
                  onChange={handleCalendarInputChange}
                  onKeyDown={handleCalendarInputKeyDown}
                  style={{
                    width: '100%',
                    padding: '6px 8px',
                    fontSize: 14,
                    lineHeight: '20px',
                    fontFamily: 'Inter',
                    borderRadius: 6,
                    border: `1px solid ${colors['border-primary']}`,
                    backgroundColor: colors['bg-primary'],
                    color: colors['text-primary'],
                    outline: 'none',
                    boxShadow: '0px 1px 2px rgba(16, 24, 40, 0.05)',
                  }}
                  placeholder="Jan 12, 2024"
                />
              </div>
              <button
                onClick={selectToday}
                style={{
                  padding: '6px 8px',
                  fontSize: 12,
                  fontWeight: 600,
                  fontFamily: 'Inter',
                  borderRadius: 6,
                  border: `1px solid ${colors['border-primary']}`,
                  backgroundColor: colors['bg-primary'],
                  color: colors['text-primary'],
                  cursor: 'pointer',
                  boxShadow: '0px 1px 2px rgba(16, 24, 40, 0.05)',
                  transition: 'all 0.2s',
                  whiteSpace: 'nowrap',
                }}
                className="hover:bg-gray-50"
              >
                Today
              </button>
            </div>

            {/* Calendar Grid */}
            <div>
              {/* Day headers */}
              <div className="grid grid-cols-7 gap-0 mb-1">
                {DAYS.map((day) => (
                  <div
                    key={day}
                    className="h-8 flex items-center justify-center"
                    style={{
                      color: colors['text-secondary'],
                      fontSize: 12,
                      fontWeight: 500,
                      fontFamily: 'Inter',
                    }}
                  >
                    {day}
                  </div>
                ))}
              </div>

              {/* Calendar days */}
              <div className="grid grid-cols-7 gap-0">
                {getDaysInMonth().map((dayInfo, index) => {
                  const { date, isCurrentMonth, isToday, isSelected } = dayInfo;

                  return (
                    <button
                      key={index}
                      onClick={() => isCurrentMonth && selectDate(date)}
                      disabled={!isCurrentMonth}
                      className="h-8 w-8 flex items-center justify-center rounded-full transition-all duration-200 relative"
                      style={{
                        color: !isCurrentMonth
                          ? colors['text-disabled']
                          : isSelected
                            ? '#FFFFFF'
                            : isToday && !isSelected
                              ? colors['text-primary']
                              : colors['text-primary'],
                        backgroundColor: isSelected
                          ? '#4E6BD7'
                          : isToday && !isSelected
                            ? colors['bg-secondary']
                            : 'transparent',
                        fontSize: 14,
                        fontWeight: isSelected ? 600 : 400,
                        fontFamily: 'Inter',
                        cursor: isCurrentMonth ? 'pointer' : 'default',
                      }}
                    >
                      {date.getDate()}
                      {isToday && !isSelected && (
                        <div
                          className="absolute bottom-1 w-1 h-1 rounded-full"
                          style={{ backgroundColor: colors['text-accent'] }}
                        />
                      )}
                    </button>
                  );
                })}
              </div>
            </div>
          </div>

          {/* Footer with Reset button */}
          <div
            className="flex justify-center p-3 border-t"
            style={{ borderColor: colors['border-secondary'] }}
          >
            <ButtonNormal
              variant="secondary"
              size="small"
              onClick={resetDate}
              className="w-full max-w-[120px]"
            >
              Reset
            </ButtonNormal>
          </div>
        </div>
      )}

      {errorMessage && (
        <div
          style={{
            color: getCssVariable('input-destructive-fg'),
            fontSize: 14,
            marginTop: 6,
          }}
        >
          {errorMessage}
        </div>
      )}
    </div>
  );
};

export default DatePicker;
</file>

<file path="app/components/FastThemeToggle.tsx">
'use client';

import { useFastTheme } from '../context/FastThemeContext';

export function FastThemeToggle() {
  const { currentTheme, toggleTheme } = useFastTheme();

  return (
    <button
      onClick={toggleTheme}
      className="
        px-4 py-2 rounded-lg border theme-transition
        bg-[var(--bg-primary)]
        text-[var(--text-primary)]
        border-[var(--border-primary)]
        hover:bg-[var(--bg-tertiary)]
      "
    >
      <span className="no-transition">
        {currentTheme === 'light' ? '' : ''}
      </span>
      <span className="ml-2">
        Switch to {currentTheme === 'light' ? 'Dark' : 'Light'} Mode
      </span>
    </button>
  );
}

/* Example of using the optimized CSS classes instead of CSS variables */
export function FastThemeToggleWithClasses() {
  const { currentTheme, toggleTheme } = useFastTheme();

  return (
    <button
      onClick={toggleTheme}
      className="btn-secondary theme-transition px-4 py-2 rounded-lg border"
    >
      <span className="no-transition">
        {currentTheme === 'light' ? '' : ''}
      </span>
      <span className="ml-2">
        Switch to {currentTheme === 'light' ? 'Dark' : 'Light'} Mode
      </span>
    </button>
  );
}
</file>

<file path="app/components/HubspotTracker.tsx">
'use client';

import { useEffect } from 'react';

export default function HubspotTracker() {
  useEffect(() => {
    // Create script element
    const script = document.createElement('script');
    script.id = 'hs-script-loader';
    script.type = 'text/javascript';
    script.async = true;
    script.defer = true;
    script.src = '//js.hs-scripts.com/47874121.js';
    
    // Append to body
    document.body.appendChild(script);
    
    // Cleanup on unmount
    return () => {
      // Find and remove the script if it exists
      const existingScript = document.getElementById('hs-script-loader');
      if (existingScript) {
        document.body.removeChild(existingScript);
      }
    };
  }, []);
  
  // This component doesn't render anything visible
  return null;
}
</file>

<file path="app/components/IconUpload.tsx">
import { useColors } from '@/app/theme/hooks';
import IconModifier from '@/app/dashboard/components/IconModifier';

interface IconUploadProps {
  currentIcon?: string | null;
  onIconChange: (iconUrl: string | null) => void;
}

export default function IconUpload({
  currentIcon,
  onIconChange,
}: IconUploadProps) {
  const colors = useColors();

  const handleIconUpdate = (icon?: string, emote?: string) => {
    onIconChange(icon || null);
  };

  return (
    <div className="flex flex-col gap-2">
      <label
        className="text-sm font-medium"
        style={{ color: colors['text-primary'] }}
      >
        Flow Icon
      </label>
      <IconModifier
        initialIcon={currentIcon || undefined}
        onUpdate={handleIconUpdate}
        allowEmoji={false}
      />
    </div>
  );
}
</file>

<file path="app/components/InputDropdown.tsx">
'use client';

import { useState, useRef, useEffect } from 'react';
import theme from '@/theme';

interface InputDropdownProps {
  label?: string;
  required?: boolean;
  value?: string;
  onChange?: (value: string) => void;
  options: Array<{ name: string, handle: string, avatarUrl?: string }>;
  mode?: 'light' | 'dark';
  disabled?: boolean;
  hintText?: string;
  helpIcon?: boolean;
  tooltipText?: string;
  iconUrl?: string;
  iconColor?: string;
  type?: 'default' | 'tags';
  selectedTags?: Array<{ 
    name: string, 
    handle: string, 
    avatarUrl?: string 
  }>;
  onTagRemove?: (tag: { 
    name: string, 
    handle: string, 
    avatarUrl?: string 
  }) => void;
  errorMessage?: string;
}

const InputDropdown: React.FC<InputDropdownProps> = ({
  label = "",
  required = false,
  value = "",
  onChange,
  options = [],
  mode = 'light',
  disabled = false,
  hintText = "",
  helpIcon = false,
  tooltipText = "Tooltips are used to describe or identify an element. In most scenarios, tooltips help the user understand meaning, function or alt-text.",
  iconUrl = "",
  iconColor = "",
  type = 'default',
  selectedTags = [],
  onTagRemove,
  errorMessage,
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [isFocused, setIsFocused] = useState(false);
  const [showTooltip, setShowTooltip] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  const selectedOption = options.find(opt => opt.name === value);

  const containerStyle = {
    display: "flex",
    flexDirection: "column" as const,
    gap: 6,
    width: "100%",
  };

  const labelStyle = {
    color: mode === 'light' 
      ? theme.colors["Gray (light mode)/700"]
      : theme.colors["Gray (dark mode)/300"],
    fontSize: 14,
    fontWeight: 500,
    lineHeight: "20px",
    fontFamily: 'Inter',
  };

  const dropdownStyle = {
    position: 'relative' as const,
    width: '100%',
  };

  const triggerStyle = {
    width: '100%',
    padding: '10px 14px',
    background: mode === 'light'
      ? theme.colors["Base/White"]
      : theme.colors["Gray (dark mode)/950"],
    border: `1px solid ${
      isFocused
        ? theme.colors["Brand/600"]
        : mode === 'light'
          ? theme.colors["Gray (light mode)/300"]
          : theme.colors["Gray (dark mode)/700"]
    }`,
    borderRadius: 8,
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    cursor: disabled ? 'not-allowed' : 'pointer',
    boxShadow: isFocused
      ? '0px 0px 0px 4px rgba(127, 86, 217, 0.12)'
      : mode === 'light'
        ? '0px 1px 2px rgba(16, 24, 40, 0.05)'
        : 'none',
  };

  const menuStyle = {
    position: 'absolute' as const,
    top: 'calc(100% + 4px)',
    left: 0,
    width: '100%',
    background: mode === 'light'
      ? theme.colors["Base/White"]
      : theme.colors["Gray (dark mode)/950"],
    border: `1px solid ${
      mode === 'light'
        ? theme.colors["Gray (light mode)/200"]
        : theme.colors["Gray (dark mode)/700"]
    }`,
    borderRadius: 8,
    boxShadow: mode === 'light'
      ? '0px 4px 6px -2px rgba(16, 24, 40, 0.05)'
      : '0px 4px 6px -2px rgba(0, 0, 0, 0.2)',
    zIndex: 10,
    maxHeight: '300px',
    overflowY: 'auto' as const,
    padding: '4px 6px',
  };

  const renderTags = () => {
    return (
      <div style={{ 
        display: 'flex', 
        flexWrap: 'wrap', 
        gap: '6px',
        padding: '2px 4px',
      }}>
        {selectedTags.map((tag) => (
          <div
            key={tag.handle}
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: '6px',
              padding: '2px 8px',
              background: mode === 'light' 
                ? theme.colors["Gray (light mode)/100"]
                : theme.colors["Gray (dark mode)/700"],
              borderRadius: '16px',
              height: '24px',
            }}
          >
            {tag.avatarUrl && (
              <img 
                src={tag.avatarUrl}
                alt=""
                width={16}
                height={16}
                style={{
                  borderRadius: '50%'
                }}
              />
            )}
            <span style={{
              fontSize: '14px',
              color: mode === 'light'
                ? theme.colors["Gray (light mode)/700"]
                : theme.colors["Gray (dark mode)/300"],
            }}>
              {tag.name}
            </span>
            <button
              onClick={() => onTagRemove?.(tag)}
              style={{ 
                cursor: 'pointer',
                padding: '0',
                background: 'none',
                border: 'none',
                display: 'flex',
                alignItems: 'center',
              }}
            >
              <svg width="12" height="12" viewBox="0 0 12 12" fill="none">
                <path 
                  d="M9 3L3 9M3 3L9 9" 
                  stroke={mode === 'light'
                    ? theme.colors["Gray (light mode)/500"]
                    : theme.colors["Gray (dark mode)/400"]
                  }
                  strokeWidth="1.5" 
                  strokeLinecap="round" 
                  strokeLinejoin="round"
                />
              </svg>
            </button>
          </div>
        ))}
      </div>
    );
  };

  return (
    <div style={containerStyle}>
      {label && (
        <div style={{ display: "flex", gap: 2, alignItems: "center" }}>
          <span style={labelStyle}>
            {label}
          </span>
          {required && (
            <span style={{
              color: mode === 'light'
                ? theme.colors["Brand/600"]
                : theme.colors["Brand/400"],
              fontSize: 14,
              fontWeight: 500,
              lineHeight: "20px",
            }}>
              *
            </span>
          )}
          {helpIcon && (
            <div 
              style={{ position: 'relative' }}
              onMouseEnter={() => setShowTooltip(true)}
              onMouseLeave={() => setShowTooltip(false)}
            >
              <svg
                width="16"
                height="16"
                viewBox="0 0 16 16"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                style={{ cursor: 'pointer' }}
              >
                <path
                  d="M6.86001 6.73333C7.00106 6.38921 7.25146 6.10189 7.56913 5.91402C7.8868 5.72615 8.25825 5.64676 8.62698 5.68814C8.99571 5.72953 9.33874 5.88964 9.60245 6.14478C9.86616 6.39992 10.0358 6.73602 10.0867 7.10333C10.0867 8.83333 7.48668 9.7 7.48668 9.7M8.00001 12.3333H8.00668M14.6667 8C14.6667 11.6819 11.6819 14.6667 8.00001 14.6667C4.31811 14.6667 1.33334 11.6819 1.33334 8C1.33334 4.3181 4.31811 1.33333 8.00001 1.33333C11.6819 1.33333 14.6667 4.3181 14.6667 8Z"
                  stroke={mode === 'light' 
                    ? theme.colors["Gray (light mode)/500"]
                    : theme.colors["Gray (dark mode)/400"]
                  }
                  strokeWidth="1.33333"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
              </svg>
              {showTooltip && (
                <div style={{
                  position: 'absolute',
                  left: '24px',
                  top: '-6px',
                  background: mode === 'light'
                    ? theme.colors["Gray (light mode)/900"]
                    : theme.colors["Gray (dark mode)/50"],
                  color: theme.colors["Base/White"],
                  padding: '8px 12px',
                  borderRadius: '8px',
                  fontSize: '14px',
                  width: '320px',
                  zIndex: 20,
                  boxShadow: '0px 4px 6px -2px rgba(16, 24, 40, 0.05)',
                }}>
                  {tooltipText}
                </div>
              )}
            </div>
          )}
        </div>
      )}

      <div style={dropdownStyle} ref={dropdownRef}>
        <button
          style={{
            ...triggerStyle,
            minHeight: type === 'tags' ? '44px' : 'auto',
            alignItems: type === 'tags' ? 'flex-start' : 'center',
          }}
          onClick={() => !disabled && setIsOpen(!isOpen)}
          onFocus={() => setIsFocused(true)}
          onBlur={() => setIsFocused(false)}
          disabled={disabled}
        >
          {type === 'tags' ? (
            <div style={{ width: '100%' }}>
              {selectedTags.length > 0 ? renderTags() : (
                <span style={{
                  color: mode === 'light'
                    ? theme.colors["Gray (light mode)/500"]
                    : theme.colors["Gray (dark mode)/400"],
                  fontSize: 16,
                  fontFamily: 'Inter',
                  display: 'flex',
                  alignItems: 'center',
                  height: '24px',
                  padding: '2px 4px',
                }}>
                  Select team members...
                </span>
              )}
            </div>
          ) : (
            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
              {iconUrl && (
                <img 
                  src={iconUrl}
                  alt=""
                  width={20}
                  height={20}
                  style={{
                    filter: iconColor ? `color(${iconColor})` : 'none'
                  }}
                />
              )}
              <span style={{
                color: mode === 'light'
                  ? theme.colors["Gray (light mode)/900"]
                  : theme.colors["Gray (dark mode)/50"],
                fontSize: 16,
                fontFamily: 'Inter',
              }}>
                {selectedOption?.name || "Select team member"}
              </span>
            </div>
          )}
          <svg 
            width="20" 
            height="20" 
            viewBox="0 0 20 20" 
            fill="none"
            style={{
              transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)',
              transition: 'transform 0.2s ease',
            }}
          >
            <path 
              d="M5 7.5L10 12.5L15 7.5" 
              stroke={mode === 'light' 
                ? theme.colors["Gray (light mode)/500"]
                : theme.colors["Gray (dark mode)/400"]
              }
              strokeWidth="1.66667" 
              strokeLinecap="round" 
              strokeLinejoin="round"
            />
          </svg>
        </button>

        {isOpen && (
          <div style={menuStyle}>
            {options.map((option) => {
              const isSelected = type === 'tags' 
                ? selectedTags?.some(tag => tag.handle === option.handle)
                : option.name === value;
              return (
                <div
                  key={option.handle}
                  className={`
                    transition-colors 
                    cursor-pointer
                    rounded-md
                    my-1
                    ${isSelected 
                      ? mode === 'light'
                        ? 'bg-gray-100'
                        : 'bg-gray-800'
                      : mode === 'light'
                        ? 'hover:bg-gray-50'
                        : 'hover:bg-gray-900'
                    }
                  `}
                  style={{
                    padding: '10px 14px',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    color: mode === 'light'
                      ? theme.colors["Gray (light mode)/900"]
                      : theme.colors["Gray (dark mode)/50"],
                    fontSize: 14,
                    fontFamily: 'Inter',
                    lineHeight: '20px',
                  }}
                  onClick={() => {
                    onChange?.(option.name);
                    setIsOpen(false);
                  }}
                >
                  <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
                    {type === 'tags' ? (
                      option.avatarUrl && (
                        <img 
                          src={option.avatarUrl}
                          alt=""
                          width={20}
                          height={20}
                          style={{
                            borderRadius: '50%'
                          }}
                        />
                      )
                    ) : (
                      iconUrl && (
                        <img 
                          src={iconUrl}
                          alt=""
                          width={20}
                          height={20}
                          style={{
                            filter: iconColor ? `color(${iconColor})` : 'none'
                          }}
                        />
                      )
                    )}
                    <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
                      <span>{option.name}</span>
                      <span style={{
                        color: mode === 'light'
                          ? theme.colors["Gray (light mode)/500"]
                          : theme.colors["Gray (dark mode)/400"],
                        fontSize: 14,
                      }}>
                        {option.handle}
                      </span>
                    </div>
                  </div>
                  {isSelected && (
                    <img 
                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-icon2.svg`}
                      alt="Selected"
                      width={20}
                      height={20}
                    />
                  )}
                </div>
              );
            })}
          </div>
        )}
      </div>

      {hintText && (
        <div style={{
          color: mode === 'light'
            ? theme.colors["Gray (light mode)/600"]
            : theme.colors["Gray (dark mode)/300"],
          fontSize: '14px',
          marginTop: '6px',
        }}>
          {hintText}
        </div>
      )}

      {errorMessage && (
        <div style={{
          color: mode === 'light'
            ? theme.colors["Error/600"]
            : theme.colors["Error/300"],
          fontSize: '14px',
          marginTop: '6px',
        }}>
          {errorMessage}
        </div>
      )}
    </div>
  );
};

export default InputDropdown;
</file>

<file path="app/components/LoadingModal.tsx">
'use client';

import React from 'react';
import { useColors } from '@/app/theme/hooks';
import LoadingSpinner from './LoadingSpinner';
import { createPortal } from 'react-dom';
// No longer need separate ThemeProvider for modals

interface LoadingModalProps {
  isOpen: boolean;
  message?: string;
  description?: string;
}

const LoadingModal: React.FC<LoadingModalProps> = ({ 
  isOpen, 
  message = "Loading...", 
  description 
}) => {
  const colors = useColors();

  if (!isOpen) return null;

  const modalContent = (
    <div className="fixed inset-0 flex items-center justify-center p-8 z-[9999] animate-in fade-in-0 duration-200">
      {/* Backdrop */}
      <div className="fixed inset-0 animate-in fade-in-0 duration-300">
        <div
          style={{ backgroundColor: colors['bg-overlay'] }}
          className="absolute inset-0 opacity-70"
        />
      </div>

      {/* Modal content */}
      <div
        className="rounded-xl shadow-lg w-[400px] flex flex-col relative z-10 animate-in zoom-in-95 slide-in-from-bottom-4 duration-300 ease-out p-8"
        style={{ backgroundColor: colors['bg-primary'] }}
      >
        <div className="flex flex-col items-center text-center">
          <LoadingSpinner size="large" />
          
          <h3
            className="text-lg font-medium mt-6 mb-2"
            style={{ color: colors['text-primary'] }}
          >
            {message}
          </h3>
          
          {description && (
            <p
              className="text-sm"
              style={{ color: colors['text-secondary'] }}
            >
              {description}
            </p>
          )}
        </div>
      </div>
    </div>
  );

  return createPortal(
    modalContent,
    document.body
  );
};

export default LoadingModal;
</file>

<file path="app/components/LoadingSpinner.tsx">
'use client';

import React from 'react';
import { useColors } from '@/app/theme/hooks';

interface LoadingSpinnerProps {
  size?: 'small' | 'medium' | 'large';
  fullScreen?: boolean;
}

/**
 * LoadingSpinner component displays a branded loading screen with animated logo
 * @param size - Controls the size of the logo ('small' | 'medium' | 'large')
 * @param fullScreen - Whether to display the loader full screen with themed background
 */
const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = 'medium',
  fullScreen = false,
}) => {
  const colors = useColors();

  const sizeClasses = {
    small: 'w-24',
    medium: 'w-32',
    large: 'w-40'
  };

  const containerClasses = fullScreen
    ? 'fixed inset-0 flex items-center justify-center z-50'
    : 'flex items-center justify-center';

  return (
    <div 
      className={containerClasses}
      style={{ backgroundColor: colors['bg-primary'] }}
    >
      <div className="relative flex items-center justify-center">
        {/* Background glow effect */}
        <div 
          className="absolute w-full h-full animate-[pulse_2s_ease-in-out_infinite]"
          style={{
            background: `radial-gradient(circle, ${colors['brand-primary']}40 0%, transparent 70%)`,
            transform: 'scale(1.2)',
            filter: 'blur(20px)'
          }}
        />
        
        {/* Logo with animation */}
        <div className="animate-[bounce_3s_ease-in-out_infinite]">
          <img
            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logo-pf-in-app.png`}
            alt="ProcessFlow Logo"
            className={`${sizeClasses[size]} transition-transform duration-300`}
          />
        </div>
      </div>
    </div>
  );
};

export default LoadingSpinner;
</file>

<file path="app/components/Modal.tsx">
import React, { ReactNode } from 'react';
import { createPortal } from 'react-dom';
import { useColors } from '@/app/theme/hooks';
// No longer need separate ThemeProvider for modals

export interface ModalProps {
  /**
   * Function to call when the modal is closed
   */
  onClose: () => void;

  /**
   * The title of the modal
   */
  title?: string;

  /**
   * Optional subtitle or description of the modal
   */
  subtitle?: string;

  /**
   * Optional icon to display in the header
   * This can be a path to an image or an SVG component
   */
  icon?: string | ReactNode;

  /**
   * Optional background color for the icon container
   */
  iconBackgroundColor?: string;

  /**
   * Optional border color for the icon container
   */
  iconBorderColor?: string;

  /**
   * The content of the modal
   */
  children: ReactNode;

  /**
   * Optional footer actions
   * Typically buttons for "Cancel", "Submit", etc.
   */
  actions?: ReactNode;

  /**
   * Optional CSS class name for additional styling
   */
  className?: string;

  /**
   * Optional width for the modal
   * Default is 'w-[480px]'
   */
  width?: string;

  /**
   * Whether to show a separator between the header and content
   * Default is false
   */
  showHeaderSeparator?: boolean;

  /**
   * Whether to show a separator between the content and actions
   * Default is true
   */
  showActionsSeparator?: boolean;
}

/**
 * A reusable modal component that can be used as a base for all modals in the application.
 * The component is built with three main sections:
 * 1. Header: Contains the icon, title, and subtitle
 * 2. Content: Contains the main content of the modal (passed as children)
 * 3. Actions: Contains the footer actions (typically buttons)
 */
const Modal: React.FC<ModalProps> = ({
  onClose,
  title,
  subtitle,
  icon,
  iconBackgroundColor,
  iconBorderColor,
  children,
  actions,
  className = '',
  width = 'w-[480px]',
  showHeaderSeparator = false,
  showActionsSeparator = true,
}) => {
  const colors = useColors();

  // Prevent background clicks from closing the modal
  const handleModalClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  // Determine if the icon is a string (path to an image) or a ReactNode
  const renderIcon = () => {
    if (!icon) return null;

    return (
      <div
        className="w-12 h-12 p-3 rounded-[10px] border shadow-sm flex items-center justify-center"
        style={{
          backgroundColor: iconBackgroundColor || colors['bg-primary'],
          borderColor: iconBorderColor || colors['border-secondary'],
        }}
      >
        {typeof icon === 'string' ? (
          <img src={icon} alt="Modal icon" className="w-6 h-6" />
        ) : (
          icon
        )}
      </div>
    );
  };

  const modalContent = (
    <div
      className="fixed inset-0 flex items-center justify-center p-8 z-[9999] animate-in fade-in-0 duration-200"
      onClick={onClose}
    >
      {/* Backdrop */}
      <div className="fixed inset-0 animate-in fade-in-0 duration-300">
        <div
          style={{ backgroundColor: colors['bg-overlay'] }}
          className="absolute inset-0 opacity-70"
        />
      </div>

      <div
        className={`rounded-xl shadow-lg ${width} flex flex-col relative z-10 ${className} animate-in zoom-in-95 slide-in-from-bottom-4 duration-300 ease-out`}
        style={{ backgroundColor: colors['bg-primary'] }}
        onClick={handleModalClick}
      >
        {/* Header */}
        <div
          className={`px-6 pt-6 ${showHeaderSeparator ? 'pb-6 border-b' : ''}`}
          style={{
            borderColor: showHeaderSeparator
              ? colors['border-secondary']
              : 'transparent',
          }}
        >
          {(icon || title) && (
            <div className="flex flex-row items-center gap-4">
              {renderIcon()}
              <div className="flex flex-col gap-1">
                <h2
                  className="text-lg font-medium"
                  style={{ color: colors['text-primary'] }}
                >
                  {title}
                </h2>
                {subtitle && (
                  <p
                    className="text-sm"
                    style={{ color: colors['text-secondary'] }}
                  >
                    {subtitle}
                  </p>
                )}
              </div>
            </div>
          )}
        </div>

        {/* Content */}
        <div className="p-6 overflow-y-auto max-h-[70vh]">{children}</div>

        {/* Actions */}
        {actions && (
          <div
            className={`flex gap-3 p-6 ${showActionsSeparator ? 'border-t' : ''}`}
            style={{
              borderColor: showActionsSeparator
                ? colors['border-secondary']
                : 'transparent',
            }}
          >
            {actions}
          </div>
        )}
      </div>
    </div>
  );

  // FastThemeProvider from layout.tsx covers the whole app, including portals
  return createPortal(modalContent, document.body);
};

export default Modal;
</file>

<file path="app/components/OptimizedIcon.tsx">
import React from 'react';

interface OptimizedIconProps {
  src: string;
  alt: string;
  className?: string;
  width?: number;
  height?: number;
  onError?: () => void;
  referrerPolicy?: React.HTMLAttributeReferrerPolicy;
  loading?: 'lazy' | 'eager';
}

/**
 * Optimized icon component with memoization to prevent unnecessary re-renders
 * Includes error handling and lazy loading support
 */
const OptimizedIcon: React.FC<OptimizedIconProps> = React.memo(({
  src,
  alt,
  className = "w-6 h-6 object-contain select-none pointer-events-none",
  width = 24,
  height = 24,
  onError,
  referrerPolicy = "strict-origin-when-cross-origin",
  loading = "lazy"
}) => {
  const [hasError, setHasError] = React.useState(false);
  const [isLoaded, setIsLoaded] = React.useState(false);

  const handleError = React.useCallback(() => {
    setHasError(true);
    onError?.();
  }, [onError]);

  const handleLoad = React.useCallback(() => {
    setIsLoaded(true);
  }, []);

  // Show placeholder while loading or if error occurred
  if (!src || hasError) {
    return (
      <div 
        className={`${className} bg-gray-100 rounded flex items-center justify-center`}
        style={{ width, height }}
      >
        <svg 
          width="12" 
          height="12" 
          viewBox="0 0 24 24" 
          fill="none" 
          stroke="currentColor" 
          strokeWidth="2"
          className="text-gray-400"
        >
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
          <circle cx="8.5" cy="8.5" r="1.5"/>
          <polyline points="21,15 16,10 5,21"/>
        </svg>
      </div>
    );
  }

  return (
    <div className="relative" style={{ width, height }}>
      {/* Loading placeholder */}
      {!isLoaded && (
        <div 
          className={`absolute inset-0 ${className} bg-gray-100 rounded animate-pulse`}
        />
      )}
      
      {/* Actual image */}
      <img
        src={src}
        alt={alt}
        className={`${className} ${!isLoaded ? 'opacity-0' : 'opacity-100'} transition-opacity duration-200`}
        width={width}
        height={height}
        onError={handleError}
        onLoad={handleLoad}
        referrerPolicy={referrerPolicy}
        loading={loading}
      />
    </div>
  );
});

OptimizedIcon.displayName = 'OptimizedIcon';

export default OptimizedIcon;
</file>

<file path="app/components/SelectField.tsx">
'use client';

import React, { useState, useRef, useEffect } from 'react';
import { useColors, useTheme } from '@/app/theme/hooks';
import { useTheme as useThemeHook } from '@/app/theme/hooks';
import { InputTokens } from '@/app/theme/types';
import { cn } from '@/lib/utils';

interface SelectFieldProps {
  label?: string;
  required?: boolean;
  value?: string;
  onChange?: (value: string) => void;
  placeholder?: string;
  disabled?: boolean;
  errorMessage?: string;
  className?: string;
  options?: string[];
  allowCustomInput?: boolean;
}

const getInputToken = (state: 'normal' | 'hover' | 'focus', type: 'bg' | 'fg' | 'border', destructive: boolean = false, disabled: boolean = false): keyof InputTokens => {
  if (disabled) {
    return `input-disabled-${type}` as keyof InputTokens;
  }
  
  const prefix = destructive ? 'input-destructive-' : 'input-';
  const suffix = state === 'normal' ? '' : `-${state}`;
  return `${prefix}${type}${suffix}` as keyof InputTokens;
};

/**
 * A select field component that allows both selection from predefined options
 * and custom input, integrating with the existing theme system
 */
const SelectField: React.FC<SelectFieldProps> = ({
  label,
  required = false,
  value = '',
  onChange,
  placeholder = 'Select or type...',
  disabled = false,
  errorMessage = '',
  className = '',
  options = [],
  allowCustomInput = true,
}) => {
  const colors = useColors();
  const { getCssVariable } = useTheme();
  const [isFocused, setIsFocused] = useState(false);
  const [isOpen, setIsOpen] = useState(false);
  const [inputValue, setInputValue] = useState(value);
  const containerRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  const destructive = !!errorMessage;

  // Filter options based on input value
  const filteredOptions = options.filter(option =>
    option.toLowerCase().includes(inputValue.toLowerCase())
  );

  useEffect(() => {
    setInputValue(value);
  }, [value]);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
        setIsOpen(false);
        setIsFocused(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleFocus = () => {
    setIsFocused(true);
    if (options.length > 0) {
      setIsOpen(true);
    }
  };

  const handleBlur = () => {
    // Don't close immediately to allow option selection
    setTimeout(() => {
      setIsFocused(false);
    }, 150);
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    setInputValue(newValue);
    if (onChange && allowCustomInput) {
      onChange(newValue);
    }
    if (options.length > 0) {
      setIsOpen(true);
    }
  };

  const handleOptionSelect = (option: string) => {
    setInputValue(option);
    if (onChange) {
      onChange(option);
    }
    setIsOpen(false);
    inputRef.current?.focus();
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'ArrowDown' && filteredOptions.length > 0) {
      e.preventDefault();
      setIsOpen(true);
    } else if (e.key === 'Escape') {
      setIsOpen(false);
    } else if (e.key === 'Enter' && filteredOptions.length === 1) {
      e.preventDefault();
      handleOptionSelect(filteredOptions[0]);
    }
  };

  const containerStyle = {
    display: 'flex',
    flexDirection: 'column' as const,
    gap: 6,
    width: '100%',
    position: 'relative' as const,
  };

  const labelStyle = {
    color: errorMessage
      ? getCssVariable('input-destructive-label')
      : disabled
      ? getCssVariable('input-disabled-label')
      : getCssVariable('input-label'),
    fontSize: 14,
    fontWeight: 600,
    lineHeight: '20px',
    fontFamily: 'Inter',
  };

  const inputContainerStyle = {
    position: 'relative' as const,
    width: '100%',
  };

  const inputStyle = {
    width: '100%',
    padding: '8px 40px 8px 12px',
    fontSize: 16,
    lineHeight: '24px',
    fontFamily: 'Inter',
    borderRadius: 6,
    border: `1px solid ${
      destructive 
        ? getCssVariable('input-destructive-border')
        : isFocused 
          ? getCssVariable(getInputToken('focus', 'border', destructive, disabled))
          : getCssVariable(getInputToken('normal', 'border', destructive, disabled))
    }`,
    backgroundColor: disabled
      ? getCssVariable('input-disabled-bg')
      : getCssVariable(getInputToken('normal', 'bg', destructive, disabled)),
    color: disabled
      ? getCssVariable('input-disabled-fg')
      : getCssVariable(getInputToken('normal', 'fg', destructive, disabled)),
    outline: 'none',
    transition: 'border-color 0.2s, box-shadow 0.2s',
    boxShadow: isFocused
      ? destructive
        ? '0px 0px 0px 4px rgba(253, 139, 139, 0.12)'
        : '0px 0px 0px 4px rgba(78, 107, 215, 0.12)'
      : '0px 1px 2px rgba(16, 24, 40, 0.05)',
  };

  const dropdownStyle = {
    position: 'absolute' as const,
    top: '100%',
    left: 0,
    right: 0,
    backgroundColor: colors['bg-primary'],
    border: `1px solid ${colors['border-primary']}`,
    borderRadius: 6,
    marginTop: 2,
    maxHeight: 200,
    overflowY: 'auto' as const,
    zIndex: 1000,
    boxShadow: '0px 4px 6px -2px rgba(16, 24, 40, 0.03), 0px 12px 16px -4px rgba(16, 24, 40, 0.08)',
  };

  const optionStyle = {
    padding: '8px 12px',
    cursor: 'pointer',
    fontSize: 14,
    fontFamily: 'Inter',
    color: colors['text-primary'],
    transition: 'background-color 0.2s',
  };

  const errorStyle = {
    color: getCssVariable('input-destructive-fg'),
    fontSize: 14,
    marginTop: 6,
  };

  return (
    <div ref={containerRef} style={containerStyle} className={className}>
      {label && (
        <div style={{ display: 'flex', gap: 2, alignItems: 'center' }}>
          <span style={labelStyle}>
            {label}
          </span>
          {required && (
            <span style={{ color: colors['text-accent'], fontSize: 14, fontWeight: 600 }}>
              *
            </span>
          )}
        </div>
      )}
      
      <div style={inputContainerStyle}>
        <input
          ref={inputRef}
          type="text"
          value={inputValue}
          onChange={handleInputChange}
          onFocus={handleFocus}
          onBlur={handleBlur}
          onKeyDown={handleKeyDown}
          disabled={disabled}
          placeholder={placeholder}
          style={inputStyle}
          className={cn(
            "w-full transition-all duration-200",
            disabled && "cursor-not-allowed"
          )}
        />
        
        {/* Dropdown arrow */}
        {options.length > 0 && (
          <div
            style={{
              position: 'absolute',
              right: 12,
              top: '50%',
              transform: 'translateY(-50%)',
              pointerEvents: 'none',
              color: colors['text-tertiary'],
            }}
          >
            <svg
              width="20"
              height="20"
              viewBox="0 0 20 20"
              fill="none"
              style={{
                transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)',
                transition: 'transform 0.2s ease',
              }}
            >
              <path
                d="M5 7.5L10 12.5L15 7.5"
                stroke="currentColor"
                strokeWidth="1.66667"
                strokeLinecap="round"
                strokeLinejoin="round"
              />
            </svg>
          </div>
        )}
      </div>

      {/* Dropdown options */}
      {isOpen && filteredOptions.length > 0 && (
        <div style={dropdownStyle}>
          {filteredOptions.map((option, index) => (
            <div
              key={index}
              style={optionStyle}
              onMouseDown={(e) => {
                e.preventDefault();
                handleOptionSelect(option);
              }}
              onMouseEnter={(e) => {
                e.currentTarget.style.backgroundColor = colors['bg-hover'];
              }}
              onMouseLeave={(e) => {
                e.currentTarget.style.backgroundColor = 'transparent';
              }}
            >
              {option}
            </div>
          ))}
        </div>
      )}

      {errorMessage && (
        <div style={errorStyle}>
          {errorMessage}
        </div>
      )}
    </div>
  );
};

export default SelectField;
</file>

<file path="app/components/SkeletonCard.tsx">
'use client';

import React from 'react';
import { useColors } from '@/app/theme/hooks';

const SkeletonCard: React.FC = () => {
  const colors = useColors();

  return (
    <div 
      style={{ 
        backgroundColor: colors['bg-primary'],
        borderColor: colors['border-primary']
      }}
      className="rounded-xl border p-4 animate-pulse"
    >
      {/* Header skeleton */}
      <div className="flex items-center justify-between mb-3">
        <div 
          style={{ backgroundColor: colors['bg-secondary'] }}
          className="w-8 h-8 rounded-lg"
        />
        <div 
          style={{ backgroundColor: colors['bg-secondary'] }}
          className="w-5 h-5 rounded"
        />
      </div>

      {/* Title skeleton */}
      <div 
        style={{ backgroundColor: colors['bg-secondary'] }}
        className="h-5 rounded mb-2 w-3/4"
      />

      {/* Description skeleton */}
      <div 
        style={{ backgroundColor: colors['bg-secondary'] }}
        className="h-4 rounded mb-1 w-full"
      />
      <div 
        style={{ backgroundColor: colors['bg-secondary'] }}
        className="h-4 rounded mb-4 w-2/3"
      />

      {/* Tags skeleton */}
      <div className="flex gap-2 mb-4">
        <div 
          style={{ backgroundColor: colors['bg-secondary'] }}
          className="h-6 rounded-full w-16"
        />
        <div 
          style={{ backgroundColor: colors['bg-secondary'] }}
          className="h-6 rounded-full w-20"
        />
      </div>

      {/* Footer skeleton */}
      <div className="flex items-center justify-between">
        <div 
          style={{ backgroundColor: colors['bg-secondary'] }}
          className="h-4 rounded w-20"
        />
        <div 
          style={{ backgroundColor: colors['bg-secondary'] }}
          className="h-4 rounded w-16"
        />
      </div>
    </div>
  );
};

export default SkeletonCard;
</file>

<file path="app/components/SkeletonWorkflowCard.tsx">
'use client';

import React from 'react';
import { useColors } from '@/app/theme/hooks';

const SkeletonWorkflowCard: React.FC = () => {
  const colors = useColors();

  return (
    <div 
      style={{ 
        backgroundColor: colors['bg-primary'],
        borderColor: colors['border-primary']
      }}
      className="rounded-lg border p-4 animate-pulse h-[200px] flex flex-col transition-all duration-300 ease-in-out"
    >
      {/* Header skeleton */}
      <div className="flex items-center justify-between mb-3">
        <div 
          style={{ backgroundColor: colors['bg-secondary'] }}
          className="w-8 h-8 rounded-lg"
        />
        <div 
          style={{ backgroundColor: colors['bg-secondary'] }}
          className="w-5 h-5 rounded"
        />
      </div>

      {/* Title skeleton */}
      <div 
        style={{ backgroundColor: colors['bg-secondary'] }}
        className="h-5 rounded mb-2 w-3/4"
      />

      {/* Process owner and review date skeleton */}
      <div className="mb-4 space-y-2">
        <div className="flex items-center gap-2">
          <div 
            style={{ backgroundColor: colors['bg-secondary'] }}
            className="w-4 h-4 rounded"
          />
          <div 
            style={{ backgroundColor: colors['bg-secondary'] }}
            className="h-3 rounded w-24"
          />
        </div>
        <div className="flex items-center gap-2">
          <div 
            style={{ backgroundColor: colors['bg-secondary'] }}
            className="w-4 h-4 rounded"
          />
          <div 
            style={{ backgroundColor: colors['bg-secondary'] }}
            className="h-3 rounded w-28"
          />
        </div>
      </div>

      {/* Bottom section skeleton */}
      <div className="mt-auto">
        <div
          style={{ borderColor: colors['border-secondary'] }}
          className="border-t w-full mb-3"
        />
        <div className="flex items-center justify-between">
          <div 
            style={{ backgroundColor: colors['bg-secondary'] }}
            className="h-5 rounded-full w-16"
          />
          <div 
            style={{ backgroundColor: colors['bg-secondary'] }}
            className="h-3 rounded w-20"
          />
        </div>
      </div>
    </div>
  );
};

export default SkeletonWorkflowCard;
</file>

<file path="app/components/TabButton.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { Folder } from '@/types/workspace';
import FolderDropdown from '@/app/dashboard/components/FolderDropdown';
import { getAssetUrl, SHARED_ASSETS } from '@/app/utils/assetUrls';
import { useColors } from '@/app/theme/hooks';
import { cn } from '@/lib/utils/cn';
import { AnimatePresence } from 'framer-motion';

interface TabButtonProps {
  icon: string;
  label: string;
  isActive: boolean;
  onClick: () => void;
  isFolder?: boolean;
  folder?: Folder;
  hasSubfolders?: boolean;
  isExpanded?: boolean;
  onToggleExpand?: () => void;
  onCreateSubfolder?: (folder: Folder) => void;
  onEditFolder?: (folder: Folder) => void;
  onDeleteFolder?: (folder: Folder) => Promise<void>;
  onSelectFolder?: (folder?: Folder) => void;
  emote?: string;
  inSortableContext?: boolean;
}

export const TabButton: React.FC<TabButtonProps> = ({
  icon,
  label,
  isActive,
  onClick,
  isFolder,
  folder,
  hasSubfolders,
  isExpanded,
  onToggleExpand,
  onCreateSubfolder,
  onEditFolder,
  onDeleteFolder,
  onSelectFolder,
  emote,
  inSortableContext,
}) => {
  const [dropdownPosition, setDropdownPosition] = useState<{
    top: number;
    left: number;
  } | null>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const colors = useColors();
  const buttonId = `tab-${Math.random().toString(36).substr(2, 9)}`;

  const handleDropdownClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (folder) {
      if (dropdownPosition) {
        // If dropdown is already open, close it
        onSelectFolder?.(undefined);
        setDropdownPosition(null);
      } else {
        // Open the dropdown
        onSelectFolder?.(folder);
        const rect = (e.target as HTMLElement).getBoundingClientRect();
        setDropdownPosition({
          top: rect.top + window.scrollY + 30,
          left: rect.left + window.scrollX + 10,
        });
      }
    }
  };

  const handleDropdownAction = async (action: () => void | Promise<void>) => {
    try {
      await action();
    } finally {
      // Always close the dropdown after an action
      onSelectFolder?.(undefined);
      setDropdownPosition(null);
    }
  };

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target as Node)
      ) {
        onSelectFolder?.(undefined);
        setDropdownPosition(null);
      }
    };

    const handleEscapeKey = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onSelectFolder?.(undefined);
        setDropdownPosition(null);
      }
    };

    if (dropdownPosition) {
      // Add a small delay to prevent immediate closing when opening
      const timeoutId = setTimeout(() => {
        document.addEventListener('mousedown', handleClickOutside);
        document.addEventListener('keydown', handleEscapeKey);
      }, 100);

      return () => {
        clearTimeout(timeoutId);
        document.removeEventListener('mousedown', handleClickOutside);
        document.removeEventListener('keydown', handleEscapeKey);
      };
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('keydown', handleEscapeKey);
    };
  }, [dropdownPosition, onSelectFolder]);

  const chevronIcon = isExpanded
    ? SHARED_ASSETS.chevronDown
    : SHARED_ASSETS.chevronRight;

  const buttonStyles = {
    backgroundColor: isActive ? colors['bg-secondary'] : 'transparent',
    borderColor: isActive ? colors['border-tertiary'] : 'transparent',
  };

  const hoverStyles = `
    #${buttonId}:not(.active):hover {
      background-color: ${colors['bg-secondary']} !important;
    }
  `;

  return (
    <>
      <style>{hoverStyles}</style>
      <div
        className={`relative group ${inSortableContext ? '' : 'drag-handle'}`}
      >
        <div
          id={buttonId}
          role="button"
          tabIndex={0}
          className={cn(
            'w-full px-3 py-1.5 rounded-md flex items-center cursor-pointer transition-all duration-200 border hover:scale-[1.02] hover:shadow-sm',
            isActive && 'active'
          )}
          style={buttonStyles}
          onClick={onClick}
          onKeyDown={(e) => e.key === 'Enter' && onClick()}
        >
          <div className="flex items-center gap-2 w-full overflow-hidden">
            {/* Chevron (shows on hover) */}
            {isFolder && hasSubfolders && (
              <div
                role="button"
                tabIndex={0}
                onClick={(e) => {
                  e.stopPropagation();
                  onToggleExpand?.();
                }}
                onKeyDown={(e) => e.key === 'Enter' && onToggleExpand?.()}
                className={cn(
                  'w-4 h-4 hidden group-hover:block flex-shrink-0 rounded-md transition-all duration-200 hover:scale-110',
                  'hover:bg-[var(--bg-secondary)]'
                )}
              >
                <img
                  src={getAssetUrl(chevronIcon)}
                  alt="Toggle Subfolders"
                  className="w-4 h-4"
                />
              </div>
            )}

            {/* Folder Icon */}
            <div
              className={`w-4 h-4 flex-shrink-0 ${hasSubfolders ? 'group-hover:hidden' : ''} flex items-center justify-center`}
            >
              {emote ? (
                <div className="w-4 h-4 flex items-center justify-center leading-none">
                  {emote}
                </div>
              ) : folder?.signedIconUrl ? (
                <img
                  src={folder.signedIconUrl}
                  alt={label}
                  className="w-4 h-4 object-contain"
                />
              ) : folder?.icon_url ? (
                folder.icon_url.startsWith('https://cdn.brandfetch.io/') ? (
                  <img
                    src={folder.icon_url}
                    alt={label}
                    className="w-4 h-4 object-contain"
                    referrerPolicy="strict-origin-when-cross-origin"
                  />
                ) : (
                  <img
                    // src={getAssetUrl(folder.icon_url)}
                    alt={label}
                    className="w-4 h-4 object-contain"
                  />
                )
              ) : isFolder ? (
                <img
                  src={getAssetUrl(SHARED_ASSETS.folderBase)}
                  alt="Folder"
                  className="w-4 h-4 object-contain"
                />
              ) : icon ? (
                <img
                  src={icon}
                  alt={label}
                  className="w-4 h-4 object-contain"
                />
              ) : null}
            </div>

            {/* Label */}
            <div className="min-w-0 flex-1 overflow-hidden">
              <span
                style={{ color: colors['text-secondary'] }}
                className="text-sm font-medium truncate block"
              >
                {label}
              </span>
            </div>
          </div>

          {/* Three dots button */}
          {isFolder && (
            <div
              role="button"
              tabIndex={0}
              onClick={handleDropdownClick}
              onKeyDown={(e) =>
                e.key === 'Enter' && handleDropdownClick(e as any)
              }
              className={cn(
                'w-5 h-5 relative overflow-hidden hidden group-hover:block ml-auto rounded-md transition-all duration-200 hover:scale-110',
                'hover:bg-[var(--bg-secondary)] opacity-70 hover:opacity-100'
              )}
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dots-horizontal.svg`}
                alt="Show Folder Dropdown"
                className="w-5 h-5"
              />
            </div>
          )}
        </div>

        {/* Dropdown Menu */}
        <AnimatePresence>
          {dropdownPosition && folder && (
            <>
              {/* Invisible backdrop for modal behavior */}
              <div 
                className="fixed inset-0 z-40 cursor-default"
                onClick={() => {
                  onSelectFolder?.(undefined);
                  setDropdownPosition(null);
                }}
              />
              <div
                ref={dropdownRef}
                style={{
                  top: dropdownPosition.top,
                  left: dropdownPosition.left,
                }}
                className="fixed z-50 w-auto min-w-[200px]"
              >
                <FolderDropdown
                  onCreateSubfolder={() =>
                    handleDropdownAction(() => onCreateSubfolder?.(folder))
                  }
                  onDeleteFolder={() =>
                    handleDropdownAction(async () => await onDeleteFolder?.(folder))
                  }
                  onEditFolder={() =>
                    handleDropdownAction(() => onEditFolder?.(folder))
                  }
                  parent={folder}
                />
              </div>
            </>
          )}
        </AnimatePresence>
      </div>
    </>
  );
};

export default TabButton;
</file>

<file path="app/components/TextAreaInput.tsx">
'use client';

import { cn } from '@/lib/utils/cn';
import { useState, useMemo } from 'react';
import { useColors } from '@/app/theme/hooks';
import { InputTokens } from '@/app/theme/types';

// =======================================================
// Helper Functions
// =======================================================
const getInputToken = (
  state: 'normal' | 'hover' | 'focus',
  type: 'bg' | 'fg' | 'border',
  destructive: boolean = false,
  disabled: boolean = false
): keyof InputTokens => {
  if (disabled) {
    return `input-disabled-${type}` as keyof InputTokens;
  }

  const prefix = destructive ? 'input-destructive-' : 'input-';
  const suffix = state === 'normal' ? '' : `-${state}`;
  return `${prefix}${type}${suffix}` as keyof InputTokens;
};

// =======================================================
// Types
// =======================================================
interface TextAreaInputProps {
  label?: string;
  required?: boolean;
  placeholder?: string;
  value?: string;
  onChange?: (value: string) => void;
  hintText?: string;
  helpIcon?: boolean;
  disabled?: boolean;
  errorMessage?: string;
  tooltipText?: string;
  rows?: number;
  destructive?: boolean;
}

// =======================================================
// Helper Components
// =======================================================
const Tooltip: React.FC<{ text: string }> = ({ text }) => {
  const colors = useColors();

  return (
    <div
      className="absolute z-10 invisible group-hover:visible bg-white dark:bg-gray-800 text-sm text-gray-500 px-2 py-1 rounded-md shadow-sm max-w-xs"
      style={{
        backgroundColor: colors['bg-primary'],
        color: colors['text-secondary'],
        borderColor: colors['border-secondary'],
        borderWidth: '1px',
      }}
    >
      {text}
    </div>
  );
};

const HelpIcon: React.FC<{ destructive?: boolean; tooltipText?: string }> = ({
  destructive,
  tooltipText,
}) => {
  const colors = useColors();

  return (
    <div className="group relative inline-block ml-1">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
        <g clipPath="url(#clip0_helpIcon)">
          <path
            d="M6.05992 5.99998C6.21665 5.55442 6.52602 5.17872 6.93322 4.9394C7.34042 4.70009 7.81918 4.61261 8.2847 4.69245C8.75022 4.7723 9.17246 5.01433 9.47664 5.37567C9.78081 5.737 9.94729 6.19433 9.94659 6.66665C9.94659 7.99998 7.94659 8.66665 7.94659 8.66665M7.99992 11.3333H8.00659M14.6666 7.99998C14.6666 11.6819 11.6818 14.6666 7.99992 14.6666C4.31802 14.6666 1.33325 11.6819 1.33325 7.99998C1.33325 4.31808 4.31802 1.33331 7.99992 1.33331C11.6818 1.33331 14.6666 4.31808 14.6666 7.99998Z"
            stroke={
              destructive
                ? colors['text-destructive']
                : colors['text-secondary']
            }
            strokeWidth="1.33333"
            strokeLinecap="round"
            strokeLinejoin="round"
          />
        </g>
        <defs>
          <clipPath id="clip0_helpIcon">
            <rect width="16" height="16" fill="white" />
          </clipPath>
        </defs>
      </svg>
      {tooltipText && <Tooltip text={tooltipText} />}
    </div>
  );
};

const ErrorIcon: React.FC<{ tooltipText?: string }> = ({ tooltipText }) => {
  const colors = useColors();

  return (
    <div className="group relative inline-block ml-1">
      <svg
        width="16"
        height="16"
        viewBox="0 0 16 16"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M8 5.33333V8M8 10.6667H8.00667M14.6667 8C14.6667 11.6819 11.6819 14.6667 8 14.6667C4.31811 14.6667 1.33334 11.6819 1.33334 8C1.33334 4.31811 4.31811 1.33334 8 1.33334C11.6819 1.33334 14.6667 4.31811 14.6667 8Z"
          stroke={colors['text-destructive']}
          strokeWidth="1.33333"
          strokeLinecap="round"
          strokeLinejoin="round"
        />
      </svg>
      {tooltipText && <Tooltip text={tooltipText} />}
    </div>
  );
};

// =======================================================
// Main Component
// =======================================================
const TextAreaInput: React.FC<TextAreaInputProps> = ({
  label = '',
  required = false,
  placeholder = '',
  value = '',
  onChange,
  hintText = '',
  helpIcon = false,
  disabled = false,
  errorMessage = '',
  tooltipText = '',
  rows = 4,
  destructive = false,
}) => {
  const [isFocused, setIsFocused] = useState(false);
  const colors = useColors();

  const baseStyles = {
    backgroundColor:
      colors[getInputToken('normal', 'bg', destructive, disabled)],
    color: colors[getInputToken('normal', 'fg', destructive, disabled)],
    borderColor:
      colors[getInputToken('normal', 'border', destructive, disabled)],
  };

  const hoverStyles = {
    backgroundColor:
      colors[getInputToken('hover', 'bg', destructive, disabled)],
    color: colors[getInputToken('hover', 'fg', destructive, disabled)],
    borderColor:
      colors[getInputToken('hover', 'border', destructive, disabled)],
  };

  const focusStyles = {
    backgroundColor:
      colors[getInputToken('focus', 'bg', destructive, disabled)],
    color: colors[getInputToken('focus', 'fg', destructive, disabled)],
    borderColor:
      colors[getInputToken('focus', 'border', destructive, disabled)],
  };

  const labelStyles = {
    color: destructive
      ? colors['input-destructive-label']
      : disabled
        ? colors['input-disabled-label']
        : colors['input-label'],
  };

  const hintStyles = {
    color: destructive
      ? colors['input-destructive-hint']
      : colors['input-hint'],
  };

  return (
    <div className="flex flex-col gap-1.5 w-full">
      {label && (
        <div className="flex gap-2 items-center">
          <span style={labelStyles} className="text-sm font-semibold">
            {label}
          </span>
          {required && (
            <span
              style={{
                color: destructive
                  ? colors['text-destructive']
                  : colors['text-primary'],
              }}
              className="text-sm font-semibold"
            >
              *
            </span>
          )}
        </div>
      )}

      <div
        style={{
          ...baseStyles,
          borderColor: isFocused
            ? colors[getInputToken('focus', 'border', destructive, disabled)]
            : colors[getInputToken('normal', 'border', destructive, disabled)],
          boxShadow: isFocused
            ? destructive
              ? '0px 0px 0px 4px rgba(253, 139, 139, 0.12)'
              : '0px 0px 0px 4px rgba(78,107,215,0.12)'
            : '0px 1px 2px rgba(16, 24, 40, 0.05)',
          zIndex: 0,
        }}
        className="relative flex items-start gap-2 p-3 rounded-lg border transition-all duration-200 hover:bg-[var(--hover-bg)]"
      >
        <textarea
          className="w-full border-none outline-none bg-transparent resize-vertical text-base leading-6 font-inter"
          style={{
            minHeight: `${rows * 24}px`,
            color: colors[getInputToken('normal', 'fg', destructive, disabled)],
            paddingRight: helpIcon || destructive ? '32px' : '14px',
          }}
          placeholder={placeholder}
          value={value}
          onChange={(e) => onChange?.(e.target.value)}
          onFocus={() => setIsFocused(true)}
          onBlur={() => setIsFocused(false)}
          disabled={disabled}
        />
        <div className="absolute top-3 right-3">
          {destructive ? (
            <ErrorIcon tooltipText={errorMessage} />
          ) : (
            helpIcon && (
              <HelpIcon tooltipText={tooltipText} destructive={destructive} />
            )
          )}
        </div>
      </div>

      {(hintText || errorMessage) && (
        <div style={hintStyles} className="text-sm">
          {errorMessage || hintText}
        </div>
      )}
    </div>
  );
};

export default TextAreaInput;
</file>

<file path="app/components/ThemeMigrationTest.tsx">
'use client';

import { useColors, useTheme } from '../theme/hooks';
import { FastThemeToggle } from './FastThemeToggle';

export function ThemeMigrationTest() {
  const colors = useColors();
  const { currentTheme } = useTheme();

  return (
    <div className="p-6 space-y-4">
      <h2 className="text-2xl font-bold" style={{ color: colors['text-primary'] }}>
        Theme Migration Test
      </h2>
      
      <p style={{ color: colors['text-secondary'] }}>
        Current theme: <strong>{currentTheme}</strong>
      </p>
      
      <div className="space-y-2">
        <div 
          className="p-4 rounded-lg border"
          style={{ 
            backgroundColor: colors['bg-secondary'],
            borderColor: colors['border-primary'],
            color: colors['text-primary']
          }}
        >
          Background: bg-secondary, Text: text-primary
        </div>
        
        <div 
          className="p-4 rounded-lg border"
          style={{ 
            backgroundColor: colors['brand-light'],
            borderColor: colors['brand-primary'],
            color: colors['brand-primary']
          }}
        >
          Brand colors test
        </div>
        
        <div 
          className="p-4 rounded-lg border"
          style={{ 
            backgroundColor: colors['error-light'],
            borderColor: colors['error-primary'],
            color: colors['error-primary']
          }}
        >
          Error colors test
        </div>
      </div>
      
      <FastThemeToggle />
      
      <div className="space-y-2">
        <div 
          className="p-4 rounded-lg border"
          style={{ 
            backgroundColor: colors['button-primary-bg'],
            borderColor: colors['button-primary-border'],
            color: colors['button-primary-fg']
          }}
        >
          Button primary colors: {colors['button-primary-bg']}
        </div>
        
        <div 
          className="p-4 rounded-lg border"
          style={{ 
            backgroundColor: colors['input-bg'],
            borderColor: colors['input-border'],
            color: colors['input-fg']
          }}
        >
          Input colors: {colors['input-bg']}
        </div>
        
        <div 
          className="p-4 rounded-lg border"
          style={{ 
            backgroundColor: colors['bg-brand-primary'],
            borderColor: colors['border-brand'],
            color: colors['fg-brand-primary']
          }}
        >
          Brand background + fg: {colors['bg-brand-primary']}
        </div>
      </div>
      
      <div className="mt-6 p-4 bg-green-50 border border-green-200 rounded-lg">
        <h3 className="font-semibold text-green-800"> All Colors Restored!</h3>
        <ul className="mt-2 text-sm text-green-700 space-y-1">
          <li> All 388+ color tokens mapped</li>
          <li> Lightning-fast theme switching</li>
          <li> 100% backward compatibility</li>
          <li> Best of both worlds!</li>
        </ul>
      </div>
    </div>
  );
}
</file>

<file path="app/components/ThemeToggle.tsx">
'use client';

import { useTheme } from '../context/ThemeContext';
import { THEME_TRANSITION_CLASS, NO_TRANSITION_CLASS } from '../theme/utils';

export function ThemeToggle() {
  const { currentTheme, setTheme } = useTheme();

  const toggleTheme = () => {
    setTheme(currentTheme === 'light' ? 'dark' : 'light');
  };

  return (
    <button
      onClick={toggleTheme}
      className={`
        px-4 py-2 rounded-lg border
        ${THEME_TRANSITION_CLASS}
        bg-[var(--button-secondary-bg)]
        text-[var(--button-secondary-fg)]
        border-[var(--button-secondary-border)]
        hover:bg-[var(--button-secondary-bg-hover)]
        hover:text-[var(--button-secondary-fg-hover)]
      `}
    >
      {/* Icon without transitions for better performance */}
      <span className={NO_TRANSITION_CLASS}>
        {currentTheme === 'light' ? '' : ''}
      </span>
      <span className="ml-2">
        Switch to {currentTheme === 'light' ? 'Dark' : 'Light'} Mode
      </span>
    </button>
  );
}
</file>

<file path="app/components/Toast.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { useColors } from '@/app/theme/hooks';

interface ToastProps {
  message: string;
  type: 'success' | 'error' | 'info' | 'warning';
  duration?: number;
  onClose: () => void;
}

const Toast: React.FC<ToastProps> = ({ message, type, duration = 3000, onClose }) => {
  const colors = useColors();
  const [isVisible, setIsVisible] = useState(true);

  useEffect(() => {
    const timer = setTimeout(() => {
      setIsVisible(false);
      setTimeout(onClose, 200); // Wait for animation to complete
    }, duration);

    return () => clearTimeout(timer);
  }, [duration, onClose]);

  const getTypeStyles = () => {
    switch (type) {
      case 'success':
        return {
          backgroundColor: colors['utility-success-50'],
          borderColor: colors['utility-success-200'],
          textColor: colors['utility-success-700'],
          icon: 'check-circle.svg'
        };
      case 'error':
        return {
          backgroundColor: colors['utility-error-50'],
          borderColor: colors['utility-error-200'],
          textColor: colors['utility-error-700'],
          icon: 'x-close.svg'
        };
      case 'warning':
        return {
          backgroundColor: colors['utility-warning-50'],
          borderColor: colors['utility-warning-200'],
          textColor: colors['utility-warning-700'],
          icon: 'alert-triangle.svg'
        };
      case 'info':
      default:
        return {
          backgroundColor: colors['utility-brand-50'],
          borderColor: colors['utility-brand-200'],
          textColor: colors['utility-brand-700'],
          icon: 'info-circle.svg'
        };
    }
  };

  const typeStyles = getTypeStyles();

  return (
    <div
      className={`
        fixed top-4 right-4 z-50 min-w-80 max-w-96 rounded-lg border p-4 shadow-lg
        transform transition-all duration-200 ease-in-out
        ${isVisible ? 'translate-x-0 opacity-100 scale-100' : 'translate-x-full opacity-0 scale-95'}
      `}
      style={{
        backgroundColor: typeStyles.backgroundColor,
        borderColor: typeStyles.borderColor,
      }}
    >
      <div className="flex items-start gap-3">
        <div className="flex-shrink-0">
          <img
            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/icons/${typeStyles.icon}`}
            alt={type}
            className="w-5 h-5"
            style={{ filter: `hue-rotate(${type === 'success' ? '90deg' : type === 'error' ? '0deg' : '45deg'})` }}
          />
        </div>
        <div className="flex-1">
          <p
            className="text-sm font-medium"
            style={{ color: typeStyles.textColor }}
          >
            {message}
          </p>
        </div>
        <button
          onClick={() => {
            setIsVisible(false);
            setTimeout(onClose, 200);
          }}
          className="flex-shrink-0 p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors"
        >
          <img
            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/icons/x-close.svg`}
            alt="Close"
            className="w-4 h-4 opacity-60 hover:opacity-100"
          />
        </button>
      </div>
    </div>
  );
};

export default Toast;
</file>

<file path="app/components/ToastContainer.tsx">
'use client';

import React from 'react';
import Toast from './Toast';
import { useToast } from '@/app/hooks/useToast';

const ToastContainer: React.FC = () => {
  const { toasts, removeToast } = useToast();

  return (
    <div className="fixed top-4 right-4 z-50 space-y-2">
      {toasts.map((toast, index) => (
        <div
          key={toast.id}
          style={{
            transform: `translateY(${index * 8}px)`,
            zIndex: 50 - index,
          }}
        >
          <Toast
            message={toast.message}
            type={toast.type}
            duration={toast.duration}
            onClose={() => removeToast(toast.id)}
          />
        </div>
      ))}
    </div>
  );
};

export default ToastContainer;
</file>

<file path="app/components/Tooltip.tsx">
import React from 'react';

interface TooltipProps {
  text: string;
  visible: boolean;
}

const Tooltip: React.FC<TooltipProps> = ({ text, visible }) => {
  if (!visible) return null;

  return (
    <div className="absolute -top-12 left-1/2 transform -translate-x-1/2 flex flex-col items-center">
      {/* Content */}
      <div 
        className="px-2 py-1 rounded-lg text-white text-[10px] font-semibold leading-[18px] whitespace-nowrap"
        style={{ 
          backgroundColor: '#4761C4',
          boxShadow: '0px 4px 6px -2px rgba(16, 24, 40, 0.03), 0px 12px 16px -4px rgba(16, 24, 40, 0.08)',
          fontFamily: 'Inter'
        }}
      >
        {text}
      </div>
      {/* Tooltip Arrow */}
      <div 
        className="w-0 h-0 border-l-[6px] border-l-transparent border-r-[6px] border-r-transparent border-t-[6px]"
        style={{ borderTopColor: '#4761C4' }}
      />
    </div>
  );
};

export default Tooltip;
</file>

<file path="app/context/ThemeContext.tsx">
'use client';

import { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { ThemeContextType, ThemeMode, ButtonTokens, InputTokens, BreadcrumbTokens, IconTokens } from '../theme/types';
import { themeRegistry } from '../theme/registry';
import { lightTheme } from '../theme/themes/light';
import { darkTheme } from '../theme/themes/dark';

// Initialize themes
themeRegistry.register(lightTheme);
themeRegistry.register(darkTheme);

export const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [currentTheme, setCurrentTheme] = useState<ThemeMode>('light');
  const [isInitialized, setIsInitialized] = useState(false);

  // Apply CSS variables directly to document root (much faster than inline styles)
  const applyThemeVariables = useCallback((theme: ThemeMode) => {
    const themeData = themeRegistry.get(theme);
    const root = document.documentElement;
    
    // Apply variables in batch for better performance
    Object.entries(themeData.tokens.colors).forEach(([key, value]) => {
      root.style.setProperty(`--${key}`, value);
    });
  }, []);

  const getCssVariable = useCallback((token: keyof (ButtonTokens & InputTokens & BreadcrumbTokens & IconTokens)): string => {
    return `var(--${token})`;
  }, []);

  const setTheme = useCallback((mode: ThemeMode) => {
    if (themeRegistry.exists(mode)) {
      // Temporarily disable transitions for instant switching
      const root = document.documentElement;
      root.style.setProperty('--theme-transition-duration', '0ms');
      
      setCurrentTheme(mode);
      applyThemeVariables(mode);
      localStorage.setItem('theme-mode', mode);
      
      // Re-enable transitions after DOM updates
      requestAnimationFrame(() => {
        root.style.setProperty('--theme-transition-duration', '150ms');
      });
    }
  }, [applyThemeVariables]);

  useEffect(() => {
    // Check system preference and saved theme
    const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const savedTheme = localStorage.getItem('theme-mode') as ThemeMode;
    
    let initialTheme: ThemeMode = 'light';
    if (savedTheme && themeRegistry.exists(savedTheme)) {
      initialTheme = savedTheme;
    } else if (systemPrefersDark) {
      initialTheme = 'dark';
    }
    
    setCurrentTheme(initialTheme);
    applyThemeVariables(initialTheme);

    // Add optimized transition styles
    const style = document.createElement('style');
    style.id = 'theme-transitions';
    style.textContent = `
      :root {
        --theme-transition-duration: 150ms;
      }
      
      /* Only transition essential elements for better performance */
      body,
      .theme-transition,
      [data-theme-transition="true"] {
        transition: 
          background-color var(--theme-transition-duration) ease,
          color var(--theme-transition-duration) ease,
          border-color var(--theme-transition-duration) ease;
      }
      
      /* Exclude performance-sensitive elements */
      svg, svg *,
      canvas,
      video,
      [data-no-transition="true"],
      .no-transition {
        transition: none !important;
      }
      
      /* Optimize icon transitions */
      [class*="icon"], [class*="Icon"] {
        transition: color 50ms ease !important;
      }
    `;
    
    // Remove existing style if it exists
    const existingStyle = document.getElementById('theme-transitions');
    if (existingStyle) {
      existingStyle.remove();
    }
    
    document.head.appendChild(style);
    setIsInitialized(true);

    return () => {
      const styleElement = document.getElementById('theme-transitions');
      if (styleElement) {
        styleElement.remove();
      }
    };
  }, [applyThemeVariables]);

  useEffect(() => {
    if (!isInitialized) return;
    
    // Update document class for CSS-based theming
    const root = document.documentElement;
    root.classList.remove('light', 'dark');
    root.classList.add(currentTheme);
  }, [currentTheme, isInitialized]);

  const value: ThemeContextType = {
    currentTheme,
    themes: themeRegistry.getAllThemes(),
    setTheme,
    getCssVariable,
  };

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
}
</file>

<file path="app/dashboard/components/BillingInfoForm.tsx">
'use client';

import React, { useState } from 'react';
import { useColors } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';
import { toast } from 'sonner';
import useSWR from 'swr';

interface BillingInfoFormProps {
  workspaceId: number;
  isFreePlan: boolean;
}

interface BillingInfo {
  billing_email: string;
  billing_address?: string;
  address_line1: string;
  address_line2?: string;
  city: string;
  state?: string;
  postal_code: string;
  country_code: string;
  tax_rate: number;
  vat_number?: string;
  payment_method?: {
    brand: string;
    last4: string;
    expiry_month: number;
    expiry_year: number;
  };
}

const fetcher = (url: string) => fetch(url).then(res => res.json());

const formatCountryCode = (countryCode: string | undefined): string => {
  if (!countryCode) return '';
  try {
    return new Intl.DisplayNames(['en'], { type: 'region' }).of(countryCode) || countryCode;
  } catch (error) {
    console.error('Error formatting country code:', error);
    return countryCode;
  }
};

const formatExpiryDate = (month?: number, year?: number): string => {
  if (!month || !year) return '';
  return `${String(month).padStart(2, '0')}/${String(year).slice(-2)}`;
};

const capitalize = (str: string): string => {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

export default function BillingInfoForm({ workspaceId, isFreePlan }: BillingInfoFormProps) {
  const colors = useColors();
  const [isLoading, setIsLoading] = useState(false);

  const { data: billingData, error, mutate } = useSWR<BillingInfo>(
    `/api/billing-info?workspaceId=${workspaceId}`,
    fetcher,
    {
      revalidateOnFocus: false,
      revalidateOnReconnect: false,
      dedupingInterval: 5000,
      errorRetryCount: 3,
      errorRetryInterval: 2000,
      shouldRetryOnError: (err) => {
        return !err.status || err.status >= 500;
      },
      onError: (err) => {
        console.error('Error fetching billing info:', err);
        toast.error('Failed to fetch billing details', {
          description: err instanceof Error ? err.message : 'Please try again later',
        });
      }
    }
  );

  const handleEditClick = async () => {
    try {
      setIsLoading(true);

      const response = await fetch('/api/stripe/customer-portal', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ workspaceId }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to access billing portal');
      }

      // Trigger a revalidation before redirecting
      await mutate();
      
      // Redirect to Stripe Customer Portal
      window.location.href = data.url;
    } catch (error) {
      console.error('Error accessing billing portal:', error);
      toast.error('Failed to Access Portal', {
        description: error instanceof Error ? error.message : 'An unexpected error occurred',
      });
    } finally {
      setIsLoading(false);
    }
  };

  if (error) {
    return (
      <div style={{ color: colors['text-error'] }} className="p-4">
        Failed to load billing information. Please try again later.
      </div>
    );
  }

  const renderSection = (title: string, content: React.ReactNode) => (
    <div className="flex flex-col gap-2">
      <h3 style={{ color: colors['text-primary'] }} className="text-lg font-semibold">
        {title}
      </h3>
      {content}
    </div>
  );

  return (
    <div 
      style={{ 
        backgroundColor: colors['bg-secondary'],
        borderColor: colors['border-secondary']
      }}
      className="w-full rounded-xl border relative"
    >
      {!isFreePlan && (
        <div className="absolute top-4 right-4">
          <ButtonNormal
            onClick={handleEditClick}
            variant="secondary"
            size="small"
            disabled={isLoading}
          >
            {isLoading ? 'Loading...' : 'Edit Billing Details'}
          </ButtonNormal>
        </div>
      )}

      <div className="p-6 flex flex-col gap-6">
        {/* Billing Address Section */}
        {renderSection(
          "Billing Address",
          <div className="flex flex-col gap-1">
            <h4 
              style={{ color: colors['text-primary'] }}
              className="text-base font-medium"
            >
              {billingData?.billing_email || 'No email provided'}
            </h4>
            <p 
              style={{ color: colors['text-tertiary'] }}
              className="text-sm whitespace-pre-line"
            >
              {[
                billingData?.address_line1,
                billingData?.address_line2,
                [
                  billingData?.city,
                  billingData?.state,
                  billingData?.postal_code
                ].filter(Boolean).join(', '),
                formatCountryCode(billingData?.country_code)
              ].filter(Boolean).join('\n')}
            </p>
          </div>
        )}

      </div>
    </div>
  );
}
</file>

<file path="app/dashboard/components/CanvaHeader.tsx">
import { Folder } from '@/types/workspace';
import ButtonNormal from '../../components/ButtonNormal';
import { useColors } from '@/app/theme/hooks';

interface CanvaHeaderProps {
  openCreateFlow: () => void;
  selectedFolder?: Folder;
  currentView: 'grid' | 'table';
  onViewChange: (view: 'grid' | 'table') => void;
}

export default function CanvaHeader({
  openCreateFlow,
  selectedFolder,
  currentView,
  onViewChange,
}: CanvaHeaderProps) {
  const colors = useColors();

  const getFolderIcon = () => {
    if (selectedFolder?.icon_url) {
      // Display the icon_url if it exists
      return selectedFolder.icon_url.startsWith(
        'https://cdn.brandfetch.io/'
      ) ? (
        <img
          src={selectedFolder.icon_url}
          alt="Folder Icon"
          className="w-6 h-6"
        />
      ) : (
        <img
          src={`${selectedFolder.signedIconUrl}`}
          alt="Folder Icon"
          className="w-6 h-6"
        />
      );
    } else if (selectedFolder?.emote) {
      // Display the emote if icon_url does not exist
      return <div className="text-2xl">{selectedFolder.emote}</div>;
    } else {
      // Default folder icon if neither icon_url nor emote exist
      return (
        <img
          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon-base.svg`}
          alt="Default Folder Icon"
          className="w-6 h-6"
        />
      );
    }
  };

  return (
    <div
      style={{
        borderColor: colors['border-secondary'],
      }}
      className="w-full h-[68px] py-5 px-8 justify-between items-center inline-flex border-b"
    >
      <div className="justify-start items-center gap-4 flex transition-all duration-200 hover:scale-[1.02]">
        {/* Dynamically display folder icon or default flows icon */}
        {selectedFolder ? (
          getFolderIcon()
        ) : (
          <img
            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/layers-icon.svg`}
            alt="Flows icon"
            className="w-6 h-6"
          />
        )}

        {/* Display selected folder name or "My Flows" */}
        <div
          style={{ color: colors['text-primary'] }}
          className="text-2xl font-medium font-['Inter'] leading-loose"
        >
          {selectedFolder ? selectedFolder.name : 'My Flows'}
        </div>
      </div>
      <div className="hidden justify-end items-center gap-2">
        {/* Import Process Button */}
        <ButtonNormal
          variant="secondary"
          size="small"
          leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/upload-01.svg`}
          className="hidden"
        >
          Import a process
        </ButtonNormal>
        {/* New Process Button */}
        <ButtonNormal
          variant="primary"
          size="small"
          leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/white-plus.svg`}
          onClick={openCreateFlow}
          className="hidden"
        >
          New Flow
        </ButtonNormal>
      </div>
    </div>
  );
}
</file>

<file path="app/dashboard/components/Canvas.tsx">
'use client';

import { Folder, Workspace } from '@/types/workspace';
import React from 'react';
import CanvaHeader from './CanvaHeader';
import WorkflowCard from './WorkflowCard';
import { Workflow, WorkflowStatus } from '@/types/workflow';
import ButtonNormal from '@/app/components/ButtonNormal';
import { useColors } from '@/app/theme/hooks';
import SkeletonCard from '@/app/components/SkeletonCard';
import SkeletonWorkflowCard from '@/app/components/SkeletonWorkflowCard';

interface CanvasProps {
  workspace: Workspace;
  openCreateFlow: () => void;
  onSelectWorkflow: (w: Workflow) => void;
  onDeleteWorkflow: () => void;
  onEditWorkflow: () => void;
  onDuplicateWorkflow: () => void;
  onMoveWorkflow: () => void;
  onStatusChange: (workflow: Workflow, newStatus: WorkflowStatus) => void;
  selectedFolder?: Folder;
  searchTerm?: string;
  currentView: 'grid' | 'table';
  onViewChange: (view: 'grid' | 'table') => void;
  isLoading?: boolean;
}

const Canvas: React.FC<CanvasProps> = React.memo(({
  workspace,
  selectedFolder,
  openCreateFlow,
  onSelectWorkflow,
  onDeleteWorkflow,
  onEditWorkflow,
  onDuplicateWorkflow,
  onMoveWorkflow,
  onStatusChange,
  searchTerm = '',
  currentView,
  onViewChange,
  isLoading = false,
}) => {
  const colors = useColors();

  // Filter workflows based on selectedFolder and searchTerm
  const workflowsToDisplay = workspace.workflows.filter((workflow) => {
    const matchesFolder = selectedFolder
      ? workflow.folder_id === selectedFolder.id
      : true;
    const matchesSearch = workflow.name
      .toLowerCase()
      .includes(searchTerm.toLowerCase());
    return matchesFolder && matchesSearch;
  });

  // Sort workflows by last_opened (recently used first)
  const recentlyUsedWorkflows = [...workflowsToDisplay]
    .filter((workflow) => workflow.last_opened) // Ensure last_opened exists
    .sort(
      (a, b) =>
        new Date(b.last_opened!).getTime() - new Date(a.last_opened!).getTime()
    )
    .slice(0, 4); // Get the top 4 most recent workflows

  return (
    <div 
      style={{ backgroundColor: colors['bg-secondary'] }}
      className="flex flex-col flex-1 w-full h-full"
    >
      <CanvaHeader
        openCreateFlow={openCreateFlow}
        selectedFolder={selectedFolder}
        currentView={currentView}
        onViewChange={onViewChange}
      />

      <div className="flex-1 overflow-y-auto px-8 py-4 pb-40">
        {recentlyUsedWorkflows.length > 0 && (
          <div className="mb-6">
            <h2 
              style={{ color: colors['text-primary'] }}
              className="text-xl font-medium mb-4"
            >
              Recently Used
            </h2>
            {currentView === 'grid' ? (
              <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                {isLoading ? (
                  Array.from({ length: 4 }).map((_, index) => (
                    <SkeletonWorkflowCard key={index} />
                  ))
                ) : recentlyUsedWorkflows.length === 0 ? (
                  <div 
                    style={{ color: colors['text-secondary'] }}
                    className="col-span-full text-center py-8"
                  >
                    No recently used workflows
                  </div>
                ) : (
                  recentlyUsedWorkflows.map((workflow) => (
                    <WorkflowCard
                      key={workflow.id}
                      workflow={workflow}
                      workspace={workspace}
                      onSelectWorkflow={onSelectWorkflow}
                      onDuplicateWorkflow={onDuplicateWorkflow}
                      onDeleteWorkflow={onDeleteWorkflow}
                      onEditWorkflow={onEditWorkflow}
                      onMoveWorkflow={onMoveWorkflow}
                      onStatusChange={onStatusChange}
                    />
                  ))
                )}
              </div>
            ) : (
              <div 
                style={{ 
                  backgroundColor: colors['bg-primary'],
                  borderColor: colors['border-primary']
                }}
                className="flex flex-col h-min rounded-lg overflow-hidden border"
              >
                <div 
                  style={{ color: colors['text-secondary'] }}
                  className="grid grid-cols-12 gap-4 px-4 py-2 text-sm font-medium"
                >
                  <div className="col-span-3">Name</div>
                  <div className="col-span-3">Tags</div>
                  <div className="col-span-2">Steps</div>
                  <div className="col-span-2">Assignee</div>
                  <div className="col-span-1">Last Used</div>
                  <div className="col-span-1"></div>
                </div>
                <div style={{ backgroundColor: colors['border-primary'] }} className="h-[1px] w-full" />
                {recentlyUsedWorkflows.map((workflow, index) => (
                  <React.Fragment key={workflow.id}>
                    <div 
                      style={{ backgroundColor: colors['bg-primary'] }}
                      className="grid grid-cols-12 px-4 py-3 hover:bg-opacity-80 transition-colors"
                    >
                      <div className="col-span-3 flex items-center gap-3">
                        <div className="w-8 h-8 flex items-center justify-center bg-[#12B76A] rounded-lg">
                          <img
                            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/command.svg`}
                            alt="Workflow icon"
                            className="w-4 h-4"
                          />
                        </div>
                        <div className="flex flex-col">
                          <span style={{ color: colors['text-primary'] }} className="font-medium">
                            {workflow.name}
                          </span>
                          <span style={{ color: colors['text-secondary'] }} className="text-sm">
                            {workflow.description}
                          </span>
                        </div>
                      </div>
                      <div className="col-span-3 flex items-center gap-2">
                        <span 
                          style={{ 
                            backgroundColor: colors['bg-secondary'],
                            color: colors['text-secondary']
                          }}
                          className="px-2 py-1 rounded-md text-sm"
                        >
                          Human Resources
                        </span>
                        <span 
                          style={{ 
                            backgroundColor: colors['bg-secondary'],
                            color: colors['text-secondary']
                          }}
                          className="px-2 py-1 rounded-md text-sm"
                        >
                          Engineering
                        </span>
                      </div>
                      <div style={{ color: colors['text-secondary'] }} className="col-span-2 flex items-center">
                        6 Steps
                      </div>
                      <div className="col-span-2 flex items-center gap-2">
                        <div className="w-6 h-6 rounded-full bg-gray-200" />
                        <span style={{ color: colors['text-secondary'] }}>Maxime Togbe</span>
                      </div>
                      <div style={{ color: colors['text-tertiary'] }} className="col-span-1 flex items-center">
                        2 hours ago
                      </div>
                      <div className="col-span-1 flex justify-center pl-16 items-center">
                        <img src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dots-vertical.svg`} alt="Actions" className="w-5 h-5" />
                      </div>
                    </div>
                    {index < recentlyUsedWorkflows.length - 1 && (
                      <div style={{ backgroundColor: colors['border-primary'] }} className="h-[1px] w-full" />
                    )}
                  </React.Fragment>
                ))}
              </div>
            )}
          </div>
        )}

        <div>
          <h2 
            style={{ color: colors['text-primary'] }}
            className="text-xl font-medium mb-4"
          >
            All Workflows
          </h2>
          {currentView === 'grid' ? (
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
              {isLoading ? (
                Array.from({ length: 8 }).map((_, index) => (
                  <SkeletonWorkflowCard key={index} />
                ))
              ) : workflowsToDisplay.length === 0 ? (
                <div 
                  style={{ color: colors['text-secondary'] }}
                  className="col-span-full text-center py-12"
                >
                  {selectedFolder ? 
                    `No workflows in "${selectedFolder.name}" folder` : 
                    searchTerm ? 
                      `No workflows found for "${searchTerm}"` : 
                      'No workflows found'
                  }
                </div>
              ) : (
                workflowsToDisplay.map((workflow) => (
                  <WorkflowCard
                    key={workflow.id}
                    workflow={workflow}
                    workspace={workspace}
                    onSelectWorkflow={onSelectWorkflow}
                    onDuplicateWorkflow={onDuplicateWorkflow}
                    onDeleteWorkflow={onDeleteWorkflow}
                    onEditWorkflow={onEditWorkflow}
                    onMoveWorkflow={onMoveWorkflow}
                    onStatusChange={onStatusChange}
                  />
                ))
              )}
            </div>
          ) : (
            <div 
              style={{ 
                backgroundColor: colors['bg-primary'],
                borderColor: colors['border-primary']
              }}
              className="flex flex-col h-min rounded-lg overflow-hidden border"
            >
              <div 
                style={{ color: colors['text-secondary'] }}
                className="grid grid-cols-12 gap-4 px-4 py-2 text-sm font-medium justify-between"
              >
                <div className="col-span-3">Name</div>
                <div className="col-span-3">Tags</div>
                <div className="col-span-2">Steps</div>
                <div className="col-span-2">Assignee</div>
                <div className="col-span-1">Last Used</div>
                <div className="col-span-1"></div>
              </div>
              <div style={{ backgroundColor: colors['border-primary'] }} className="h-[1px] w-full" />
              {workflowsToDisplay.map((workflow, index) => (
                <React.Fragment key={workflow.id}>
                  <div 
                    style={{ backgroundColor: colors['bg-primary'] }}
                    className="grid grid-cols-12 px-4 py-3 hover:bg-opacity-80 transition-colors"
                  >
                    <div className="col-span-3 flex items-center gap-3">
                      <div className="flex flex-col">
                        <span style={{ color: colors['text-primary'] }} className="font-medium">
                          {workflow.name}
                        </span>
                      </div>
                    </div>
                    <div className="col-span-3 flex items-center gap-2">
                      <span 
                        style={{ 
                          backgroundColor: colors['bg-secondary'],
                          color: colors['text-secondary']
                        }}
                        className="px-2 py-1 rounded-md text-sm"
                      >
                        Human Resources
                      </span>
                      <span 
                        style={{ 
                          backgroundColor: colors['bg-secondary'],
                          color: colors['text-secondary']
                        }}
                        className="px-2 py-1 rounded-md text-sm"
                      >
                        Engineering
                      </span>
                    </div>
                    <div style={{ color: colors['text-secondary'] }} className="col-span-2 flex items-center">
                      6 Steps
                    </div>
                    <div className="col-span-2 flex items-center gap-2">
                      <div className="w-6 h-6 rounded-full bg-gray-200" />
                      <span style={{ color: colors['text-secondary'] }}>{workflow.workspaceId}</span>
                    </div>
                    <div style={{ color: colors['text-tertiary'] }} className="col-span-1 flex items-center">
                      2 hours ago
                    </div>
                    <div className="col-span-1 pl-16 flex justify-center items-center">
                      <ButtonNormal
                        variant="secondary"
                        size="small"
                        iconOnly
                        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dots-vertical.svg`}
                        className="border-none bg-transparent"
                      >
                      </ButtonNormal>
                    </div>
                  </div>
                  {index < workflowsToDisplay.length - 1 && (
                    <div style={{ backgroundColor: colors['border-primary'] }} className="h-[1px] w-full" />
                  )}
                </React.Fragment>
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
});

export default Canvas;
</file>

<file path="app/dashboard/components/ConfirmChangePasswordModal.tsx">
// components/ConfirmChangePasswordModal.tsx
import React from 'react';
import { useColors } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';

interface ConfirmChangePasswordModalProps {
  onCancel: () => void;
  onChangePassword: () => void;
}

const ConfirmChangePasswordModal: React.FC<ConfirmChangePasswordModalProps> = ({
  onCancel,
  onChangePassword,
}) => {
  const colors = useColors();
  
  return (
    <div className="fixed inset-0 flex justify-center items-center p-8 z-50">
      {/* Backdrop */}
      <div className="absolute inset-0">
        <div 
          style={{ backgroundColor: colors['bg-overlay'] }}
          className="absolute inset-0 opacity-70" 
        />
      </div>

      {/* Modal Card */}
      <div 
        style={{ backgroundColor: colors['bg-primary'] }}
        className="relative w-[480px] h-[260px] rounded-xl shadow-lg flex flex-col overflow-hidden z-10"
      >
        {/* Icon placeholder */}
        <div className="w-[336px] h-[336px] relative" />

        {/* Title & Description */}
        <div className="flex flex-col justify-start items-start px-6 pt-6 gap-4">
          <div 
            style={{ 
              backgroundColor: colors['bg-secondary'],
              borderColor: colors['border-secondary']
            }}
            className="w-12 h-12 p-3 rounded-[10px] border shadow-sm flex justify-center items-center"
          >
            <div className="w-6 h-6 relative">
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/lock-icon.svg`}
                alt="Upload Icon"
                className="w-6 h-6 object-contain"
              />
            </div>
          </div>
          <div className="flex flex-col justify-start items-start gap-1">
            <div 
              style={{ color: colors['text-primary'] }}
              className="text-lg font-semibold font-['Inter'] leading-7"
            >
              Confirm change password
            </div>
            <div 
              style={{ color: colors['text-secondary'] }}
              className="text-sm font-normal font-['Inter'] leading-tight"
            >
              If you change your password, your account will be signed out on
              all other devices.
            </div>
          </div>
        </div>

        {/* Buttons */}
        <div className="flex justify-start items-center px-6 pb-6 pt-8 gap-3">
          {/* Cancel Button */}
          <ButtonNormal
            variant="secondary"
            onClick={onCancel}
            className="flex-grow"
          >
            Cancel
          </ButtonNormal>

          {/* Change Password Button */}
          <ButtonNormal
            variant="primary"
            onClick={onChangePassword}
            className="flex-grow"
          >
            Change password
          </ButtonNormal>
        </div>
      </div>
    </div>
  );
};

export default ConfirmChangePasswordModal;
</file>

<file path="app/dashboard/components/ConfirmDeleteFlowModal.tsx">
'use client';

import { Workflow } from '@/types/workflow';
import { createDeleteConfirmationModal } from '@/app/utils/modalPatterns';
import { useState } from 'react';

interface ConfirmDeleteModalProps {
  onClose: () => void;
  onDelete: (workflowId: number) => Promise<void>;
  selectedWorkflow: Workflow;
}

export default function ConfirmDeleteFlowModal({
  onClose,
  onDelete,
  selectedWorkflow,
}: ConfirmDeleteModalProps) {
  const [isLoading, setIsLoading] = useState(false);
  // Use the pattern function to create the modal
  return createDeleteConfirmationModal({
    title: 'Confirm delete',
    message:
      'Are you sure you want to delete this Flow? This action cannot be undone.',
    itemType: 'flow',
    onDelete: async () => {
      setIsLoading(true);
      await onDelete(selectedWorkflow.id);
      setIsLoading(false);
      onClose();
    },
    onClose: onClose,
    isLoading: isLoading,
  });
}
</file>

<file path="app/dashboard/components/ConfirmDeleteFolderModal.tsx">
'use client';

import { createDeleteConfirmationModal } from '@/app/utils/modalPatterns';

interface ConfirmDeleteModalProps {
  onClose: () => void;
  onDelete: () => Promise<void>;
}

export default function ConfirmDeleteFolderModal({
  onClose,
  onDelete,
}: ConfirmDeleteModalProps) {
  // Use the pattern function to create the modal
  return createDeleteConfirmationModal({
    title: 'Confirm delete',
    message: 'Are you sure you want to delete this folder? This action cannot be undone. The flows inside will not be deleted.',
    itemType: 'folder',
    onDelete: async () => {
      await onDelete();
      onClose();
    },
    onClose: onClose
  });
}
</file>

<file path="app/dashboard/components/CreateWorkspaceModal.tsx">
import React, { useState, useEffect, useRef } from 'react';
import ButtonNormal from '@/app/components/ButtonNormal';
import InputField from '@/app/components/InputFields';
import { useColors } from '@/app/theme/hooks';

interface CreateWorkspaceModalProps {
  onClose: () => void;
  onCreateWorkspace: (workspaceData: {
    name: string;
    logo?: File;
    url: string;
  }) => void;
}

export default function CreateWorkspaceModal({
  onClose,
  onCreateWorkspace,
}: CreateWorkspaceModalProps) {
  const [workspaceName, setWorkspaceName] = useState('');
  const [workspaceUrl, setWorkspaceUrl] = useState('');
  const [logoFile, setLogoFile] = useState<File | null>(null);
  const [logoPreview, setLogoPreview] = useState<string | null>(null);
  const [urlPlaceholder, setUrlPlaceholder] = useState('acmecorp');
  const [isLoading, setIsLoading] = useState(false);
  const colors = useColors();
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Update URL placeholder when workspace name changes
  useEffect(() => {
    if (workspaceName) {
      // Convert workspace name to lowercase, replace spaces with hyphens, and remove special characters
      const suggestedUrl = workspaceName
        .toLowerCase()
        .replace(/\s+/g, '-')
        .replace(/[^a-z0-9-]/g, '');
      
      setUrlPlaceholder(suggestedUrl || 'acmecorp');
    } else {
      setUrlPlaceholder('acmecorp');
    }
  }, [workspaceName]);

  // Handle file upload when user selects a file
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setLogoFile(file);
      const reader = new FileReader();
      reader.onloadend = () => {
        setLogoPreview(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  };

  const handleLogoClick = () => {
    fileInputRef.current?.click();
  };

  // Clean up preview URL on unmount
  useEffect(() => {
    return () => {
      if (logoPreview && logoPreview.startsWith('blob:')) {
        URL.revokeObjectURL(logoPreview);
      }
    };
  }, [logoPreview]);

  const handleSubmit = () => {
    setIsLoading(true);
    
    onCreateWorkspace({
      name: workspaceName,
      logo: logoFile || undefined,
      url: workspaceUrl || urlPlaceholder, // Use placeholder as fallback if no URL is entered
    });
    
    // Note: we don't set isLoading to false here because the component will be unmounted
    // when the modal is closed after successful creation
  };

  // Prevent background clicks from closing the modal
  const handleModalClick = (e: React.MouseEvent) => {
    // Stop the click from reaching the backdrop
    e.stopPropagation();
  };

  return (
    <div 
      className="fixed inset-0 flex items-center justify-center p-8 z-50"
      onClick={onClose}
    >
      {/* Backdrop */}
      <div className="absolute inset-0">
        <div 
          style={{ backgroundColor: colors['bg-overlay'] }}
          className="absolute inset-0 opacity-70" 
        />
      </div>

      <div 
        className="rounded-xl shadow-lg w-[480px] flex flex-col relative z-10"
        style={{ backgroundColor: colors['bg-primary'] }}
        onClick={handleModalClick}
      >
        {/* Header */}
        <div className="flex flex-col items-start gap-4 px-6 pt-6">
          <div 
            className="w-12 h-12 p-3 rounded-[10px] border shadow-sm flex items-center justify-center"
            style={{ 
              backgroundColor: colors['bg-primary'],
              borderColor: colors['border-secondary']
            }}
          >
            <img
              src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon.svg`}
              alt="Workspace icon"
              className="w-6 h-6"
            />
          </div>
          <div className="flex flex-col gap-1">
            <h2 
              className="text-lg font-semibold"
              style={{ color: colors['text-primary'] }}
            >
              Create a new workspace
            </h2>
            <p 
              className="text-sm"
              style={{ color: colors['text-secondary'] }}
            >
              Add your workspace information here
            </p>
          </div>
        </div>

        {/* Form */}
        <div className="p-6 flex flex-col gap-6">
          {/* Workspace Name */}
          <InputField
            type="icon-leading"
            label="Workspace Name"
            placeholder="e.g. Acme Corp"
            value={workspaceName}
            onChange={setWorkspaceName}
          />

          {/* Workspace Logo */}
          <div className="flex flex-col gap-1.5">
            <label 
              className="text-sm font-medium"
              style={{ color: colors['text-primary'] }}
            >
              Workspace Logo
            </label>
            <div className="flex items-center gap-3">
              <input
                type="file"
                ref={fileInputRef}
                onChange={handleFileChange}
                accept="image/svg+xml,image/png,image/jpeg,image/gif"
                className="hidden"
              />
              <div 
                className="relative group cursor-pointer"
                onClick={handleLogoClick}
              >
                {logoPreview ? (
                  <div className="relative">
                    <div 
                      style={{ 
                        backgroundImage: `url(${logoPreview})`,
                        backgroundSize: 'cover',
                        backgroundPosition: 'center',
                        backgroundRepeat: 'no-repeat',
                        width: '64px',
                        height: '64px',
                        borderRadius: '8px',
                        border: `2px solid ${colors['border-secondary']}`,
                      }}
                      className="shadow-sm"
                    />
                    {/* Edit overlay on hover */}
                    <div className="absolute inset-0 bg-black bg-opacity-40 rounded-lg opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex items-center justify-center">
                      <div className="w-8 h-8 bg-white bg-opacity-20 rounded-full flex items-center justify-center">
                        <img
                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                          alt="Edit"
                          className="w-5 h-5 brightness-[10]"
                        />
                      </div>
                    </div>
                  </div>
                ) : (
                  <div 
                    className="w-16 h-16 rounded-lg flex items-center justify-center"
                    style={{ backgroundColor: colors['bg-secondary'] }}
                  >
                    <img
                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/upload-01.svg`}
                      alt="Upload"
                      className="w-6 h-6"
                    />
                  </div>
                )}
              </div>
              <div className="flex-1">
                <div 
                  className="px-4 py-3 border rounded-lg text-center cursor-pointer transition-colors duration-200"
                  style={{ 
                    borderColor: colors['border-secondary'],
                    backgroundColor: colors['bg-primary'],
                    '--hover-bg': colors['bg-secondary']
                  } as React.CSSProperties}
                  onClick={handleLogoClick}
                >
                  <span style={{ color: colors['text-accent'] }} className="text-sm font-semibold">Click to upload</span>
                  <span style={{ color: colors['text-secondary'] }} className="text-sm"> or drag and drop</span>
                  <p style={{ color: colors['text-secondary'] }} className="text-sm">SVG, PNG, JPG or GIF (max. 800400px)</p>
                </div>
              </div>
            </div>
          </div>

          {/* Workspace URL */}
          <div className="flex flex-col gap-1.5">
            <label 
              className="text-sm font-medium"
              style={{ color: colors['text-primary'] }}
            >
              Workspace URL
            </label>
            <div className="flex">
              <span 
                className="px-3.5 py-2.5 border border-r-0 rounded-l-lg"
                style={{ 
                  backgroundColor: colors['bg-secondary'],
                  borderColor: colors['border-secondary'],
                  color: colors['text-primary']
                }}
              >
                app.process-flow.io/
              </span>
              <input
                type="text"
                placeholder={urlPlaceholder}
                value={workspaceUrl}
                onChange={(e) => setWorkspaceUrl(e.target.value)}
                className="flex-1 px-3.5 py-2.5 border rounded-r-lg transition-all duration-200"
                style={{ 
                  backgroundColor: colors['bg-primary'],
                  borderColor: colors['border-secondary'],
                  color: colors['text-primary'],
                  outline: 'none',
                }}
                onFocus={(e) => {
                  e.target.style.borderColor = colors['border-focus'];
                  e.target.style.boxShadow = "0px 0px 0px 4px rgba(78,107,215,0.12)";
                }}
                onBlur={(e) => {
                  e.target.style.borderColor = colors['border-secondary'];
                  e.target.style.boxShadow = "0px 1px 2px rgba(16, 24, 40, 0.05)";
                }}
              />
            </div>
          </div>
        </div>

        {/* Footer */}
        <div 
          className="flex gap-3 p-6 border-t"
          style={{ borderColor: colors['border-secondary'] }}
        >
          <ButtonNormal
            variant="secondary"
            size="small"
            className="flex-1"
            onClick={onClose}
            disabled={isLoading}
          >
            Cancel
          </ButtonNormal>
          <ButtonNormal
            variant="primary"
            size="small"
            className="flex-1"
            onClick={handleSubmit}
            disabled={!workspaceName || isLoading}
          >
            {isLoading ? (
              <div className="flex items-center gap-2">
                <div className="animate-spin rounded-full h-3 w-3 border-2 border-t-transparent border-r-transparent"></div>
                <span>Creating...</span>
              </div>
            ) : 'Create workspace'}
          </ButtonNormal>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/dashboard/components/FolderDropdown.tsx">
import { Folder } from '@/types/workspace';
import { useColors } from '@/app/theme/hooks';
import { motion } from 'framer-motion';

interface FolderDropdownProps {
  onCreateSubfolder: (folder: Folder) => void;
  onDeleteFolder: (folder: Folder) => Promise<void>;
  onEditFolder: (folder: Folder) => void;
  parent: Folder;
}

export default function FolderDropdown({
  onCreateSubfolder,
  onDeleteFolder,
  onEditFolder,
  parent,
}: FolderDropdownProps) {
  const colors = useColors();

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.95, y: -10 }}
      animate={{ opacity: 1, scale: 1, y: 0 }}
      exit={{ opacity: 0, scale: 0.95, y: -10 }}
      transition={{ 
        duration: 0.15, 
        ease: [0.16, 1, 0.3, 1] // Custom easing for smooth feel
      }}
      style={{
        backgroundColor: colors['bg-secondary'],
        borderColor: colors['border-primary']
      }}
      className="rounded-lg shadow-[0px_4px_6px_-2px_rgba(16,24,40,0.03)] py-1 border flex-col justify-start items-start inline-flex overflow-hidden"
    >
        {/* Edit folder Item */}
        <div
          className="self-stretch px-1.5 py-px justify-start items-center inline-flex cursor-pointer"
          onClick={() => onEditFolder(parent)}
        >
          <div 
            style={{
              '--hover-bg': colors['bg-quaternary']
            } as React.CSSProperties}
            className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-200 overflow-hidden">
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative overflow-hidden">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                  alt="Edit Icon"
                  className="w-4 h-4 object-contain"
                />
              </div>
              <div 
                style={{ color: colors['text-primary'] }}
                className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight">
                Edit folder
              </div>
            </div>
          </div>
        </div>

        {/* Create subfolder Item */}
        <div
          className="self-stretch px-1.5 py-px justify-start items-center inline-flex cursor-pointer"
          onClick={() => onCreateSubfolder(parent)}
        >
          <div 
            style={{
              '--hover-bg': colors['bg-quaternary']
            } as React.CSSProperties}
            className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-200 overflow-hidden">
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative overflow-hidden">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/git-branch-01.svg`}
                  alt="Git Branch Icon"
                  className="w-4 h-4 object-contain"
                />
              </div>
              <div 
                style={{ color: colors['text-primary'] }}
                className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight">
                Create subfolder
              </div>
            </div>
          </div>
        </div>

        {/* Horizontal line spacer */}
        <div 
          style={{ borderColor: colors['border-secondary'] }}
          className="self-stretch h-px border-b my-1" />

        {/* Delete folder Item */}
        <div
          className="self-stretch px-1.5 py-px justify-start items-center inline-flex cursor-pointer"
          onClick={() => onDeleteFolder(parent)}
        >
          <div 
            style={{
              '--hover-bg': colors['bg-quaternary']
            } as React.CSSProperties}
            className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-200 overflow-hidden">
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative overflow-hidden">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`}
                  alt="Trash Icon"
                  className="w-4 h-4 object-contain"
                />
              </div>
              <div 
                style={{ color: colors['text-primary'] }}
                className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight">
                Delete folder
              </div>
            </div>
          </div>
        </div>
    </motion.div>
  );
}
</file>

<file path="app/dashboard/components/folderUtils.ts">
import { Folder } from '@/types/workspace';

export interface FolderWithDepth extends Folder {
  depth: number;
}

/**
 * Flatten folders into an array with depth information
 */
export function flattenFoldersWithDepth(
  folders: Folder[],
  parentId: number | null = null,
  depth: number = 0,
  expandedFolders: Set<number>,
  result: FolderWithDepth[] = []
): FolderWithDepth[] {
  // Get folders at the current level
  const currentLevelFolders = folders
    .filter(folder => folder.parent_id === parentId)
    .sort((a, b) => a.position - b.position);

  // Add each folder to the result
  for (const folder of currentLevelFolders) {
    result.push({ ...folder, depth });
    
    // If the folder is expanded, recursively add its children
    if (expandedFolders.has(folder.id)) {
      flattenFoldersWithDepth(folders, folder.id, depth + 1, expandedFolders, result);
    }
  }

  return result;
}

/**
 * Find all descendant folder IDs of a given folder
 */
export function getAllDescendantIds(
  folders: Folder[],
  folderId: number,
  result: Set<number> = new Set()
): Set<number> {
  // Get direct children
  const children = folders.filter(folder => folder.parent_id === folderId);
  
  // Add each child and their descendants
  for (const child of children) {
    result.add(child.id);
    getAllDescendantIds(folders, child.id, result);
  }
  
  return result;
}

/**
 * Check if a folder is a descendant of another folder
 */
export function isDescendantOf(
  folders: Folder[],
  folderId: number,
  potentialAncestorId: number
): boolean {
  const descendants = getAllDescendantIds(folders, potentialAncestorId);
  return descendants.has(folderId);
}
</file>

<file path="app/dashboard/components/HelpCenterModal.tsx">
// components/HelpCenterModal.tsx
import { User } from '@/types/user';
import { redirectToRoadmap } from '@/app/utils/roadmap';
import { restartTutorial } from '@/app/utils/tutorial';
import { useColors } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';

interface HelpCenterModalProps {
  onClose: () => void;
  user: User;
  setShowTutorial?: (show: boolean) => void;
}

export default function HelpCenterModal({
  onClose,
  user,
  setShowTutorial
}: HelpCenterModalProps) {
  const colors = useColors();

  const handleRoadmapClick = async (e: React.MouseEvent) => {
    e.preventDefault();
    if (user) {
      await redirectToRoadmap(user);
    }
  };

  const handleRestartTutorial = async (e: React.MouseEvent) => {
    e.preventDefault();
    if (user) {
      // Clean up any remaining styles from previous tutorial run
      const foldersSection = document.querySelector('[data-testid="folders-section"]');
      if (foldersSection && foldersSection instanceof HTMLElement) {
        foldersSection.style.backgroundColor = '';
      }
      
      const success = await restartTutorial(user);
      if (success) {
        // Close the modal
        onClose();
        
        // Show the tutorial directly instead of refreshing the page
        if (setShowTutorial) {
          setShowTutorial(true);
        }
      }
    }
  };

  return (
    <div 
      className="flex items-center justify-center p-8 h-full w-full"
      onClick={onClose}
    >
      {/* Backdrop */}
      <div className="absolute inset-0">
        <div 
          style={{ backgroundColor: colors['bg-overlay'] }}
          className="absolute inset-0 opacity-70" 
        />
      </div>

      {/* Modal content */}
      <div 
        className="relative z-10 w-[480px] rounded-xl shadow-lg flex flex-col items-center overflow-hidden"
        style={{ backgroundColor: colors['bg-primary'] }}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Close Button */}
        <ButtonNormal
          variant="tertiary"
          iconOnly
          size="small"
          className="absolute top-4 right-4"
          onClick={onClose}
          leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/x-close-icon.svg`}
        />

        <div className="self-stretch flex flex-col items-center">
          <div className="self-stretch px-6 pt-6 flex items-start gap-4">
            {/* Support Icon */}
            <div 
              className="p-3 rounded-full flex justify-center items-center overflow-hidden"
              style={{ backgroundColor: colors['bg-secondary'] }}
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/support-icon.svg`}
                alt="Support Icon"
                className="w-6"
              />
            </div>

            {/* Title & Subtitle */}
            <div className="w-[432px] flex flex-col justify-center gap-1">
              <div 
                className="text-lg font-semibold leading-7"
                style={{ color: colors['text-primary'] }}
              >
                Help center
              </div>
              <div 
                className="text-sm font-normal leading-tight"
                style={{ color: colors['text-secondary'] }}
              >
                Everything you need
              </div>
            </div>
          </div>
        </div>

        {/* Options List */}
        <div className="self-stretch p-6 flex flex-col gap-5">
          {/* Reach out to us */}
          <a
            href="mailto:contact@process-flow.io"
            className="self-stretch px-1.5 py-px flex items-center rounded-lg transition-colors duration-200"
            style={{ 
              '--hover-bg': colors['bg-quaternary'],
            } as React.CSSProperties}
            onMouseEnter={(e) => {
              e.currentTarget.style.backgroundColor = colors['bg-quaternary'];
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.backgroundColor = 'transparent';
            }}
          >
            <div className="flex-grow h-[38px] px-2.5 py-[9px] rounded-md flex items-center gap-3 overflow-hidden">
              <div className="flex-grow flex items-center gap-2">
                {/* Certificate Icon */}
                <div className="w-4 h-4 relative overflow-hidden">
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/certificate.svg`}
                    alt="Certificate Icon"
                    className="w-full h-full object-contain"
                  />
                </div>
                <div 
                  className="text-sm font-medium leading-tight"
                  style={{ color: colors['text-secondary'] }}
                >
                  Reach out to us
                </div>
              </div>
              {/* <div 
                className="text-xs font-normal leading-[18px]"
                style={{ color: colors['text-secondary'] }}
              >
                S
              </div> */}
            </div>
          </a>

          {/* Take a look at our roadmap */}
          <a
            href="#"
            onClick={handleRoadmapClick}
            className="self-stretch px-1.5 py-px flex items-center rounded-lg transition-colors duration-200"
            style={{ 
              '--hover-bg': colors['bg-quaternary'],
            } as React.CSSProperties}
            onMouseEnter={(e) => {
              e.currentTarget.style.backgroundColor = colors['bg-quaternary'];
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.backgroundColor = 'transparent';
            }}
          >
            <div className="flex-grow h-[38px] px-2.5 py-[9px] rounded-md flex items-center gap-3 overflow-hidden">
              <div className="flex-grow flex items-center gap-2">
                {/* Compass Icon */}
                <div className="w-4 h-4 relative overflow-hidden">
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/compass-icon.svg`}
                    alt="Compass Icon"
                    className="w-full h-full object-contain"
                  />
                </div>
                <div 
                  className="text-sm font-medium leading-tight"
                  style={{ color: colors['text-secondary'] }}
                >
                  Take a look at our roadmap
                </div>
              </div>
              {/* <div 
                className="text-xs font-normal leading-[18px]"
                style={{ color: colors['text-secondary'] }}
              >
                D
              </div> */}
            </div>
          </a>

          {/* Join our Slack community */}
          <a
            href="https://join.slack.com/t/processflowcommunity/shared_invite/zt-2z10aormq-aFsRf5mw1~~Y~ryFXgrwog"
            target="_blank"
            rel="noopener noreferrer"
            className="self-stretch px-1.5 py-px flex items-center rounded-lg transition-colors duration-200"
            style={{ 
              '--hover-bg': colors['bg-quaternary'],
            } as React.CSSProperties}
            onMouseEnter={(e) => {
              e.currentTarget.style.backgroundColor = colors['bg-quaternary'];
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.backgroundColor = 'transparent';
            }}
          >
            <div className="flex-grow h-[38px] px-2.5 py-[9px] rounded-md flex items-center gap-3 overflow-hidden">
              <div className="flex-grow flex items-center gap-2">
                {/* Slack Icon */}
                <div className="w-4 h-4 relative overflow-hidden">
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/slack.svg`}
                    alt="Slack Icon"
                    className="w-full h-full object-contain"
                  />
                </div>
                <div 
                  className="text-sm font-medium leading-tight"
                  style={{ color: colors['text-secondary'] }}
                >
                  Join our Slack community
                </div>
              </div>
              {/* <div 
                className="text-xs font-normal leading-[18px]"
                style={{ color: colors['text-secondary'] }}
              >
                X
              </div> */}
            </div>
          </a>

          {/* Restart Tutorial */}
          <a
            href="#"
            onClick={handleRestartTutorial}
            className="self-stretch px-1.5 py-px hidden items-center rounded-lg transition-colors duration-200"
            style={{ 
              '--hover-bg': colors['bg-quaternary'],
            } as React.CSSProperties}
            onMouseEnter={(e) => {
              e.currentTarget.style.backgroundColor = colors['bg-quaternary'];
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.backgroundColor = 'transparent';
            }}
          >
            <div className="flex-grow h-[38px] px-2.5 py-[9px] rounded-md flex items-center gap-3 overflow-hidden">
              <div className="flex-grow flex items-center gap-2">
                {/* Tutorial Icon */}
                <div className="w-4 h-4 relative overflow-hidden">
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/file-heart-02.svg`}
                    alt="Tutorial Icon"
                    className="w-full h-full object-contain"
                  />
                </div>
                <div 
                  className="text-sm font-medium leading-tight"
                  style={{ color: colors['text-secondary'] }}
                >
                  Tutorial
                </div>
              </div>
              {/* <div 
                className="text-xs font-normal leading-[18px]"
                style={{ color: colors['text-secondary'] }}
              >
                T
              </div> */}
            </div>
          </a>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/dashboard/components/MoveWorkflowModal.tsx">
import React, { useState } from 'react';
import { Workspace, Folder } from '@/types/workspace';
import { Workflow } from '@/types/workflow';
import ButtonNormal from '@/app/components/ButtonNormal';
import InputField from '@/app/components/InputFields';
import { useColors } from '@/app/theme/hooks';
import { toast } from 'sonner';

interface MoveWorkflowModalProps {
  onClose: () => void;
  onConfirm: (
    folder: Folder | null
  ) => Promise<{
    workflow: Workflow | null;
    error?: { title: string; description: string };
  }>;
  activeWorkspace: Workspace;
  selectedWorkflow: Workflow;
}

export default function MoveWorkflowModal({
  onClose,
  onConfirm,
  activeWorkspace,
  selectedWorkflow,
}: MoveWorkflowModalProps) {
  const colors = useColors();
  const [searchTerm, setSearchTerm] = useState('');
  const [expandedFolders, setExpandedFolders] = useState<Set<number>>(
    new Set()
  );
  const [targetFolder, setTargetFolder] = useState<Folder | null | undefined>(
    undefined
  );
  const [isMoving, setIsMoving] = useState(false);

  const handleSearchChange = (value: string) => {
    setSearchTerm(value);

    if (value) {
      const matchingFolders = activeWorkspace.folders.reduce(
        (acc: Set<number>, folder) => {
          if (folder.name.toLowerCase().includes(value.toLowerCase())) {
            const parentFolders = getParentFolders(
              folder,
              activeWorkspace.folders
            );
            parentFolders.forEach((parent) => acc.add(parent.id));
            acc.add(folder.id);
          }
          return acc;
        },
        new Set<number>()
      );
      setExpandedFolders(matchingFolders);
    } else {
      setExpandedFolders(new Set());
    }
  };

  const getParentFolders = (folder: Folder, folders: Folder[]): Folder[] => {
    const parentFolder = folders.find((f) => f.id === folder.parent_id);
    return parentFolder
      ? [parentFolder, ...getParentFolders(parentFolder, folders)]
      : [];
  };

  const filteredFolders = searchTerm
    ? activeWorkspace.folders.reduce((acc: Folder[], folder) => {
        if (folder.name.toLowerCase().includes(searchTerm.toLowerCase())) {
          const parentFolders = getParentFolders(
            folder,
            activeWorkspace.folders
          );
          return [...acc, ...parentFolders, folder];
        }
        return acc;
      }, [])
    : activeWorkspace.folders;

  const uniqueFilteredFolders = Array.from(
    new Map(filteredFolders.map((folder) => [folder.id, folder])).values()
  );

  const getChildFolders = (parentId: number | null) =>
    uniqueFilteredFolders.filter((folder) => folder.parent_id === parentId);

  const toggleFolder = (folderId: number) => {
    setExpandedFolders((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(folderId)) {
        newSet.delete(folderId);
      } else {
        newSet.add(folderId);
      }
      return newSet;
    });
  };

  const handleFolderClick = (folder: Folder | null) => {
    setTargetFolder(folder);
  };

  const handleMove = async () => {
    if (targetFolder === undefined) return;

    setIsMoving(true);
    try {
      const result = await onConfirm(targetFolder);

      if (result.error) {
        toast.error(result.error.title, {
          description: result.error.description,
        });
        return;
      }

      if (result.workflow) {
        onClose();
      }
    } catch (error) {
      console.error('Error moving flow:', error);
      toast.error('Error Moving Flow', {
        description: 'An unexpected error occurred while moving the flow.',
      });
    } finally {
      setIsMoving(false);
    }
  };

  return (
    <div
      className="fixed inset-0 flex items-center justify-center z-50 w-full"
      onClick={onClose}
    >
      {/* Backdrop */}
      <div className="absolute inset-0">
        <div
          style={{ backgroundColor: colors['bg-overlay'] }}
          className="absolute inset-0 opacity-70"
        />
      </div>

      {/* Modal content */}
      <div
        className="relative z-10 w-[400px] h-[515px] rounded-xl shadow-md flex flex-col justify-center items-center overflow-hidden"
        style={{ backgroundColor: colors['bg-primary'] }}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="self-stretch px-6 pt-6 pb-4">
          <div className="flex flex-row items-center gap-3">
            <div
              className="w-12 h-12 p-3 rounded-[10px] shadow-sm flex justify-center items-center overflow-hidden"
              style={{
                backgroundColor: colors['bg-secondary'],
                borderWidth: '1px',
                borderStyle: 'solid',
                borderColor: colors['border-secondary'],
              }}
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-download.svg`}
                alt="Folder move icon"
                className="w-6 h-6"
              />
            </div>
            <div className="flex flex-col">
              <div
                className="text-lg font-semibold"
                style={{ color: colors['text-primary'] }}
              >
                Move Flow "{selectedWorkflow.name}"
              </div>
            </div>
          </div>
        </div>
        <div className="self-stretch h-11 px-6 flex flex-col justify-start items-start gap-5 mb-4">
          <InputField
            type="icon-leading"
            value={searchTerm}
            onChange={handleSearchChange}
            placeholder="Search"
            iconUrl={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/search-icon.svg`}
          />
        </div>
        <div
          className="self-stretch h-px mb-4"
          style={{ backgroundColor: colors['border-secondary'] }}
        />
        <div className="self-stretch h-[194px] px-3 flex flex-col gap-1 overflow-y-auto">
          <div
            className="self-stretch px-1.5 py-px inline-flex items-center transition-colors duration-200 rounded-[6px] cursor-pointer"
            style={
              {
                backgroundColor:
                  targetFolder === null
                    ? colors['bg-quaternary']
                    : 'transparent',
                '--hover-bg': colors['bg-quaternary'],
              } as React.CSSProperties
            }
            onClick={() => handleFolderClick(null)}
          >
            <div className="grow h-[60px] px-2.5 py-[9px] rounded-md flex items-center gap-3 overflow-hidden">
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon-grey.svg`}
                alt="Root icon"
                className="w-4 h-4 relative"
                style={{ top: '-10px', left: '0px' }}
              />
              <div
                className="text-sm font-medium"
                style={{ color: colors['text-primary'] }}
              >
                My Flows
              </div>
            </div>
          </div>
          <FolderList
            folders={uniqueFilteredFolders}
            parentId={null}
            getChildFolders={getChildFolders}
            activeWorkspace={activeWorkspace}
            expandedFolders={expandedFolders}
            toggleFolder={toggleFolder}
            handleFolderClick={handleFolderClick}
            targetFolder={targetFolder}
            colors={colors}
          />
        </div>
        <div className="self-stretch flex-1" />
        <div
          className="self-stretch h-px"
          style={{ backgroundColor: colors['border-secondary'] }}
        />
        <div className="self-stretch px-6 py-6 flex gap-3">
          <ButtonNormal
            variant="secondary"
            size="small"
            onClick={onClose}
            className="flex-1"
            disabled={isMoving}
          >
            Cancel
          </ButtonNormal>
          <ButtonNormal
            variant="primary"
            size="small"
            onClick={handleMove}
            className="flex-1"
            disabled={targetFolder === undefined || isMoving}
            isLoading={isMoving}
            loadingText="Moving..."
          >
            Move
          </ButtonNormal>
        </div>
      </div>
    </div>
  );
}

function FolderList({
  folders,
  parentId,
  getChildFolders,
  activeWorkspace,
  expandedFolders,
  toggleFolder,
  handleFolderClick,
  targetFolder,
  colors,
}: {
  folders: Folder[];
  parentId: number | null;
  getChildFolders: (parentId: number | null) => Folder[];
  activeWorkspace: Workspace;
  expandedFolders: Set<number>;
  toggleFolder: (folderId: number) => void;
  handleFolderClick: (folder: Folder | null) => void;
  targetFolder: Folder | null | undefined;
  colors: { [key: string]: string };
}) {
  return (
    <div>
      {getChildFolders(parentId).map((folder) => {
        const hasChildren = getChildFolders(folder.id).length > 0;
        const isSelected = targetFolder?.id === folder.id;

        return (
          <div key={folder.id} className="flex flex-col ml-4">
            <div
              className="self-stretch px-1.5 py-px inline-flex items-center transition-colors duration-200 rounded-[6px] cursor-pointer"
              style={
                {
                  backgroundColor: isSelected
                    ? colors['bg-quaternary']
                    : 'transparent',
                  '--hover-bg': colors['bg-quaternary'],
                } as React.CSSProperties
              }
              onClick={() => {
                toggleFolder(folder.id);
                handleFolderClick(folder);
              }}
            >
              <div className="grow h-[60px] px-2.5 py-[9px] rounded-md flex items-center gap-3 overflow-hidden">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${
                    process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH
                  }/assets/shared_components/${
                    folder.parent_id === null
                      ? 'folder-icon-grey.svg'
                      : 'corner-down-right-icon.svg'
                  }`}
                  alt="Folder icon"
                  className="w-4 h-4 relative"
                  style={{ top: '-10px', left: '0px' }}
                />
                <div className="grow h-[42px] flex items-start gap-2">
                  <div className="grow flex flex-col justify-center items-start gap-1">
                    <div
                      className="text-sm font-medium"
                      style={{ color: colors['text-primary'] }}
                    >
                      {folder.name}
                    </div>
                    <div
                      className="text-xs font-normal"
                      style={{ color: colors['text-secondary'] }}
                    >
                      {activeWorkspace.name}
                    </div>
                  </div>
                </div>
              </div>
            </div>
            {Array.from(expandedFolders).includes(folder.id) && (
              <div className="ml-1">
                <FolderList
                  folders={folders}
                  parentId={folder.id}
                  getChildFolders={getChildFolders}
                  activeWorkspace={activeWorkspace}
                  expandedFolders={expandedFolders}
                  toggleFolder={toggleFolder}
                  handleFolderClick={handleFolderClick}
                  targetFolder={targetFolder}
                  colors={colors}
                />
              </div>
            )}
          </div>
        );
      })}
    </div>
  );
}
</file>

<file path="app/dashboard/components/SearchBar.tsx">
// components/SearchBar.tsx
'use client';

import InputField from '@/app/components/InputFields';
import { useState } from 'react';

interface SearchBarProps {
  searchTerm: string;
  onSearchChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}

export default function SearchBar({ searchTerm, onSearchChange }: SearchBarProps) {
  const [isFocused, setIsFocused] = useState(false);

  const handleChange = (value: string) => {
    onSearchChange({ target: { value } } as React.ChangeEvent<HTMLInputElement>);
  };

  return (
    <div className="w-[350px] flex items-center transition-all duration-200 hover:scale-[1.02]">
      <div className="flex-grow">
        <InputField
          type="icon-leading"
          value={searchTerm}
          onChange={handleChange}
          placeholder="Search"
          iconUrl={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/search-icon.svg`}
        />
      </div>
    </div>
  );
}
</file>

<file path="app/dashboard/components/SortableFolderItem.tsx">
'use client';

import React, { forwardRef } from 'react';
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import TabButton from '@/app/components/TabButton';
import { Folder } from '@/types/workspace';
import { useColors } from '@/app/theme/hooks';

interface SortableFolderItemProps {
  folder: Folder;
  isActive: boolean;
  onClick: () => void;
  onCreateSubfolder?: (folder: Folder) => void;
  onEditFolder?: (folder: Folder) => void;
  onDeleteFolder?: (folder: Folder) => Promise<void>;
  hasSubfolders?: boolean;
  isExpanded?: boolean;
  onToggleExpand?: () => void;
  onSelectFolder?: (folder?: Folder) => void;
  id: string;
  depth: number;
}

const SortableFolderItem = (props: SortableFolderItemProps) => {
  const {
    folder,
    isActive,
    onClick,
    onCreateSubfolder,
    onEditFolder,
    onDeleteFolder,
    hasSubfolders,
    isExpanded,
    onToggleExpand,
    onSelectFolder,
    id,
    depth,
  } = props;

  const colors = useColors();

  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.6 : 1,
    position: 'relative',
    zIndex: isDragging ? 999 : 'auto',
    boxShadow: isDragging ? '0 5px 10px rgba(0,0,0,0.15)' : 'none',
    backgroundColor: isDragging ? colors['bg-secondary'] : 'transparent',
    borderRadius: isDragging ? '6px' : '0',
    cursor: isDragging ? 'grabbing' : 'grab',
  } as React.CSSProperties;

  let folderIcon;
  if (folder.icon_url) {
    folderIcon = folder.icon_url.startsWith('https://cdn.brandfetch.io/')
      ? folder.icon_url
      : folder.signedIconUrl
        ? folder.signedIconUrl
        : `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon-base.svg`;
  } else {
    folderIcon = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon-base.svg`;
  }

  return (
    <div
      ref={setNodeRef}
      style={style}
      {...attributes}
      className={`mt-1 max-w-full${isDragging ? ' dragging' : ''} relative group/folder`}
      data-depth={depth}
    >
      {/* Single Drag Handle Indicator - Only visible on hover */}
      <div
        {...listeners}
        className="absolute left-[-16px] top-0 bottom-0 w-4 flex items-center justify-center opacity-0 group-hover/folder:opacity-40 hover:opacity-80 transition-opacity cursor-grab z-10"
        style={{ color: colors['text-tertiary'] }}
      >
        <svg
          width="12"
          height="12"
          viewBox="0 0 12 12"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <circle cx="3" cy="3" r="1.5" fill="currentColor" />
          <circle cx="3" cy="9" r="1.5" fill="currentColor" />
          <circle cx="9" cy="3" r="1.5" fill="currentColor" />
          <circle cx="9" cy="9" r="1.5" fill="currentColor" />
        </svg>
      </div>

      {/* TabButton without attaching listeners to it */}
      <div className="w-full">
        <TabButton
          icon={folder.emote ? '' : folderIcon}
          label={folder.name}
          emote={folder.emote}
          isActive={isActive}
          onClick={onClick}
          isFolder={true}
          folder={folder}
          onCreateSubfolder={onCreateSubfolder}
          onEditFolder={onEditFolder}
          onDeleteFolder={onDeleteFolder}
          hasSubfolders={hasSubfolders}
          isExpanded={isExpanded}
          onToggleExpand={onToggleExpand}
          onSelectFolder={onSelectFolder}
          inSortableContext={true}
        />
      </div>
    </div>
  );
};

export default SortableFolderItem;
</file>

<file path="app/dashboard/components/SortableFolderList.tsx">
'use client';

import React, { useEffect, useState } from 'react';
import {
  DndContext,
  DragEndEvent,
  DragOverEvent,
  DragOverlay,
  DragStartEvent,
  KeyboardSensor,
  PointerSensor,
  closestCenter,
  useSensor,
  useSensors,
} from '@dnd-kit/core';
import {
  SortableContext,
  arrayMove,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable';
import {
  restrictToVerticalAxis,
  restrictToWindowEdges,
} from '@dnd-kit/modifiers';
import { Folder, Workspace } from '@/types/workspace';
import SortableFolderItem from './SortableFolderItem';
import {
  flattenFoldersWithDepth,
  FolderWithDepth,
  isDescendantOf,
} from './folderUtils';
import { useColors } from '@/app/theme/hooks';
import TabButton from '@/app/components/TabButton';
import { toast } from 'react-hot-toast';

interface SortableFolderListProps {
  activeWorkspace: Workspace;
  expandedFolders: Set<number>;
  onToggleFolder: (folderId: number) => void;
  activeTabId: string | null;
  onTabClick: (tabId: string | null, folder?: Folder) => void;
  onCreateSubfolder: (folder: Folder) => void;
  onEditFolder: (folder: Folder) => void;
  onDeleteFolder: (folder: Folder) => Promise<void>;
  onSelectFolder: (folder?: Folder) => void;
  isSettingsView: boolean;
  updateFolderPositions: (
    folderId: number,
    newParentId: number | null,
    newPosition: number,
    workspace?: Workspace
  ) => Promise<boolean | void>;
}

export default function SortableFolderList({
  activeWorkspace,
  expandedFolders,
  onToggleFolder,
  activeTabId,
  onTabClick,
  onCreateSubfolder,
  onEditFolder,
  onDeleteFolder,
  onSelectFolder,
  isSettingsView,
  updateFolderPositions,
}: SortableFolderListProps) {
  // Create a flattened list of folders with depth information
  const [flattenedFolders, setFlattenedFolders] = useState<FolderWithDepth[]>(
    []
  );
  // Track the currently dragged folder
  const [activeFolderId, setActiveFolderId] = useState<string | null>(null);
  const [activeFolder, setActiveFolder] = useState<FolderWithDepth | null>(
    null
  );
  const [dropTarget, setDropTarget] = useState<{
    id: string;
    isParent: boolean;
    position?: string;
  } | null>(null);

  const colors = useColors();

  // Add a timer state for delayed folder expansion
  const [expandTimer, setExpandTimer] = useState<NodeJS.Timeout | null>(null);

  // Add expandingFolderId state to track which folder is about to be expanded
  const [expandingFolderId, setExpandingFolderId] = useState<number | null>(
    null
  );

  // Create a flattened list when folders or expanded state changes
  useEffect(() => {
    const flattened = flattenFoldersWithDepth(
      activeWorkspace.folders,
      null, // Start with root folders
      0, // Initial depth
      expandedFolders
    );

    setFlattenedFolders(flattened);
  }, [activeWorkspace.folders, expandedFolders]);

  // Cleanup expansion timer when component unmounts
  useEffect(() => {
    return () => {
      if (expandTimer) {
        clearTimeout(expandTimer);
      }
    };
  }, [expandTimer]);

  // Configure sensors for drag and drop
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 5, // Minimum distance before drag starts to prevent accidental drags
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  // Find a folder by its ID in the flattened list
  const findFolderById = (id: string): FolderWithDepth | undefined => {
    const numericId = parseInt(id.replace('folder-', ''));
    return flattenedFolders.find((folder) => folder.id === numericId);
  };

  // Handle drag start
  const handleDragStart = (event: DragStartEvent) => {
    const { active } = event;
    setActiveFolderId(active.id as string);

    const folder = findFolderById(active.id as string);
    if (folder) {
      setActiveFolder(folder);
    }
  };

  // Handle drag over to detect potential parent changes and auto-expand folders on hover
  const handleDragOver = (event: DragOverEvent) => {
    const { active, over } = event;

    if (!over || active.id === over.id) {
      // Clear expansion timer when not over a valid target
      if (expandTimer) {
        clearTimeout(expandTimer);
        setExpandTimer(null);
      }
      setDropTarget(null);
      return;
    }

    const activeFolder = findFolderById(active.id as string);
    const overFolder = findFolderById(over.id as string);

    if (!activeFolder || !overFolder) {
      if (expandTimer) {
        clearTimeout(expandTimer);
        setExpandTimer(null);
      }
      setDropTarget(null);
      return;
    }

    // Prevent dropping a folder into its own descendant
    if (
      isDescendantOf(activeWorkspace.folders, activeFolder.id, overFolder.id)
    ) {
      if (expandTimer) {
        clearTimeout(expandTimer);
        setExpandTimer(null);
      }
      setDropTarget(null);
      return;
    }

    // Check if target folder has subfolders
    const hasSubfolders = activeWorkspace.folders.some(
      (f) => f.parent_id === overFolder.id
    );

    // Update the auto-expand functionality to show a visual indicator
    if (hasSubfolders && !expandedFolders.has(overFolder.id)) {
      // Clear any existing timer
      if (expandTimer) {
        clearTimeout(expandTimer);
        setExpandTimer(null);
        setExpandingFolderId(null);
      }

      // Show the visual indicator that the folder is about to expand
      setExpandingFolderId(overFolder.id);

      // Set a new timer to expand the folder after a delay
      const timer = setTimeout(() => {
        onToggleFolder(overFolder.id);
        setExpandingFolderId(null);
      }, 500); // 500ms delay before expanding

      setExpandTimer(timer);
    } else if (
      expandingFolderId === overFolder.id &&
      (!hasSubfolders || expandedFolders.has(overFolder.id))
    ) {
      // If we're no longer hovering over a folder that can be expanded,
      // clear the expanding state
      setExpandingFolderId(null);
      if (expandTimer) {
        clearTimeout(expandTimer);
        setExpandTimer(null);
      }
    }

    // Get pointer position relative to the over target
    const { x, y } = event.activatorEvent as PointerEvent;
    const overElement = document.querySelector(`[data-id="${over.id}"]`);

    if (overElement) {
      const rect = overElement.getBoundingClientRect();

      // Calculate relative X position within the element (0 to 1)
      const relativeX = (x - rect.left) / rect.width;
      // Adjust the threshold - if pointer is deeper within the element horizontally
      // and in the middle vertically, consider it as a child drop
      const isDeepInElement = relativeX > 0.3; // 30% from the left edge

      // For vertical position, split into thirds
      const upperThreshold = rect.height * 0.33;
      const lowerThreshold = rect.height * 0.66;
      const relativeY = y - rect.top;

      const isInUpperPart = relativeY < upperThreshold;
      const isInLowerPart = relativeY > lowerThreshold;
      const isInMiddlePart = !isInUpperPart && !isInLowerPart;

      // Remove previous indicators
      document
        .querySelectorAll(
          '.drag-over-as-child, .drag-over-as-sibling-before, .drag-over-as-sibling-after'
        )
        .forEach((el) => {
          el.classList.remove(
            'drag-over-as-child',
            'drag-over-as-sibling-before',
            'drag-over-as-sibling-after'
          );
        });

      // If pointer is deep enough into the element horizontally and in the middle vertically,
      // consider it a child drop
      if (isDeepInElement && isInMiddlePart) {
        setDropTarget({ id: over.id as string, isParent: true });
        overElement.classList.add('drag-over-as-child');
      } else {
        // Otherwise, treat as sibling before/after based on vertical position
        const isBeforeTarget = isInUpperPart;
        setDropTarget({
          id: over.id as string,
          isParent: false,
          position: isBeforeTarget ? 'before' : 'after',
        });

        if (isBeforeTarget) {
          overElement.classList.add('drag-over-as-sibling-before');
        } else {
          overElement.classList.add('drag-over-as-sibling-after');
        }
      }
    }
  };

  // Handle drag end - make sure to clear any pending timers
  const handleDragEnd = async (event: DragEndEvent) => {
    // Clear any pending expansion timer
    if (expandTimer) {
      clearTimeout(expandTimer);
      setExpandTimer(null);
    }

    // Reset expanding folder state
    setExpandingFolderId(null);

    const { active, over } = event;
    setActiveFolderId(null);
    setActiveFolder(null);

    // Remove any visual indicators
    document
      .querySelectorAll(
        '.drag-over-as-child, .drag-over-as-sibling-before, .drag-over-as-sibling-after'
      )
      .forEach((el) => {
        el.classList.remove(
          'drag-over-as-child',
          'drag-over-as-sibling-before',
          'drag-over-as-sibling-after'
        );
      });

    // No drop target, abort
    if (!over) {
      setDropTarget(null);
      return;
    }

    const activeId = active.id as string;
    const overId = over.id as string;

    if (activeId === overId) {
      setDropTarget(null);
      return;
    }

    const activeFolder = findFolderById(activeId);
    const overFolder = findFolderById(overId);

    if (!activeFolder || !overFolder) {
      setDropTarget(null);
      return;
    }

    // Check if we are dropping as a child or as a sibling (and which position)
    const dropAsChild = dropTarget?.isParent && dropTarget.id === overId;
    const dropPosition = dropTarget?.position || 'after'; // Default to 'after' if not specified

    try {
      // Create a new version of the folders array to work with
      const updatedFolders = [...activeWorkspace.folders];
      const activeFolderIndex = updatedFolders.findIndex(
        (f) => f.id === activeFolder.id
      );
      const folderToMove = updatedFolders[activeFolderIndex];

      if (dropAsChild) {
        // Prevent dropping a folder as a child of itself
        if (overFolder.id === folderToMove.id) {
          setDropTarget(null);
          return;
        }
        // Optimistically update the UI by changing the parent_id and position
        const oldParentId = folderToMove.parent_id;

        // Get existing children of the target folder to find the highest position
        const existingChildren = updatedFolders.filter(
          (f) => f.parent_id === overFolder.id
        );
        const highestPosition =
          existingChildren.length > 0
            ? Math.max(...existingChildren.map((c) => (c as Folder).position)) +
              1
            : 0;

        // Update the folder's parent and position - place it at the end of children
        folderToMove.parent_id = overFolder.id;
        (folderToMove as Folder).position = highestPosition;

        // If the old parent had other children, update their positions
        if (oldParentId !== null) {
          const oldSiblings = updatedFolders.filter(
            (f) => f.parent_id === oldParentId && f.id !== folderToMove.id
          );

          // Reorder old siblings (decreasing position for items after the moved item)
          oldSiblings.forEach((f) => {
            if ((f as Folder).position > (activeFolder as Folder).position) {
              (f as Folder).position -= 1;
            }
          });
        }

        // Ensure the parent folder is expanded
        if (!expandedFolders.has(overFolder.id)) {
          onToggleFolder(overFolder.id);
        }
      } else {
        // Get siblings of the target folder
        const oldParentId = folderToMove.parent_id;
        const newParentId =
          overFolder.parent_id === folderToMove.id
            ? null
            : overFolder.parent_id;

        // Get the old position before changing it
        const oldPosition = (folderToMove as Folder).position;

        // Get siblings in the old parent
        const oldSiblings = updatedFolders.filter(
          (f) => f.parent_id === oldParentId && f.id !== folderToMove.id
        );

        // Reorder old siblings (decreasing position for items after the moved item)
        oldSiblings.forEach((f) => {
          if ((f as Folder).position > oldPosition) {
            (f as Folder).position -= 1;
          }
        });

        // Update the moved folder's parent
        folderToMove.parent_id = newParentId as number;

        // Get siblings in the new parent (excluding the folder being moved)
        const newSiblings = updatedFolders.filter(
          (f) => f.parent_id === newParentId && f.id !== folderToMove.id
        );

        // Get the position of the target folder
        const overFolderPosition = (overFolder as Folder).position;

        // Calculate the new position based on whether we're dropping before or after
        let newPosition = overFolderPosition;
        if (dropPosition === 'after') {
          newPosition = overFolderPosition;

          // Update positions of all siblings in the new parent
          // that are at or after the new position (make room for our folder)
          newSiblings.forEach((f) => {
            if ((f as Folder).position >= newPosition) {
              (f as Folder).position += 1;
            }
          });
        } else {
          // 'before'
          // Update positions of all siblings in the new parent
          // that are at or after the new position (make room for our folder)
          newSiblings.forEach((f) => {
            if ((f as Folder).position >= newPosition) {
              (f as Folder).position += 1;
            }
          });
        }

        // Set the new position for our moved folder
        (folderToMove as Folder).position = newPosition;
      }

      // Sort the folders array by position to ensure correct ordering
      updatedFolders.sort((a, b) => {
        // First sort by parent_id (null parents come first)
        if (a.parent_id === null && b.parent_id !== null) return -1;
        if (a.parent_id !== null && b.parent_id === null) return 1;
        if (a.parent_id !== b.parent_id)
          return (a.parent_id || 0) - (b.parent_id || 0);

        // Then sort by position
        return (a as Folder).position - (b as Folder).position;
      });

      // Create a new workspace object with the updated folders
      const updatedWorkspace = {
        ...activeWorkspace,
        folders: updatedFolders,
      };

      // Manually trigger a UI update by rebuilding the flattened folders
      setFlattenedFolders(
        flattenFoldersWithDepth(updatedFolders, null, 0, expandedFolders)
      );

      // Now make the actual API call with the optimistic workspace
      await updateFolderPositions(
        activeFolder.id,
        folderToMove.parent_id === undefined ? null : folderToMove.parent_id, // Ensure parent_id is number | null
        (folderToMove as Folder).position, // Use the actual calculated position
        updatedWorkspace
      );

      toast.success('Folder moved successfully');
    } catch (error) {
      console.error('Error moving folder:', error);
      toast.error('Failed to move folder');

      // Refresh from server in case of error to ensure UI is in sync
      setFlattenedFolders(
        flattenFoldersWithDepth(
          activeWorkspace.folders,
          null,
          0,
          expandedFolders
        )
      );
    }

    setDropTarget(null);
  };

  // Add a new handler for drag cancel events
  const handleDragCancel = () => {
    // Clear any pending expansion timer
    if (expandTimer) {
      clearTimeout(expandTimer);
      setExpandTimer(null);
    }

    // Reset expanding folder state
    setExpandingFolderId(null);

    setActiveFolderId(null);
    setActiveFolder(null);
    setDropTarget(null);

    // Clean up any visual indicators
    document
      .querySelectorAll(
        '.drag-over-as-child, .drag-over-as-sibling-before, .drag-over-as-sibling-after'
      )
      .forEach((el) => {
        el.classList.remove(
          'drag-over-as-child',
          'drag-over-as-sibling-before',
          'drag-over-as-sibling-after'
        );
      });
  };

  // Create sortable item IDs
  const items = flattenedFolders.map((folder) => `folder-${folder.id}`);

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragStart={handleDragStart}
      onDragOver={handleDragOver}
      onDragEnd={handleDragEnd}
      onDragCancel={handleDragCancel}
      modifiers={[restrictToVerticalAxis, restrictToWindowEdges]}
    >
      <SortableContext items={items} strategy={verticalListSortingStrategy}>
        <div
          className={`flex flex-col w-full ${activeFolderId ? 'dnd-active' : ''}`}
        >
          {flattenedFolders.map((folder) => {
            const folderId = `folder-${folder.id}`;
            const isActive = !isSettingsView && activeTabId === folderId;
            const subfolders = activeWorkspace.folders.filter(
              (f) => f.parent_id === folder.id
            );

            // Check if this folder is about to be expanded
            const isExpanding = expandingFolderId === folder.id;

            return (
              <div
                key={folderId}
                style={{
                  marginLeft: `${folder.depth * 1}rem`,
                }}
                data-id={folderId}
                data-has-children={subfolders.length > 0 ? 'true' : 'false'}
                className={isExpanding ? 'folder-expanding' : ''}
              >
                <SortableFolderItem
                  id={folderId}
                  folder={folder}
                  depth={folder.depth}
                  isActive={isActive}
                  onClick={() => onTabClick(folderId, folder)}
                  onCreateSubfolder={onCreateSubfolder}
                  onEditFolder={onEditFolder}
                  onDeleteFolder={onDeleteFolder}
                  onSelectFolder={onSelectFolder}
                  hasSubfolders={subfolders.length > 0}
                  isExpanded={expandedFolders.has(folder.id)}
                  onToggleExpand={() => onToggleFolder(folder.id)}
                />
              </div>
            );
          })}
        </div>
      </SortableContext>

      {/* Drag overlay shows a preview of the dragged folder */}
      <DragOverlay>
        {activeFolder && (
          <div
            className="opacity-80"
            style={{
              width: '90%',
              backgroundColor: colors['bg-secondary'],
              border: `1px solid ${colors['border-secondary']}`,
              borderRadius: '6px',
              padding: '6px',
            }}
          >
            <TabButton
              icon={
                activeFolder.emote
                  ? ''
                  : activeFolder.icon_url &&
                    !activeFolder.icon_url.startsWith('https://cdn.brandfetch.io/')
                    ? `${activeFolder.icon_url}`
                    : activeFolder.signedIconUrl
                    ? `${activeFolder.signedIconUrl}`
                    : `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon-base.svg`
              }
              label={activeFolder.name}
              emote={activeFolder.emote}
              isActive={false}
              onClick={() => {}}
              isFolder={true}
            />
          </div>
        )}
      </DragOverlay>
    </DndContext>
  );
}
</file>

<file path="app/dashboard/components/TabButton.tsx">
import { Folder } from '@/types/workspace';

export interface TabButtonProps {
  icon: string;
  label: string;
  isActive: boolean;
  onClick: () => void;
  disabled?: boolean;
  emote?: string;
  isFolder?: boolean;
  folder?: Folder;
  onCreateSubfolder?: (parentFolder: Folder) => void;
  onEditFolder?: (folder: Folder) => void;
  onDeleteFolder?: (folder: Folder) => Promise<void>;
  hasSubfolders?: boolean;
  isExpanded?: boolean;
  onToggleExpand?: () => void;
}

export function TabButton({ 
  icon, 
  label, 
  isActive, 
  onClick, 
  disabled,
  emote,
  isFolder,
  folder,
  onCreateSubfolder,
  onEditFolder,
  onDeleteFolder,
  hasSubfolders,
  isExpanded,
  onToggleExpand
}: TabButtonProps) {
  return (
    <button 
      onClick={onClick}
      disabled={disabled}
      className={`flex items-center gap-2 px-4 py-2 rounded-lg transition-colors
        ${isActive ? 'bg-primary-600 text-white' : 'hover:bg-gray-100'}
        ${disabled ? 'opacity-50 cursor-not-allowed' : ''}`}
    >
      {emote ? (
        <span>{emote}</span>
      ) : (
        <img src={icon} alt="" className="w-5 h-5" />
      )}
      <span>{label}</span>
      {isFolder && hasSubfolders && (
        <span 
          onClick={(e) => {
            e.stopPropagation();
            onToggleExpand?.();
          }}
          className={`ml-auto transform transition-transform ${isExpanded ? 'rotate-90' : ''}`}
        >
          
        </span>
      )}
    </button>
  );
}
</file>

<file path="app/dashboard/components/TutorialOverlay.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useTheme, useColors } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';
import styles from '../styles/tutorial.module.css';

interface TutorialStep {
  title: string;
  description: string;
  position: {
    top?: string;
    bottom?: string;
    left?: string;
    right?: string;
  };
  arrowPosition?: {
    top?: string;
    bottom?: string;
    left?: string;
    right?: string;
  };
}

const tutorialSteps: TutorialStep[] = [
  {
    title: 'Create a new process',
    description: 'Click here to create your first process.',
    position: { top: '80px', right: '20px' },
    arrowPosition: { bottom: '100%', left: '50%' },
  },
  {
    title: 'Organize your folders',
    description:
      'Create folders to organize your processes and keep everything tidy.',
    position: { top: '50px', left: '260px' },
    arrowPosition: { right: '100%', top: '50%' },
  },
  {
    title: 'Manage your workspace',
    description:
      'Manage your workspace to edit your workspace name, logo, and billing.',
    position: { top: '80px', left: '20px' },
    arrowPosition: { right: '80%', bottom: '100%' },
  },
  {
    title: 'Account settings',
    description: 'Set up everything related to your account here.',
    position: { top: '80px', right: '10px' },
    arrowPosition: { bottom: '100%', right: '20px' },
  },
];

interface TutorialOverlayProps {
  onComplete: () => void;
}

export default function TutorialOverlay({ onComplete }: TutorialOverlayProps) {
  const [currentStep, setCurrentStep] = useState(0);
  const { currentTheme } = useTheme();
  const colors = useColors();
  const [retryCount, setRetryCount] = useState(0);

  useEffect(() => {
    // Function to handle clicks on the highlighted elements
    const handleElementClick = (e: Event) => {
      e.preventDefault();
      e.stopPropagation();
      handleNext();
    };

    // Update class names to use CSS modules
    document.querySelectorAll(`.${styles.highlight}`).forEach((el) => {
      el.classList.remove(
        styles.highlight,
        styles.highlightFolders,
        styles.highlightWorkspace,
        styles.highlightUser
      );
      el.removeEventListener('click', handleElementClick);
      // Instead of directly setting styles, use data attributes
      el.removeAttribute('data-tutorial-active');
    });

    // Function to highlight elements with retry mechanism
    const highlightElement = () => {
      let elementFound = false;

      // Handle different step highlights
      switch (currentStep) {
        case 0:
          const newFlowButton = document.querySelector(
            '[data-testid="new-flow-button"]'
          );
          if (newFlowButton) {
            elementFound = true;
            newFlowButton.classList.add(styles.highlight);
            newFlowButton.addEventListener('click', handleElementClick);
            // Mark as tutorial active instead of changing styles directly
            newFlowButton.setAttribute('data-tutorial-active', 'true');
          }
          break;

        case 1:
          const foldersSection = document.querySelector(
            '[data-testid="folders-section"]'
          );
          if (foldersSection) {
            elementFound = true;
            foldersSection.classList.add(
              styles.highlight,
              styles.highlightFolders
            );
            // Add class for styling rather than inline style
            foldersSection.classList.add(
              currentTheme === 'dark' ? styles.darkFolderHighlight : styles.lightFolderHighlight
            );
            foldersSection.addEventListener('click', handleElementClick);
            foldersSection.setAttribute('data-tutorial-active', 'true');
          }
          break;

        case 2:
          const workspaceSwitcher = document.querySelector(
            '[data-testid="workspace-switcher"]'
          );
          if (workspaceSwitcher) {
            elementFound = true;
            workspaceSwitcher.classList.add(
              styles.highlight,
              styles.highlightWorkspace
            );
            workspaceSwitcher.addEventListener('click', handleElementClick);
            workspaceSwitcher.setAttribute('data-tutorial-active', 'true');
          }
          break;

        case 3:
          const userSettings = document.querySelector(
            '[data-testid="user-settings"]'
          );
          if (userSettings) {
            elementFound = true;
            userSettings.classList.add(styles.highlight, styles.highlightUser);
            userSettings.addEventListener('click', handleElementClick);
            userSettings.setAttribute('data-tutorial-active', 'true');
          }
          break;
      }

      // If element not found and we haven't exceeded max retries, try again
      if (!elementFound && retryCount < 5) {
        const retryTimeout = setTimeout(() => {
          setRetryCount(prevCount => prevCount + 1);
        }, 300);
        return () => clearTimeout(retryTimeout);
      } else if (retryCount >= 5) {
        console.warn(`Could not find element for tutorial step ${currentStep}`);
      }

      return undefined;
    };

    const cleanupFn = highlightElement();

    // Update cleanup function
    return () => {
      if (cleanupFn) cleanupFn();
      
      // Use a more robust query selector to find all elements with highlight class
      const highlightedElements = document.querySelectorAll(
        `.${styles.highlight}, [data-tutorial-active="true"]`
      );
      
      highlightedElements.forEach((el) => {
        el.classList.remove(
          styles.highlight,
          styles.highlightFolders,
          styles.highlightWorkspace,
          styles.highlightUser,
          styles.darkFolderHighlight,
          styles.lightFolderHighlight
        );
        el.removeEventListener('click', handleElementClick);
        // Clean up attribute
        el.removeAttribute('data-tutorial-active');
      });
    };
  }, [currentStep, currentTheme, colors, retryCount]);

  const handleNext = () => {
    if (currentStep < tutorialSteps.length - 1) {
      setCurrentStep(currentStep + 1);
    } else {
      onComplete();
    }
  };

  const handleSkip = () => {
    onComplete();
  };

  const step = tutorialSteps[currentStep];

  return (
    <>
      <div
        className={styles.overlayBlocker}
        style={{
          backgroundColor:
            currentTheme === 'dark'
              ? 'rgba(0, 0, 0, 0.75)'
              : 'rgba(0, 0, 0, 0.5)',
        }}
      />

      <div className="fixed inset-0 z-50 pointer-events-none">
        {/* Tutorial popup */}
        <div
          className="absolute p-6 rounded-lg shadow-lg max-w-[300px] pointer-events-auto"
          style={{
            backgroundColor:
              currentTheme === 'dark'
                ? '#1a1f2e' // Darker blue-gray for dark mode
                : colors['bg-primary'],
            color: colors['text-primary'],
            boxShadow:
              currentTheme === 'dark'
                ? '0 4px 6px -1px rgba(0, 0, 0, 0.5), 0 2px 4px -1px rgba(0, 0, 0, 0.36)'
                : '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
            ...step.position,
          }}
        >
          {/* Arrow with adjusted color */}
          <div
            className="absolute w-4 h-4 transform rotate-45"
            style={{
              backgroundColor:
                currentTheme === 'dark' ? '#1a1f2e' : colors['bg-primary'],
              ...step.arrowPosition,
            }}
          />

          <h3 className="text-lg font-semibold mb-2">{step.title}</h3>
          <p
            className="text-sm mb-4"
            style={{
              color:
                currentTheme === 'dark'
                  ? 'rgba(255, 255, 255, 0.8)'
                  : colors['text-secondary'],
            }}
          >
            {step.description}
          </p>

          <div className="flex justify-between items-center">
            <span
              className="text-sm"
              style={{
                color:
                  currentTheme === 'dark'
                    ? 'rgba(255, 255, 255, 0.6)'
                    : colors['text-secondary'],
              }}
            >
              {currentStep + 1} of {tutorialSteps.length}
            </span>
            <div className="flex gap-2">
              <ButtonNormal
                variant="secondary"
                size="small"
                onClick={handleSkip}
              >
                Skip
              </ButtonNormal>
              <ButtonNormal variant="primary" size="small" onClick={handleNext}>
                {currentStep === tutorialSteps.length - 1 ? 'Finish' : 'Next'}
              </ButtonNormal>
            </div>
          </div>
        </div>
      </div>
    </>
  );
}
</file>

<file path="app/dashboard/components/UploadImageModal.tsx">
import { useState, useRef } from 'react';
import { useColors } from '@/app/theme/hooks';

interface UploadImageModalProps {
  onClose: () => void;
  onSave: (file: File) => void;
}

export default function UploadImageModal({
  onClose,
  onSave,
}: UploadImageModalProps) {
  const colors = useColors();
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      setSelectedFile(file);
    }
  };

  const handleUploadAreaClick = () => {
    fileInputRef.current?.click();
  };

  const handleRemoveFile = () => {
    if (fileInputRef.current) fileInputRef.current.value = '';
    setSelectedFile(null);
  };

  return (
    <main 
      className="fixed inset-0 flex items-center justify-center z-50 w-full"
      onClick={onClose}
    >
      {/* Background Overlay */}
      <div className="absolute inset-0">
        <div 
          style={{ backgroundColor: colors['bg-overlay'] }}
          className="absolute inset-0 opacity-70" 
        />
      </div>

      {/* Modal */}
      <div 
        className="relative w-[480px] rounded-xl shadow-lg flex flex-col justify-start items-center overflow-hidden z-10"
        style={{ backgroundColor: colors['bg-primary'] }}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="w-full h-40 flex flex-col justify-start items-center">
          <div className="w-full h-[140px] px-6 pt-6 flex flex-col justify-start items-start gap-4">
            {/* Image Icon */}
            <div 
              className="w-12 h-12 p-3 rounded-[10px] shadow-sm flex justify-center items-center overflow-hidden"
              style={{ 
                backgroundColor: colors['bg-secondary'],
                borderWidth: '1px',
                borderStyle: 'solid',
                borderColor: colors['border-secondary']
              }}
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/image-03.svg`}
                alt="Image Icon"
                className="w-6 h-6"
              />
            </div>
            <div className="w-full flex flex-col justify-start items-start gap-1">
              <h2 
                className="text-lg font-semibold"
                style={{ color: colors['text-primary'] }}
              >
                {selectedFile
                  ? 'Selected File'
                  : 'Drop an image here or click to upload'}
              </h2>
              <p 
                className="text-sm font-normal"
                style={{ color: colors['text-secondary'] }}
              >
                Upload your profile picture
              </p>
            </div>
          </div>
        </div>

        {/* Conditionally Show Upload Area or File Info */}
        <div className="w-full px-6 flex flex-col justify-start items-start gap-5">
          {!selectedFile ? (
            // Upload Area
            <div
              className="w-full h-[126px] px-6 py-4 rounded-xl border-2 flex flex-col justify-start items-center gap-1 group transition-all duration-300 cursor-pointer"
              style={{ 
                backgroundColor: colors['bg-primary'],
                borderColor: colors['border-secondary'],
                '--hover-border': colors['text-accent']
              } as React.CSSProperties}
              onClick={handleUploadAreaClick}
              onMouseEnter={(e) => {
                e.currentTarget.style.borderColor = colors['text-accent'];
              }}
              onMouseLeave={(e) => {
                e.currentTarget.style.borderColor = colors['border-secondary'];
              }}
            >
              <div className="w-full h-[94px] flex flex-col justify-start items-center gap-3">
                {/* Upload Icon */}
                <div 
                  className="w-10 h-10 p-2.5 rounded-lg shadow border flex justify-center items-center overflow-hidden"
                  style={{ 
                    backgroundColor: colors['bg-secondary'],
                    borderColor: colors['border-secondary']
                  }}
                >
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/upload-cloud-02.svg`}
                    alt="Upload Cloud"
                    className="w-5 h-5"
                  />
                </div>
                <div className="w-full flex flex-col justify-start items-center gap-1">
                  <div className="flex justify-center items-start gap-1">
                    <span 
                      className="text-sm font-semibold cursor-pointer transition-all duration-300"
                      style={{ 
                        color: colors['text-accent'],
                        '--hover-color': colors['text-accent-hover']
                      } as React.CSSProperties}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.color = colors['text-accent-hover'];
                      }}
                      onMouseLeave={(e) => {
                        e.currentTarget.style.color = colors['text-accent'];
                      }}
                    >
                      Click to upload
                    </span>
                    <span 
                      className="text-sm font-normal"
                      style={{ color: colors['text-secondary'] }}
                    >
                      or drag and drop
                    </span>
                  </div>
                  <p 
                    className="text-center text-xs font-normal"
                    style={{ color: colors['text-secondary'] }}
                  >
                    SVG, PNG, JPG or GIF (max. 800x400px)
                  </p>
                </div>
              </div>
            </div>
          ) : (
            // Selected File Display
            <div 
              className="h-[72px] w-full p-4 rounded-xl border justify-start items-start gap-1 inline-flex"
              style={{ 
                backgroundColor: colors['bg-primary'],
                borderColor: colors['border-secondary']
              }}
            >
              <div className="grow shrink basis-0 h-10 justify-start items-start gap-3 flex">
                <div className="w-10 h-10 relative">
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/page-icon.svg`}
                    alt="Delete Icon"
                    className="w-8 h-10 left-[5px] top-[0px] absolute"
                  />
                  <div 
                    className="px-[3px] py-0.5 left-[1px] top-[15px] absolute rounded-sm justify-start items-start gap-2 inline-flex"
                    style={{ backgroundColor: colors['text-accent'] }}
                  >
                    <div className="text-center text-white text-[10px] font-bold font-['Inter']">
                      IMG
                    </div>
                  </div>
                </div>
                <div className="grow shrink basis-0 flex-col justify-start items-start gap-1 inline-flex">
                  <div className="self-stretch h-10 flex-col justify-start items-start flex">
                    <div 
                      className="self-stretch text-sm font-medium font-['Inter'] leading-tight"
                      style={{ color: colors['text-primary'] }}
                    >
                      {selectedFile.name}
                    </div>
                    <div 
                      className="self-stretch pt-1 text-sm font-normal font-['Inter'] leading-tight"
                      style={{ color: colors['text-secondary'] }}
                    >
                      {(selectedFile.size / 1024 / 1024).toFixed(2)} MB
                    </div>
                  </div>
                </div>
              </div>
              <div className="p-0 rounded-lg gap-2 overflow-hidden">
                <button
                  onClick={handleRemoveFile}
                  className="w-5 h-5 transition-all duration-300"
                  style={{ 
                    color: colors['text-accent'],
                    '--hover-color': colors['text-accent-hover']
                  } as React.CSSProperties}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.color = colors['text-accent-hover'];
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.color = colors['text-accent'];
                  }}
                >
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/delete-icon.svg`}
                    alt="Delete Icon"
                    className="w-5 h-5 object-contain"
                  />
                </button>
              </div>
            </div>
          )}

          {/* Hidden File Input */}
          <input
            type="file"
            ref={fileInputRef}
            className="hidden"
            onChange={handleFileChange}
          />
        </div>

        {/* Buttons Section */}
        <div className="w-full h-[100px] pt-8 flex flex-col justify-start items-start">
          <div className="w-full px-6 pb-6 flex items-center gap-3">
            {/* Cancel Button */}
            <button
              onClick={() => onClose()}
              className="w-full h-11 px-4 py-2.5 rounded-lg shadow border flex justify-center items-center gap-1.5 transition-all duration-300"
              style={{ 
                backgroundColor: colors['bg-primary'],
                borderColor: colors['border-secondary'],
                '--hover-bg': colors['bg-secondary']
              } as React.CSSProperties}
              onMouseEnter={(e) => {
                e.currentTarget.style.backgroundColor = colors['bg-secondary'];
              }}
              onMouseLeave={(e) => {
                e.currentTarget.style.backgroundColor = colors['bg-primary'];
              }}
            >
              <span 
                className="text-base font-semibold"
                style={{ color: colors['text-primary'] }}
              >
                Cancel
              </span>
            </button>

            {/* Save Button */}
            <button
              onClick={() => {
                if (selectedFile) {
                  onSave(selectedFile);
                  onClose();
                }
              }}
              className="w-full h-11 px-4 py-2.5 rounded-lg shadow-md border-none flex justify-center items-center gap-1.5 transition-all duration-300"
              style={{ 
                backgroundColor: colors['text-accent'],
                '--hover-bg': colors['text-accent-hover']
              } as React.CSSProperties}
              onMouseEnter={(e) => {
                e.currentTarget.style.backgroundColor = colors['text-accent-hover'];
              }}
              onMouseLeave={(e) => {
                e.currentTarget.style.backgroundColor = colors['text-accent'];
              }}
            >
              <span className="text-white text-base font-semibold">Save</span>
            </button>
          </div>
        </div>
      </div>
    </main>
  );
}
</file>

<file path="app/dashboard/components/UserDropdown.tsx">
'use client';

import React, { useEffect, useRef } from 'react';
import { createClient } from '@/utils/supabase/client';
import { User } from '@/types/user';
import { redirectToRoadmap } from '@/app/utils/roadmap';
import { useColors } from '@/app/theme/hooks';
import { motion } from 'framer-motion';

// Helper function for environment-based logging
const devLog = (...args: any[]) => {
  if (process.env.NODE_ENV !== 'production') {
    console.log(...args);
  }
};

interface UserDropdownProps {
  user: User | null;
  onOpenUserSettings: () => void;
  onOpenHelpCenter: () => void;
  onClose: () => void;
}

export default function UserDropdown({
  user,
  onOpenUserSettings,
  onOpenHelpCenter,
  onClose,
}: UserDropdownProps) {
  const colors = useColors();
  const supabase = createClient();

  const handleLogout = async () => {
    const { error } = await supabase.auth.signOut();
    if (error) {
      console.error('Error logging out:', error.message);
    } else {
      devLog('Successfully logged out');
      window.location.href = '/login';
    }
  };

  const handleRoadmapClick = async () => {
    try {
      // Get authenticated user
      const { data: { user: authUser }, error } = await supabase.auth.getUser();
      devLog('Authenticated user:', authUser);
      devLog('User prop:', user);

      if (authUser && user) {
        devLog('User data being sent to roadmap:', {
          email: user.email,
          id: user.id,
          first_name: user.first_name,
          last_name: user.last_name,
          avatar_url: user.avatar_url
        });
        await redirectToRoadmap(user);
      } else {
        console.error('Authentication check failed:', {
          hasAuthUser: !!authUser,
          hasUserProp: !!user
        });
      }
    } catch (error) {
      console.error('Error in handleRoadmapClick:', error);
    }
  };

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.95, y: -10 }}
      animate={{ opacity: 1, scale: 1, y: 0 }}
      exit={{ opacity: 0, scale: 0.95, y: -10 }}
      transition={{ 
        duration: 0.15, 
        ease: [0.16, 1, 0.3, 1] // Custom easing for smooth feel
      }}
      style={{
        backgroundColor: colors['bg-secondary'],
        borderColor: colors['border-primary']
      }}
      className="h-full rounded-lg shadow-[0px_4px_6px_-2px_rgba(16,24,40,0.03)] py-1 border flex-col justify-start items-start inline-flex overflow-hidden z-[70]"
    >
      <div className="h-full flex-col justify-start items-start flex overflow-hidden">
        {/* Settings Item */}
        <div
          className="self-stretch px-1.5 py-px justify-start items-center inline-flex cursor-pointer"
          onClick={() => {
            onOpenUserSettings();
            // Delay closing the dropdown to allow modal to start loading
            setTimeout(onClose, 50);
          }}
        >
          <div 
            style={{
              '--hover-bg': colors['bg-quaternary']
            } as React.CSSProperties}
            className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-200 overflow-hidden">
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative overflow-hidden">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/user-profile.svg`}
                  alt="Settings Icon"
                  className="w-4 h-4 object-contain"
                />
              </div>
              <div 
                style={{ color: colors['text-primary'] }}
                className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight">
                Account settings
              </div>
            </div>
          </div>
        </div>

        {/* Horizontal line spacer */}
        <div 
          style={{ borderColor: colors['border-secondary'] }}
          className="self-stretch h-px border-b my-1" />

        {/* Changelog & Roadmap Item */}
        <div className="self-stretch px-1.5 py-px justify-start items-center inline-flex">
          <div
            onClick={handleRoadmapClick}
            style={{
              '--hover-bg': colors['bg-quaternary']
            } as React.CSSProperties}
            className="cursor-pointer grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-200 overflow-hidden"
          >
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative overflow-hidden">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/compass-icon.svg`}
                  alt="Compass Icon"
                  className="w-4 h-4 object-contain"
                />
              </div>
              <div 
                style={{ color: colors['text-primary'] }}
                className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight">
                Changelog &amp; Roadmap
              </div>
            </div>
          </div>
        </div>

        {/* Slack community */}
        <a
          href="https://join.slack.com/t/processflowcommunity/shared_invite/zt-2z10aormq-aFsRf5mw1~~Y~ryFXgrwog"
          target="_blank"
          rel="noopener noreferrer"
          className="self-stretch px-1.5 py-px justify-start items-center inline-flex cursor-pointer"
        >
          <div 
            style={{
              '--hover-bg': colors['bg-quaternary']
            } as React.CSSProperties}
            className="grow shrink basis-0 h-[38px] px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-200 overflow-hidden">
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative overflow-hidden">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/slack.svg`}
                  alt="Slack Icon"
                  className="w-full h-full object-contain"
                />
              </div>
              <div 
                style={{ color: colors['text-primary'] }}
                className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight">
                Slack Community
              </div>
            </div>
          </div>
        </a>

        {/* Support Item */}
        <div
          className="self-stretch px-1.5 py-px justify-start items-center inline-flex cursor-pointer"
          onClick={() => {
            onOpenHelpCenter();
            // Delay closing the dropdown to allow modal to start loading
            setTimeout(onClose, 50);
          }}
        >
          <div 
            style={{
              '--hover-bg': colors['bg-quaternary']
            } as React.CSSProperties}
            className="grow shrink basis-0 h-[38px] px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-200 overflow-hidden">
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative overflow-hidden">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/support-icon.svg`}
                  alt="Support Icon"
                  className="w-4 h-4 object-contain"
                />
              </div>
              <div 
                style={{ color: colors['text-primary'] }}
                className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight">
                Support
              </div>
            </div>
          </div>
        </div>

        {/* Horizontal line spacer */}
        <div 
          style={{ borderColor: colors['border-secondary'] }}
          className="self-stretch h-px border-b my-1" />

        {/* Log out Item */}
        <div 
          className="self-stretch px-1.5 py-px justify-start items-center inline-flex cursor-pointer"
          onClick={handleLogout}
        >
          <div 
            style={{
              '--hover-bg': colors['bg-quaternary']
            } as React.CSSProperties}
            className="grow shrink basis-0 h-[38px] px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-200 overflow-hidden">
            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
              <div className="w-4 h-4 relative overflow-hidden">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/log-out-icon.svg`}
                  alt="Log Out Icon"
                  className="w-4 h-4 object-contain"
                />
              </div>
              <div 
                style={{ color: colors['text-primary'] }}
                className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight">
                Log out
              </div>
            </div>
          </div>
        </div>
      </div>
    </motion.div>
  );
}
</file>

<file path="app/dashboard/components/UserInfo.tsx">
// components/UserInfo.tsx

'use client';

import React from 'react';
import { User } from '@/types/user';

interface UserInfoProps {
  user: User | null;
  isActive?: boolean;
}

export default function UserInfo({ user, isActive = false }: UserInfoProps) {
  // Define the default avatar URL using environment variables.
  const defaultAvatar = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/images/default_avatar.png`;

  // First try to use the direct avatar_url (which could be a Google avatar URL)
  // Then fall back to avatar_signed_url if it exists
  // Finally use the default avatar
  const avatarSrc = user?.avatar_url
    ? user.avatar_url.startsWith('http')
      ? user.avatar_url // Use as is if it's a full URL (like Google avatar)
      : user?.avatar_signed_url
        ? user.avatar_signed_url
        : defaultAvatar
    : defaultAvatar;

  return (
    <div
      className={`flex items-center select-none rounded-full border transition-all duration-300 hover:bg-lightMode-bg-primary_hover ${
        isActive
          ? 'border-[#4E6BD7] shadow-[0px_0px_0px_4px_rgba(78,107,215,0.12)]'
          : 'border-transparent'
      }`}
      data-testid="user-settings"
      draggable="false"
    >
      {/* Avatar */}
      <img
        src={avatarSrc}
        alt="User Avatar"
        className="w-10 h-10 rounded-full object-cover select-none"
        draggable="false"
      />

      {/* User Info */}
      <div className="flex flex-col">
        <div className="text-[#101828] text-sm font-semibold hidden">
          {user?.first_name ? `${user.first_name} ${user.last_name}` : 'User'}
        </div>
        <div className="text-[#475467] text-sm hidden">
          {user?.email || 'user@example.com'}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/dashboard/components/UserSettings.tsx">
// components/UserSettings.tsx
'use client';

import React, { useEffect, useRef, useState } from 'react';
import { createClient } from '@/utils/supabase/client';
import { User } from '@/types/user';
import ButtonNormal from '@/app/components/ButtonNormal';
import ButtonDestructive from '@/app/components/ButtonDestructive';
import InputField from '@/app/components/InputFields';
import { useColors } from '@/app/theme/hooks';
import { toast } from 'sonner';

interface UserSettingsProps {
  user: User;
  onClose: () => void;
  updateNewPassword: React.Dispatch<React.SetStateAction<string>>;
  passwordChanged: boolean;
  openDeleteAccount: () => void;
  onUserUpdate?: (updatedUser: User) => void;
}

// Utility to sanitize name input
function sanitizeNameInput(value: string): string {
  // Remove leading/trailing whitespace
  let sanitized = value.trim();

  // Remove any HTML tags
  sanitized = sanitized.replace(/<[^>]*>?/gm, '');

  // Allow only letters, spaces, hyphens, and apostrophes
  sanitized = sanitized.replace(/[^a-zA-Z-' -]/g, '');

  return sanitized;
}

export default function UserSettings({
  user,
  onClose,
  updateNewPassword,
  passwordChanged,
  openDeleteAccount,
  onUserUpdate,
}: UserSettingsProps) {
  const colors = useColors();
  const supabase = createClient();

  // Local state for avatar deletion
  const [isDeleteAvatar, setIsDeleteAvatar] = useState(false);

  // Add local state for preview file and preview URL
  const [previewFile, setPreviewFile] = useState<File | null>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);

  const handleLogout = async () => {
    const { error } = await supabase.auth.signOut();
    if (error) {
      console.error('Error logging out:', error.message);
    } else {
      window.location.href = '/login';
    }
  };

  // Update the avatar URL handling logic
  const defaultAvatar = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/images/default_avatar.png`;

  // First try to use the direct avatar_url (which could be a Google avatar URL)
  // Then fall back to avatar_signed_url if it exists
  // Finally use the default avatar
  const avatarSrc = user.avatar_url
    ? user.avatar_url.startsWith('http')
      ? user.avatar_url // Use as is if it's a full URL (like Google avatar)
      : user.avatar_signed_url
        ? user.avatar_signed_url
        : defaultAvatar
    : defaultAvatar;

  // Local state for file upload and preview.
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Local state for editable fields.
  const [firstName, setFirstName] = useState<string>(
    sanitizeNameInput(user.first_name).slice(0, 40)
  );
  const [lastName, setLastName] = useState<string>(
    sanitizeNameInput(user.last_name).slice(0, 40)
  );
  const [newEmail, setNewEmail] = useState<string>(user.email);

  // New states for password change section.
  const [showPasswordForm, setShowPasswordForm] = useState<boolean>(false);
  const [oldPassword, setOldPassword] = useState<string>('');
  const [newPassword, setNewPassword] = useState<string>('');
  const [confirmNewPassword, setConfirmNewPassword] = useState<string>('');

  // Error messages for password fields.
  const [oldPasswordError, setOldPasswordError] = useState<string>('');
  const [newPasswordError, setNewPasswordError] = useState<string>('');
  const [confirmPasswordError, setConfirmPasswordError] = useState<string>('');

  // Add this to your existing state declarations
  const [isSaving, setIsSaving] = useState(false);
  const [isUpdatingPassword, setIsUpdatingPassword] = useState(false);

  // Update local state when user changes.
  useEffect(() => {
    setFirstName(sanitizeNameInput(user.first_name).slice(0, 40));
    setLastName(sanitizeNameInput(user.last_name).slice(0, 40));
    setNewEmail(user.email);
  }, [user]);

  // --- Add these handlers for sanitization and length cap ---
  const handleFirstNameChange = (value: string) => {
    const sanitized = sanitizeNameInput(value).slice(0, 40);
    setFirstName(sanitized);
  };

  const handleLastNameChange = (value: string) => {
    const sanitized = sanitizeNameInput(value).slice(0, 40);
    setLastName(sanitized);
  };

  // --- Sanitize email input as well ---
  const handleEmailChange = (value: string) => {
    setNewEmail(value.trim().replace(/<[^>]*>?/gm, ''));
  };

  // --- Update file input handler for type/size check ---
  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      // Check file type (image only)
      if (!file.type.startsWith('image/')) {
        toast.error('Invalid file type', {
          description: 'Please select a valid image file.',
          duration: 5000,
        });
        event.target.value = '';
        return;
      }
      // Check file size (max 1MB)
      if (file.size > 1024 * 1024) {
        toast.error('File too large', {
          description: 'Image must be less than 1MB.',
          duration: 5000,
        });
        event.target.value = '';
        return;
      }

      setIsDeleteAvatar(false);

      setPreviewFile(file);
      const objectUrl = URL.createObjectURL(file);
      setPreviewUrl(objectUrl);

      if (process.env.NODE_ENV !== 'production') {
        console.log('Selected file:', {
          name: file.name,
          size: file.size,
          type: file.type,
          lastModified: file.lastModified,
        });
      }
    }
    event.target.value = '';
  };

  // Clean up the preview URL when the component unmounts or when a new file is selected
  useEffect(() => {
    return () => {
      if (previewUrl) {
        URL.revokeObjectURL(previewUrl);
      }
    };
  }, [previewUrl]);

  // Simple email validation.
  const validateEmail = (email: string): boolean => {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  };

  // Handle the change email button.
  const handleChangeEmail = async () => {
    if (newEmail === user.email) return; // Nothing to change.
    if (!validateEmail(newEmail)) {
      toast.error('Invalid Email', {
        description: 'Please enter a valid email address.',
        duration: 5000,
      });
      return;
    }
    const { error } = await supabase.auth.updateUser({ email: newEmail });
    if (error) {
      console.error('Error updating email:', error.message);
      toast.error('Failed to Update Email', {
        description: error.message,
        duration: 5000,
      });
      return;
    }
    toast.success('Confirmation Email Sent', {
      description:
        'Please check your new email inbox and click the confirmation link to complete the email change.',
      duration: 7000,
    });
    // Note: We don't update the parent component here anymore since the email isn't actually changed yet
  };

  // Save changes: upload new avatar (if selected) and update the user record (excluding email).
  const handleSave = async () => {
    setIsSaving(true);
    try {
      let newAvatarUrl = user.avatar_url; // Default to current avatar.

      // If a new file was selected, perform the upload.
      if (previewFile && !isDeleteAvatar) {
        try {
          const formData = new FormData();
          formData.append('file', previewFile);

          const uploadRes = await fetch('/api/upload/avatar', {
            method: 'POST',
            body: formData,
          });
          const uploadData = await uploadRes.json();

          if (uploadRes.ok && uploadData.filePath) {
            newAvatarUrl = uploadData.filePath;
          } else {
            console.error('File upload failed', uploadData.error);
          }
        } catch (error) {
          console.error('Error during file upload:', error);
        }
      }

      // Compute full_name based on updated firstName and lastName.
      const fullName = `${firstName} ${lastName}`;

      // Update the user record in your database (excluding the email update).
      const updateRes = await fetch('/api/user/update', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          id: user.id,
          avatar_url: newAvatarUrl,
          first_name: firstName,
          last_name: lastName,
          full_name: fullName,
          delete_avatar: isDeleteAvatar,
        }),
      });

      if (updateRes.ok) {
        const updatedUser = await updateRes.json();
        if (onUserUpdate) {
          onUserUpdate(updatedUser);
        }
      } else {
        console.error('Failed to update user information');
      }

      // Close the modal after saving.
      onClose();
    } catch (error) {
      console.error('Error saving settings:', error);
    } finally {
      setIsSaving(false);
    }
  };

  // Handle canceling the password change.
  const handleCancelPasswordChange = () => {
    setShowPasswordForm(false);
    setOldPassword('');
    setNewPassword('');
    setConfirmNewPassword('');
    setOldPasswordError('');
    setNewPasswordError('');
    setConfirmPasswordError('');
  };

  // Handle updating the password.
  const handleUpdatePassword = async () => {
    // Reset previous error messages
    setOldPasswordError('');
    setNewPasswordError('');
    setConfirmPasswordError('');

    // Check that new password is at least 6 characters
    if (newPassword.length < 6) {
      setNewPasswordError('The new password must be at least 6 characters.');
      return;
    }

    // Check that new password and confirm password match
    if (newPassword !== confirmNewPassword) {
      setConfirmPasswordError('The passwords do not match.');
      return;
    }

    setIsUpdatingPassword(true);
    try {
      // Verify that the old password is correct
      const data = {
        email: user.email as string,
        password: oldPassword as string,
      };

      const { error } = await supabase.auth.signInWithPassword(data);
      if (error) {
        setOldPasswordError('The old password is incorrect.');
        return;
      }

      updateNewPassword(newPassword);
      handleCancelPasswordChange();
    } catch (error) {
      console.error('Error updating password:', error);
    } finally {
      setIsUpdatingPassword(false);
    }
  };

  return (
    <div
      className="fixed inset-0 flex items-center justify-center p-8"
      onClick={onClose}
    >
      {/* Backdrop */}
      <div className="absolute inset-0">
        <div
          style={{ backgroundColor: colors['bg-overlay'] }}
          className="absolute inset-0 opacity-70"
        />
      </div>

      <div
        style={{ backgroundColor: colors['bg-primary'] }}
        className="w-[628px] max-h-[90vh] rounded-xl shadow-[0px_8px_8px_-4px_rgba(16,24,40,0.03)] flex-col justify-start items-start inline-flex overflow-hidden relative z-10"
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="self-stretch h-[92px] flex-col justify-start items-center flex">
          <div className="self-stretch px-6 pt-6 justify-start items-center gap-4 inline-flex">
            <div
              style={{ backgroundColor: colors['bg-tertiary'] }}
              className="w-12 h-12 p-3 rounded-full justify-center items-center flex overflow-hidden"
            >
              <div className="w-6 h-6 relative flex-col justify-start items-start flex overflow-hidden">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/user-profile.svg`}
                  alt="Settings Icon"
                  className="w-6 h-6 object-contain"
                />
              </div>
            </div>
            <div className="w-[432px] flex-col justify-start items-start gap-1 inline-flex">
              <div
                style={{ color: colors['text-primary'] }}
                className="self-stretch text-lg font-semibold font-['Inter'] leading-7"
              >
                Account settings
              </div>
            </div>
          </div>
          <div className="self-stretch h-5" />
        </div>

        {/* Body */}
        <div className="self-stretch overflow-y-auto flex-1 w-full">
          <div className="w-full p-6 flex-col justify-start items-start gap-5 inline-flex">
            {/* Main settings form */}
            <div className="w-full flex-col justify-start items-start gap-6 flex">
              <div className="w-full flex-col justify-start items-start gap-5 flex pr-4">
                {/* Photo & Name section */}
                <div className="w-full flex-col justify-start items-start gap-4 flex">
                  {/* Photo label */}
                  <div className="w-full flex-col justify-start items-start flex">
                    <div className="inline-flex gap-0.5">
                      <div
                        style={{ color: colors['text-primary'] }}
                        className="text-sm font-semibold font-['Inter'] leading-tight"
                      >
                        Your photo
                      </div>
                    </div>
                    <div
                      style={{ color: colors['text-secondary'] }}
                      className="self-stretch text-sm font-normal font-['Inter'] leading-tight"
                    >
                      This will be displayed as your avatar.
                    </div>
                  </div>
                  {/* Photo controls */}
                  <div className="w-full justify-start items-center gap-4 inline-flex">
                    <input
                      type="file"
                      ref={fileInputRef}
                      onChange={handleFileChange}
                      accept="image/*"
                      className="hidden"
                    />
                    <div
                      className="w-16 h-16 rounded-full justify-center overflow-hidden items-center flex relative group cursor-pointer"
                      onClick={() => fileInputRef.current?.click()}
                    >
                      <div
                        style={{ borderColor: colors['border-secondary'] }}
                        className="w-16 h-16 relative rounded-full border"
                      >
                        <img
                          src={
                            isDeleteAvatar
                              ? defaultAvatar
                              : previewUrl
                                ? previewUrl
                                : avatarSrc
                          }
                          alt="User Avatar"
                          className="w-16 h-16 rounded-full object-cover"
                        />
                        {/* Edit overlay on hover */}
                        <div className="absolute inset-0 bg-black bg-opacity-40 rounded-full opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex items-center justify-center">
                          <div className="w-8 h-8 bg-white bg-opacity-20 rounded-full flex items-center justify-center">
                            <img
                              src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                              alt="Edit"
                              className="w-5 h-5 brightness-[10]"
                            />
                          </div>
                        </div>
                      </div>
                    </div>
                    <ButtonDestructive
                      variant="tertiary"
                      size="small"
                      leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-icon.svg`}
                      onClick={() => setIsDeleteAvatar(true)}
                    >
                      Delete
                    </ButtonDestructive>
                  </div>
                  {/* Name section */}
                  <div className="w-full flex-col justify-start items-start gap-4 flex">
                    <div className="w-full flex-col justify-start items-start flex">
                      <div className="inline-flex gap-0.5">
                        <div
                          style={{ color: colors['text-primary'] }}
                          className="text-sm font-semibold font-['Inter'] leading-tight"
                        >
                          Name
                        </div>
                      </div>
                    </div>
                    <div className="w-full justify-start items-center gap-4 inline-flex">
                      <div className="grow shrink basis-0 flex-col justify-start items-start gap-1.5 inline-flex">
                        <InputField
                          type="default"
                          value={lastName}
                          onChange={handleLastNameChange}
                          placeholder="Last name"
                        />
                      </div>
                      <div className="grow shrink basis-0 flex-col justify-start items-start gap-1.5 inline-flex">
                        <InputField
                          type="default"
                          value={firstName}
                          onChange={handleFirstNameChange}
                          placeholder="First name"
                        />
                      </div>
                    </div>
                  </div>
                </div>
                {/* Divider */}
                <div
                  style={{ borderColor: colors['border-secondary'] }}
                  className="w-full border-b flex-col justify-start items-start flex"
                />
                {/* Email section */}
                <div className="w-full flex-col justify-start items-start gap-4 flex">
                  <div className="w-full flex-col justify-start items-start flex">
                    <div className="inline-flex gap-0.5">
                      <div
                        style={{ color: colors['text-primary'] }}
                        className="text-sm font-semibold font-['Inter'] leading-tight"
                      >
                        Email
                      </div>
                    </div>
                  </div>
                  <div className="w-full justify-start items-center gap-4 inline-flex">
                    <div className="grow shrink basis-0 flex-col justify-start items-start gap-1.5 inline-flex">
                      <div className="w-full h-10 flex-col justify-start items-start gap-1.5 flex">
                        <div className="relative w-full">
                          <InputField
                            type="default"
                            value={newEmail}
                            iconColor={colors['text-primary']}
                            onChange={handleEmailChange}
                            placeholder="Enter email"
                            iconUrl={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/mail-01.svg`}
                          />
                        </div>
                      </div>
                    </div>
                    <ButtonNormal
                      variant="secondary"
                      size="small"
                      onClick={handleChangeEmail}
                      disabled={newEmail === user.email}
                      className="h-full"
                    >
                      Change email
                    </ButtonNormal>
                  </div>
                </div>
                {/* Divider */}
                <div
                  style={{ borderColor: colors['border-secondary'] }}
                  className="w-full border-b flex-col justify-start items-start flex"
                />
                {/* Password section */}

                {!showPasswordForm ? (
                  // When the form is hidden, show the change password button.
                  <div className="w-full flex flex-col gap-4">
                    {/* Header and Change Password Button */}
                    <div className="w-full flex flex-col gap-4">
                      <div className="w-full flex items-center">
                        <div className="inline-flex gap-0.5">
                          <div
                            style={{ color: colors['text-primary'] }}
                            className="text-sm font-semibold font-['Inter'] leading-tight"
                          >
                            Password
                          </div>
                        </div>
                      </div>
                      <ButtonNormal
                        variant="secondary"
                        size="small"
                        onClick={() => setShowPasswordForm(true)}
                        className="w-fit"
                      >
                        Change password
                      </ButtonNormal>
                    </div>

                    {/* Confirmation Message - displayed when passwordChanged is true */}
                    {passwordChanged && (
                      <div className="h-[52px] py-0 rounded-xl flex items-center gap-4 mt-0">
                        <div
                          style={{ backgroundColor: colors['bg-success'] }}
                          className="w-5 h-5 rounded-full overflow-hidden"
                        >
                          <img
                            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-icon-green.svg`}
                            alt="Mail Icon"
                            className="w-5 h-5 object-contain"
                          />
                        </div>
                        <div className="flex flex-col gap-1">
                          <div
                            style={{ color: colors['text-primary'] }}
                            className="text-sm font-semibold font-['Inter'] leading-tight"
                          >
                            Your password has been changed successfully
                          </div>
                        </div>
                      </div>
                    )}
                  </div>
                ) : (
                  // When the form is displayed, show the full password change section.
                  <div className="flex flex-col w-96 gap-4 rounded-lg">
                    <div
                      style={{ color: colors['text-primary'] }}
                      className="text-sm font-semibold font-['Inter'] leading-tight"
                    >
                      Password
                    </div>
                    <div className="flex flex-col gap-4">
                      {/* Old password field */}
                      <div className="flex flex-col gap-1.5">
                        <label
                          style={{ color: colors['text-primary'] }}
                          className="text-sm font-medium font-['Inter'] leading-tight"
                        >
                          Old password
                        </label>
                        <InputField
                          type="password"
                          value={oldPassword}
                          onChange={setOldPassword}
                          placeholder="Old password"
                          iconColor={colors['text-primary']}
                          errorMessage={oldPasswordError}
                        />
                      </div>

                      {/* New password field */}
                      <div className="flex flex-col gap-1.5">
                        <label
                          style={{ color: colors['text-primary'] }}
                          className="text-sm font-medium font-['Inter'] leading-tight"
                        >
                          New password
                        </label>
                        <InputField
                          type="password"
                          value={newPassword}
                          iconColor={colors['text-primary']}
                          onChange={setNewPassword}
                          placeholder="New password"
                          errorMessage={newPasswordError}
                        />
                      </div>

                      {/* Confirm new password field */}
                      <div className="flex flex-col gap-1.5">
                        <label
                          style={{ color: colors['text-primary'] }}
                          className="text-sm font-medium font-['Inter'] leading-tight"
                        >
                          Confirm new password
                        </label>
                        <InputField
                          type="password"
                          value={confirmNewPassword}
                          iconColor={colors['text-primary']}
                          onChange={setConfirmNewPassword}
                          placeholder="Confirm new password"
                          errorMessage={confirmPasswordError}
                        />
                      </div>
                    </div>
                    {/* Action buttons */}
                    <div className="flex gap-4">
                      <ButtonNormal
                        variant="secondary"
                        size="small"
                        onClick={handleCancelPasswordChange}
                      >
                        Cancel change
                      </ButtonNormal>
                      <ButtonNormal
                        variant="primary"
                        size="small"
                        onClick={handleUpdatePassword}
                        isLoading={isUpdatingPassword}
                        loadingText="Updating password..."
                      >
                        Update password
                      </ButtonNormal>
                    </div>
                  </div>
                )}

                {/* Divider */}
                <div
                  style={{ borderColor: colors['border-secondary'] }}
                  className="w-full border-b flex-col justify-start items-start flex"
                />

                {/* Account Security section */}
                <div className="w-full flex-col justify-start items-start gap-4 flex">
                  <div className="w-full flex-col justify-start items-start flex">
                    <div className="inline-flex gap-0.5">
                      <div
                        style={{ color: colors['text-primary'] }}
                        className="text-sm font-semibold font-['Inter'] leading-tight"
                      >
                        Account Security
                      </div>
                    </div>
                  </div>
                  <div className="flex items-center gap-4">
                    <ButtonNormal
                      variant="secondary"
                      size="small"
                      leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/log-out-icon.svg`}
                      onClick={() => handleLogout()}
                    >
                      Log out
                    </ButtonNormal>
                    <ButtonDestructive
                      variant="secondary"
                      size="small"
                      leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/delete-icon-red.svg`}
                      onClick={() => openDeleteAccount()}
                    >
                      Delete my account
                    </ButtonDestructive>
                  </div>
                </div>
              </div>
              {/* Divider */}
              <div
                style={{ borderColor: colors['border-secondary'] }}
                className="w-full border-b flex-col justify-start items-start flex"
              />
              {/* Footer buttons */}
              <div className="w-full flex-col justify-start items-center gap-5 flex">
                <div className="w-full flex justify-end items-center gap-5">
                  <div className="grow shrink basis-0 h-10 flex justify-end items-center gap-3">
                    <ButtonNormal
                      variant="secondary"
                      size="small"
                      onClick={onClose}
                    >
                      Cancel
                    </ButtonNormal>
                    <ButtonNormal
                      variant="primary"
                      size="small"
                      onClick={handleSave}
                      isLoading={isSaving}
                      loadingText="Saving..."
                    >
                      Save
                    </ButtonNormal>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/dashboard/hooks/useFolderPositioning.ts">
'use client';

import { useState } from 'react';
import { Folder, Workspace } from '@/types/workspace';
import { toast } from 'react-hot-toast';

export function useFolderPositioning(
  activeWorkspace: Workspace,
  setWorkspaces: (workspaces: Workspace[]) => void,
  workspaces: Workspace[]
) {
  const [isUpdating, setIsUpdating] = useState(false);

  /**
   * Update folder positions in the database and refresh the workspace data
   */
  const updateFolderPositions = async (
    folderId: number,
    newParentId: number | null,
    newPosition: number,
    optimisticWorkspace?: Workspace 
  ) => {
    setIsUpdating(true);
    try {
      // If we have an optimistically updated workspace, use it immediately
      if (optimisticWorkspace) {
        setWorkspaces(workspaces.map(ws => 
          ws.id === optimisticWorkspace.id ? optimisticWorkspace : ws
        ));
      }

      const response = await fetch('/api/workspace/folders/update-position', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          folderId,
          newParentId,
          newPosition,
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to update folder position');
      }

      // Only fetch from server if we didn't provide an optimistic update
      if (!optimisticWorkspace) {
        // Update was successful, but we need to refresh the folders in the workspace
        const workspaceResponse = await fetch(`/api/workspace/${activeWorkspace.id}`);
        
        if (workspaceResponse.ok) {
          const updatedWorkspace = await workspaceResponse.json();
          
          // Update the local state with the new workspace data
          setWorkspaces(workspaces.map(ws => 
            ws.id === updatedWorkspace.id ? updatedWorkspace : ws
          ));
        }
      }
      
      return true;
    } catch (error) {
      console.error('Error updating folder position:', error);
      toast.error('Failed to update folder position');

      // If we used an optimistic update but the request failed, revert to the original workspace
      if (optimisticWorkspace) {
        const workspaceResponse = await fetch(`/api/workspace/${activeWorkspace.id}`);
        if (workspaceResponse.ok) {
          const originalWorkspace = await workspaceResponse.json();
          setWorkspaces(workspaces.map(ws => 
            ws.id === activeWorkspace.id ? originalWorkspace : ws
          ));
        }
      }
      
      return false;
    } finally {
      setIsUpdating(false);
    }
  };

  return {
    updateFolderPositions,
    isUpdating,
  };
}
</file>

<file path="app/dashboard/styles/tutorial.module.css">
@keyframes tutorialPulse {
  0% {
    box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.6);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(99, 102, 241, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(99, 102, 241, 0);
  }
}

.highlight {
  animation: tutorialPulse 2s infinite;
  position: relative;
  z-index: 51;
  cursor: pointer;
}

/* Add pointer-events auto to elements with data-tutorial-active attribute */
.highlight[data-tutorial-active="true"] {
  pointer-events: auto;
  z-index: 52;
}

.highlight::after {
  content: '';
  position: absolute;
  top: -4px;
  left: -4px;
  right: -4px;
  bottom: -4px;
  border-radius: 8px;
  pointer-events: none;
}

.highlightFolders::after {
  border-radius: 4px;
  top: -2px;
  left: -2px;
  right: -2px;
  bottom: -2px;
}

.darkFolderHighlight {
  background-color: rgba(255, 255, 255, 0.1) !important;
}

.lightFolderHighlight {
  background-color: rgba(255, 255, 255, 1) !important;
}

.highlightWorkspace::after {
  border-radius: 4px;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

.highlightUser::after {
  border-radius: 50%;
  top: -4px;
  left: -4px;
  right: -4px;
  bottom: -4px;
}

.overlayBlocker {
  position: fixed;
  inset: 0;
  z-index: 49;
  cursor: not-allowed;
}
</file>

<file path="app/docs/page.jsx">
'use client';

import dynamic from 'next/dynamic';
import 'swagger-ui-react/swagger-ui.css';

const SwaggerUI = dynamic(
  () => Promise.resolve(require('swagger-ui-react').default),
  { ssr: false }
);

export default function ApiDocsPage() {
  return <SwaggerUI url="/api/docs" />;
}
</file>

<file path="app/error/page.tsx">
'use client';

import { useSearchParams } from 'next/navigation';
import { Suspense } from 'react';
import LoadingSpinner from '../components/LoadingSpinner';

function ErrorMessage() {
  const searchParams = useSearchParams();
  const errorMessage =
    searchParams?.get('message') || 'Sorry, something went wrong';

  return <p>{errorMessage}</p>;
}

export default function ErrorPage() {
  return (
    <Suspense fallback={<LoadingSpinner size="medium" />}>
      <ErrorMessage />
    </Suspense>
  );
}
</file>

<file path="app/hooks/useToast.ts">
'use client';

import { useState, useCallback } from 'react';

interface ToastData {
  id: string;
  message: string;
  type: 'success' | 'error' | 'info' | 'warning';
  duration?: number;
}

export const useToast = () => {
  const [toasts, setToasts] = useState<ToastData[]>([]);

  const addToast = useCallback((message: string, type: ToastData['type'] = 'info', duration = 3000) => {
    const id = Math.random().toString(36).substring(2, 9);
    const toast: ToastData = { id, message, type, duration };
    
    setToasts((prev) => [...prev, toast]);
    
    return id;
  }, []);

  const removeToast = useCallback((id: string) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
  }, []);

  const success = useCallback((message: string, duration?: number) => {
    return addToast(message, 'success', duration);
  }, [addToast]);

  const error = useCallback((message: string, duration?: number) => {
    return addToast(message, 'error', duration);
  }, [addToast]);

  const warning = useCallback((message: string, duration?: number) => {
    return addToast(message, 'warning', duration);
  }, [addToast]);

  const info = useCallback((message: string, duration?: number) => {
    return addToast(message, 'info', duration);
  }, [addToast]);

  return {
    toasts,
    addToast,
    removeToast,
    success,
    error,
    warning,
    info,
  };
};
</file>

<file path="app/not-found/page.tsx">
'use client';

import { useTheme } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';
import Link from 'next/link';
import { useSupabaseSession } from '@/hooks/useSupabaseSession';

export default function NotFound() {
  const { getCssVariable } = useTheme();
  const { user } = useSupabaseSession();

  return (
    <div 
      className="flex flex-col items-center justify-center min-h-screen"
      style={{ 
        backgroundColor: getCssVariable('button-secondary-bg'),
        color: getCssVariable('button-secondary-fg')
      }}
    >
      <h1 className="text-4xl font-bold">404 - Not Found</h1>
      <p className="mt-4" style={{ color: getCssVariable('button-tertiary-fg') }}>
        The page you're looking for doesn't exist.
      </p>
      <div className="mt-8">
        <Link href={user ? '/' : '/login'}>
          <ButtonNormal variant="primary">
            {user ? 'Return to Dashboard' : 'Go to Login'}
          </ButtonNormal>
        </Link>
      </div>
    </div>
  );
}
</file>

<file path="app/onboarding/components/MotionStep.tsx">
import { motion } from 'framer-motion';
import React from 'react';

interface MotionStepProps {
  children: React.ReactNode;
}

const MotionStep: React.FC<MotionStepProps> = ({ children }) => {
  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      transition={{ duration: 0.3 }}
      className="w-full"
    >
      {children}
    </motion.div>
  );
};

export default MotionStep;
</file>

<file path="app/onboarding/utils/inputSanitizer.ts">
/**
 * Sanitizes name input (first name, last name)
 * @param value The input value to sanitize
 * @returns Sanitized string that only allows letters, spaces, hyphens, and apostrophes
 */
export function sanitizeNameInput(value: string): string {
  // Remove any HTML tags
  let sanitized = value.replace(/<[^>]*>?/gm, '');
  // Allow only letters, spaces, hyphens, and apostrophes
  sanitized = sanitized.replace(/[^a-zA-Z-'\- ]/g, '');
  return sanitized;
}

/**
 * Sanitizes workspace name input
 * @param value The input value to sanitize
 * @returns Sanitized string that allows letters, numbers, spaces, hyphens, and apostrophes
 */
export function sanitizeWorkspaceNameInput(value: string): string {
  // Remove HTML tags
  let sanitized = value.replace(/<[^>]*>?/gm, '');
  // Only allow letters, numbers, spaces, and hyphens
  sanitized = sanitized.replace(/[^a-zA-Z0-9\- ]/g, '');
  // Limit to 50 characters
  sanitized = sanitized.slice(0, 50);
  return sanitized;
}

/**
 * Generates a URL slug from a workspace name
 * @param name The workspace name
 * @returns A URL-friendly slug
 */
export function generateSlugFromName(name: string): string {
  return name
    .toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^a-zA-Z0-9-]/g, '');
}
</file>

<file path="app/onboarding/layout.tsx">
import type { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'ProcessFlow',
  description: '',
};

export default function OnboardingLayout({ children }: { children: React.ReactNode }) {
  // No <body> here! Just return children.
  return <>{children}</>;
}
</file>

<file path="app/password-reset/page.tsx">
import React from 'react';

export default function Home() {
  return (
    <div className="relative w-full min-h-screen bg-white overflow-hidden flex items-center justify-center">
      {/* Outer gray parent container */}
      <div className="w-[420px] p-3 bg-gray-50 rounded-3xl border border-[#e4e7ec] flex flex-col justify-center items-center gap-2">
        
        {/* Inner white card */}
        <div className="relative w-full px-6 py-8 bg-white rounded-2xl border border-[#e4e7ec] flex flex-col justify-start items-center gap-6 overflow-hidden">
          
          {/* Corner dots (16px from each edge) */}
          <div className="pointer-events-none absolute inset-0">
            <div
              className="
                w-1.5 h-1.5
                bg-white
                rounded-full
                shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)]
                border border-[#e4e7ec]
                absolute
              "
              style={{ top: 16, left: 16 }}
            />
            <div
              className="
                w-1.5 h-1.5
                bg-white
                rounded-full
                shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)]
                border border-[#e4e7ec]
                absolute
              "
              style={{ bottom: 16, left: 16 }}
            />
            <div
              className="
                w-1.5 h-1.5
                bg-white
                rounded-full
                shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)]
                border border-[#e4e7ec]
                absolute
              "
              style={{ top: 16, right: 16 }}
            />
            <div
              className="
                w-1.5 h-1.5
                bg-white
                rounded-full
                shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)]
                border border-[#e4e7ec]
                absolute
              "
              style={{ bottom: 16, right: 16 }}
            />
          </div>

          {/* App icon container */}
          <div
            className="
              z-10
              flex
              justify-start
              items-start
            "
          >
            <div
              className="
                w-10
                h-10
                relative
                overflow-hidden
                bg-white
                rounded-[10px]
                flex
                items-center
                justify-center
              "
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`}
                alt="App Icon"
                className="w-full h-full object-cover"
              />
            </div>
          </div>

          {/* Heading section */}
          <div className="z-10 flex flex-col items-center gap-3 w-full">
            <div className="flex flex-col items-start gap-1 w-full">
              <div
                className="
                  w-full
                  text-center
                  text-[#101828]
                  text-lg
                  font-semibold
                  font-['Inter']
                  leading-7
                "
              >
                Password reset
              </div>
            </div>
          </div>

          {/* Confirmation message */}
          <div className="self-stretch text-center">
            <span className="text-[#475467] text-sm font-normal font-['Inter'] leading-tight">
              Your password has been successfully reset. Click below to log in.
            </span>
          </div>

          {/* Email button */}
                
                <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-icon-onboarding.svg`}
                    alt="Check Icon"
                    className="w-12 h-12"
                />
                <div className="self-stretch h-9 rounded-xl flex flex-col justify-start items-center gap-6">
                <div className="self-stretch h-9 flex flex-col justify-start items-start gap-4">
                    <a 
                    href="mailto:" 
                    className="self-stretch px-3 py-2 bg-[#4e6bd7] rounded-lg shadow-[0px_1px_2px_0px_rgba(16,24,40,0.05)] flex justify-center items-center gap-1 cursor-pointer transition duration-300 hover:bg-[#374c99] no-underline"
                    >
                    <div className="px-0.5 flex justify-center items-center">
                        <div className="text-white text-sm font-semibold font-['Inter'] leading-tight">
                        Continue
                        </div>
                    </div>
                    </a>
                </div>
                </div>



          {/* Back to login */}
                <a 
                href="/login" 
                className="justify-center items-center gap-1.5 flex cursor-pointer text-inherit no-underline"
                >
                <div className="w-5 h-5 relative flex justify-center items-center">
                    <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-left.svg`}
                    alt="Arrow Left Icon"
                    className="w-5 h-5"
                    />
                </div>
                <div className="text-[#475467] text-sm font-semibold font-['Inter'] leading-tight">
                    Back to log in
                </div>
                </a>


        </div>


        <div className="absolute bottom-6 left-1/2 transform -translate-x-1/2">
          <div className="w-[420px] h-9 px-2 py-1.5 bg-gray-50 rounded-full border border-[#e4e7ec] flex justify-center items-center">
            <div className="grow shrink basis-0 h-6 px-2 py-0.5 bg-white rounded-[99px] flex justify-between items-center">
              <div className="text-[#475467] text-sm font-normal">2025  Processflow</div>
              <div className="w-0.5 h-0.5 bg-[#475467] rounded-full mx-2" />
              <a href="/support" className="text-[#475467] text-sm font-normal hover:underline">Support</a>
              <div className="w-0.5 h-0.5 bg-[#475467] rounded-full mx-2" />
              <a href="/privacy" className="text-[#475467] text-sm font-normal hover:underline">Privacy</a>
              <div className="w-0.5 h-0.5 bg-[#475467] rounded-full mx-2" />
              <a href="/terms" className="text-[#475467] text-sm font-normal hover:underline">Terms</a>
            </div>
          </div>
        </div>

      </div>
    </div>
  );
}
</file>

<file path="app/reset-email/page.tsx">
'use client';
import React, { useState } from 'react';
import { toast } from 'sonner';

export default function Home() {
  const [isResending, setIsResending] = useState(false);

  const handleResendEmail = async () => {
    setIsResending(true);
    try {
      const response = await fetch('/api/auth/resend-email', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: 'ceo@process-flow.io' }),
      });

      if (response.ok) {
        toast.success('Email Sent', {
          description: 'A new confirmation email has been sent to your inbox.',
          duration: 5000,
        });
      } else {
        const data = await response.json();
        toast.error('Failed to Resend Email', {
          description: data.error || 'Please try again later.',
          duration: 5000,
        });
      }
    } catch (error) {
      toast.error('Failed to Resend Email', {
        description: 'An unexpected error occurred. Please try again later.',
        duration: 5000,
      });
    } finally {
      setIsResending(false);
    }
  };

  return (
    <div className="relative w-full min-h-screen bg-white overflow-hidden flex items-center justify-center">
      {/* Outer gray parent container */}
      <div className="w-[420px] p-3 bg-gray-50 rounded-3xl border border-[#e4e7ec] flex flex-col justify-center items-center gap-2">
        {/* Inner white card */}
        <div className="relative w-full px-6 py-8 bg-white rounded-2xl border border-[#e4e7ec] flex flex-col justify-start items-center gap-6 overflow-hidden">
          {/* Corner dots (16px from each edge) */}
          <div className="pointer-events-none absolute inset-0">
            <div
              className="
                w-1.5 h-1.5
                bg-white
                rounded-full
                shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)]
                border border-[#e4e7ec]
                absolute
              "
              style={{ top: 16, left: 16 }}
            />
            <div
              className="
                w-1.5 h-1.5
                bg-white
                rounded-full
                shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)]
                border border-[#e4e7ec]
                absolute
              "
              style={{ bottom: 16, left: 16 }}
            />
            <div
              className="
                w-1.5 h-1.5
                bg-white
                rounded-full
                shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)]
                border border-[#e4e7ec]
                absolute
              "
              style={{ top: 16, right: 16 }}
            />
            <div
              className="
                w-1.5 h-1.5
                bg-white
                rounded-full
                shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)]
                border border-[#e4e7ec]
                absolute
              "
              style={{ bottom: 16, right: 16 }}
            />
          </div>

          {/* App icon container */}
          <div
            className="
              z-10
              flex
              justify-start
              items-start
            "
          >
            <div
              className="
                w-10
                h-10
                relative
                overflow-hidden
                bg-white
                rounded-[10px]
                flex
                items-center
                justify-center
              "
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`}
                alt="App Icon"
                className="w-full h-full object-cover"
              />
            </div>
          </div>

          {/* Heading section */}
          <div className="z-10 flex flex-col items-center gap-3 w-full">
            <div className="flex flex-col items-start gap-1 w-full">
              <div
                className="
                  w-full
                  text-center
                  text-[#101828]
                  text-lg
                  font-semibold
                  font-['Inter']
                  leading-7
                "
              >
                Check your email
              </div>
            </div>
          </div>

          {/* Confirmation message */}
          <div className="self-stretch text-center">
            <span className="text-[#475467] text-sm font-normal font-['Inter'] leading-tight">
              We've sent a reset link to
            </span>
            <br />
            <span className="text-[#475467] text-sm font-semibold font-['Inter'] leading-tight">
              ceo@process-flow.io
            </span>
          </div>

          {/* Email button */}

          <img
            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-icon-onboarding.svg`}
            alt="Check Icon"
            className="w-12 h-12"
          />
          <div className="self-stretch h-9 rounded-xl flex flex-col justify-start items-center gap-6">
            <div className="self-stretch h-9 flex flex-col justify-start items-start gap-4">
              <a
                href="mailto:"
                className="self-stretch px-3 py-2 bg-[#4e6bd7] rounded-lg shadow-[0px_1px_2px_0px_rgba(16,24,40,0.05)] flex justify-center items-center gap-1 cursor-pointer transition duration-300 hover:bg-[#374c99] no-underline"
              >
                <div className="px-0.5 flex justify-center items-center">
                  <div className="text-white text-sm font-semibold font-['Inter'] leading-tight">
                    Open email app
                  </div>
                </div>
              </a>
            </div>
          </div>

          {/* Back to login */}
          <a
            href="/login"
            className="justify-center items-center gap-1.5 flex cursor-pointer text-inherit no-underline"
          >
            <div className="w-5 h-5 relative flex justify-center items-center">
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-left.svg`}
                alt="Arrow Left Icon"
                className="w-5 h-5"
              />
            </div>
            <div className="text-[#475467] text-sm font-semibold font-['Inter'] leading-tight">
              Back to log in
            </div>
          </a>
        </div>

        {/* Resend email outside the white container */}
        <button
          onClick={handleResendEmail}
          disabled={isResending}
          className="py-3 flex justify-center items-baseline gap-1 cursor-pointer no-underline"
        >
          <div className="text-[#667085] text-sm font-normal font-['Inter'] leading-tight">
            Didn't receive the email?
          </div>
          <div className="flex justify-center items-center gap-1.5">
            <div className="text-[#374c99] text-sm font-semibold font-['Inter'] leading-tight">
              {isResending ? 'Sending...' : 'Click to resend'}
            </div>
          </div>
        </button>

        <div className="absolute bottom-6 left-1/2 transform -translate-x-1/2">
          <div className="w-[420px] h-9 px-2 py-1.5 bg-gray-50 rounded-full border border-[#e4e7ec] flex justify-center items-center">
            <div className="grow shrink basis-0 h-6 px-2 py-0.5 bg-white rounded-[99px] flex justify-between items-center">
              <div className="text-[#475467] text-sm font-normal">
                2025  Processflow
              </div>
              <div className="w-0.5 h-0.5 bg-[#475467] rounded-full mx-2" />
              <a
                href="/support"
                className="text-[#475467] text-sm font-normal hover:underline"
              >
                Support
              </a>
              <div className="w-0.5 h-0.5 bg-[#475467] rounded-full mx-2" />
              <a
                href="/privacy"
                className="text-[#475467] text-sm font-normal hover:underline"
              >
                Privacy
              </a>
              <div className="w-0.5 h-0.5 bg-[#475467] rounded-full mx-2" />
              <a
                href="/terms"
                className="text-[#475467] text-sm font-normal hover:underline"
              >
                Terms
              </a>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/reset-password/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { createClient } from '@/utils/supabase/client';
import { toast } from 'sonner';

// Password strength validation (same as signup)
const validatePassword = (password: string): boolean => {
  // At least 8 characters, one uppercase, one lowercase, one number, one special character
  const strongPasswordRegex =
    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_\-+=\[\]{};':"\\|,.<>/?]).{8,}$/;
  return strongPasswordRegex.test(password);
};

export default function ResetPasswordPage() {
  const router = useRouter();
  const [showPassword, setShowPassword] = useState(false);
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    // Validate password fields before making the API call
    if (!password || !confirmPassword) {
      toast.error('Missing Fields', {
        description: 'Please fill in both password fields.',
        duration: 5000,
      });
      return;
    }

    if (!validatePassword(password)) {
      toast.error('Weak Password', {
        description:
          'Password must be at least 8 characters and include uppercase, lowercase, number, and special character.',
        duration: 6000,
      });
      return;
    }

    if (password !== confirmPassword) {
      toast.error('Password Mismatch', {
        description: 'Passwords do not match.',
        duration: 5000,
      });
      return;
    }

    setIsLoading(true);

    try {
      const response = await fetch('/api/auth/perform-password-reset', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password }),
      });

      const data = await response.json();
      if (!response.ok) {
        toast.error('Password Reset Failed', { description: data.error });
        setIsLoading(false);
        return;
      }

      toast.success('Password Reset Successful');
      // Optionally sign out and redirect to login
      router.push('/login?message=password-reset-success');
    } catch (error) {
      toast.error('Password Reset Failed', {
        description: 'Unexpected error.',
      });
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="relative w-full min-h-screen bg-white overflow-hidden flex items-center justify-center p-4">
      {/* Outer gray parent container */}
      <div className="w-full max-w-[420px] p-3 bg-gray-50 rounded-3xl border border-[#e4e7ec] flex flex-col justify-center items-center gap-2">
        {/* Inner white card */}
        <div className="relative w-full px-4 sm:px-6 py-6 sm:py-8 bg-white rounded-2xl border border-[#e4e7ec] flex flex-col justify-start items-center gap-4 sm:gap-6 overflow-hidden">
          {/* Corner dots (16px from each edge) */}
          <div className="pointer-events-none absolute inset-0">
            <div
              className="
                w-1.5 h-1.5
                bg-white
                rounded-full
                shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)]
                border border-[#e4e7ec]
                absolute
              "
              style={{ top: 16, left: 16 }}
            />
            <div
              className="
                w-1.5 h-1.5
                bg-white
                rounded-full
                shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)]
                border border-[#e4e7ec]
                absolute
              "
              style={{ bottom: 16, left: 16 }}
            />
            <div
              className="
                w-1.5 h-1.5
                bg-white
                rounded-full
                shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)]
                border border-[#e4e7ec]
                absolute
              "
              style={{ top: 16, right: 16 }}
            />
            <div
              className="
                w-1.5 h-1.5
                bg-white
                rounded-full
                shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)]
                border border-[#e4e7ec]
                absolute
              "
              style={{ bottom: 16, right: 16 }}
            />
          </div>

          {/* App icon container */}
          <div
            className="
              z-10
              flex
              justify-start
              items-start
            "
          >
            <div
              className="
                w-10
                h-10
                relative
                overflow-hidden
                bg-white
                rounded-[10px]
                flex
                items-center
                justify-center
              "
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`}
                alt="App Icon"
                className="w-full h-full object-cover"
              />
            </div>
          </div>

          {/* Heading section */}
          <div className="z-10 flex flex-col items-center gap-3 w-full">
            <div className="flex flex-col items-start gap-1 w-full">
              <div
                className="
                  w-full
                  text-center
                  text-[#101828]
                  text-lg
                  font-semibold
                  font-['Inter']
                  leading-7
                "
              >
                Set new password
              </div>
              <div
                className="
                  w-full
                  text-center
                  text-[#475467]
                  text-sm
                  font-normal
                  font-['Inter']
                  leading-tight
                "
              >
                Your new password must be different to previously used
                passwords.
              </div>
            </div>
          </div>

          {/* Password form fields */}
          <form
            onSubmit={handleSubmit}
            className="z-10 flex flex-col items-center gap-6 w-full rounded-xl"
          >
            <div className="flex flex-col items-start gap-5 w-full">
              {/* New Password field */}
              <div className="flex flex-col items-start gap-1.5 w-full">
                <label className="flex items-start gap-0.5 text-[#344054] text-sm font-medium font-['Inter'] leading-tight">
                  New Password
                </label>
                <div
                  className="
                    px-3.5 py-1.5
                    bg-white
                    rounded-lg
                    shadow-[0px_1px_2px_0px_rgba(16,24,40,0.05)]
                    border border-[#d0d5dd]
                    flex
                    items-center
                    gap-2
                    w-full
                    focus-within:border-[#4e6bd7]
                    focus-within:shadow-[0px_0px_0px_4px_rgba(78,107,215,0.2)]
                    transition-colors duration-200
                  "
                >
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/lock-01.svg`}
                    alt="Lock Icon"
                    className="w-4 h-4"
                  />
                  <input
                    type={showPassword ? 'text' : 'password'}
                    placeholder=""
                    className="
                      grow
                      text-[#667085]
                      text-base
                      font-normal
                      font-['Inter']
                      leading-normal
                      outline-none
                      bg-transparent
                    "
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    required
                  />
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${
                      showPassword ? 'eye-off' : 'eye'
                    }.svg`}
                    alt={showPassword ? 'Hide Password' : 'Show Password'}
                    className="w-4 h-4 cursor-pointer"
                    onClick={() => setShowPassword(!showPassword)}
                  />
                </div>
              </div>

              {/* Confirm Password field */}
              <div className="flex flex-col items-start gap-1.5 w-full">
                <label className="flex items-start gap-0.5 text-[#344054] text-sm font-medium font-['Inter'] leading-tight">
                  Confirm Password
                </label>
                <div
                  className="
                    px-3.5 py-1.5
                    bg-white
                    rounded-lg
                    shadow-[0px_1px_2px_0px_rgba(16,24,40,0.05)]
                    border border-[#d0d5dd]
                    flex
                    items-center
                    gap-2
                    w-full
                    focus-within:border-[#4e6bd7]
                    focus-within:shadow-[0px_0px_0px_4px_rgba(78,107,215,0.2)]
                    transition-colors duration-200
                  "
                >
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/lock-01.svg`}
                    alt="Lock Icon"
                    className="w-4 h-4"
                  />
                  <input
                    type={showPassword ? 'text' : 'password'}
                    placeholder=""
                    className="
                      grow
                      text-[#667085]
                      text-base
                      font-normal
                      font-['Inter']
                      leading-normal
                      outline-none
                      bg-transparent
                    "
                    value={confirmPassword}
                    onChange={(e) => setConfirmPassword(e.target.value)}
                    required
                  />
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${
                      showPassword ? 'eye-off' : 'eye'
                    }.svg`}
                    alt={showPassword ? 'Hide Password' : 'Show Password'}
                    className="w-4 h-4 cursor-pointer"
                    onClick={() => setShowPassword(!showPassword)}
                  />
                </div>
              </div>
            </div>

            {/* Reset password button */}
            <div className="flex flex-col items-start gap-4 w-full">
              <button
                type="submit"
                disabled={isLoading || !password || !confirmPassword}
                className={`
                  w-full
                  px-3 py-2
                  rounded-lg
                  border-2
                  border-white
                  flex
                  items-center
                  justify-center
                  gap-1
                  overflow-hidden
                  transition-colors
                  duration-300
                  ${
                    isLoading
                      ? 'bg-[#F9FAFB]'
                      : 'bg-[#4e6bd7] hover:bg-[#374c99]'
                  }
                `}
              >
                {isLoading ? (
                  <div
                    className="w-5 h-5 animate-spin"
                    style={{
                      borderRadius: '50%',
                      background: 'conic-gradient(#4761C4 0%, #F9FAFB 100%)',
                      maskImage:
                        'radial-gradient(closest-side, transparent 83%, black 84%)',
                    }}
                  />
                ) : (
                  <div className="text-white text-sm font-semibold font-['Inter'] leading-tight">
                    Reset Password
                  </div>
                )}
              </button>
            </div>
          </form>

          {/* Back to login */}
          <a
            href="/login"
            className="justify-center items-center gap-1.5 flex cursor-pointer text-inherit no-underline"
          >
            <div className="w-5 h-5 relative flex justify-center items-center">
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-left.svg`}
                alt="Arrow Left Icon"
                className="w-5 h-5"
              />
            </div>
            <div className="text-[#475467] text-sm font-semibold font-['Inter'] leading-tight">
              Back to log in
            </div>
          </a>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/reset-password-request/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { toast } from 'sonner';

export default function ResetPasswordRequestPage() {
  const [email, setEmail] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isEmailSent, setIsEmailSent] = useState(false);
  const [isResending, setIsResending] = useState(false);
  const [waitTime, setWaitTime] = useState<number | null>(null);

  const formatWaitTime = (seconds: number): string => {
    if (seconds < 60) {
      return `${seconds} seconds`;
    }
    const minutes = Math.ceil(seconds / 60);
    return `${minutes} minute${minutes > 1 ? 's' : ''}`;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      const cleanEmail = email;
      const response = await fetch('/api/auth/reset-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: cleanEmail }),
      });

      const data = await response.json();
      if (process.env.NODE_ENV !== 'production') {
        console.log('API Response:', data);
      }

      if (response.ok) {
        setIsEmailSent(true);
      } else if (response.status === 400) {
        // Extract wait time from error message using regex
        const waitTimeMatch = data.error?.match(/after (\d+) seconds/);
        const waitTimeValue = waitTimeMatch
          ? parseInt(waitTimeMatch[1], 10)
          : null;
        if (process.env.NODE_ENV !== 'production') {
          console.log('Extracted wait time:', waitTimeValue);
        }
        setWaitTime(waitTimeValue);
        toast.error('Password Reset Request Failed', {
          description: waitTimeValue
            ? `Please wait ${formatWaitTime(waitTimeValue)} before requesting another password reset.`
            : 'Please wait a few minutes before requesting another password reset.',
          duration: 7000,
        });
      }
    } catch (error) {
      console.error('Error:', error);
      toast.error('Request Failed', {
        description: 'An unexpected error occurred. Please try again later.',
        duration: 5000,
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleResendEmail = async () => {
    setIsResending(true);
    try {
      const response = await fetch('/api/auth/reset-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email }),
      });

      const data = await response.json();
      if (process.env.NODE_ENV !== 'production') {
        console.log('Resend API Response:', data);
      }

      if (response.status === 400) {
        // Extract wait time from error message using regex
        const waitTimeMatch = data.error?.match(/after (\d+) seconds/);
        const waitTimeValue = waitTimeMatch
          ? parseInt(waitTimeMatch[1], 10)
          : null;
        if (process.env.NODE_ENV !== 'production') {
          console.log('Extracted wait time:', waitTimeValue);
        }
        setWaitTime(waitTimeValue);
        toast.error('Password Reset Request Failed', {
          description: waitTimeValue
            ? `Please wait ${formatWaitTime(waitTimeValue)} before requesting another password reset.`
            : 'Please wait a few minutes before requesting another password reset.',
          duration: 7000,
        });
      } else if (response.ok) {
        toast.success('Email Sent', {
          description:
            'A new password reset email has been sent to your inbox.',
          duration: 5000,
        });
      }
    } catch (error) {
      console.error('Resend Error:', error);
      toast.error('Request Failed', {
        description: 'An unexpected error occurred. Please try again later.',
        duration: 5000,
      });
    } finally {
      setIsResending(false);
    }
  };

  return (
    <div className="relative w-full min-h-screen bg-white overflow-hidden flex items-center justify-center p-4">
      <div className="w-full max-w-[420px] p-2 sm:p-3 bg-gray-50 rounded-3xl border border-[#e4e7ec] flex flex-col justify-center items-center gap-2">
        {/* Inner white card */}
        <div className="relative w-full px-4 sm:px-6 py-6 sm:py-8 bg-white rounded-2xl border border-[#e4e7ec] flex flex-col justify-start items-center gap-4 sm:gap-6 overflow-hidden">
          {/* Corner dots */}
          <div className="pointer-events-none absolute inset-0">
            <div
              className="w-1.5 h-1.5 bg-white rounded-full shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)] border border-[#e4e7ec] absolute"
              style={{ top: 16, left: 16 }}
            />
            <div
              className="w-1.5 h-1.5 bg-white rounded-full shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)] border border-[#e4e7ec] absolute"
              style={{ bottom: 16, left: 16 }}
            />
            <div
              className="w-1.5 h-1.5 bg-white rounded-full shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)] border border-[#e4e7ec] absolute"
              style={{ top: 16, right: 16 }}
            />
            <div
              className="w-1.5 h-1.5 bg-white rounded-full shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)] border border-[#e4e7ec] absolute"
              style={{ bottom: 16, right: 16 }}
            />
          </div>

          {/* App icon container */}
          <div className="z-10 flex justify-start items-start">
            <div className="w-10 h-10 relative overflow-hidden bg-white rounded-[10px] flex items-center justify-center">
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`}
                alt="App Icon"
                className="w-full h-full object-cover"
              />
            </div>
          </div>

          {isEmailSent ? (
            <>
              {/* Email sent view */}
              <div className="z-10 flex flex-col items-center gap-3 w-full">
                <div className="flex flex-col items-start gap-1 w-full">
                  <div className="w-full text-center text-[#101828] text-lg font-semibold font-['Inter'] leading-7">
                    Check your email
                  </div>
                  <div className="w-full text-center text-[#475467] text-sm font-normal font-['Inter'] leading-tight">
                    We've sent a reset link to
                    <br />
                    {email}
                  </div>
                </div>
              </div>

              {/* Check icon */}
              <div className="flex justify-center">
                <div className="w-12 h-12 bg-[#F4F3FF] rounded-full flex items-center justify-center">
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-icon-onboarding.svg`}
                    alt="Check Icon"
                    className="w-6 h-6"
                  />
                </div>
              </div>

              {/* Open email app button */}
              <button
                onClick={() => (window.location.href = 'mailto:')}
                className="w-full px-3 py-2 bg-[#4e6bd7] rounded-lg shadow-[0px_1px_2px_0px_rgba(16,24,40,0.05)] flex justify-center items-center gap-1 text-white text-sm font-semibold font-['Inter'] leading-tight hover:bg-[#374c99] transition-colors duration-300"
              >
                Open email app
              </button>

              {/* Resend link */}
              <div className="text-center">
                <span className="text-[#475467] text-sm font-normal font-['Inter']">
                  Didn't receive the email?{' '}
                </span>
                <button
                  onClick={handleResendEmail}
                  disabled={isResending}
                  className={`text-[#4e6bd7] text-sm font-semibold font-['Inter'] hover:underline inline-flex items-center gap-2 ${isResending ? 'cursor-not-allowed opacity-70' : ''}`}
                >
                  {isResending ? (
                    <>
                      <div
                        className="w-4 h-4 animate-spin"
                        style={{
                          borderRadius: '50%',
                          background:
                            'conic-gradient(#4761C4 0%, #F9FAFB 100%)',
                          maskImage:
                            'radial-gradient(closest-side, transparent 83%, black 84%)',
                        }}
                      />
                      Sending...
                    </>
                  ) : (
                    <span className="text-[#4e6bd7]">Click to resend</span>
                  )}
                </button>
              </div>
            </>
          ) : (
            <>
              {/* Initial form view */}
              <div className="z-10 flex flex-col items-center gap-3 w-full">
                <div className="flex flex-col items-start gap-1 w-full">
                  <div className="w-full text-center text-[#101828] text-lg font-semibold font-['Inter'] leading-7">
                    Forgot password?
                  </div>
                  <div className="w-full text-center text-[#475467] text-sm font-normal font-['Inter'] leading-tight">
                    No worries, we'll send you instructions
                  </div>
                </div>
              </div>

              {/* Login form fields */}
              <div className="z-10 flex flex-col items-center gap-6 w-full rounded-xl">
                <form
                  className="flex flex-col items-start gap-5 w-full"
                  onSubmit={handleSubmit}
                >
                  {/* Email field */}
                  <div className="flex flex-col items-start gap-1.5 w-full">
                    <label className="flex items-start gap-0.5 text-[#344054] text-sm font-medium font-['Inter'] leading-tight">
                      Email
                    </label>
                    <div className="px-3.5 py-1.5 bg-white rounded-lg shadow-[0px_1px_2px_0px_rgba(16,24,40,0.05)] border border-[#d0d5dd] flex items-center gap-2 w-full focus-within:border-[#4e6bd7] focus-within:shadow-[0px_0px_0px_4px_rgba(78,107,215,0.2)] transition-colors duration-200">
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/mail-01.svg`}
                        alt="Mail Icon"
                        className="w-4 h-4"
                      />
                      <input
                        type="email"
                        placeholder="Email address"
                        className="grow text-[#667085] text-base font-normal font-['Inter'] leading-normal outline-none bg-transparent"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        required
                      />
                    </div>
                  </div>

                  {/* Reset password button */}
                  <button
                    type="submit"
                    disabled={isLoading || !email}
                    className={`w-full px-3 py-2 rounded-lg border-2 border-white flex items-center justify-center gap-1 overflow-hidden transition-colors duration-300 ${
                      isLoading
                        ? 'bg-[#F9FAFB]'
                        : 'bg-[#4e6bd7] hover:bg-[#374c99]'
                    }`}
                  >
                    {isLoading ? (
                      <div
                        className="w-5 h-5 animate-spin"
                        style={{
                          borderRadius: '50%',
                          background:
                            'conic-gradient(#4761C4 0%, #F9FAFB 100%)',
                          maskImage:
                            'radial-gradient(closest-side, transparent 83%, black 84%)',
                        }}
                      />
                    ) : (
                      <div className="text-white text-sm font-semibold font-['Inter'] leading-tight">
                        Reset password
                      </div>
                    )}
                  </button>
                </form>
              </div>
            </>
          )}

          {/* Back to login */}
          <a
            href="/login"
            className="justify-center items-center gap-1.5 flex cursor-pointer text-inherit no-underline"
          >
            <div className="w-5 h-5 relative flex justify-center items-center">
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-left.svg`}
                alt="Arrow Left Icon"
                className="w-5 h-5"
              />
            </div>
            <div className="text-[#475467] text-sm font-semibold font-['Inter'] leading-tight">
              Back to log in
            </div>
          </a>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/services/roadmapAuth.ts">
import { supabasePublicClient } from '@/lib/supabasePublicClient';
import { User } from '@/types/user';

export async function generateRoadmapToken(user: User) {
  try {
   
    const userData = {
      user_email: user.email,
      app_user_id: user.auth_id,
      user_name: `${user.first_name} ${user.last_name}`,
      img_url: user.avatar_signed_url || user.avatar_url,
    };

    const response = await fetch(
      'https://features.vote/api/public/user-token',
      {
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          apiSecretKey: process.env.NEXT_PUBLIC_FEATURES_VOTE_API_KEY,
          slug: 'processflow',
          user_data: userData,
        }),
      }
    );

    const data = await response.json();
    if (data.error) {
      throw new Error(data.error);
    }
    return data.token;
  } catch (error) {
    console.error('Erreur lors de la gnration du token roadmap:', error);
    return null;
  }
}
</file>

<file path="app/set-new-password/page.tsx">
"use client";
import { useState } from "react";
import { useRouter } from 'next/navigation';
import { createClient } from '@/utils/supabase/client';
import { toast } from 'sonner';

export default function Home() {
  const router = useRouter();
  const [showPassword, setShowPassword] = useState(false);
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  // Handle form submission: check if passwords match and update password
  const handlePasswordReset = async () => {
    if (!password || !confirmPassword) {
      toast.error('Missing Fields', {
        description: 'Please fill in both password fields.',
        duration: 5000,
      });
      return;
    }
    
    if (password !== confirmPassword) {
      toast.error('Password Mismatch', {
        description: 'Passwords do not match!',
        duration: 5000,
      });
      return;
    }

    setIsLoading(true);

    try {
      // Create Supabase client
      const supabase = createClient();

      // Attempt to update the user's password
      const { error } = await supabase.auth.updateUser({ password });

      if (error) {
        toast.error('Password Reset Failed', {
          description: error.message,
          duration: 5000,
        });
      } else {
        // Call the API to clear the cookie
        const res = await fetch('/api/clear-password-reset-cookie', {
          method: 'POST',
        });

        if (res.ok) {
          toast.success('Password Reset Successful', {
            description: 'Your password has been successfully reset. You will be redirected to the login page.',
            duration: 7000,
          });
          // Redirect to home page
          router.push('/');
        } else {
          toast.error('Cookie Cleanup Failed', {
            description: 'Password reset succeeded, but failed to clear the cookie. You may need to clear your browser cookies manually.',
            duration: 7000,
          });
        }
      }
    } catch (error) {
      toast.error('Password Reset Failed', {
        description: 'An unexpected error occurred. Please try again.',
        duration: 5000,
      });
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="relative w-full min-h-screen bg-white overflow-hidden flex items-center justify-center">
      {/* Outer gray parent container */}
      <div className="w-[420px] p-3 bg-gray-50 rounded-3xl border border-[#e4e7ec] flex flex-col justify-center items-center gap-2">
        
        {/* Inner white card */}
        <div className="relative w-full px-6 py-8 bg-white rounded-2xl border border-[#e4e7ec] flex flex-col justify-start items-center gap-6 overflow-hidden">
          
          {/* Corner dots (16px from each edge) */}
          <div className="pointer-events-none absolute inset-0">
            <div
              className="
                w-1.5 h-1.5
                bg-white
                rounded-full
                shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)]
                border border-[#e4e7ec]
                absolute
              "
              style={{ top: 16, left: 16 }}
            />
            <div
              className="
                w-1.5 h-1.5
                bg-white
                rounded-full
                shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)]
                border border-[#e4e7ec]
                absolute
              "
              style={{ bottom: 16, left: 16 }}
            />
            <div
              className="
                w-1.5 h-1.5
                bg-white
                rounded-full
                shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)]
                border border-[#e4e7ec]
                absolute
              "
              style={{ top: 16, right: 16 }}
            />
            <div
              className="
                w-1.5 h-1.5
                bg-white
                rounded-full
                shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)]
                border border-[#e4e7ec]
                absolute
              "
              style={{ bottom: 16, right: 16 }}
            />
          </div>

          {/* App icon container */}
          <div
            className="
              z-10
              flex
              justify-start
              items-start
            "
          >
            <div
              className="
                w-10
                h-10
                relative
                overflow-hidden
                bg-white
                rounded-[10px]
                flex
                items-center
                justify-center
              "
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`}
                alt="App Icon"
                className="w-full h-full object-cover"
              />
            </div>
          </div>

          {/* Heading section */}
          <div className="z-10 flex flex-col items-center gap-3 w-full">
            <div className="flex flex-col items-start gap-1 w-full">
              <div
                className="
                  w-full
                  text-center
                  text-[#101828]
                  text-lg
                  font-semibold
                  font-['Inter']
                  leading-7
                "
              >
                Set new password
              </div>
              <div
                className="
                  w-full
                  text-center
                  text-[#475467]
                  text-sm
                  font-normal
                  font-['Inter']
                  leading-tight
                "
              >
                Your new password must be different to previously used passwords.
              </div>
            </div>
          </div>

          {/* Password form fields */}
          <div className="z-10 flex flex-col items-center gap-6 w-full rounded-xl">
            <div className="flex flex-col items-start gap-5 w-full">
              {/* New Password field */}
              <div className="flex flex-col items-start gap-1.5 w-full">
                <label className="flex items-start gap-0.5 text-[#344054] text-sm font-medium font-['Inter'] leading-tight">
                  New Password
                </label>
                <div
                  className="
                    px-3.5 py-1.5
                    bg-white
                    rounded-lg
                    shadow-[0px_1px_2px_0px_rgba(16,24,40,0.05)]
                    border border-[#d0d5dd]
                    flex
                    items-center
                    gap-2
                    w-full
                    focus-within:border-[#4e6bd7]
                    focus-within:shadow-[0px_0px_0px_4px_rgba(78,107,215,0.2)]
                    transition-colors duration-200
                  "
                >
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/lock-01.svg`}
                    alt="Lock Icon"
                    className="w-4 h-4"
                  />
                  <input
                    type={showPassword ? "text" : "password"}
                    placeholder=""
                    className="
                      grow
                      text-[#667085]
                      text-base
                      font-normal
                      font-['Inter']
                      leading-normal
                      outline-none
                      bg-transparent
                    "
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                  />
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${
                      showPassword ? "eye-off" : "eye"
                    }.svg`}
                    alt={showPassword ? "Hide Password" : "Show Password"}
                    className="w-4 h-4 cursor-pointer"
                    onClick={() => setShowPassword(!showPassword)}
                  />
                </div>
              </div>

              {/* Confirm Password field */}
              <div className="flex flex-col items-start gap-1.5 w-full">
                <label className="flex items-start gap-0.5 text-[#344054] text-sm font-medium font-['Inter'] leading-tight">
                  Confirm Password
                </label>
                <div
                  className="
                    px-3.5 py-1.5
                    bg-white
                    rounded-lg
                    shadow-[0px_1px_2px_0px_rgba(16,24,40,0.05)]
                    border border-[#d0d5dd]
                    flex
                    items-center
                    gap-2
                    w-full
                    focus-within:border-[#4e6bd7]
                    focus-within:shadow-[0px_0px_0px_4px_rgba(78,107,215,0.2)]
                    transition-colors duration-200
                  "
                >
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/lock-01.svg`}
                    alt="Lock Icon"
                    className="w-4 h-4"
                  />
                  <input
                    type={showPassword ? "text" : "password"}
                    placeholder=""
                    className="
                      grow
                      text-[#667085]
                      text-base
                      font-normal
                      font-['Inter']
                      leading-normal
                      outline-none
                      bg-transparent
                    "
                    value={confirmPassword}
                    onChange={(e) => setConfirmPassword(e.target.value)}
                  />
                </div>
              </div>
            </div>
          </div>

          {/* Reset password button */}
          <div className="flex flex-col items-start gap-4 w-full">
            <button
              onClick={handlePasswordReset}
              disabled={isLoading || !password || !confirmPassword}
              className={`
                w-full
                px-3 py-2
                rounded-lg
                border-2
                border-white
                flex
                items-center
                justify-center
                gap-1
                overflow-hidden
                transition-colors
                duration-300
                ${
                  isLoading
                    ? "bg-[#F9FAFB]"
                    : "bg-[#4e6bd7] hover:bg-[#374c99]"
                }
              `}
            >
              {isLoading ? (
                <div
                  className="w-5 h-5 animate-spin"
                  style={{
                    borderRadius: "50%",
                    background: "conic-gradient(#4761C4 0%, #F9FAFB 100%)",
                    maskImage: "radial-gradient(closest-side, transparent 83%, black 84%)"
                  }}
                />
              ) : (
                <div className="text-white text-sm font-semibold font-['Inter'] leading-tight">
                  Reset Password
                </div>
              )}
            </button>
          </div>

          {/* Back to login */}
          <a
            href="/login"
            className="justify-center items-center gap-1.5 flex cursor-pointer text-inherit no-underline"
          >
            <div className="w-5 h-5 relative flex justify-center items-center">
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-left.svg`}
                alt="Arrow Left Icon"
                className="w-5 h-5"
              />
            </div>
            <div className="text-[#475467] text-sm font-semibold font-['Inter'] leading-tight">
              Back to log in
            </div>
          </a>
        </div>

        <div className="absolute bottom-6 left-1/2 transform -translate-x-1/2">
          <div className="w-[420px] h-9 px-2 py-1.5 bg-gray-50 rounded-full border border-[#e4e7ec] flex justify-center items-center">
            <div className="grow shrink basis-0 h-6 px-2 py-0.5 bg-white rounded-[99px] flex justify-between items-center">
              <div className="text-[#475467] text-sm font-normal">2025  Processflow</div>
              <div className="w-0.5 h-0.5 bg-[#475467] rounded-full mx-2" />
              <a href="/support" className="text-[#475467] text-sm font-normal hover:underline">Support</a>
              <div className="w-0.5 h-0.5 bg-[#475467] rounded-full mx-2" />
              <a href="/privacy" className="text-[#475467] text-sm font-normal hover:underline">Privacy</a>
              <div className="w-0.5 h-0.5 bg-[#475467] rounded-full mx-2" />
              <a href="/terms" className="text-[#475467] text-sm font-normal hover:underline">Terms</a>
            </div>
          </div>
        </div>

      </div>
    </div>
  );
}
</file>

<file path="app/shared/[flow]/embed/components/HorizontalDelay.tsx">
import React from 'react';
import { cn } from '@/lib/utils';
import { useColors } from '@/app/theme/hooks';
import { BaseStepProps } from '@/app/[slug]/[flow]/read/components/steps/BaseStep';
import Image from 'next/image';
import { DelayType } from '@/app/[slug]/[flow]/types';
import { motion, AnimatePresence } from 'framer-motion';

interface HorizontalDelayProps extends BaseStepProps {
  selectedOptionIds?: [number, number][];
  onOptionSelect?: (
    optionId: number,
    blockId: number,
    isMerge?: boolean
  ) => void;
}

export default function HorizontalDelay({
  block,
  selectedOptionIds,
  onOptionSelect,
}: HorizontalDelayProps) {
  const colors = useColors();

  const handleOptionSelect = (
    optionId: number,
    blockId: number,
    isMerge?: boolean
  ) => {
    onOptionSelect?.(optionId, blockId, isMerge);
  };

  const getDelayText = () => {
    if (block.delay_type === DelayType.WAIT_FOR_EVENT) {
      return block.delay_event;
    } else {
      const seconds = block.delay_seconds || 0;
      const days = Math.floor(seconds / 86400);
      const hours = Math.floor((seconds % 86400) / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);

      const parts = [];
      if (days > 0) parts.push(`${days} ${days === 1 ? 'day' : 'days'}`);
      if (hours > 0) parts.push(`${hours} ${hours === 1 ? 'hour' : 'hours'}`);
      if (minutes > 0)
        parts.push(`${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`);

      return parts.length > 0 ? parts.join(' and ') : '';
    }
  };

  const renderTitleWithLineBreaks = (title: string, chunkSize = 200) => {
    if (!title) return null;
    const chunks = [];
    for (let i = 0; i < title.length; i += chunkSize) {
      chunks.push(title.slice(i, i + chunkSize));
    }
    // Interleave <br /> except after the last chunk
    return chunks.map((chunk, idx) => (
      <React.Fragment key={idx}>
        {chunk}
        {idx < chunks.length - 1 && <br />}
      </React.Fragment>
    ));
  };

  const getDelayIcon = () => {
    if (block.delay_type === DelayType.WAIT_FOR_EVENT) {
      return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/calendar-clock-1.svg`;
    }
    return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/clock-stopwatch-1.svg`;
  };

  const getDelayTitle = () => {
    return block.delay_type === DelayType.WAIT_FOR_EVENT
      ? 'Event-Based Delay'
      : 'Fixed Duration';
  };

  const expirationText = () => {
    if (!block.delay_seconds) return '';
    const days = Math.floor(block.delay_seconds / 86400);
    const hours = Math.floor((block.delay_seconds % 86400) / 3600);
    const minutes = Math.floor((block.delay_seconds % 3600) / 60);

    const parts = [];
    if (days > 0) parts.push(`${days} ${days === 1 ? 'day' : 'days'}`);
    if (hours > 0) parts.push(`${hours} ${hours === 1 ? 'hour' : 'hours'}`);
    if (minutes > 0)
      parts.push(`${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`);

    return parts.length > 0 ? `${parts.join(' and ')}` : '';
  };

  if (block.delay_type === DelayType.FIXED_DURATION) {
    return (
      <div className="h-full flex items-center justify-center">
        <div className="flex flex-col gap-4">
          <div className="flex flex-col gap-6">
            <div className="flex items-center gap-4">
              <div
                className={cn(
                  'rounded-[6px] border shadow-sm flex items-center justify-center',
                  'w-12 h-12'
                )}
                style={{
                  backgroundColor: colors['bg-primary'],
                  borderColor: colors['border-secondary'],
                }}
              >
                <Image
                  src={getDelayIcon()}
                  alt="Delay"
                  width={24}
                  height={24}
                />
              </div>
              <span
                className={cn('font-semibold', 'text-base')}
                style={{ color: colors['text-primary'] }}
              >
                {getDelayTitle()}
              </span>
            </div>

            <div
              className={cn(
                'flex items-center gap-2 p-3 rounded-lg bg-opacity-5'
              )}
              style={{ backgroundColor: colors['bg-secondary'] }}
            >
              <Image
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/pause-circle.svg`}
                alt="Info"
                width={20}
                height={20}
              />
              <span
                className={cn('text-sm whitespace-pre-line')}
                style={{ color: colors['text-secondary'] }}
              >
                Flow paused for {getDelayText()}
              </span>
            </div>

            {block.child_paths && block.child_paths.length > 0 && (
              <motion.div
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.2, delay: 0.1 }}
                className="mt-4"
              >
                <p
                  className="text-sm font-medium mb-4"
                  style={{ color: colors['text-primary'] }}
                >
                  Select an option
                </p>
                <div className="space-y-2">
                  {block.child_paths.map((option, index) => (
                    <motion.button
                      key={option.path.id}
                      onClick={() =>
                        handleOptionSelect(option.path.id, block.id, false)
                      }
                      className={cn(
                        'w-full p-4 rounded-lg border transition-colors duration-200 will-change-transform',
                        'flex items-start gap-3 text-left',
                        selectedOptionIds?.some(
                          ([pathId, blockId]) =>
                            pathId === option.path.id && blockId === block.id
                        ) && 'border-brand'
                      )}
                      initial={{ opacity: 0, y: -10 }}
                      animate={{ opacity: 1, y: 0 }}
                      transition={{
                        duration: 0.2,
                        delay: 0.1 + index * 0.05,
                      }}
                      whileHover={{ scale: 1.01 }}
                      whileTap={{ scale: 0.99 }}
                      style={{
                        backgroundColor: colors['bg-primary'],
                        borderColor: selectedOptionIds?.some(
                          ([pathId, blockId]) =>
                            pathId === option.path.id && blockId === block.id
                        )
                          ? colors['border-brand']
                          : colors['border-secondary'],
                        transform: 'translateZ(0)',
                      }}
                    >
                      <div
                        className="w-5 h-5 rounded-full border-2 flex-shrink-0 flex items-center justify-center"
                        style={{
                          borderColor: selectedOptionIds?.some(
                            ([pathId, blockId]) =>
                              pathId === option.path.id && blockId === block.id
                          )
                            ? colors['border-brand']
                            : colors['border-secondary'],
                          backgroundColor: selectedOptionIds?.some(
                            ([pathId, blockId]) =>
                              pathId === option.path.id && blockId === block.id
                          )
                            ? colors['bg-brand-solid']
                            : 'transparent',
                        }}
                      >
                        <AnimatePresence>
                          {selectedOptionIds?.some(
                            ([pathId, blockId]) =>
                              pathId === option.path.id && blockId === block.id
                          ) && (
                            <motion.div
                              className="w-2 h-2 bg-white rounded-full"
                              initial={{ scale: 0 }}
                              animate={{ scale: 1 }}
                              exit={{ scale: 0 }}
                              transition={{ duration: 0.2 }}
                            />
                          )}
                        </AnimatePresence>
                      </div>
                      <div className="flex flex-col gap-1">
                        <p
                          className="font-normal text-sm break-words line-clamp-2"
                          style={{ color: colors['text-primary'] }}
                        >
                          {renderTitleWithLineBreaks(option.path.name)}
                        </p>
                      </div>
                    </motion.button>
                  ))}
                </div>
              </motion.div>
            )}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="h-full flex items-center justify-center">
      <div className="flex flex-col gap-4">
        <div className="flex flex-col gap-6">
          <div className="flex flex-col gap-4">
            <div className="flex items-center gap-4">
              <div
                className={cn(
                  'rounded-[6px] border shadow-sm flex items-center justify-center',
                  'w-12 h-12'
                )}
                style={{
                  backgroundColor: colors['bg-primary'],
                  borderColor: colors['border-secondary'],
                }}
              >
                <Image
                  src={getDelayIcon()}
                  alt="Delay"
                  width={24}
                  height={24}
                />
              </div>
              <span
                className={cn('font-semibold', 'text-base')}
                style={{ color: colors['text-primary'] }}
              >
                {getDelayTitle()}
              </span>
            </div>

            <div className="flex flex-col gap-2">
              <div className="flex items-center gap-2">
                <span
                  className={cn('text-sm')}
                  style={{ color: colors['text-secondary'] }}
                >
                  Waiting for:
                </span>
                <span
                  className={cn(
                    'text-sm whitespace-pre-line line-clamp-2 break-words'
                  )}
                  style={{ color: colors['text-primary'] }}
                >
                  {renderTitleWithLineBreaks(getDelayText() || '')}
                </span>
              </div>

              {(block.delay_seconds ?? 0) > 0 && (
                <div className="flex items-center gap-2">
                  <Image
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/hourglass-01.svg`}
                    alt="Clock"
                    width={16}
                    height={16}
                  />
                  <span
                    className={cn('text-sm')}
                    style={{ color: colors['text-secondary'] }}
                  >
                    Expires after {expirationText()}
                  </span>
                </div>
              )}
            </div>
          </div>

          <div
            className={cn(
              'flex items-center gap-2 p-3 rounded-lg bg-opacity-5'
            )}
            style={{ backgroundColor: colors['bg-secondary'] }}
          >
            <Image
              src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/pause-circle.svg`}
              alt="Info"
              width={20}
              height={20}
            />
            <span
              className={cn('text-sm')}
              style={{ color: colors['text-secondary'] }}
            >
              {(block.delay_seconds ?? 0) > 0
                ? 'Flow paused until event occurs or time expires'
                : 'Flow paused until event occurs'}
            </span>
          </div>

          {block.child_paths && block.child_paths.length > 0 && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.2, delay: 0.1 }}
              className="mt-4"
            >
              <p
                className="text-sm font-medium mb-4"
                style={{ color: colors['text-primary'] }}
              >
                Select an option
              </p>
              <div className="space-y-2">
                {block.child_paths.map((option, index) => (
                  <motion.button
                    key={option.path.id}
                    onClick={() =>
                      handleOptionSelect(option.path.id, block.id, false)
                    }
                    className={cn(
                      'w-full p-4 rounded-lg border transition-colors duration-200 will-change-transform',
                      'flex items-start gap-3 text-left',
                      selectedOptionIds?.some(
                        ([pathId, blockId]) =>
                          pathId === option.path.id && blockId === block.id
                      ) && 'border-brand'
                    )}
                    initial={{ opacity: 0, y: -10 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{
                      duration: 0.2,
                      delay: 0.1 + index * 0.05,
                    }}
                    whileHover={{ scale: 1.01 }}
                    whileTap={{ scale: 0.99 }}
                    style={{
                      backgroundColor: colors['bg-primary'],
                      borderColor: selectedOptionIds?.some(
                        ([pathId, blockId]) =>
                          pathId === option.path.id && blockId === block.id
                      )
                        ? colors['border-brand']
                        : colors['border-secondary'],
                      transform: 'translateZ(0)',
                    }}
                  >
                    <div
                      className="w-5 h-5 rounded-full border-2 flex-shrink-0 flex items-center justify-center"
                      style={{
                        borderColor: selectedOptionIds?.some(
                          ([pathId, blockId]) =>
                            pathId === option.path.id && blockId === block.id
                        )
                          ? colors['border-brand']
                          : colors['border-secondary'],
                        backgroundColor: selectedOptionIds?.some(
                          ([pathId, blockId]) =>
                            pathId === option.path.id && blockId === block.id
                        )
                          ? colors['bg-brand-solid']
                          : 'transparent',
                      }}
                    >
                      <AnimatePresence>
                        {selectedOptionIds?.some(
                          ([pathId, blockId]) =>
                            pathId === option.path.id && blockId === block.id
                        ) && (
                          <motion.div
                            className="w-2 h-2 bg-white rounded-full"
                            initial={{ scale: 0 }}
                            animate={{ scale: 1 }}
                            exit={{ scale: 0 }}
                            transition={{ duration: 0.2 }}
                          />
                        )}
                      </AnimatePresence>
                    </div>
                    <div className="flex flex-col gap-1">
                      <p
                        className="font-normal text-sm break-words line-clamp-2"
                        style={{ color: colors['text-primary'] }}
                      >
                        {renderTitleWithLineBreaks(option.path.name)}
                      </p>
                    </div>
                  </motion.button>
                ))}
              </div>
            </motion.div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/shared/[flow]/embed/components/HorizontalLastStep.tsx">
import React from 'react';
import { useColors } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';

interface HorizontalLastStepProps {
  onCopyLink: () => void;
  onRestart: () => void;
  onPreviousStep: () => void;
}

export default function HorizontalLastStep({
  onCopyLink,
  onRestart,
  onPreviousStep,
}: HorizontalLastStepProps) {
  const colors = useColors();

  return (
    <div className="h-full flex flex-col items-center justify-center gap-4">
      <img
        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logo-pf-in-app.png`}
        alt="ProcessFlow Logo"
        className="w-40 mb-4 object-contain"
      />
      <h3
        className="text-xl font-medium"
        style={{ color: colors['text-primary'] }}
      >
        Congratulations! You've completed the process.
      </h3>
      <p
        className="text-base mb-4 text-center"
        style={{ color: colors['text-secondary'] }}
      >
        Share it with your team members!
      </p>
      <div className="flex flex-col gap-3">
        <ButtonNormal
          variant="primary"
          size="small"
          onClick={onCopyLink}
          leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/link-02-white.svg`}
        >
          Copy link
        </ButtonNormal>
        <ButtonNormal
          variant="tertiary"
          size="small"
          onClick={onRestart}
          leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/refresh-cw-01.svg`}
        >
          Restart process
        </ButtonNormal>
      </div>
    </div>
  );
}
</file>

<file path="app/shared/[flow]/embed/components/HorizontalStep.tsx">
import React, { useState, useEffect, useRef, useMemo } from 'react';
import { useColors } from '@/app/theme/hooks';
import { BaseStepProps } from '@/app/[slug]/[flow]/read/components/steps/BaseStep';
import DynamicIcon from '@/utils/DynamicIcon';
import { Block } from '@/app/[slug]/[flow]/types';
import { motion, AnimatePresence } from 'framer-motion';
import { cn } from '@/lib/utils';
import { generateWorkspaceURL } from '@/app/api/utils/generateWorkspaceURL';
// ... other imports

interface HorizontalStepProps extends BaseStepProps {
  isFirstStep?: boolean;
}

// Regular expression to match URLs
const URL_REGEX = /(https?:\/\/[^\s]+)/g;

// Function to parse text and identify links
const parseTextWithLinks = (text: string) => {
  const parts = [];
  let lastIndex = 0;
  let match;

  while ((match = URL_REGEX.exec(text)) !== null) {
    // Add text before the link
    if (match.index > lastIndex) {
      parts.push({
        type: 'text',
        content: text.slice(lastIndex, match.index),
      });
    }

    // Add the link
    parts.push({
      type: 'link',
      content: match[0],
    });

    lastIndex = match.index + match[0].length;
  }

  // Add remaining text after last link
  if (lastIndex < text.length) {
    parts.push({
      type: 'text',
      content: text.slice(lastIndex),
    });
  }

  return parts.length > 0 ? parts : [{ type: 'text', content: text }];
};

// Add a style tag to hide scrollbars globally
const HideScrollbarStyles = () => (
  <style jsx global>{`
    .hide-scrollbar {
      -ms-overflow-style: none; /* IE and Edge */
      scrollbar-width: none; /* Firefox */
    }
    .hide-scrollbar::-webkit-scrollbar {
      display: none; /* Chrome, Safari and Opera */
    }
  `}</style>
);

export default function HorizontalStep({
  block,
  selectedOptionIds,
  onOptionSelect,
  isFirstStep = false,
}: HorizontalStepProps) {
  const colors = useColors();
  const contentRef = useRef<HTMLDivElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [scrollbarThumbHeight, setScrollbarThumbHeight] = useState<
    number | null
  >(null);
  const [contentHeight, setContentHeight] = useState<number>(0);
  const [containerHeight, setContainerHeight] = useState<number>(0);
  const [scrollTop, setScrollTop] = useState<number>(0);
  const [windowWidth, setWindowWidth] = useState<number>(0);
  const [windowHeight, setWindowHeight] = useState<number>(0);
  const [imageLoaded, setImageLoaded] = useState<boolean>(false);
  const [imageError, setImageError] = useState<boolean>(false);
  const [imageDimensions, setImageDimensions] = useState<{
    width: number;
    height: number;
  } | null>(null);
  const [isImageFullscreen, setIsImageFullscreen] = useState(false);
  const [zoomLevel, setZoomLevel] = useState(1);
  const [isDragging, setIsDragging] = useState(false);
  const [dragPosition, setDragPosition] = useState({ x: 0, y: 0 });
  const imageContainerRef = useRef<HTMLDivElement>(null);
  const descriptionRef = useRef<HTMLDivElement>(null);
  const [descriptionHeight, setDescriptionHeight] = useState(0);

  // Generate image URL directly using generateWorkspaceURL
  const imageUrl = useMemo(() => {
    if (!block.image) return null;
    try {
      return generateWorkspaceURL(block.image);
    } catch (error) {
      console.error('Error generating workspace URL:', error);
      return null;
    }
  }, [block.image]);

  // Add null check for block
  if (!block) {
    return null;
  }

  // Reset scroll position when block changes
  useEffect(() => {
    if (contentRef.current) {
      contentRef.current.scrollTop = 0;
      setScrollTop(0);
    }
  }, [block.id]); // Use block.id to ensure we only reset on actual block changes

  // Update window size
  useEffect(() => {
    const updateWindowDimensions = () => {
      setWindowWidth(window.innerWidth);
      setWindowHeight(window.innerHeight);
    };

    // Initialize
    updateWindowDimensions();

    // Add event listener
    window.addEventListener('resize', updateWindowDimensions);

    // Clean up
    return () => {
      window.removeEventListener('resize', updateWindowDimensions);
    };
  }, []);

  // Update scrollbar thumb size based on content and window size
  useEffect(() => {
    const updateScrollThumb = () => {
      if (contentRef.current && containerRef.current) {
        const contentScrollHeight = contentRef.current.scrollHeight;
        const containerClientHeight = containerRef.current.clientHeight;

        setContentHeight(contentScrollHeight);
        setContainerHeight(containerClientHeight);

        // If content is taller than container, calculate ratio for thumb
        if (contentScrollHeight > containerClientHeight) {
          // Adjust thumb size based on both content ratio and container height
          const ratio = containerClientHeight / contentScrollHeight;

          // Scale thumb minimum size based on viewport height
          // (smaller screens get smaller minimum thumb size)
          const minThumbSize = Math.max(
            20,
            Math.min(30, window.innerHeight * 0.04)
          );

          const thumbHeight = Math.max(
            minThumbSize,
            containerClientHeight * ratio
          );
          setScrollbarThumbHeight(thumbHeight);
        } else {
          setScrollbarThumbHeight(null); // Hide scrollbar when not needed
        }
      }
    };

    updateScrollThumb();

    // Set up resize observer to detect content changes
    const resizeObserver = new ResizeObserver(updateScrollThumb);
    if (contentRef.current) {
      resizeObserver.observe(contentRef.current);
    }
    if (containerRef.current) {
      resizeObserver.observe(containerRef.current);
    }

    return () => {
      resizeObserver.disconnect();
    };
  }, [block, imageUrl, windowWidth, windowHeight, imageLoaded]); // Update when content, window size, or image loaded status changes

  // Handle image load event to get dimensions
  const handleImageLoad = (event: React.SyntheticEvent<HTMLImageElement>) => {
    const img = event.currentTarget;
    setImageDimensions({
      width: img.naturalWidth,
      height: img.naturalHeight,
    });
    setImageLoaded(true);
    setImageError(false);
  };

  // Handle image error
  const handleImageError = () => {
    setImageError(true);
    setImageLoaded(false);
  };

  // Add scroll event listener to track scroll position
  useEffect(() => {
    const contentElement = contentRef.current;

    const handleScroll = () => {
      if (contentElement) {
        setScrollTop(contentElement.scrollTop);
      }
    };

    if (contentElement) {
      contentElement.addEventListener('scroll', handleScroll);
    }

    return () => {
      if (contentElement) {
        contentElement.removeEventListener('scroll', handleScroll);
      }
    };
  }, []);

  // Custom scrollbar click handler
  const handleScrollbarClick = (e: React.MouseEvent<HTMLDivElement>) => {
    if (contentRef.current) {
      const track = e.currentTarget;
      const trackRect = track.getBoundingClientRect();
      const clickPosition = e.clientY - trackRect.top;
      const percentage = clickPosition / trackRect.height;

      const scrollPosition = percentage * (contentHeight - containerHeight);
      contentRef.current.scrollTop = scrollPosition;
    }
  };

  // Calculate appropriate scrollbar width based on viewport
  const getScrollbarWidth = () => {
    if (windowWidth <= 640) {
      return 3; // 3px on small screens (mobile)
    } else if (windowWidth <= 1024) {
      return 4; // 4px on medium screens (tablet)
    } else {
      return 6; // 6px on large screens (desktop)
    }
  };

  const scrollbarWidth = getScrollbarWidth();

  const getIconPath = (block: Block) => {
    if (block.icon && block.signedIconUrl) {
      return `${block.signedIconUrl}`;
    }

    switch (block.type) {
      case 'STEP':
        return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/git-commit.svg`;
      case 'PATH':
        return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dataflow-04.svg`;
      case 'DELAY':
        return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/clock-stopwatch-1.svg`;
      default:
        return `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon-base.svg`;
    }
  };

  const getDisplayTitle = (block: Block) => {
    if (block.title) return block.title;

    // Convert block type from ALL_CAPS to Title Case
    const typeName = block.type
      .toLowerCase()
      .replace(/_/g, ' ')
      .split(' ')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');

    return `${typeName}`;
  };

  // Check if the step has both image and options
  const hasBothImageAndOptions =
    block.image && block.child_paths && block.child_paths.length > 0;

  // Check if there's only description (no image or options)
  const hasOnlyDescription =
    !block.image && (!block.child_paths || block.child_paths.length === 0);

  // Calculate if scrollbar should be visible
  const showScrollbar = contentHeight > containerHeight;

  // Calculate thumb position
  const thumbPosition =
    contentHeight <= containerHeight
      ? 0
      : (scrollTop / (contentHeight - containerHeight)) *
        (containerHeight - (scrollbarThumbHeight || 0));

  // Determine appropriate padding based on screen size
  const getResponsivePadding = () => {
    if (windowWidth <= 640) {
      return 'px-3 pt-3'; // Less padding on small screens
    } else if (windowWidth <= 1024) {
      return 'px-4 pt-4'; // Medium padding on medium screens
    } else {
      return 'px-5 pt-5'; // More padding on large screens
    }
  };

  // Determine optimal display mode for image based on its dimensions
  const getImageDisplayMode = () => {
    if (!imageDimensions) return 'object-contain';

    const aspectRatio = imageDimensions.width / imageDimensions.height;

    // For very wide images (panoramas)
    if (aspectRatio > 2.5) {
      return 'object-contain';
    }

    // For very tall images
    if (aspectRatio < 0.5) {
      return 'object-contain';
    }

    // Default to contain to show full image
    return 'object-contain';
  };

  const renderTitleWithLineBreaks = (title: string, chunkSize = 150) => {
    if (!title) return null;
    const chunks = [];
    for (let i = 0; i < title.length; i += chunkSize) {
      chunks.push(title.slice(i, i + chunkSize));
    }
    return chunks.map((chunk, idx) => (
      <React.Fragment key={idx}>
        {chunk}
        {idx < chunks.length - 1 && <br />}
      </React.Fragment>
    ));
  };
  // Reset zoom and drag when closing fullscreen
  useEffect(() => {
    if (!isImageFullscreen) {
      setZoomLevel(1);
      setDragPosition({ x: 0, y: 0 });
    }
  }, [isImageFullscreen]);

  // Handle wheel event for zooming
  useEffect(() => {
    const handleWheel = (e: WheelEvent) => {
      if (!isImageFullscreen) return;
      e.preventDefault();
      if (e.deltaY < 0) {
        setZoomLevel((prev) => Math.min(prev + 0.1, 5));
      } else {
        setZoomLevel((prev) => Math.max(prev - 0.1, 0.5));
      }
    };
    const container = imageContainerRef.current;
    if (container) {
      container.addEventListener('wheel', handleWheel, { passive: false });
    }
    return () => {
      if (container) {
        container.removeEventListener('wheel', handleWheel);
      }
    };
  }, [isImageFullscreen, imageContainerRef]);

  // ESC key to close fullscreen
  useEffect(() => {
    const handleEscKey = (event: KeyboardEvent) => {
      if (event.key === 'Escape' && isImageFullscreen) {
        setIsImageFullscreen(false);
      }
    };
    window.addEventListener('keydown', handleEscKey);
    return () => {
      window.removeEventListener('keydown', handleEscKey);
    };
  }, [isImageFullscreen]);

  // Prevent body scroll when fullscreen
  useEffect(() => {
    if (isImageFullscreen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = '';
    }
    return () => {
      document.body.style.overflow = '';
    };
  }, [isImageFullscreen]);

  useEffect(() => {
    if (descriptionRef.current) {
      setDescriptionHeight(descriptionRef.current.offsetHeight);
    }
  }, [block.description]);

  const toggleFullscreen = (e: React.MouseEvent) => {
    e.stopPropagation();
    setIsImageFullscreen(!isImageFullscreen);
  };
  const zoomIn = (e: React.MouseEvent) => {
    e.stopPropagation();
    setZoomLevel((prev) => Math.min(prev + 0.1, 5));
  };
  const zoomOut = (e: React.MouseEvent) => {
    e.stopPropagation();
    setZoomLevel((prev) => Math.max(prev - 0.1, 0.5));
  };
  const resetZoom = (e?: React.MouseEvent) => {
    if (e) e.stopPropagation();
    setZoomLevel(1);
    setDragPosition({ x: 0, y: 0 });
  };
  const handleMouseDown = (e: React.MouseEvent) => {
    if (zoomLevel <= 1) return;
    e.preventDefault();
    setIsDragging(true);
  };
  const handleMouseMove = (e: React.MouseEvent) => {
    if (!isDragging || zoomLevel <= 1) return;
    setDragPosition((prev) => ({
      x: prev.x + e.movementX,
      y: prev.y + e.movementY,
    }));
  };
  const handleMouseUp = () => {
    setIsDragging(false);
  };
  const handleDoubleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    resetZoom();
  };

  return (
    <>
      <HideScrollbarStyles />
      <div
        ref={containerRef}
        className={cn(
          'h-full w-full overflow-hidden relative',
          !block.image && 'flex flex-col items-center justify-center'
        )}
      >
        {/* Main scrollable container */}
        <div
          ref={contentRef}
          className={cn(
            'h-full w-full overflow-y-auto overflow-x-hidden hide-scrollbar',
            hasOnlyDescription &&
              descriptionHeight <= windowHeight * 0.5 &&
              'flex items-center justify-center'
          )}
        >
          <div
            className={cn(
              'w-full',
              hasOnlyDescription
                ? 'flex flex-col items-center justify-center px-5'
                : ''
            )}
          >
            {/* Header Section */}
            <div
              className={cn(hasOnlyDescription ? '' : 'w-full px-5 pt-5 pb-4')}
            >
              {/* Step Header */}
              <div className="flex items-center gap-2 sm:gap-3 md:gap-4 mb-3 sm:mb-4">
                {/* App Icon */}
                <div
                  className="flex-shrink-0 w-10 h-10 sm:w-11 sm:h-11 md:w-12 md:h-12 rounded-[6px] border shadow-sm flex items-center justify-center"
                  style={{
                    backgroundColor: colors['bg-primary'],
                    borderColor: colors['border-secondary'],
                  }}
                >
                  <div className="flex items-center justify-center">
                    {block.icon &&
                    block.icon.startsWith('https://cdn.brandfetch.io/') ? (
                      <img
                        src={block.icon}
                        alt="Step Icon"
                        className="w-5 h-5 sm:w-6 sm:h-6"
                        referrerPolicy="strict-origin-when-cross-origin"
                      />
                    ) : (
                      <img
                        src={getIconPath(block)}
                        alt="Step Icon"
                        className="w-5 h-5 sm:w-6 sm:h-6"
                        onError={(e) => {
                          e.currentTarget.src = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon-base.svg`;
                        }}
                      />
                    )}
                  </div>
                </div>
                {/* Step Title */}
                <div className="flex-1">
                  <div
                    className="flex items-center text-sm sm:text-base font-semibold break-words line-clamp-2"
                    style={{ color: colors['text-primary'] }}
                  >
                    <span>
                      {renderTitleWithLineBreaks(getDisplayTitle(block))}
                    </span>
                  </div>
                </div>
              </div>

              {/* Description */}
              <div className="relative w-full">
                <p
                  ref={descriptionRef}
                  className="text-base break-words whitespace-pre-line w-full"
                  style={{ color: colors['text-quaternary'] }}
                >
                  {parseTextWithLinks(block.description || '').map(
                    (segment, index) =>
                      segment.type === 'link' ? (
                        <a
                          key={index}
                          href={segment.content}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="text-blue-500 hover:underline break-all"
                          onClick={(e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            window.open(
                              segment.content,
                              '_blank',
                              'noopener,noreferrer'
                            );
                          }}
                        >
                          {segment.content}
                        </a>
                      ) : (
                        <span key={index}>{segment.content}</span>
                      )
                  )}
                </p>
              </div>
            </div>

            {/* Content Section */}
            {!hasOnlyDescription && (
              <div className="px-5 pb-16">
                <div className="space-y-6 w-full">
                  {/* Image Section */}
                  {block.image && (
                    <div
                      className="rounded-lg overflow-hidden w-full bg-[#fafafa] dark:bg-[#1c1c1c] mb-4 cursor-zoom-in"
                      onClick={toggleFullscreen}
                      aria-label="View image fullscreen"
                      style={{ backgroundColor: colors['bg-secondary'] }}
                    >
                      {imageUrl && !imageError ? (
                        <img
                          src={imageUrl}
                          alt="Step visualization"
                          className="w-full h-[500px] object-contain"
                          onLoad={handleImageLoad}
                          onError={handleImageError}
                        />
                      ) : (
                        <div
                          className="w-full h-32 sm:h-36 md:h-40 flex items-center justify-center"
                          style={{ backgroundColor: colors['bg-secondary'] }}
                        >
                          <div
                            className="w-6 h-6 sm:w-7 sm:h-7 md:w-8 md:h-8 rounded-full"
                            style={{ backgroundColor: colors['bg-tertiary'] }}
                          />
                        </div>
                      )}
                    </div>
                  )}

                  {/* Options Section */}
                  {block.child_paths && block.child_paths.length > 0 && (
                    <div className="w-full">
                      <p
                        className="w-full text-xs sm:text-sm font-medium mb-2 sm:mb-3 md:mb-4"
                        style={{ color: colors['text-primary'] }}
                      >
                        Select an option
                      </p>
                      <div className="w-full space-y-2">
                        {block.child_paths.map((option, index) => (
                          <div key={option.path.id} className="overflow-hidden">
                            <motion.button
                              onClick={() =>
                                onOptionSelect?.(
                                  option.path.id,
                                  block.id,
                                  false
                                )
                              }
                              className={cn(
                                'w-full p-3 sm:p-4 rounded-lg border transition-all duration-200',
                                'flex items-center gap-2 sm:gap-3 text-left hover:bg-secondary active:bg-secondary',
                                selectedOptionIds?.some(
                                  ([pathId, blockId]) =>
                                    pathId === option.path.id &&
                                    blockId === block.id
                                ) && 'border-brand'
                              )}
                              initial={{ opacity: 0.4 }}
                              animate={{
                                opacity: 1,
                                transition: {
                                  duration: 0.2,
                                  ease: 'easeOut',
                                  delay: index * 0.05,
                                },
                              }}
                              style={{
                                backgroundColor: colors['bg-primary'],
                                borderColor: selectedOptionIds?.some(
                                  ([pathId, blockId]) =>
                                    pathId === option.path.id &&
                                    blockId === block.id
                                )
                                  ? colors['border-brand']
                                  : colors['border-secondary'],
                              }}
                            >
                              <div
                                className="w-4 h-4 sm:w-5 sm:h-5 rounded-full border-2 flex-shrink-0 flex items-center justify-center"
                                style={{
                                  borderColor: selectedOptionIds?.some(
                                    ([pathId, blockId]) =>
                                      pathId === option.path.id &&
                                      blockId === block.id
                                  )
                                    ? colors['border-brand']
                                    : colors['border-secondary'],
                                  backgroundColor: selectedOptionIds?.some(
                                    ([pathId, blockId]) =>
                                      pathId === option.path.id &&
                                      blockId === block.id
                                  )
                                    ? colors['bg-brand-solid']
                                    : 'transparent',
                                }}
                              >
                                <AnimatePresence>
                                  {selectedOptionIds?.some(
                                    ([pathId, blockId]) =>
                                      pathId === option.path.id &&
                                      blockId === block.id
                                  ) && (
                                    <motion.div
                                      className="w-1.5 h-1.5 sm:w-2 sm:h-2 bg-white rounded-full"
                                      initial={{ scale: 0 }}
                                      animate={{ scale: 1 }}
                                      exit={{ scale: 0 }}
                                      transition={{ duration: 0.2 }}
                                    />
                                  )}
                                </AnimatePresence>
                              </div>
                              <div className="flex flex-col gap-0.5 sm:gap-1">
                                <p
                                  className="font-normal text-xs sm:text-sm"
                                  style={{ color: colors['text-primary'] }}
                                >
                                  {renderTitleWithLineBreaks(option.path.name)}
                                </p>
                              </div>
                            </motion.button>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              </div>
            )}
          </div>
        </div>

        {/* Custom scrollbar - responsive width and position */}
        {showScrollbar && (
          <div
            className={`absolute top-4 bottom-4 rounded-full cursor-pointer`}
            style={{
              right: windowWidth <= 640 ? '2px' : '4px',
              width: `${scrollbarWidth}px`,
              backgroundColor: 'rgba(0,0,0,0.05)',
            }}
            onClick={handleScrollbarClick}
          >
            <div
              className="absolute rounded-full transition-all duration-100"
              style={{
                width: `${scrollbarWidth}px`,
                backgroundColor: colors['border-secondary'],
                height: `${scrollbarThumbHeight}px`,
                top: `${thumbPosition}px`,
                opacity: 0.8,
              }}
            />
          </div>
        )}
      </div>

      {/* Fullscreen Modal */}
      {isImageFullscreen && imageUrl && (
        <div
          className="fixed inset-0 z-[9999] bg-black/90 flex items-center justify-center"
          onClick={() => setIsImageFullscreen(false)}
          style={{ backdropFilter: 'blur(4px)' }}
        >
          {/* Close button */}
          <button
            className="absolute top-4 right-4 z-10 p-2 rounded-full bg-black/50 cursor-pointer hover:bg-black/70 transition-colors"
            onClick={() => setIsImageFullscreen(false)}
            aria-label="Close fullscreen view"
          >
            <svg
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M18 6L6 18M6 6L18 18"
                stroke="white"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              />
            </svg>
          </button>
          {/* Help tooltip */}
          <div className="absolute top-4 left-4 z-10 text-white font-normal text-sm bg-black/50 px-3 py-2 rounded-md">
            <span className="hidden sm:inline">
              Use mouse wheel to zoom  Double-click to reset {' '}
              {Math.round(zoomLevel * 100)}%
            </span>
            <span className="sm:hidden">{Math.round(zoomLevel * 100)}%</span>
          </div>
          {/* Zoom controls */}
          <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex space-x-2 bg-black/50 p-2 rounded-lg z-10">
            <button
              onClick={zoomOut}
              className="p-2 bg-gray-800 hover:bg-gray-700 rounded-full transition-colors"
              aria-label="Zoom out"
            >
              <svg
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M5 12H19"
                  stroke="white"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
              </svg>
            </button>
            <button
              onClick={resetZoom}
              className="p-2 bg-gray-800 hover:bg-gray-700 rounded-full transition-colors"
              aria-label="Reset zoom"
            >
              <svg
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M15 15L21 21M17 10C17 13.866 13.866 17 10 17C6.13401 17 3 13.866 3 10C3 6.13401 6.13401 3 10 3C13.866 3 17 6.13401 17 10Z"
                  stroke="white"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
              </svg>
            </button>
            <button
              onClick={zoomIn}
              className="p-2 bg-gray-800 hover:bg-gray-700 rounded-full transition-colors"
              aria-label="Zoom in"
            >
              <svg
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M12 5V19M5 12H19"
                  stroke="white"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
              </svg>
            </button>
          </div>
          {/* Image container with drag functionality */}
          <div
            ref={imageContainerRef}
            className={cn(
              'relative w-[90vw] h-[90vh] flex items-center justify-center overflow-hidden',
              zoomLevel > 1 ? 'cursor-grab' : '',
              isDragging && zoomLevel > 1 ? 'cursor-grabbing' : ''
            )}
            onClick={(e) => e.stopPropagation()}
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
            onDoubleClick={handleDoubleClick}
          >
            <div
              className="transition-all duration-200 ease-out"
              style={{
                transform: `scale(${zoomLevel}) translate(${dragPosition.x}px, ${dragPosition.y}px)`,
                transformOrigin: 'center center',
              }}
            >
              <img
                src={imageUrl}
                alt="Block Media Fullscreen"
                className="max-h-full max-w-full object-contain"
                style={{ pointerEvents: 'none' }}
                draggable="false"
              />
            </div>
          </div>
        </div>
      )}
    </>
  );
}
</file>

<file path="app/shared/[flow]/embed/components/ProcessCard.tsx">
'use client';

import { useColors } from '@/app/theme/hooks';
import { useState, useRef, useEffect } from 'react';
import { cn } from '@/lib/utils';

interface Integration {
  name: string;
  icon?: string;
}

interface Owner {
  name: string;
  avatar?: string;
}

interface ProcessCardProps {
  icon: string;
  workflow: {
    name: string;
    description?: string; // "Why does this Flow exist?"
  };
  integrations: Integration[];
  owner?: Owner; // Flow owner
  review_date?: string; // Review Date
  additionalNotes?: string; // Additional notes
  lastUpdate?: string; // Keep for backwards compatibility
}

export default function ProcessCard({
  icon,
  workflow,
  integrations,
  owner,
  review_date,
  additionalNotes,
  lastUpdate,
}: ProcessCardProps) {
  const colors = useColors();
  const [showPopover, setShowPopover] = useState(false);
  const popoverTimerRef = useRef<NodeJS.Timeout>();
  const [windowHeight, setWindowHeight] = useState<number>(0);
  const [shouldCenter, setShouldCenter] = useState(false);
  const descriptionRef = useRef<HTMLDivElement>(null);
  const additionalNotesRef = useRef<HTMLDivElement>(null);

  const visibleIntegrations = integrations.slice(0, 5);
  const hiddenIntegrations = integrations.slice(5);
  const hasHiddenIntegrations = integrations.length > 5;

  // Update window dimensions
  useEffect(() => {
    const updateWindowDimensions = () => {
      setWindowHeight(window.innerHeight);
    };

    // Initialize
    updateWindowDimensions();

    // Add event listener
    window.addEventListener('resize', updateWindowDimensions);

    // Clean up
    return () => {
      window.removeEventListener('resize', updateWindowDimensions);
    };
  }, []);

  // Check if content should be centered based on height
  useEffect(() => {
    const checkContentHeight = () => {
      let totalContentHeight = 0;

      if (descriptionRef.current) {
        totalContentHeight += descriptionRef.current.offsetHeight;
      }

      if (additionalNotesRef.current) {
        totalContentHeight += additionalNotesRef.current.offsetHeight;
      }

      const halfWindowHeight = windowHeight * 0.5;
      setShouldCenter(
        totalContentHeight < halfWindowHeight && windowHeight > 0
      );
    };

    // Use setTimeout to ensure DOM has been updated
    const timeoutId = setTimeout(checkContentHeight, 0);

    return () => clearTimeout(timeoutId);
  }, [workflow.description, additionalNotes, windowHeight]);

  const handleMouseEnter = () => {
    if (popoverTimerRef.current) {
      clearTimeout(popoverTimerRef.current);
    }
    setShowPopover(true);
  };

  const handleMouseLeave = () => {
    popoverTimerRef.current = setTimeout(() => {
      setShowPopover(false);
    }, 100); // 300ms delay before hiding
  };

  useEffect(() => {
    return () => {
      if (popoverTimerRef.current) {
        clearTimeout(popoverTimerRef.current);
      }
    };
  }, []);

  const IntegrationBadge = ({ integration }: { integration: Integration }) => (
    <div
      style={{
        backgroundColor: colors['bg-secondary'],
        borderColor: colors['border-secondary'],
      }}
      className="inline-flex items-center px-2 py-1 rounded-md border gap-1.5"
    >
      {integration.icon && (
        <img
          src={integration.icon}
          alt={integration.name}
          className="w-3.5 h-3.5 object-contain"
        />
      )}
      <span
        style={{ color: colors['text-secondary'] }}
        className="text-xs leading-none font-medium"
      >
        {integration.name}
      </span>
    </div>
  );

  return (
    <div
      style={{
        borderColor: colors['border-secondary'],
      }}
      className={cn(
        'h-full w-full',
        shouldCenter
          ? 'flex items-center justify-center'
          : 'flex justify-center'
      )}
    >
      <div className="flex gap-4 flex-row items-start max-w-3xl">
        {/* Large Icon */}
        <div
          style={{
            backgroundColor: colors['bg-secondary'],
          }}
          className="w-12 h-12 rounded-xl flex items-center justify-center flex-shrink-0"
        >
          <img
            src={icon}
            alt={workflow.name}
            className="w-10 h-10 object-contain"
          />
        </div>

        {/* Content Container */}
        <div className="flex flex-col gap-3 flex-1 items-start text-left">
          {/* Title and Description */}
          <div className="flex flex-col gap-1">
            <h3
              style={{ color: colors['text-primary'] }}
              className="font-semibold text-2xl leading-tight"
            >
              {workflow.name}
            </h3>
            {workflow.description && (
              <div className="max-w-2xl break-words">
                <p
                  style={{ color: colors['text-secondary'] }}
                  className="text-sm font-medium mb-1"
                >
                  Why does this Flow exist?
                </p>
                <p
                  ref={descriptionRef}
                  style={{ color: colors['text-quaternary'] }}
                  className="font-normal text-sm"
                >
                  {workflow.description}
                </p>
              </div>
            )}
          </div>

          {/* Integration Badges */}
          <div className="flex flex-wrap gap-2 justify-start">
            {visibleIntegrations.map((integration, index) => (
              <IntegrationBadge key={index} integration={integration} />
            ))}

            {hasHiddenIntegrations && (
              <div
                className="relative"
                onMouseEnter={handleMouseEnter}
                onMouseLeave={handleMouseLeave}
              >
                <div
                  style={{
                    backgroundColor: colors['bg-secondary'],
                    borderColor: colors['border-secondary'],
                    color: colors['text-secondary'],
                  }}
                  className="inline-flex items-center px-2 py-1 rounded-md border gap-1.5 hover:bg-opacity-80 transition-all duration-200"
                >
                  <span className="text-xs leading-none font-medium">
                    +{hiddenIntegrations.length}
                  </span>
                </div>

                {/* Popover for additional integrations */}
                <div
                  style={{
                    backgroundColor: colors['bg-primary'],
                    borderColor: colors['border-secondary'],
                    boxShadow: `0px 4px 6px -2px ${colors['shadow-md_01']}, 0px 12px 16px -4px ${colors['shadow-md_02']}`,
                    opacity: showPopover ? 1 : 0,
                    visibility: showPopover ? 'visible' : 'hidden',
                  }}
                  className="absolute left-0 top-full mt-2 z-50 rounded-lg border p-3 min-w-[200px] max-w-[300px] transition-all duration-200"
                >
                  <div className="flex flex-col gap-2">
                    {hiddenIntegrations.map((integration, index) => (
                      <IntegrationBadge key={index} integration={integration} />
                    ))}
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* Footer */}
          <div className="flex items-center gap-4 flex-row">
            {owner && owner.name && owner.name.trim() && (
              <>
                <div className="flex items-center gap-2">
                  {owner.avatar && (
                    <img
                      src={owner.avatar}
                      alt={owner.name}
                      className="rounded-full w-8 h-8"
                    />
                  )}
                  <span
                    style={{ color: colors['text-secondary'] }}
                    className="font-medium text-sm"
                  >
                    {owner.name}
                  </span>
                </div>
                {(review_date || lastUpdate) && (
                  <div
                    style={{ color: colors['text-tertiary'] }}
                    className="w-1 h-1 rounded-full bg-current"
                  />
                )}
              </>
            )}
            {review_date && (
              <>
                <div className="flex items-center gap-2">
                  <span
                    style={{ color: colors['text-tertiary'] }}
                    className="text-sm"
                  >
                    Review date: {review_date}
                  </span>
                </div>
                {lastUpdate && (
                  <div
                    style={{ color: colors['text-tertiary'] }}
                    className="w-1 h-1 rounded-full bg-current"
                  />
                )}
              </>
            )}
            {lastUpdate && (
              <div className="flex items-center gap-2">
                <span
                  style={{ color: colors['text-tertiary'] }}
                  className="text-sm"
                >
                  Last update: {lastUpdate}
                </span>
              </div>
            )}
          </div>

          {/* Additional Notes */}
          {additionalNotes && (
            <div className="mt-2">
              <p
                ref={additionalNotesRef}
                style={{ color: colors['text-quaternary'] }}
                className="text-sm italic"
              >
                <span className="font-medium not-italic">
                  Additional notes:
                </span>{' '}
                {additionalNotes}
              </p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/shared/[flow]/embed/page.tsx">
'use client';

import React, { useState, useEffect, useMemo, use } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { useColors, useTheme } from '@/app/theme/hooks';
import ProcessCard from './components/ProcessCard';
import ButtonNormal from '@/app/components/ButtonNormal';
import { cn } from '@/lib/utils';
import HorizontalLastStep from './components/HorizontalLastStep';
import HorizontalStep from './components/HorizontalStep';
import HorizontalDelay from './components/HorizontalDelay';
import { usePathsStore } from '@/app/[slug]/[flow]/read/store/pathsStore';
import { Block, Path, WorkflowData } from '@/app/[slug]/[flow]/types';
import { toast } from 'sonner';

// Modify the type for source block pairs
type SourceBlockPair = {
  originalId: number;
  copies: Block[];
};

// Add after imports, before component
const generateUniqueId = (
  existingIds: Set<number>,
  isPath: boolean = false
): number => {
  let id: number;
  do {
    id = Math.floor(Math.random() * -1000000);
  } while (existingIds.has(id));
  existingIds.add(id);
  return id;
};

export default function SharePage({
  params,
}: {
  params: Promise<{ flow: string }>;
}) {
  const resolvedParams = use(params);
  const router = useRouter();
  const { currentTheme, setTheme } = useTheme();
  const colors = useColors();
  const [currentStep, setCurrentStep] = useState<number>(-1);
  const [selectedOptions, setSelectedOptions] = useState<[number, number][]>(
    []
  );
  const [pathsToDisplay, setPathsToDisplay] = useState<typeof paths>([]);
  const [workflowData, setWorkflowData] = useState<WorkflowData | null>(null);
  const [generatedPathIds] = useState<Set<number>>(new Set());
  const [generatedBlockIds] = useState<Set<number>>(new Set());
  const [copyPaths, setCopyPaths] = useState<Path[]>([]);

  // Add sourceBlockPairs as a component-level variable
  const sourceBlockPairs: SourceBlockPair[] = [];

  const paths = usePathsStore((state) => state.paths);
  const mainPath = useMemo(
    () => paths.find((path) => path.parent_blocks.length === 0),
    [paths]
  );

  const PathsToDisplayBlocks = useMemo(() => {
    return pathsToDisplay.flatMap((path) => {
      return path.blocks.filter(
        (block) => !['BEGIN', 'LAST', 'MERGE', 'END'].includes(block.type)
      );
    });
  }, [pathsToDisplay, selectedOptions, paths]);

  // Fetch paths
  useEffect(() => {
    const fetchPathsAndStrokeLines = async () => {
      if (!workflowData) {
        return;
      }
      try {
        const response = await fetch(
          `/api/workspace/${workflowData?.workspace_id}/paths?workflow_id=${workflowData?.id}`
        );
        const pathsData = await response.json();

        if (pathsData.paths) {
          const newPaths = [...pathsData.paths];

          // First process stroke lines
          const strokeLinesResponse = await fetch(
            `/api/stroke-lines?workflow_id=${workflowData?.id}`
          );
          if (strokeLinesResponse.ok) {
            const strokeLinesData = await strokeLinesResponse.json();

            strokeLinesData.forEach((strokeLine: any) => {
              const sourcePath = newPaths.find((p: Path) =>
                p.blocks.some((b) => b.id === strokeLine.source_block_id)
              );
              let targetPath = newPaths.find((p: Path) =>
                p.blocks.some((b) => b.id === strokeLine.target_block_id)
              );

              if (sourcePath && targetPath) {
                const sourceBlockIndex = sourcePath.blocks.findIndex(
                  (b: Block) => b.id === strokeLine.source_block_id
                );

                if (sourceBlockIndex !== -1) {
                  // Get the next block after source
                  const nextBlock = sourcePath.blocks[sourceBlockIndex + 1];

                  let continuePath: Path | undefined;

                  // Original logic for non-PATH blocks
                  const blocksAfterSource = sourcePath.blocks.slice(
                    sourceBlockIndex + 1
                  );

                  if (blocksAfterSource.length > 0) {
                    continuePath = {
                      id: generateUniqueId(generatedPathIds, true),
                      name:
                        blocksAfterSource[0].type === 'MERGE' &&
                        blocksAfterSource[0].child_paths?.[0]
                          ? (() => {
                              const childPathId =
                                blocksAfterSource[0].child_paths[0].path_id;
                              const childPath = pathsData.paths.find(
                                (p: Path) => p.id === childPathId
                              );
                              const childBlock = childPath?.blocks[1];
                              return (
                                childBlock?.title ||
                                (childBlock?.type
                                  ? childBlock.type.charAt(0).toUpperCase() +
                                    childBlock.type.slice(1).toLowerCase() +
                                    ' Block'
                                  : 'Merge Block')
                              );
                            })()
                          : blocksAfterSource[0].title ||
                            (blocksAfterSource[0].type === 'LAST' ||
                            blocksAfterSource[0].type === 'END'
                              ? 'Complete process'
                              : blocksAfterSource[0].type
                                  .charAt(0)
                                  .toUpperCase() +
                                blocksAfterSource[0].type
                                  .slice(1)
                                  .toLowerCase() +
                                ' Block'),
                      workflow_id: parseInt(workflowData.id),
                      workflow: sourcePath.workflow,
                      blocks: blocksAfterSource,
                      parent_blocks: [
                        {
                          path_id: -1,
                          block_id: strokeLine.source_block_id,
                          created_at: new Date().toISOString(),
                          path: {} as Path,
                          block: {} as Block,
                        },
                      ],
                    };

                    const sourceBlock = newPaths
                      .flatMap((p) => p.blocks)
                      .find((b: Block) => b.id === strokeLine.source_block_id);

                    if (sourceBlock) {
                      if (
                        sourceBlock.is_endpoint &&
                        (blocksAfterSource[0].type === 'LAST' ||
                          blocksAfterSource[0].type === 'END')
                      ) {
                        sourceBlock.child_paths = sourceBlock.child_paths;
                      } else {
                        sourceBlock.child_paths = [
                          ...(sourceBlock.child_paths || []),
                          {
                            path_id: continuePath.id,
                            block_id: sourceBlock.id,
                            created_at: new Date().toISOString(),
                            path: continuePath,
                            block: sourceBlock,
                          },
                        ];
                      }
                    }

                    newPaths.push(continuePath);
                  }

                  // Remove blocks after source block
                  sourcePath.blocks = sourcePath.blocks.slice(
                    0,
                    sourceBlockIndex + 1
                  );

                  // If target path is the same as source path and we created a continue path,
                  // update targetPath to be the continue path
                  if (targetPath.id === sourcePath.id && continuePath) {
                    const targetBlockIndex = continuePath.blocks.findIndex(
                      (b: Block) => b.id === strokeLine.target_block_id
                    );
                    if (targetBlockIndex !== -1) {
                      targetPath = continuePath;
                    }
                  }
                }
              }

              const targetBlockIndex = targetPath.blocks.findIndex(
                (b: Block) => b.id === strokeLine.target_block_id
              );

              if (targetBlockIndex !== -1) {
                const newPath = {
                  id: generateUniqueId(generatedPathIds, true),
                  name: strokeLine.label,
                  workflow_id: parseInt(workflowData.id),
                  workflow: targetPath.workflow,
                  blocks: targetPath.blocks.slice(targetBlockIndex),
                  parent_blocks: [
                    {
                      path_id: -1,
                      block_id: strokeLine.source_block_id,
                      created_at: new Date().toISOString(),
                      path: {} as Path,
                      block: {} as Block,
                    },
                  ],
                };

                const sourceBlock = newPaths
                  .flatMap((p) => p.blocks)
                  .find((b) => b.id === strokeLine.source_block_id);

                if (sourceBlock) {
                  sourceBlock.child_paths = [
                    ...(sourceBlock.child_paths || []),
                    {
                      path_id: newPath.id,
                      block_id: sourceBlock.id,
                      created_at: new Date().toISOString(),
                      path: newPath,
                      block: sourceBlock,
                    },
                  ];
                }

                newPaths.push(newPath);
              }
            });
          }

          // Then process MERGE blocks
          newPaths.forEach((path: Path) => {
            const mergeBlockIndex = path.blocks.findIndex(
              (block: Block) => block.type === 'MERGE' && block.child_paths?.[0]
            );

            if (mergeBlockIndex !== -1) {
              const mergeBlock = path.blocks[mergeBlockIndex];
              const childPath = pathsData.paths.find(
                (p: Path) => p.id === mergeBlock.child_paths[0].path.id
              );
              if (childPath) {
                const clonedBlocks = childPath.blocks
                  .filter((b: Block) => !['BEGIN', 'END'].includes(b.type))
                  .map((block: Block) => ({
                    ...block,
                    path_id: path.id,
                  }));

                path.blocks = [
                  ...path.blocks.slice(0, mergeBlockIndex),
                  ...clonedBlocks,
                  ...path.blocks.slice(mergeBlockIndex + 1),
                ];
              }
            }
          });

          usePathsStore.getState().setPaths(newPaths);
        }
      } catch (error) {
        console.error('Error fetching paths:', error);
      }
    };

    fetchPathsAndStrokeLines();
  }, [workflowData]);

  // Update initial pathsToDisplay
  useEffect(() => {
    if (mainPath) {
      setPathsToDisplay([mainPath]);
    }
  }, [mainPath]);

  // Fetch workflow data and check public status
  useEffect(() => {
    // Parse the flow parameter
    const lastPfIndex = resolvedParams.flow.lastIndexOf('--pf-');
    const workflowName = resolvedParams.flow.slice(0, lastPfIndex);
    const publicAccessId = resolvedParams.flow.slice(lastPfIndex + 5);

    if (!workflowName || !publicAccessId) {
      console.error('Invalid URL format');
      return;
    }

    // Fix: decode only, do not replace dashes
    const decodedWorkflowName = decodeURIComponent(workflowName);
    const fetchData = async () => {
      try {
        const workflowResponse = await fetch(
          `/api/workflow/public?public_access_id=${encodeURIComponent(publicAccessId)}`
        );
        const workflowData = await workflowResponse.json();

        // Check if workflow is not public
        // if (!workflowData.is_public) {
        //   router.push('/unauthorized');
        //   return;
        // }

        setWorkflowData(workflowData);
      } catch (error) {
        console.error('Error fetching workflow data:', error);
        router.push('/unauthorized');
      }
    };

    fetchData();
  }, [resolvedParams.flow, router]);

  // Initialize copyPaths when paths change
  useEffect(() => {
    setCopyPaths(paths);
  }, [paths]);

  // Initialize theme from URL
  useEffect(() => {
    const url = new URL(window.location.href);
    const urlTheme = url.searchParams.get('theme') as 'light' | 'dark';
    if (urlTheme && ['light', 'dark'].includes(urlTheme)) {
      setTheme(urlTheme);
    }
  }, [setTheme]);

  const toggleEmbedTheme = () => {
    const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    setTheme(newTheme);

    // Update URL without navigation
    const url = new URL(window.location.href);
    url.searchParams.set('theme', newTheme);
    window.history.replaceState({}, '', url.toString());
  };

  const handleOptionSelect = (optionId: number, blockId: number) => {
    if (
      selectedOptions.some(
        ([pathId, bId]) => pathId === optionId && bId === blockId
      )
    ) {
      return;
    }

    // Search in copyPaths instead of paths
    const pathToAdd = copyPaths.find((path) => path.id === optionId);
    if (!pathToAdd) {
      return;
    }

    // Find the index where this selection will replace an existing one
    const replaceIndex = pathsToDisplay.findIndex((path) =>
      path.blocks.some((block) =>
        selectedOptions.some(
          ([_, selectedBlockId]) =>
            selectedBlockId === block.id && block.id === blockId
        )
      )
    );

    // Remove any existing selection for this blockId
    const existingSelection = selectedOptions.find(
      ([_, bId]) => bId === blockId
    );
    if (existingSelection) {
      const [existingPathId] = existingSelection;
      setSelectedOptions((prev) => prev.filter(([_, bId]) => bId !== blockId));
      setPathsToDisplay((prev) => prev.filter((p) => p.id !== existingPathId));
    }

    // Always create a copy of the path
    const newPathId = generateUniqueId(generatedPathIds, true);
    const pathCopy = {
      ...pathToAdd,
      id: newPathId,
      blocks: pathToAdd.blocks.map((block) => ({
        ...block,
        original_id: block.original_id ? block.original_id : block.id,
        id: generateUniqueId(generatedBlockIds),
        path_id: newPathId,
      })),
      parent_blocks: [
        {
          path_id: newPathId,
          block_id: blockId,
          created_at: new Date().toISOString(),
          path: {} as Path,
          block:
            PathsToDisplayBlocks.find((b) => b.id === blockId) || ({} as Block),
        },
      ],
    };

    // Add the new path copy to copyPaths
    setCopyPaths((current) => {
      // If pathToAdd was only in copyPaths (not in original paths), remove it
      if (!paths.some((p) => p.id === pathToAdd.id)) {
        return current.filter((p) => p.id !== pathToAdd.id).concat(pathCopy);
      }
      // Otherwise just add the new copy
      return [...current, pathCopy];
    });

    // Replace in child_paths of the parent block
    const parentBlock = PathsToDisplayBlocks.find(
      (block) =>
        block.id === blockId &&
        block.child_paths?.some((cp) => cp.path.id === pathToAdd.id)
    );

    if (parentBlock) {
      parentBlock.child_paths = parentBlock.child_paths?.map((cp) =>
        cp.path.id === pathToAdd.id
          ? {
              ...cp,
              path_id: newPathId,
              block_id: blockId,
              path: pathCopy,
            }
          : cp
      );
    }

    // If we found a replace index, remove everything after it
    if (replaceIndex !== -1) {
      setPathsToDisplay((current) => [
        ...current.slice(0, replaceIndex + 1),
        pathCopy,
      ]);
      setSelectedOptions((prev) => {
        const blockIdsToKeep = new Set(
          pathsToDisplay
            .slice(0, replaceIndex + 1)
            .flatMap((p) => p.blocks)
            .map((b) => b.id)
        );
        return [
          ...prev.filter(([_, bId]) => blockIdsToKeep.has(bId)),
          [pathCopy.id, blockId],
        ];
      });
    } else {
      setPathsToDisplay((current) => [...current, pathCopy]);
      setSelectedOptions((prev) => [...prev, [pathCopy.id, blockId]]);
    }
  };

  const handleStepNavigation = (direction: 'prev' | 'next') => {
    if (direction === 'next') {
      if (currentStep === PathsToDisplayBlocks.length - 1) {
        setCurrentStep(PathsToDisplayBlocks.length);
      } else {
        setCurrentStep((prev) =>
          Math.min(prev + 1, PathsToDisplayBlocks.length - 1)
        );
      }
    } else {
      if (currentStep === PathsToDisplayBlocks.length) {
        setCurrentStep(PathsToDisplayBlocks.length - 1);
      } else {
        setCurrentStep((prev) => Math.max(prev - 1, -1));
      }
    }
  };

  const handleCopyLink = async (e?: React.MouseEvent) => {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }

    if (!workflowData) return;

    const url = window.location.href;

    try {
      // Try the modern clipboard API first
      await navigator.clipboard.writeText(url);
      toast.success('Link Copied!', {
        description: 'Share link has been copied to your clipboard.',
        duration: 3000,
      });
    } catch (err) {
      try {
        // Fallback: Create a temporary textarea element
        const textArea = document.createElement('textarea');
        textArea.value = url;
        // Position off-screen without affecting scroll
        textArea.style.position = 'absolute';
        textArea.style.opacity = '0';
        textArea.style.pointerEvents = 'none';
        textArea.style.zIndex = '-1';
        textArea.style.left = '-9999px';
        textArea.style.top = '0';
        document.body.appendChild(textArea);

        // Select and copy without focusing
        textArea.select();
        const successful = document.execCommand('copy');
        textArea.remove();

        if (successful) {
          toast.success('Link Copied!', {
            description: 'Share link has been copied to your clipboard.',
            duration: 3000,
          });
        } else {
          throw new Error('Fallback copy failed');
        }
      } catch (fallbackErr) {
        // If both methods fail, show error with the URL
        toast.error('Failed to Copy', {
          description: 'Please copy this URL manually: ' + url,
          duration: 5000,
        });
      }
    }
  };

  const handleRestart = () => {
    setCurrentStep(-1);
    setSelectedOptions([]);
    if (mainPath) {
      setPathsToDisplay([mainPath]);
    }
  };

  // Process card data preparation
  const processCardData = workflowData
    ? {
        icon:
          workflowData.icon && workflowData.icon.trim() !== ''
            ? workflowData.icon.startsWith('https://cdn.brandfetch.io/')
              ? workflowData.icon
              : workflowData.signedIconUrl
                ? workflowData.signedIconUrl
                : `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`
            : `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`,
        workflow: {
          name: workflowData.name,
          description: workflowData.description,
        },
        integrations: paths
          .flatMap((path) =>
            path.blocks
              .filter(
                (block) =>
                  block.icon &&
                  block.icon.includes('/apps/') &&
                  block.signedIconUrl
              )
              .map((block) => ({
                name: block
                  .icon!.split('/apps/')[1]
                  .split('.svg')[0]
                  .split('-')
                  .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
                  .join(' '),
                icon: `${block.signedIconUrl}`,
              }))
          )
          .filter(
            (integration, index, self) =>
              index === self.findIndex((i) => i.name === integration.name)
          ),
        // Use process owner data instead of author
        ...(workflowData.process_owner && workflowData.process_owner.trim() && {
          owner: {
            name: workflowData.process_owner,
            // Flow owners don't have avatars in our current system
          },
        }),
        review_date: workflowData.review_date
          ? new Date(workflowData.review_date).toLocaleDateString('en-GB')
          : 'No review date',
        additionalNotes: workflowData.additional_notes,
        lastUpdate:
          paths
            .flatMap((path) => path.blocks)
            .reduce(
              (latest, block) =>
                block.updated_at &&
                (!latest || new Date(block.updated_at) > new Date(latest))
                  ? new Date(block.updated_at).toLocaleDateString('en-GB')
                  : latest,
              ''
            ) || 'No updates',
      }
    : null;

  // Update openEmbedLink to use embedTheme
  const openEmbedLink = () => {
    const url = new URL(window.location.href);
    url.searchParams.set('theme', currentTheme);
    window.open(url.toString(), '_blank');
  };

  // Return null while checking public status
  if (!workflowData) {
    return null;
  }

  return (
    <div
      className="h-[100vh] w-[100vw] transition-colors duration-200"
      style={{ backgroundColor: colors['bg-primary'] }}
    >
      <div className="h-full flex items-center justify-center">
        <div
          className={cn('rounded-lg border w-full mx-0', 'h-full')}
          style={{
            backgroundColor: colors['bg-primary'],
            borderColor: colors['border-secondary'],
          }}
        >
          {/* Main container with fixed header and bottom bar */}
          <div className="h-full w-full flex flex-col">
            {/* Content area - fills available space */}
            <div className="flex-1 p-4 flex flex-col min-h-0">
              {currentStep === -1 ? (
                <>
                  {/* ProcessCard view */}
                  <div className="flex-1 min-h-0 overflow-y-auto">
                    {processCardData && <ProcessCard {...processCardData} />}
                  </div>
                  <div className="h-16 flex-shrink-0 flex items-center justify-end">
                    <ButtonNormal
                      variant="primary"
                      size="small"
                      onClick={() => handleStepNavigation('next')}
                      trailingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-right.svg`}
                    >
                      Get Started
                    </ButtonNormal>
                  </div>
                </>
              ) : (
                <>
                  {/* Main content area - fills available space */}
                  <div className="flex-1 min-h-0 overflow-hidden">
                    {currentStep === PathsToDisplayBlocks.length ? (
                      <HorizontalLastStep
                        onCopyLink={handleCopyLink}
                        onRestart={handleRestart}
                        onPreviousStep={() => handleStepNavigation('prev')}
                      />
                    ) : PathsToDisplayBlocks[currentStep]?.type === 'DELAY' ? (
                      <HorizontalDelay
                        block={PathsToDisplayBlocks[currentStep]}
                        selectedOptionIds={selectedOptions}
                        onOptionSelect={handleOptionSelect}
                      />
                    ) : (
                      <HorizontalStep
                        block={PathsToDisplayBlocks[currentStep]}
                        selectedOptionIds={selectedOptions}
                        onOptionSelect={handleOptionSelect}
                        isFirstStep={currentStep === 0}
                      />
                    )}
                  </div>

                  {/* Navigation buttons - fixed height */}
                  <div className="h-16 flex-shrink-0 flex items-center justify-end">
                    <div className="flex items-center gap-2">
                      <ButtonNormal
                        variant="secondary"
                        size="small"
                        onClick={() => handleStepNavigation('prev')}
                        leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-left.svg`}
                      >
                        Previous step
                      </ButtonNormal>
                      {currentStep !== PathsToDisplayBlocks.length && (
                        <ButtonNormal
                          variant="primary"
                          size="small"
                          onClick={() => handleStepNavigation('next')}
                          disabled={
                            currentStep === PathsToDisplayBlocks.length ||
                            (PathsToDisplayBlocks[currentStep]?.child_paths
                              ?.length > 0 &&
                              !selectedOptions.some(
                                ([_, blockId]) =>
                                  blockId ===
                                  PathsToDisplayBlocks[currentStep].id
                              ))
                          }
                          trailingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-right.svg`}
                        >
                          {currentStep === PathsToDisplayBlocks.length - 1
                            ? 'Complete'
                            : 'Next step'}
                        </ButtonNormal>
                      )}
                    </div>
                  </div>
                </>
              )}
            </div>

            {/* Bottom bar - fixed height */}
            <div
              className="h-12 flex-shrink-0 flex justify-between items-center px-[17.5px] py-[2.9px] border-t"
              style={{
                backgroundColor: colors['bg-tertiary'],
                borderColor: colors['border-secondary'],
              }}
            >
              <div className="flex items-center gap-[8.7px]">
                <span
                  className="text-[10.2px] leading-[1.43] font-normal"
                  style={{ color: colors['text-secondary'] }}
                >
                  Made with
                </span>
                <button
                  onClick={() =>
                    window.open('https://process-flow.io', '_blank')
                  }
                  className="hover:opacity-80 transition-opacity"
                >
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logo-pf-in-app.png`}
                    alt="ProcessFlow Logo"
                    className="h-[20px]"
                  />
                </button>
              </div>
              <div className="flex items-center gap-2">
                <button
                  className="p-2 rounded-[5.8px] hover:bg-[rgba(0,0,0,0.05)]"
                  onClick={toggleEmbedTheme}
                  title={`Switch to ${currentTheme === 'light' ? 'dark' : 'light'} theme`}
                >
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${currentTheme === 'light' ? 'moon' : 'sun'}.svg`}
                    alt={
                      currentTheme === 'light' ? 'Dark theme' : 'Light theme'
                    }
                    className="w-[14.5px] h-[14.5px]"
                  />
                </button>
                <button
                  className="p-2 rounded-[5.8px] hover:bg-[rgba(0,0,0,0.08)]"
                  onClick={openEmbedLink}
                >
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/link-external-02.svg`}
                    alt="External Link"
                    className="w-[14.5px] h-[14.5px]"
                  />
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/shared/[flow]/page.tsx">
'use client';

import React, { useState, useEffect, useRef, useMemo, use } from 'react';
import { useParams } from 'next/navigation';
import { User } from '@/types/user';
import { createClient } from '@/utils/supabase/client';
import dynamic from 'next/dynamic';
import Sidebar from '@/app/[slug]/[flow]/read/components/Sidebar';
import { Workspace, Folder } from '@/types/workspace';
import { useColors } from '@/app/theme/hooks';
import ProcessCard from '@/app/[slug]/[flow]/read/components/ProcessCard';
import ViewModeSwitch from '@/app/[slug]/[flow]/read/components/ViewModeSwitch';
import VerticalStep from '@/app/[slug]/[flow]/read/components/steps/VerticalStep';
import HorizontalLastStep from '@/app/[slug]/[flow]/read/components/steps/HorizontalLastStep';
import ButtonNormal from '@/app/components/ButtonNormal';
import { cn } from '@/lib/utils';
import { toast } from 'sonner';
import { usePathsStore } from '@/app/[slug]/[flow]/read/store/pathsStore';
import ProcessCanvas from '@/app/[slug]/[flow]/read/components/ProcessCanvas';
import VerticalLastStep from '@/app/[slug]/[flow]/read/components/steps/VerticalLastStep';
import HorizontalStep from '@/app/[slug]/[flow]/read/components/steps/HorizontalStep';
import {
  Block,
  Path,
  PathParentBlock,
  WorkflowData,
} from '@/app/[slug]/[flow]/types';
import { BlockEndType } from '@/types/block';
import { cp } from 'fs';
import VerticalDelay from '@/app/[slug]/[flow]/read/components/steps/VerticalDelay';
import HorizontalDelay from '@/app/[slug]/[flow]/read/components/steps/HorizontalDelay';

const HelpCenterModalDynamic = dynamic(
  () => import('@/app/dashboard/components/HelpCenterModal'),
  {
    ssr: false,
  }
);

const UserSettingsDynamic = dynamic(
  () => import('@/app/dashboard/components/UserSettings'),
  {
    ssr: false,
  }
);

interface StepOption {
  id: string;
  title: string;
  description: string;
}

interface StepData {
  number: number;
  label: string;
  description: string;
  icon: string;
  isActive?: boolean;
  isConditional?: boolean;
  options?: StepOption[];
}

interface StrokeLine {
  id: number;
  source_block_id: number;
  target_block_id: number;
  workflow_id: number;
  label: string;
}

interface BreadcrumbItem {
  label: string;
  href?: string;
}

// Modify the type for source block pairs
type SourceBlockPair = {
  originalId: number;
  copies: Block[];
};

export default function SharedPage({
  params,
}: {
  params: Promise<{ flow: string }>;
}) {
  const resolvedParams = use(params);
  const supabase = createClient();
  const colors = useColors();
  const [user, setUser] = useState<User | null>(null);
  const [userSettingsVisible, setUserSettingsVisible] =
    useState<boolean>(false);
  const [helpCenterVisible, setHelpCenterVisible] = useState<boolean>(false);
  const [fileToUpload, setFileToUpload] = useState<File | null>(null);
  const [isDeleteAvatar, setIsDeleteAvatar] = useState<boolean>(false);
  const [passwordChanged, setPasswordChanged] = useState<boolean>(false);
  const [newPassword, setNewPassword] = useState<string>('');
  const [workspace, setWorkspace] = useState<Workspace | null>(null);
  const [viewMode, setViewMode] = useState<'vertical' | 'carousel'>('vertical');
  const [selectedOptions, setSelectedOptions] = useState<[number, number][]>(
    []
  );
  const [currentStep, setCurrentStep] = useState<number>(-1);
  const [expandedSteps, setExpandedSteps] = useState<number[]>([]);
  const [showLinkCopiedAlert, setShowLinkCopiedAlert] =
    useState<boolean>(false);
  const stepRefs = useRef<(HTMLDivElement | null)[]>([]);
  const [pathsToDisplay, setPathsToDisplay] = useState<typeof paths>([]);
  const [strokeLines, setStrokeLines] = useState<StrokeLine[]>([]);
  const [workflowData, setWorkflowData] = useState<WorkflowData | null>(null);
  const [breadcrumbItems, setBreadcrumbItems] = useState<BreadcrumbItem[]>([]);
  const [mergePathsParents, setMergePathsParents] = useState<
    [number, number][]
  >([]);
  const [generatedPathIds] = useState<Set<number>>(new Set());
  const [generatedBlockIds] = useState<Set<number>>(new Set());
  const [copyPaths, setCopyPaths] = useState<Path[]>([]);
  const [workflow, setWorkflow] = useState<WorkflowData | null>(null);

  // Add sourceBlockPairs as a component-level variable
  const sourceBlockPairs: SourceBlockPair[] = [];

  const paths = usePathsStore((state) => state.paths);
  const mainPath = useMemo(
    () => paths.find((path) => path.parent_blocks.length === 0),
    [paths]
  );

  const PathsToDisplayBlocks = useMemo(() => {
    return pathsToDisplay.flatMap((path) => {
      // Filter blocks and apply skip logic
      return path.blocks.filter(
        (block) => !['BEGIN', 'LAST', 'MERGE', 'END'].includes(block.type)
      );
    });
  }, [pathsToDisplay, selectedOptions, paths]);

  //   if (!params.id || !params.workflowId) {
  //     return <div>No id or workflowId</div>;
  //   }
  // Initialize all steps as expanded when paths are loaded
  useEffect(() => {
    if (pathsToDisplay.length > 0) {
      const allBlockIds = pathsToDisplay.flatMap((path) =>
        path.blocks
          .filter((block) => block.type !== 'BEGIN' && block.type !== 'LAST')
          .map((block) => block.id)
      );
      setExpandedSteps(allBlockIds);
    }
  }, [pathsToDisplay]);

  // Fetch user data
  useEffect(() => {
    const fetchUser = async () => {
      try {
        // Check authentication status first
        const {
          data: { user: authUser },
          error: authError,
        } = await supabase.auth.getUser();

        if (!authUser || authError) {
          setUser(null);
          // window.location.href = '/login';
          return;
        }

        const res = await fetch('/api/user');
        const data = await res.json();
        if (data) {
          setUser(data);
        }
      } catch (error) {
        console.error('Error fetching user:', error);
        window.location.href = '/login';
      }
    };
    fetchUser();
  }, []);

  //   Fetch workspace data
  useEffect(() => {
    const fetchWorkspace = async () => {
      try {
        const response = await fetch(
          `/api/workspace/${workflowData?.workspace_id}`
        );
        if (!response.ok) throw new Error('Failed to fetch workspace');
        const data = await response.json();
        setWorkspace(data);
      } catch (error) {
        console.error('Error fetching workspace:', error);
      }
    };

    if (workflowData) {
      fetchWorkspace();
    }
  }, [workflowData]);

  useEffect(() => {}, [paths]);
  // Fetch paths
  useEffect(() => {
    const fetchPathsAndStrokeLines = async () => {
      if (!workflowData) {
        return;
      }
      try {
        // Fetch paths
        const response = await fetch(
          `/api/workspace/${workflowData?.id}/paths?workflow_id=${workflowData?.id}`
        );
        const pathsData = await response.json();

        if (process.env.NODE_ENV !== 'production') {
          console.log('pathsData', pathsData);
        }
        if (pathsData.paths) {
          const newPaths = [...pathsData.paths];

          // First process stroke lines
          const strokeLinesResponse = await fetch(
            `/api/stroke-lines?workflow_id=${workflowData?.id}`
          );
          if (strokeLinesResponse.ok) {
            const strokeLinesData: StrokeLine[] =
              await strokeLinesResponse.json();
            setStrokeLines(strokeLinesData);

            strokeLinesData.forEach((strokeLine) => {
              const sourcePath = newPaths.find((p: Path) =>
                p.blocks.some((b) => b.id === strokeLine.source_block_id)
              );
              let targetPath = newPaths.find((p: Path) =>
                p.blocks.some((b) => b.id === strokeLine.target_block_id)
              );

              if (sourcePath && targetPath) {
                // Find the source block index
                const sourceBlockIndex = sourcePath.blocks.findIndex(
                  (b: Block) => b.id === strokeLine.source_block_id
                );

                if (sourceBlockIndex !== -1) {
                  // Get the next block after source
                  const nextBlock = sourcePath.blocks[sourceBlockIndex + 1];

                  let continuePath: Path | undefined;

                  if (nextBlock?.type === 'PATH') {
                    // If next block is PATH, append its child paths to source block
                    const sourceBlock = newPaths
                      .flatMap((p) => p.blocks)
                      .find((b: Block) => b.id === strokeLine.source_block_id);

                    if (sourceBlock && nextBlock.child_paths) {
                      sourceBlock.child_paths = [
                        ...(sourceBlock.child_paths || []),
                        ...nextBlock.child_paths.map((childPath: Path) => ({
                          ...childPath,
                          block_id: sourceBlock.id, // Update block_id to point to source block
                        })),
                      ];
                    }

                    // Remove blocks after source block including the PATH block
                    sourcePath.blocks = sourcePath.blocks.slice(
                      0,
                      sourceBlockIndex + 1
                    );
                  } else {
                    // Original logic for non-PATH blocks
                    const blocksAfterSource = sourcePath.blocks.slice(
                      sourceBlockIndex + 1
                    );
                    if (blocksAfterSource.length > 0) {
                      continuePath = {
                        id: generateUniqueId(generatedPathIds, true),
                        name:
                          blocksAfterSource[0].type === 'MERGE' &&
                          blocksAfterSource[0].child_paths?.[0]
                            ? (() => {
                                const childPathId =
                                  blocksAfterSource[0].child_paths[0].path_id;
                                const childPath = pathsData.paths.find(
                                  (p: Path) => p.id === childPathId
                                );
                                const childBlock = childPath?.blocks[1];
                                return (
                                  childBlock?.title ||
                                  (childBlock?.type
                                    ? childBlock.type.charAt(0).toUpperCase() +
                                      childBlock.type.slice(1).toLowerCase() +
                                      ' Block'
                                    : 'Merge Block')
                                );
                              })()
                            : blocksAfterSource[0].title ||
                              (blocksAfterSource[0].type === 'LAST' ||
                              blocksAfterSource[0].type === 'END'
                                ? 'Complete process'
                                : blocksAfterSource[0].type
                                    .charAt(0)
                                    .toUpperCase() +
                                  blocksAfterSource[0].type
                                    .slice(1)
                                    .toLowerCase() +
                                  ' Block'),
                        workflow_id: parseInt(workflowData?.id as string),
                        workflow: sourcePath.workflow,
                        blocks: blocksAfterSource,
                        parent_blocks: [
                          {
                            path_id: -1,
                            block_id: strokeLine.source_block_id,
                            created_at: new Date().toISOString(),
                            path: {} as Path,
                            block: {} as Block,
                          },
                        ],
                      };

                      const sourceBlock = newPaths
                        .flatMap((p) => p.blocks)
                        .find(
                          (b: Block) => b.id === strokeLine.source_block_id
                        );

                      if (sourceBlock) {
                        if (
                          sourceBlock.is_endpoint &&
                          (blocksAfterSource[0].type === 'LAST' ||
                            blocksAfterSource[0].type === 'END')
                        ) {
                          sourceBlock.child_paths = sourceBlock.child_paths;
                        } else {
                          sourceBlock.child_paths = [
                            ...(sourceBlock.child_paths || []),
                            {
                              path_id: continuePath.id,
                              block_id: sourceBlock.id,
                              created_at: new Date().toISOString(),
                              path: continuePath,
                              block: sourceBlock,
                            },
                          ];
                        }
                      }

                      newPaths.push(continuePath);
                    }

                    // Remove blocks after source block
                    sourcePath.blocks = sourcePath.blocks.slice(
                      0,
                      sourceBlockIndex + 1
                    );
                  }

                  // If target path is the same as source path and we created a continue path,
                  // update targetPath to be the continue path
                  if (targetPath.id === sourcePath.id && continuePath) {
                    const targetBlockIndex = continuePath.blocks.findIndex(
                      (b: Block) => b.id === strokeLine.target_block_id
                    );
                    if (targetBlockIndex !== -1) {
                      targetPath = continuePath;
                    }
                  }

                  const targetBlockIndex = targetPath.blocks.findIndex(
                    (b: Block) => b.id === strokeLine.target_block_id
                  );

                  if (targetBlockIndex !== -1) {
                    // Rest of the existing code for creating the target path...
                    const { clonedPath: newPath, sourceBlocks } =
                      clonePathWithMergeBlocks(
                        {
                          id: generateUniqueId(generatedPathIds, true),
                          name: strokeLine.label,
                          workflow_id: parseInt(workflowData?.id as string),
                          workflow: targetPath.workflow,
                          blocks: targetPath.blocks.slice(targetBlockIndex),
                          parent_blocks: [
                            {
                              path_id: -1,
                              block_id: strokeLine.source_block_id,
                              created_at: new Date().toISOString(),
                              path: {} as Path,
                              block: {} as Block,
                            },
                          ],
                        },
                        newPaths,
                        strokeLine.source_block_id
                      );

                    // Add the new path to all source blocks as a child path
                    const sourceBlock = newPaths
                      .flatMap((p) => p.blocks)
                      .find((b: Block) => b.id === strokeLine.source_block_id);
                    if (sourceBlock) {
                      sourceBlock.child_paths = [
                        ...(sourceBlock.child_paths || []),
                        {
                          path_id: newPath.id,
                          block_id: sourceBlock.id,
                          created_at: new Date().toISOString(),
                          path: newPath,
                          block: sourceBlock,
                        },
                      ];
                    }

                    // Add the new path to newPaths
                    newPaths.push(newPath);
                  }
                }
              }
            });

            // Apply child_paths from original blocks to their copies
            sourceBlockPairs.forEach((pair) => {
              const originalBlock = newPaths
                .flatMap((p) => p.blocks)
                .find((b) => b.id === pair.originalId);

              if (originalBlock?.child_paths) {
                if (process.env.NODE_ENV !== 'production') {
                  console.log('originalBlock', originalBlock);
                }
                pair.copies.forEach((copyBlock) => {
                  const existingPathIds = new Set(
                    copyBlock.child_paths?.map((cp) => cp.path_id) || []
                  );

                  copyBlock.child_paths = [
                    ...(copyBlock.child_paths || []),
                    ...originalBlock.child_paths
                      .filter(
                        (cp: PathParentBlock) =>
                          !existingPathIds.has(cp.path_id)
                      )
                      .map((cp: PathParentBlock) => ({
                        ...cp,
                        block_id: copyBlock.id,
                        block: copyBlock,
                      })),
                  ];
                });
              }
            });

            // Then process MERGE blocks in each path
            newPaths.forEach((path: Path) => {
              const mergeBlockIndex = path.blocks.findIndex(
                (block: Block) =>
                  block.type === 'MERGE' && block.child_paths?.[0]
              );

              if (mergeBlockIndex !== -1) {
                const mergeBlock = path.blocks[mergeBlockIndex];
                const childPath = pathsData.paths.find(
                  (p: Path) => p.id === mergeBlock.child_paths[0].path.id
                );
                if (childPath) {
                  // Deep clone the blocks from child path
                  const clonedBlocks = childPath.blocks
                    .filter((b: Block) => !['BEGIN', 'END'].includes(b.type))
                    .map((block: Block) => ({
                      ...block,
                      path_id: path.id,
                    }));

                  // Replace MERGE block with the cloned blocks
                  path.blocks = [
                    ...path.blocks.slice(0, mergeBlockIndex),
                    ...clonedBlocks,
                    ...path.blocks.slice(mergeBlockIndex + 1),
                  ];
                }
              }
            });

            // After syncing child paths for blocks with original_id
            newPaths.forEach((path) => {
              path.blocks.forEach((block: Block) => {
                if (block.original_id) {
                  // Find original block
                  const originalBlock = newPaths
                    .flatMap((p) => p.blocks)
                    .find((b) => b.id === block.original_id);

                  if (originalBlock?.child_paths) {
                    // Get existing path IDs
                    const existingPathIds = new Set(
                      block.child_paths?.map((cp) => cp.path_id) || []
                    );

                    // Add missing child paths from original block
                    block.child_paths = [
                      ...(block.child_paths || []),
                      ...originalBlock.child_paths
                        .filter(
                          (cp: PathParentBlock) =>
                            !existingPathIds.has(cp.path_id)
                        )
                        .map((cp: PathParentBlock) => ({
                          ...cp,
                          block_id: block.id,
                          block: block,
                        })),
                    ];
                  }
                }
              });
            });

            // Now remove blocks after any block with child paths
            newPaths.forEach((path) => {
              path.blocks.forEach((block: Block) => {
                if (block.child_paths?.length > 0) {
                  const blockIndex = path.blocks.findIndex(
                    (b: Block) => b.id === block.id
                  );
                  if (blockIndex !== -1) {
                    // Trim path to remove blocks after this one
                    path.blocks = path.blocks.slice(0, blockIndex + 1);
                  }
                }
              });
            });

            // Update paths store with the final processed paths
            usePathsStore.getState().setPaths(newPaths);
          }
        }
      } catch (error) {
        console.error('Error fetching paths and stroke lines:', error);
      }
    };

    fetchPathsAndStrokeLines();
  }, [workflowData]);

  // Update this useEffect to set initial pathsToDisplay
  useEffect(() => {
    if (mainPath) {
      setPathsToDisplay([mainPath]);
    }
  }, [mainPath]);

  // Add utility function for generating unique IDs
  const generateUniqueId = (
    existingIds: Set<number>,
    isPath: boolean = false
  ): number => {
    let id: number;
    do {
      id = Math.floor(Math.random() * -1000000);
    } while (existingIds.has(id));

    existingIds.add(id);
    return id;
  };

  // Remove sourceBlockPairs parameter since we can access it from component scope
  const deepCloneBlock = (block: Block, sourceBlockId: number): Block => {
    const newBlockId = generateUniqueId(generatedBlockIds);
    const newBlock = {
      ...block,
      id: newBlockId,
      original_id: block.original_id ? block.original_id : block.id,
      path_id: block.path_id,
    };

    if (sourceBlockId < 0) {
      if (process.env.NODE_ENV !== 'production') {
        console.log('sourceBlockId', sourceBlockId);
      }
    }
    if (block.id === sourceBlockId) {
      if (process.env.NODE_ENV !== 'production') {
        console.log('pushing the copy ofsourceBlockId', sourceBlockId);
      }
      const pair = sourceBlockPairs.find((p) => p.originalId === sourceBlockId);
      if (pair) {
        pair.copies.push(newBlock);
      } else {
        sourceBlockPairs.push({
          originalId: sourceBlockId,
          copies: [newBlock],
        });
      }
    }

    return newBlock;
  };

  // Modify clonePathWithMergeBlocks function
  const clonePathWithMergeBlocks = (
    path: Path,
    allPaths: Path[],
    sourceBlockId: number
  ): { clonedPath: Path; sourceBlocks: Block[] } => {
    const newPathId = generateUniqueId(generatedPathIds, true);

    // Clone the path normally
    const clonedPath = {
      ...path,
      id: newPathId,
      blocks: path.blocks.reduce<Block[]>((acc, block, index, blocks) => {
        const clonedBlock = deepCloneBlock(block, sourceBlockId);
        clonedBlock.path_id = newPathId;

        return [...acc, clonedBlock];
      }, []),
      parent_blocks: path.parent_blocks.map((pb) => ({
        ...pb,
        path_id: newPathId,
        path: { ...pb.path },
        block: { ...pb.block },
      })),
    };

    return {
      clonedPath,
      sourceBlocks: sourceBlockPairs.flatMap((pair) => pair.copies),
    };
  };

  // Update the useEffect to only fetch workflow data
  useEffect(() => {
    const fetchData = async () => {
      try {
        // Parse the flow parameter
        const lastPfIndex = resolvedParams.flow.lastIndexOf('--pf-');
        const workflowName = resolvedParams.flow.slice(0, lastPfIndex);
        const publicAccessId = resolvedParams.flow.slice(lastPfIndex + 5);

        if (!workflowName || !publicAccessId) {
          console.error('Invalid URL format');
          return;
        }

        // Fix: decode only, do not replace dashes
        const decodedWorkflowName = decodeURIComponent(workflowName);

        // Fetch workflow data using the public API
        const workflowResponse = await fetch(
          `/api/workflow/public?public_access_id=${encodeURIComponent(publicAccessId)}`
        );

        if (!workflowResponse.ok) {
          throw new Error('Failed to fetch workflow data');
        }

        const workflowData = await workflowResponse.json();

        setWorkflowData(workflowData);

        if (process.env.NODE_ENV !== 'production') {
          console.log('workflowData signedIconUrl', workflowData.signedIconUrl);
        }
        // Create breadcrumbs from workflow data
        const items: BreadcrumbItem[] = [];

        if (workflowData.folder?.parent) {
          items.push({
            label: workflowData.folder.parent.name,
            href: `/?folder=${workflowData.folder.parent.id}`,
          });
        }

        if (workflowData.folder) {
          items.push({
            label: workflowData.folder.name,
            href: `/?folder=${workflowData.folder.id}`,
          });
        }

        items.push({ label: workflowData.name });
        setBreadcrumbItems(items);
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    };

    fetchData();
  }, [resolvedParams.flow]);

  // Update processCardData to use workflow data
  const processCardData = workflowData
    ? {
        icon:
          workflowData.icon && workflowData.icon.trim() !== ''
            ? workflowData.icon.startsWith('https://cdn.brandfetch.io/')
              ? workflowData.icon
              : workflowData.signedIconUrl
                ? workflowData.signedIconUrl
                : `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`
            : `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`,
        workflow: {
          name: workflowData.name,
          description: workflowData.description,
        },
        integrations: paths
          .flatMap((path) =>
            path.blocks
              .filter(
                (block) =>
                  block.icon &&
                  block.icon.includes('/apps/') &&
                  block.signedIconUrl
              )
              .map((block) => ({
                name: block
                  .icon!.split('/apps/')[1]
                  .split('.svg')[0]
                  .split('-')
                  .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
                  .join(' '),
                icon: `${block.signedIconUrl}`,
              }))
          )
          .filter(
            (integration, index, self) =>
              index === self.findIndex((i) => i.name === integration.name)
          ),
        // Use process owner data instead of author
        ...(workflowData.process_owner &&
          workflowData.process_owner.trim() && {
            owner: {
              name: workflowData.process_owner,
              // Flow owners don't have avatars in our current system
            },
          }),
        review_date: workflowData.review_date
          ? new Date(workflowData.review_date).toLocaleDateString('en-GB')
          : 'No review date',
        additionalNotes: workflowData.additional_notes,
        lastUpdate:
          paths
            .flatMap((path) => path.blocks)
            .reduce(
              (latest, block) =>
                block.updated_at &&
                (!latest || new Date(block.updated_at) > new Date(latest))
                  ? new Date(block.updated_at).toLocaleDateString('en-GB')
                  : latest,
              ''
            ) || 'No updates',
      }
    : null;

  const openUserSettings = () => {
    setUserSettingsVisible(true);
  };

  const closeUserSettings = () => {
    setFileToUpload(null);
    setUserSettingsVisible(false);
    setPasswordChanged(false);
  };

  const openHelpCenter = () => {
    setHelpCenterVisible(true);
  };

  const closeHelpCenter = () => {
    setHelpCenterVisible(false);
  };

  // Function to update the user in state
  const updateUser = (updatedUser: User) => {
    setUser(updatedUser);
  };

  // Add this effect to handle view mode changes
  useEffect(() => {
    // Reset to main path when view mode changes
    const mainPath = paths.find((path) => path.parent_blocks.length === 0);
    if (mainPath) {
      setPathsToDisplay([mainPath]);
      setSelectedOptions([]); // Clear selected options
      setCurrentStep(-1); // Reset current step to initial state
    }
  }, [viewMode, paths]);

  // Update useEffect to initialize copyPaths when paths change
  useEffect(() => {
    setCopyPaths(paths);
  }, [paths]);

  // Modify handleOptionSelect to use copyPaths
  const handleOptionSelect = (optionId: number, blockId: number) => {
    if (
      selectedOptions.some(
        ([pathId, bId]) => pathId === optionId && bId === blockId
      )
    ) {
      return;
    }

    // Search in copyPaths instead of paths
    const pathToAdd = copyPaths.find((path) => path.id === optionId);
    if (!pathToAdd) {
      return;
    }

    // Find the index where this selection will replace an existing one
    const replaceIndex = pathsToDisplay.findIndex((path) =>
      path.blocks.some((block) =>
        selectedOptions.some(
          ([_, selectedBlockId]) =>
            selectedBlockId === block.id && block.id === blockId
        )
      )
    );

    // Remove any existing selection for this blockId
    const existingSelection = selectedOptions.find(
      ([_, bId]) => bId === blockId
    );
    if (existingSelection) {
      const [existingPathId] = existingSelection;
      setSelectedOptions((prev) => prev.filter(([_, bId]) => bId !== blockId));
      setPathsToDisplay((prev) => prev.filter((p) => p.id !== existingPathId));
    }

    // Always create a copy of the path
    const newPathId = generateUniqueId(generatedPathIds, true);
    const pathCopy = {
      ...pathToAdd,
      id: newPathId,
      blocks: pathToAdd.blocks.map((block) => ({
        ...block,
        original_id: block.original_id ? block.original_id : block.id,
        id: generateUniqueId(generatedBlockIds),
        path_id: newPathId,
      })),
      parent_blocks: [
        {
          path_id: newPathId,
          block_id: blockId,
          created_at: new Date().toISOString(),
          path: {} as Path,
          block:
            PathsToDisplayBlocks.find((b) => b.id === blockId) || ({} as Block),
        },
      ],
    };

    // Add the new path copy to copyPaths
    setCopyPaths((current) => {
      // If pathToAdd was only in copyPaths (not in original paths), remove it
      if (!paths.some((p) => p.id === pathToAdd.id)) {
        return current.filter((p) => p.id !== pathToAdd.id).concat(pathCopy);
      }
      // Otherwise just add the new copy
      return [...current, pathCopy];
    });

    // Replace in child_paths of the parent block
    const parentBlock = PathsToDisplayBlocks.find(
      (block) =>
        block.id === blockId &&
        block.child_paths?.some((cp) => cp.path.id === pathToAdd.id)
    );

    if (parentBlock) {
      parentBlock.child_paths = parentBlock.child_paths?.map((cp) =>
        cp.path.id === pathToAdd.id
          ? {
              ...cp,
              path_id: newPathId,
              block_id: blockId,
              path: pathCopy,
            }
          : cp
      );
    }

    // If we found a replace index, remove everything after it
    if (replaceIndex !== -1) {
      setPathsToDisplay((current) => [
        ...current.slice(0, replaceIndex + 1),
        pathCopy,
      ]);
      setSelectedOptions((prev) => {
        const blockIdsToKeep = new Set(
          pathsToDisplay
            .slice(0, replaceIndex + 1)
            .flatMap((p) => p.blocks)
            .map((b) => b.id)
        );
        return [
          ...prev.filter(([_, bId]) => blockIdsToKeep.has(bId)),
          [pathCopy.id, blockId],
        ];
      });
    } else {
      setPathsToDisplay((current) => [...current, pathCopy]);
      setSelectedOptions((prev) => [...prev, [pathCopy.id, blockId]]);
    }
  };

  // Add this function to handle step navigation
  const handleStepNavigation = (direction: 'prev' | 'next') => {
    if (direction === 'next') {
      if (currentStep === PathsToDisplayBlocks.length - 1) {
        setCurrentStep(PathsToDisplayBlocks.length);
      } else {
        setCurrentStep((prev) =>
          Math.min(prev + 1, PathsToDisplayBlocks.length - 1)
        );
      }
    } else {
      if (currentStep === PathsToDisplayBlocks.length) {
        setCurrentStep(PathsToDisplayBlocks.length - 1);
      } else {
        setCurrentStep((prev) => Math.max(prev - 1, -1));
      }
    }
  };

  // Add this function to calculate progress
  const calculateProgress = () => {
    return ((currentStep + 1) / (PathsToDisplayBlocks.length + 1)) * 100;
  };

  const handleCopyLink = () => {
    if (!workflowData) return;

    const url = window.location.href;
    navigator.clipboard
      .writeText(url)
      .then(() => {
        toast.success('Link Copied!', {
          description: 'Share link has been copied to your clipboard.',
          duration: 3000,
        });
      })
      .catch(() => {
        toast.error('Failed to Copy', {
          description: 'Could not copy the link to your clipboard.',
          duration: 3000,
        });
      });
  };

  // Function to handle step click from sidebar
  const handleStepClick = (blockId: number) => {
    setCurrentStep(blockId);

    // Add to expanded steps if not already expanded
    if (!expandedSteps.includes(blockId)) {
      setExpandedSteps((prev) => [...prev, blockId]);
    }

    // Find the element with the matching block ID
    const blockElement = document.getElementById(`block-${blockId.toString()}`);
    if (blockElement) {
      setTimeout(() => {
        blockElement.scrollIntoView({
          behavior: 'smooth',
          block: 'center',
        });
        // Adjust for header height
        window.scrollBy(0, -120); // Offset for header height
      }, 50);
    }
  };

  const handleStepToggle = (blockId: number, isExpanded: boolean) => {
    if (isExpanded) {
      setCurrentStep(blockId);
      // Add scrolling behavior
      const element = stepRefs.current[blockId];
      if (element) {
        setTimeout(() => {
          element.scrollIntoView({
            behavior: 'smooth',
            block: 'center',
          });
          window.scrollBy(0, -120);
        }, 50);
      }
    }
    setExpandedSteps((prev) =>
      isExpanded ? [...prev, blockId] : prev.filter((i) => i !== blockId)
    );
  };

  const handleRestart = () => {
    setCurrentStep(-1);
    setSelectedOptions([]);
    if (mainPath) {
      setPathsToDisplay([mainPath]);
    }
  };

  const toggleWorkflowAccess = async () => {
    try {
      const response = await fetch(`/api/workflow/${workflowData?.id}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          is_public: !workflow?.is_public,
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to update workflow access');
      }

      const updatedWorkflow = await response.json();
      setWorkflow((prev) =>
        prev ? { ...prev, is_public: !prev.is_public } : null
      );
    } catch (error) {
      console.error('Error toggling workflow access:', error);
    }
  };

  return (
    <div
      className="min-h-screen flex"
      style={{ backgroundColor: colors['bg-primary'] }}
    >
      {workspace && workflowData && (
        <>
          {viewMode === 'vertical' && (
            <Sidebar
              className="w-64"
              workspace={workspace}
              activeStepId={currentStep}
              onStepClick={handleStepClick}
              pathsToDisplay={pathsToDisplay}
            />
          )}
          <div
            className={cn(
              'flex-1',
              viewMode === 'vertical' ? 'ml-64' : 'w-full'
            )}
          >
            <div
              className={cn(
                'fixed right-0 bg-primary z-30',
                viewMode === 'vertical' ? 'left-64' : 'left-0'
              )}
            >
              <div className="absolute right-4 top-20 flex items-center gap-2">
                <ViewModeSwitch mode={viewMode} onModeChange={setViewMode} />
              </div>
            </div>

            {/* User Settings Modal */}
            {/* {userSettingsVisible && (
              <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
                <UserSettingsDynamic
                  user={user}
                  onClose={closeUserSettings}
                  onUserUpdate={updateUser}
                  selectedFile={fileToUpload}
                  isDeleteAvatar={isDeleteAvatar}
                  onDeleteAvatar={() => setIsDeleteAvatar(true)}
                  passwordChanged={passwordChanged}
                  openImageUpload={() => {}}
                  openDeleteAccount={() => {}}
                  updateNewPassword={setNewPassword}
                />
              </div>
            )} */}

            {/* Help Center Modal */}
            {/* {helpCenterVisible && (
              <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
                <HelpCenterModalDynamic onClose={closeHelpCenter} user={user} />
              </div>
            )} */}

            {/* Main content */}
            <ProcessCanvas
              className={cn(
                viewMode === 'vertical'
                  ? 'overflow-y-scroll absolute inset-0 left-64 ml-0'
                  : 'w-full overflow-hidden'
              )}
            >
              {viewMode === 'vertical' ? (
                <div className="p-6">
                  <div className="ml-28 flex flex-col gap-[72px]">
                    {processCardData && (
                      <ProcessCard {...processCardData} viewMode={viewMode} />
                    )}
                    {pathsToDisplay
                      .map((path) => {
                        return (
                          <div key={path.id} className="space-y-16">
                            {path.blocks
                              .filter(
                                (block) =>
                                  block.type !== 'BEGIN' &&
                                  block.type !== 'LAST' &&
                                  block.type !== 'END'
                              )
                              .map((block, index, filteredBlocks) => {
                                return (
                                  <div
                                    key={block.id}
                                    id={`block-${block.id}`}
                                    ref={(el) => {
                                      if (el) stepRefs.current[index] = el;
                                    }}
                                  >
                                    {block.type === 'DELAY' ? (
                                      <VerticalDelay
                                        block={block}
                                        isActive={currentStep === block.id}
                                        isLastStep={
                                          index === filteredBlocks.length - 1
                                        }
                                      />
                                    ) : (
                                      <VerticalStep
                                        variant="default"
                                        block={block}
                                        isActive={currentStep === block.id}
                                        defaultExpanded={expandedSteps.includes(
                                          block.id
                                        )}
                                        onToggle={(isExpanded) =>
                                          handleStepToggle(block.id, isExpanded)
                                        }
                                        selectedOptionIds={selectedOptions}
                                        onOptionSelect={(optionId, blockId) =>
                                          handleOptionSelect(optionId, blockId)
                                        }
                                        copyPaths={copyPaths}
                                        isLastStep={
                                          index === filteredBlocks.length - 1
                                        }
                                      />
                                    )}
                                  </div>
                                );
                              })
                              .filter(Boolean)}
                          </div>
                        );
                      })
                      .filter(Boolean)}
                    {(() => {
                      const lastPath =
                        pathsToDisplay[pathsToDisplay.length - 1];
                      if (!lastPath) return null;
                      const filteredBlocks = lastPath.blocks.filter(
                        (block) =>
                          block.type !== 'BEGIN' &&
                          block.type !== 'LAST' &&
                          block.type !== 'END'
                      );
                      const lastBlock =
                        filteredBlocks[filteredBlocks.length - 1];

                      if (
                        !lastBlock ||
                        !lastBlock.child_paths ||
                        lastBlock.child_paths.length === 0
                      ) {
                        return (
                          <VerticalLastStep
                            onCopyLink={handleCopyLink}
                            onRestart={handleRestart}
                            icon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-circle.svg`}
                          />
                        );
                      }
                      return null;
                    })()}
                  </div>
                </div>
              ) : (
                <div className="h-full flex items-center justify-center">
                  <div
                    className="rounded-lg border w-full max-w-3xl mx-6"
                    style={{
                      backgroundColor: colors['bg-primary'],
                      borderColor: colors['border-secondary'],
                    }}
                  >
                    <div className="p-8 flex flex-col">
                      {currentStep === -1 ? (
                        <>
                          <div
                            style={{
                              height: '472px',
                              backgroundColor: colors['bg-primary'],
                            }}
                            className="flex items-center justify-center"
                          >
                            {processCardData && (
                              <div className="w-full flex justify-center h-full">
                                <ProcessCard
                                  {...processCardData}
                                  viewMode={viewMode}
                                />
                              </div>
                            )}
                          </div>
                          {/* Navigation and Progress Bar */}
                          <div className="flex items-center justify-end mt-8">
                            {/* Progress Bar - hidden */}
                            <div className="items-center hidden">
                              <div className="relative flex items-center w-[400px]">
                                {/* Home Icon */}
                                <img
                                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/home-05.svg`}
                                  alt="Home icon"
                                  className="w-6 h-6"
                                />

                                {/* Line from home to first step */}
                                <div
                                  className="w-[40px] h-[1px] mx-2"
                                  style={{
                                    backgroundColor:
                                      currentStep >= 0
                                        ? colors['bg-brand-solid']
                                        : colors['border-secondary'],
                                  }}
                                />

                                {/* Step Dots - Initial View */}
                                {PathsToDisplayBlocks.map((_, index) => (
                                  <div
                                    key={index}
                                    className="flex items-center"
                                  >
                                    {/* Step Indicator */}
                                    <div className="relative z-10 flex items-center justify-center w-6 h-6">
                                      {index < currentStep ? (
                                        // Completed step - show tick icon
                                        <img
                                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/step-icon-done.svg`}
                                          alt="Completed step"
                                          className="w-6 h-6"
                                        />
                                      ) : (
                                        // Current or future step - show simple dot
                                        <div
                                          className={cn('w-2 h-2 rounded-full')}
                                          style={{
                                            backgroundColor:
                                              index === currentStep
                                                ? colors['bg-brand-solid']
                                                : colors['border-secondary'],
                                          }}
                                        />
                                      )}
                                    </div>
                                    {/* Connecting Line */}
                                    {index <
                                      PathsToDisplayBlocks.length - 1 && (
                                      <div
                                        className="w-[40px] h-[1px] mx-2"
                                        style={{
                                          backgroundColor:
                                            index < currentStep
                                              ? colors['bg-brand-solid']
                                              : colors['border-secondary'],
                                        }}
                                      />
                                    )}
                                  </div>
                                ))}
                              </div>
                            </div>

                            {/* Navigation Buttons */}
                            <div className="flex items-center gap-2">
                              {currentStep > -1 && (
                                <ButtonNormal
                                  variant="secondary"
                                  size="small"
                                  onClick={() => handleStepNavigation('prev')}
                                  disabled={currentStep === -1}
                                  leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-left.svg`}
                                >
                                  Previous step
                                </ButtonNormal>
                              )}
                              {currentStep < PathsToDisplayBlocks.length && (
                                <ButtonNormal
                                  variant="primary"
                                  size="small"
                                  onClick={() => handleStepNavigation('next')}
                                  disabled={
                                    currentStep ===
                                      PathsToDisplayBlocks.length ||
                                    (currentStep >= 0 &&
                                      currentStep <
                                        PathsToDisplayBlocks.length &&
                                      PathsToDisplayBlocks[currentStep]
                                        ?.child_paths?.length > 0 &&
                                      !selectedOptions.some(
                                        ([_, blockId]) =>
                                          blockId ===
                                          PathsToDisplayBlocks[currentStep].id
                                      ))
                                  }
                                  trailingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-right.svg`}
                                >
                                  {currentStep === -1
                                    ? 'Get Started'
                                    : currentStep ===
                                          PathsToDisplayBlocks.length - 1 &&
                                        (!PathsToDisplayBlocks[currentStep]
                                          ?.child_paths?.length ||
                                          selectedOptions.some(
                                            ([_, blockId]) =>
                                              blockId ===
                                              PathsToDisplayBlocks[currentStep]
                                                .id
                                          ))
                                      ? 'Complete'
                                      : 'Next step'}
                                </ButtonNormal>
                              )}
                            </div>
                          </div>
                        </>
                      ) : (
                        <>
                          <div className="h-[472px] flex">
                            <div
                              className={cn(
                                'w-full flex flex-col',
                                !PathsToDisplayBlocks[currentStep]?.image &&
                                  (!PathsToDisplayBlocks[currentStep]
                                    ?.child_paths ||
                                    PathsToDisplayBlocks[currentStep]
                                      ?.child_paths.length === 0) &&
                                  'justify-center'
                              )}
                            >
                              {currentStep === PathsToDisplayBlocks.length ? (
                                <HorizontalLastStep
                                  onCopyLink={handleCopyLink}
                                  onRestart={handleRestart}
                                />
                              ) : PathsToDisplayBlocks[currentStep].type ===
                                'DELAY' ? (
                                <HorizontalDelay
                                  block={PathsToDisplayBlocks[currentStep]}
                                />
                              ) : (
                                <HorizontalStep
                                  block={PathsToDisplayBlocks[currentStep]}
                                  selectedOptionIds={selectedOptions}
                                  onOptionSelect={(optionId, blockId) =>
                                    handleOptionSelect(optionId, blockId)
                                  }
                                />
                              )}
                            </div>
                          </div>

                          {/* Navigation and Progress Bar */}
                          <div className="flex items-center justify-end mt-8">
                            {/* Progress Bar */}
                            <div className="items-center hidden">
                              <div className="relative flex items-center w-[400px]">
                                {/* Home Icon */}
                                <img
                                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/home-05.svg`}
                                  alt="Home icon"
                                  className="w-6 h-6"
                                />

                                {/* Line from home to first step */}
                                <div
                                  className="w-[40px] h-[1px] mx-2"
                                  style={{
                                    backgroundColor:
                                      currentStep >= 0
                                        ? colors['bg-brand-solid']
                                        : colors['border-secondary'],
                                  }}
                                />

                                {/* Step Dots - Step View */}
                                {PathsToDisplayBlocks.map((_, index) => (
                                  <div
                                    key={index}
                                    className="flex items-center"
                                  >
                                    {/* Step Indicator */}
                                    <div className="relative z-10 flex items-center justify-center w-6 h-6">
                                      {index < currentStep ? (
                                        // Completed step - show tick icon
                                        <img
                                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/step-icon-done.svg`}
                                          alt="Completed step"
                                          className="w-6 h-6"
                                        />
                                      ) : (
                                        // Current or future step - show simple dot
                                        <div
                                          className={cn('w-2 h-2 rounded-full')}
                                          style={{
                                            backgroundColor:
                                              index === currentStep
                                                ? colors['bg-brand-solid']
                                                : colors['border-secondary'],
                                          }}
                                        />
                                      )}
                                    </div>
                                    {/* Connecting Line */}
                                    {index <
                                      PathsToDisplayBlocks.length - 1 && (
                                      <div
                                        className="w-[40px] h-[1px] mx-2"
                                        style={{
                                          backgroundColor:
                                            index < currentStep
                                              ? colors['bg-brand-solid']
                                              : colors['border-secondary'],
                                        }}
                                      />
                                    )}
                                  </div>
                                ))}
                              </div>
                            </div>

                            {/* Navigation Buttons */}
                            <div className="flex items-center gap-2">
                              {currentStep > -1 && (
                                <ButtonNormal
                                  variant="secondary"
                                  size="small"
                                  onClick={() => handleStepNavigation('prev')}
                                  disabled={currentStep === -1}
                                  leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-left.svg`}
                                >
                                  Previous step
                                </ButtonNormal>
                              )}
                              {currentStep < PathsToDisplayBlocks.length && (
                                <ButtonNormal
                                  variant="primary"
                                  size="small"
                                  onClick={() => handleStepNavigation('next')}
                                  disabled={
                                    currentStep ===
                                      PathsToDisplayBlocks.length ||
                                    (currentStep >= 0 &&
                                      currentStep <
                                        PathsToDisplayBlocks.length &&
                                      PathsToDisplayBlocks[currentStep]
                                        ?.child_paths?.length > 0 &&
                                      !selectedOptions.some(
                                        ([_, blockId]) =>
                                          blockId ===
                                          PathsToDisplayBlocks[currentStep].id
                                      ))
                                  }
                                  trailingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-right.svg`}
                                >
                                  {currentStep === -1
                                    ? 'Get Started'
                                    : currentStep ===
                                          PathsToDisplayBlocks.length - 1 &&
                                        (!PathsToDisplayBlocks[currentStep]
                                          ?.child_paths?.length ||
                                          selectedOptions.some(
                                            ([_, blockId]) =>
                                              blockId ===
                                              PathsToDisplayBlocks[currentStep]
                                                .id
                                          ))
                                      ? 'Complete'
                                      : 'Next step'}
                                </ButtonNormal>
                              )}
                            </div>
                          </div>
                        </>
                      )}
                    </div>
                  </div>
                </div>
              )}
            </ProcessCanvas>
          </div>
        </>
      )}
    </div>
  );
}
</file>

<file path="app/swagger-ui/page.jsx">
// app/swagger-ui/page.tsx

'use client';

import { useEffect } from 'react';

export default function SwaggerPage() {
  useEffect(() => {
    const ui = SwaggerUIBundle({
      url: '/api/docs', // This fetches your Swagger spec
      dom_id: '#swagger-ui',
      deepLinking: true,
      presets: [SwaggerUIBundle.presets.apis, SwaggerUIStandalonePreset],
    });

    return () => {
      ui.destroy();
    };
  }, []);

  return (
    <div>
      <div id="swagger-ui"></div>
    </div>
  );
}
</file>

<file path="app/theme/themes/dark.ts">
import { Theme } from '../types';

// Import the base theme colors
import baseTheme from '@/theme';

// Create a type for the theme.js color paths
type ThemeColorPath = keyof typeof baseTheme.colors;

// Utility function to get color from theme.js
const getThemeColor = (path: ThemeColorPath): string => {
  return baseTheme.colors[path];
};

export const darkTheme: Theme = {
  name: 'dark',
  label: 'Dark Mode',
  tokens: {
    colors: {
      // Text colors
      'text-primary': getThemeColor('Gray (dark mode)/50'),
      'text-primary_on-brand': getThemeColor('Gray (dark mode)/50'),
      'text-secondary': getThemeColor('Gray (dark mode)/300'),
      'text-secondary_hover': getThemeColor('Gray (dark mode)/200'),
      'text-secondary_on-brand': getThemeColor('Gray (dark mode)/300'),
      'text-tertiary': getThemeColor('Gray (dark mode)/400'),
      'text-tertiary_hover': getThemeColor('Gray (dark mode)/300'),
      'text-tertiary_on-brand': getThemeColor('Gray (dark mode)/400'),
      'text-quaternary': getThemeColor('Gray (dark mode)/400'),
      'text-quaternary_on-brand': getThemeColor('Gray (dark mode)/400'),
      'text-white': getThemeColor('Base/White'),
      'text-disabled': getThemeColor('Gray (dark mode)/500'),
      'text-placeholder': getThemeColor('Gray (dark mode)/500'),
      'text-placeholder_subtle': getThemeColor('Gray (dark mode)/700'),
      'text-brand-primary': getThemeColor('Gray (dark mode)/50'),
      'text-brand-secondary': getThemeColor('Gray (dark mode)/300'),
      'text-brand-tertiary': getThemeColor('Gray (dark mode)/400'),
      'text-brand-tertiary_alt': getThemeColor('Gray (dark mode)/50'),
      'text-error-primary': getThemeColor('Error/400'),
      'text-warning-primary': getThemeColor('Warning/400'),
      'text-success-primary': getThemeColor('Success/400'),

      // Border colors
      'border-primary': getThemeColor('Gray (dark mode)/700'),
      'border-secondary': getThemeColor('Gray (dark mode)/800'),
      'border-tertiary': getThemeColor('Gray (dark mode)/800'),
      'border-disabled': getThemeColor('Gray (dark mode)/700'),
      'border-disabled_subtle': getThemeColor('Gray (dark mode)/800'),
      'border-brand': getThemeColor('Brand/400'),
      'border-brand_alt': getThemeColor('Gray (dark mode)/700'),
      'border-error': getThemeColor('Error/400'),
      'border-error_subtle': getThemeColor('Error/400'),

      // Base colors
      'base-white': getThemeColor('Base/Black'),
      'base-black': getThemeColor('Base/White'),
      
      // Foreground colors
      'fg-primary': getThemeColor('Base/White'),
      'fg-secondary': getThemeColor('Gray (dark mode)/300'),
      'fg-secondary_hover': getThemeColor('Gray (dark mode)/200'),
      'fg-tertiary': getThemeColor('Gray (dark mode)/400'),
      'fg-tertiary_hover': getThemeColor('Gray (dark mode)/300'),
      'fg-quaternary': getThemeColor('Gray (dark mode)/400'),
      'fg-quaternary_hover': getThemeColor('Gray (dark mode)/300'),
      'fg-quinary': getThemeColor('Gray (dark mode)/500'),
      'fg-quinary_hover': getThemeColor('Gray (dark mode)/400'),
      'fg-senary': getThemeColor('Gray (dark mode)/600'),
      'fg-white': getThemeColor('Base/White'),
      'fg-disabled': getThemeColor('Gray (dark mode)/500'),
      'fg-disabled_subtle': getThemeColor('Gray (dark mode)/600'),
      'fg-brand-primary': getThemeColor('Brand/500'),
      'fg-brand-primary_alt': getThemeColor('Gray (dark mode)/300'),
      'fg-brand-secondary': getThemeColor('Brand/500'),
      'fg-error-primary': getThemeColor('Error/500'),
      'fg-error-secondary': getThemeColor('Error/400'),
      'fg-warning-primary': getThemeColor('Warning/500'),
      'fg-warning-secondary': getThemeColor('Warning/400'),
      'fg-success-primary': getThemeColor('Success/500'),
      'fg-success-secondary': getThemeColor('Success/400'),

      // Background colors
      'bg-primary': getThemeColor('Gray (dark mode)/950'),
      'bg-primary_alt': getThemeColor('Gray (dark mode)/900'),
      'bg-primary_hover': getThemeColor('Gray (dark mode)/800'),
      'bg-primary-solid': getThemeColor('Gray (dark mode)/900'),
      'bg-secondary': getThemeColor('Gray (dark mode)/900'),
      'bg-secondary_alt': getThemeColor('Gray (dark mode)/800'),
      'bg-secondary_hover': getThemeColor('Gray (dark mode)/800'),
      'bg-secondary_subtle': getThemeColor('Gray (dark mode)/900'),
      'bg-secondary-solid': getThemeColor('Gray (dark mode)/600'),
      'bg-tertiary': getThemeColor('Gray (dark mode)/800'),
      'bg-quaternary': getThemeColor('Gray (dark mode)/700'),
      'bg-active': getThemeColor('Gray (dark mode)/800'),
      'bg-disabled': getThemeColor('Gray (dark mode)/800'),
      'bg-disabled_subtle': getThemeColor('Gray (dark mode)/900'),
      'bg-overlay': getThemeColor('Gray (dark mode)/800'),
      'bg-brand-primary': getThemeColor('Brand/500'),
      'bg-brand-primary_alt': getThemeColor('Gray (dark mode)/900'),
      'bg-brand-secondary': getThemeColor('Brand/600'),
      'bg-brand-solid': getThemeColor('Brand/600'),
      'bg-brand-solid_hover': getThemeColor('Brand/500'),
      'bg-brand-section': getThemeColor('Gray (dark mode)/900'),
      'bg-brand-section_subtle': getThemeColor('Gray (dark mode)/800'),
      'bg-error-primary': getThemeColor('Error/500'),
      'bg-error-secondary': getThemeColor('Error/600'),
      'bg-error-solid': getThemeColor('Error/600'),
      'bg-warning-primary': getThemeColor('Warning/500'),
      'bg-warning-secondary': getThemeColor('Warning/600'),
      'bg-warning-solid': getThemeColor('Warning/600'),
      'bg-success-primary': getThemeColor('Success/500'),
      'bg-success-secondary': getThemeColor('Success/600'),
      'bg-success-solid': getThemeColor('Success/600'),
      
      // Button colors
      // Primary button
      'button-primary-fg': getThemeColor('Base/White'),
      'button-primary-fg-hover': getThemeColor('Base/White'),
      'button-primary-bg': getThemeColor('Brand/500'),
      'button-primary-bg-hover': getThemeColor('Brand/700'),
      'button-primary-border': getThemeColor('Brand/500'),
      'button-primary-border-hover': getThemeColor('Brand/700'),

      // Secondary button
      'button-secondary-fg': getThemeColor('Gray (dark mode)/300'),
      'button-secondary-fg-hover': getThemeColor('Gray (dark mode)/100'),
      'button-secondary-bg': getThemeColor('Gray (dark mode)/900'),
      'button-secondary-bg-hover': getThemeColor('Gray (dark mode)/800'),
      'button-secondary-border': getThemeColor('Gray (dark mode)/700'),
      'button-secondary-border-hover': getThemeColor('Gray (dark mode)/700'),
      
      // Secondary color button
      'button-secondary-color-fg': getThemeColor('Gray (dark mode)/300'),
      'button-secondary-color-fg-hover': getThemeColor('Gray (dark mode)/100'),
      'button-secondary-color-bg': getThemeColor('Gray (dark mode)/900'),
      'button-secondary-color-bg-hover': getThemeColor('Gray (dark mode)/800'),
      'button-secondary-color-border': getThemeColor('Gray (dark mode)/700'),
      'button-secondary-color-border-hover': getThemeColor('Gray (dark mode)/700'),
      
      // Tertiary button
      'button-tertiary-bg': 'transparent',
      'button-tertiary-fg': getThemeColor('Gray (dark mode)/400'),
      'button-tertiary-fg-hover': getThemeColor('Gray (dark mode)/200'),
      'button-tertiary-border': 'transparent',
      'button-tertiary-bg-hover': getThemeColor('Gray (dark mode)/800'),
      'button-tertiary-border-hover': 'transparent',
      
      // Tertiary color button
      'button-tertiary-color-bg': 'transparent',
      'button-tertiary-color-fg': getThemeColor('Gray (dark mode)/300'),
      'button-tertiary-color-fg-hover': getThemeColor('Gray (dark mode)/100'),
      'button-tertiary-color-border': 'transparent',
      'button-tertiary-color-bg-hover': getThemeColor('Gray (dark mode)/800'),
      'button-tertiary-color-border-hover': 'transparent',
      
      // Destructive button tokens
      // Primary destructive
      'button-destructive-primary-bg': getThemeColor('Error/600'),
      'button-destructive-primary-fg': getThemeColor('Base/White'),
      'button-destructive-primary-border': getThemeColor('Error/400'),
      'button-destructive-primary-bg-hover': getThemeColor('Error/700'),
      'button-destructive-primary-fg-hover': getThemeColor('Base/White'),
      'button-destructive-primary-border-hover': getThemeColor('Error/400'),

      // Secondary destructive
      'button-destructive-secondary-bg': getThemeColor('Error/950'),
      'button-destructive-secondary-fg': getThemeColor('Error/200'),
      'button-destructive-secondary-border': getThemeColor('Error/800'),
      'button-destructive-secondary-bg-hover': getThemeColor('Error/900'),
      'button-destructive-secondary-fg-hover': getThemeColor('Error/100'),
      'button-destructive-secondary-border-hover': getThemeColor('Error/700'),

      // Tertiary destructive
      'button-destructive-tertiary-bg': 'transparent',
      'button-destructive-tertiary-fg': getThemeColor('Error/300'),
      'button-destructive-tertiary-border': 'transparent',
      'button-destructive-tertiary-bg-hover': getThemeColor('Error/900'),
      'button-destructive-tertiary-fg-hover': getThemeColor('Error/200'),
      'button-destructive-tertiary-border-hover': 'transparent',
      
      // Loading spinner
      'button-loading-spinner': getThemeColor('Base/White'),

      // Icon colors
      'icon-default': getThemeColor('Gray (dark mode)/400'),
      'icon-default-hover': getThemeColor('Gray (dark mode)/200'),
      'icon-primary': getThemeColor('Gray (dark mode)/300'),
      'icon-primary-hover': getThemeColor('Gray (dark mode)/100'),
      'icon-secondary': getThemeColor('Gray (dark mode)/400'),
      'icon-secondary-hover': getThemeColor('Gray (dark mode)/200'),
      'icon-tertiary': getThemeColor('Gray (dark mode)/400'),
      'icon-tertiary-hover': getThemeColor('Gray (dark mode)/200'),
      'icon-success': getThemeColor('Success/400'),
      'icon-success-hover': getThemeColor('Success/300'),
      'icon-warning': getThemeColor('Warning/400'), 
      'icon-warning-hover': getThemeColor('Warning/300'),
      'icon-error': getThemeColor('Error/400'),
      'icon-error-hover': getThemeColor('Error/300'),
      'icon-info': getThemeColor('Brand/400'),
      'icon-info-hover': getThemeColor('Brand/300'),

      // Input field tokens
      // Default input
      'input-bg': getThemeColor('Gray (dark mode)/950'),
      'input-fg': getThemeColor('Gray (dark mode)/100'),
      'input-border': getThemeColor('Gray (dark mode)/700'),
      'input-bg-hover': getThemeColor('Gray (dark mode)/800'),
      'input-fg-hover': getThemeColor('Gray (dark mode)/50'),
      'input-border-hover': getThemeColor('Gray (dark mode)/600'),
      'input-bg-focus': getThemeColor('Gray (dark mode)/900'),
      'input-fg-focus': getThemeColor('Gray (dark mode)/50'),
      'input-border-focus': getThemeColor('Brand/500'),
      'input-placeholder': getThemeColor('Gray (dark mode)/500'),
      'input-label': getThemeColor('Gray (dark mode)/300'),
      'input-hint': getThemeColor('Gray (dark mode)/400'),
      'input-icon': getThemeColor('Gray (dark mode)/500'),
      'input-prefix': getThemeColor('Gray (dark mode)/500'),

      // Destructive input
      'input-destructive-bg': getThemeColor('Error/950'),
      'input-destructive-fg': getThemeColor('Gray (dark mode)/50'),
      'input-destructive-border': getThemeColor('Error/800'),
      'input-destructive-bg-hover': getThemeColor('Error/900'),
      'input-destructive-fg-hover': getThemeColor('Gray (dark mode)/50'),
      'input-destructive-border-hover': getThemeColor('Error/700'),
      'input-destructive-bg-focus': getThemeColor('Error/950'),
      'input-destructive-fg-focus': getThemeColor('Gray (dark mode)/50'),
      'input-destructive-border-focus': getThemeColor('Error/500'),
      'input-destructive-label': getThemeColor('Error/300'),
      'input-destructive-hint': getThemeColor('Error/400'),
      'input-destructive-icon': getThemeColor('Error/400'),

      // Disabled input
      'input-disabled-bg': getThemeColor('Gray (dark mode)/800'),
      'input-disabled-fg': getThemeColor('Gray (dark mode)/600'),
      'input-disabled-border': getThemeColor('Gray (dark mode)/800'),
      'input-disabled-placeholder': getThemeColor('Gray (dark mode)/600'),
      'input-disabled-label': getThemeColor('Gray (dark mode)/600'),

      // Breadcrumb tokens
      'breadcrumb-active-bg': getThemeColor('Brand/900'),
      'breadcrumb-active-fg': getThemeColor('Brand/400'),
      'breadcrumb-inactive-fg': getThemeColor('Gray (dark mode)/400'),
      'breadcrumb-separator': getThemeColor('Gray (dark mode)/600'),
      'breadcrumb-hover-opacity': '0.75',

      // Utility colors
      // Gray
      'utility-gray-50': getThemeColor('Gray (dark mode)/900'),
      'utility-gray-100': getThemeColor('Gray (dark mode)/800'),
      'utility-gray-200': getThemeColor('Gray (dark mode)/700'),
      'utility-gray-300': getThemeColor('Gray (dark mode)/700'),
      'utility-gray-400': getThemeColor('Gray (dark mode)/600'),
      'utility-gray-500': getThemeColor('Gray (dark mode)/500'),
      'utility-gray-600': getThemeColor('Gray (dark mode)/400'),
      'utility-gray-700': getThemeColor('Gray (dark mode)/300'),
      'utility-gray-800': getThemeColor('Gray (dark mode)/200'),
      'utility-gray-900': getThemeColor('Gray (dark mode)/100'),

      // Brand
      'utility-brand-50': getThemeColor('Brand/950'),
      'utility-brand-100': getThemeColor('Brand/900'),
      'utility-brand-200': getThemeColor('Brand/800'),
      'utility-brand-300': getThemeColor('Brand/700'),
      'utility-brand-400': getThemeColor('Brand/600'),
      'utility-brand-500': getThemeColor('Brand/500'),
      'utility-brand-600': getThemeColor('Brand/400'),
      'utility-brand-700': getThemeColor('Brand/300'),
      'utility-brand-800': getThemeColor('Brand/200'),
      'utility-brand-900': getThemeColor('Brand/100'),

      // Error
      'utility-error-50': getThemeColor('Error/950'),
      'utility-error-100': getThemeColor('Error/900'),
      'utility-error-200': getThemeColor('Error/800'),
      'utility-error-300': getThemeColor('Error/700'),
      'utility-error-400': getThemeColor('Error/600'),
      'utility-error-500': getThemeColor('Error/500'),
      'utility-error-600': getThemeColor('Error/400'),
      'utility-error-700': getThemeColor('Error/300'),

      // Warning
      'utility-warning-50': getThemeColor('Warning/950'),
      'utility-warning-100': getThemeColor('Warning/900'),
      'utility-warning-200': getThemeColor('Warning/800'),
      'utility-warning-300': getThemeColor('Warning/700'),
      'utility-warning-400': getThemeColor('Warning/600'),
      'utility-warning-500': getThemeColor('Warning/500'),
      'utility-warning-600': getThemeColor('Warning/400'),
      'utility-warning-700': getThemeColor('Warning/300'),

      // Success
      'utility-success-50': getThemeColor('Success/950'),
      'utility-success-100': getThemeColor('Success/900'),
      'utility-success-200': getThemeColor('Success/800'),
      'utility-success-300': getThemeColor('Success/700'),
      'utility-success-400': getThemeColor('Success/600'),
      'utility-success-500': getThemeColor('Success/500'),
      'utility-success-600': getThemeColor('Success/400'),
      'utility-success-700': getThemeColor('Success/300'),

      // Purple
      'utility-purple-50': getThemeColor('Purple/950'),
      'utility-purple-100': getThemeColor('Purple/900'),
      'utility-purple-200': getThemeColor('Purple/800'),
      'utility-purple-300': getThemeColor('Purple/700'),
      'utility-purple-400': getThemeColor('Purple/600'),
      'utility-purple-500': getThemeColor('Purple/500'),
      'utility-purple-600': getThemeColor('Purple/400'),
      'utility-purple-700': getThemeColor('Purple/300'),

      // Alpha colors
      'alpha-white-10': 'rgba(12, 17, 29, 0.10)',
      'alpha-white-20': 'rgba(12, 17, 29, 0.20)',
      'alpha-white-30': 'rgba(12, 17, 29, 0.30)',
      'alpha-white-40': 'rgba(12, 17, 29, 0.40)',
      'alpha-white-50': 'rgba(12, 17, 29, 0.50)',
      'alpha-white-60': 'rgba(12, 17, 29, 0.60)',
      'alpha-white-70': 'rgba(12, 17, 29, 0.70)',
      'alpha-white-80': 'rgba(12, 17, 29, 0.80)',
      'alpha-white-90': 'rgba(12, 17, 29, 0.90)',
      'alpha-white-100': getThemeColor('Gray (dark mode)/950'),
      'alpha-black-10': 'rgba(255, 255, 255, 0.10)',
      'alpha-black-20': 'rgba(255, 255, 255, 0.20)',
      'alpha-black-30': 'rgba(255, 255, 255, 0.30)',
      'alpha-black-40': 'rgba(255, 255, 255, 0.40)',
      'alpha-black-50': 'rgba(255, 255, 255, 0.50)',
      'alpha-black-60': 'rgba(255, 255, 255, 0.60)',
      'alpha-black-70': 'rgba(255, 255, 255, 0.70)',
      'alpha-black-80': 'rgba(255, 255, 255, 0.80)',
      'alpha-black-90': 'rgba(255, 255, 255, 0.90)',
      'alpha-black-100': '#ffffff',

      // Shadow colors
      'shadow-xs': 'rgba(12, 17, 29, 0.05)',
      'shadow-sm_01': 'rgba(12, 17, 29, 0.10)',
      'shadow-sm_02': 'rgba(12, 17, 29, 0.06)',
      'shadow-md_01': 'rgba(12, 17, 29, 0.10)',
      'shadow-md_02': 'rgba(12, 17, 29, 0.06)',
      'shadow-lg_01': 'rgba(12, 17, 29, 0.08)',
      'shadow-lg_02': 'rgba(12, 17, 29, 0.03)',
      'shadow-xl_01': 'rgba(12, 17, 29, 0.08)',
      'shadow-xl_02': 'rgba(12, 17, 29, 0.03)',
      'shadow-2xl': 'rgba(12, 17, 29, 0.18)',
      'shadow-3xl': 'rgba(12, 17, 29, 0.14)',
      'shadow-skeumorphic-inner': 'rgba(12, 17, 29, 0.05)',
      'shadow-skeumorphic-inner-border': 'rgba(12, 17, 29, 0.18)',
      'shadow-main-centre-md': 'rgba(12, 17, 29, 0.14)',
      'shadow-main-centre-lg': 'rgba(12, 17, 29, 0.18)',
      'shadow-overlay-lg': 'rgba(12, 17, 29, 0.12)',
      'shadow-grid-md': 'rgba(12, 17, 29, 0.08)',

      // Miscellaneous
      'app-store-badge-border': '#a6a6a6',
      'social-icon-fg-x': getThemeColor('Base/White'),
      'social-icon-fg-instagram': getThemeColor('Base/White'),
      'social-icon-fg-apple': getThemeColor('Base/White'),
      'social-icon-fg-github': getThemeColor('Base/White'),
      'social-icon-fg-angellist': getThemeColor('Base/White'),
      'social-icon-fg-tumblr': getThemeColor('Base/White'),
      'screen-mockup-border': getThemeColor('Gray (dark mode)/700'),
      'slider-handle-bg': getThemeColor('Brand/600'),
      'slider-handle-border': getThemeColor('Gray (dark mode)/900'),
      'thumbnail-badge-brand-fg': getThemeColor('Gray (dark mode)/300'),
      'thumbnail-badge-success-fg': getThemeColor('Gray (dark mode)/300'),
      'toggle-button-fg_disabled': getThemeColor('Gray (dark mode)/600'),
      'tooltip-supporting-text': getThemeColor('Gray (dark mode)/300'),
      'wysiwyg-editor-icon-fg': getThemeColor('Gray (dark mode)/400'),
      'wysiwyg-editor-icon-fg_active': getThemeColor('Base/White'),
    },
    typography: {
      'body-default': {
        fontSize: '16px',
        lineHeight: '24px',
        fontWeight: '400',
      },
      'heading-1': {
        fontSize: '30px',
        lineHeight: '38px',
        fontWeight: '600',
      },
    },
    spacing: {
      'spacing-xs': '4px',
      'spacing-sm': '8px',
      'spacing-md': '16px',
      'spacing-lg': '24px',
      'spacing-xl': '32px',
    },
    borderRadius: {
      'radius-sm': '4px',
      'radius-md': '8px',
      'radius-lg': '12px',
      'radius-full': '9999px',
    },
    boxShadow: {
      'shadow-sm': '0px 1px 2px rgba(0, 0, 0, 0.3)',
      'shadow-md': '0px 4px 6px -2px rgba(0, 0, 0, 0.3)',
      'shadow-lg': '0px 8px 8px -4px rgba(0, 0, 0, 0.3)',
    },
  },
  assets: {
    icons: {
      'theme-toggle': '/assets/shared_components/moon.svg',
    },
    images: {},
  },
};
</file>

<file path="app/theme/themes/light.ts">
import { Theme } from '../types';

// Import the base theme colors
import baseTheme from '@/theme';

// Create a type for the theme.js color paths
type ThemeColorPath = keyof typeof baseTheme.colors;

// Utility function to get color from theme.js
const getThemeColor = (path: ThemeColorPath): string => {
  return baseTheme.colors[path];
};

export const lightTheme: Theme = {
  name: 'light',
  label: 'Light Mode',
  tokens: {
    colors: {
      // Text colors
      'text-primary': getThemeColor('Gray (light mode)/900'),
      'text-primary_on-brand': getThemeColor('Base/White'),
      'text-secondary': getThemeColor('Gray (light mode)/700'),
      'text-secondary_hover': getThemeColor('Gray (light mode)/800'),
      'text-secondary_on-brand': getThemeColor('Brand/200'),
      'text-tertiary': getThemeColor('Gray (light mode)/600'),
      'text-tertiary_hover': getThemeColor('Gray (light mode)/700'),
      'text-tertiary_on-brand': getThemeColor('Brand/200'),
      'text-quaternary': getThemeColor('Gray (light mode)/500'),
      'text-quaternary_on-brand': getThemeColor('Brand/300'),
      'text-white': getThemeColor('Base/White'),
      'text-disabled': getThemeColor('Gray (light mode)/500'),
      'text-placeholder': getThemeColor('Gray (light mode)/500'),
      'text-placeholder_subtle': getThemeColor('Gray (light mode)/300'),
      'text-brand-primary': getThemeColor('Brand/900'),
      'text-brand-secondary': getThemeColor('Brand/700'),
      'text-brand-tertiary': getThemeColor('Brand/600'),
      'text-brand-tertiary_alt': getThemeColor('Brand/600'),
      'text-error-primary': getThemeColor('Error/600'),
      'text-warning-primary': getThemeColor('Warning/600'),
      'text-success-primary': getThemeColor('Success/600'),

      // Border colors
      'border-primary': getThemeColor('Gray (light mode)/300'),
      'border-secondary': getThemeColor('Gray (light mode)/200'),
      'border-tertiary': getThemeColor('Gray (light mode)/100'),
      'border-disabled': getThemeColor('Gray (light mode)/300'),
      'border-disabled_subtle': getThemeColor('Gray (light mode)/200'),
      'border-brand': getThemeColor('Brand/500'),
      'border-brand_alt': getThemeColor('Brand/600'),
      'border-error': getThemeColor('Error/500'),
      'border-error_subtle': getThemeColor('Error/300'),

      // Base colors
      'base-white': getThemeColor('Base/White'),
      'base-black': getThemeColor('Base/Black'),
      
      // Foreground colors
      'fg-primary': getThemeColor('Gray (light mode)/900'),
      'fg-secondary': getThemeColor('Gray (light mode)/700'),
      'fg-secondary_hover': getThemeColor('Gray (light mode)/800'),
      'fg-tertiary': getThemeColor('Gray (light mode)/600'),
      'fg-tertiary_hover': getThemeColor('Gray (light mode)/700'),
      'fg-quaternary': getThemeColor('Gray (light mode)/500'),
      'fg-quaternary_hover': getThemeColor('Gray (light mode)/600'),
      'fg-quinary': getThemeColor('Gray (light mode)/400'),
      'fg-quinary_hover': getThemeColor('Gray (light mode)/500'),
      'fg-senary': getThemeColor('Gray (light mode)/300'),
      'fg-white': getThemeColor('Base/White'),
      'fg-disabled': getThemeColor('Gray (light mode)/400'),
      'fg-disabled_subtle': getThemeColor('Gray (light mode)/300'),
      'fg-brand-primary': getThemeColor('Brand/600'),
      'fg-brand-primary_alt': getThemeColor('Brand/600'),
      'fg-brand-secondary': getThemeColor('Brand/500'),
      'fg-error-primary': getThemeColor('Error/600'),
      'fg-error-secondary': getThemeColor('Error/500'),
      'fg-warning-primary': getThemeColor('Warning/600'),
      'fg-warning-secondary': getThemeColor('Warning/500'),
      'fg-success-primary': getThemeColor('Success/600'),
      'fg-success-secondary': getThemeColor('Success/500'),

      // Background colors
      'bg-primary': getThemeColor('Base/White'),
      'bg-primary_alt': getThemeColor('Base/White'),
      'bg-primary_hover': getThemeColor('Gray (light mode)/100'),
      'bg-primary-solid': getThemeColor('Gray (light mode)/950'),
      'bg-secondary': getThemeColor('Gray (light mode)/50'),
      'bg-secondary_alt': getThemeColor('Gray (light mode)/50'),
      'bg-secondary_hover': getThemeColor('Gray (light mode)/200'),
      'bg-secondary_subtle': getThemeColor('Gray (light mode)/25'),
      'bg-secondary-solid': getThemeColor('Gray (light mode)/600'),
      'bg-tertiary': getThemeColor('Gray (light mode)/100'),
      'bg-quaternary': getThemeColor('Gray (light mode)/200'),
      'bg-active': getThemeColor('Gray (light mode)/200'),
      'bg-disabled': getThemeColor('Gray (light mode)/100'),
      'bg-disabled_subtle': getThemeColor('Gray (light mode)/50'),
      'bg-overlay': getThemeColor('Gray (light mode)/950'),
      'bg-brand-primary': getThemeColor('Brand/50'),
      'bg-brand-primary_alt': getThemeColor('Brand/50'),
      'bg-brand-secondary': getThemeColor('Brand/100'),
      'bg-brand-solid': getThemeColor('Brand/600'),
      'bg-brand-solid_hover': getThemeColor('Brand/700'),
      'bg-brand-section': getThemeColor('Brand/800'),
      'bg-brand-section_subtle': getThemeColor('Brand/700'),
      'bg-error-primary': getThemeColor('Error/50'),
      'bg-error-secondary': getThemeColor('Error/100'),
      'bg-error-solid': getThemeColor('Error/600'),
      'bg-warning-primary': getThemeColor('Warning/50'),
      'bg-warning-secondary': getThemeColor('Warning/100'),
      'bg-warning-solid': getThemeColor('Warning/600'),
      'bg-success-primary': getThemeColor('Success/50'),
      'bg-success-secondary': getThemeColor('Success/100'),
      'bg-success-solid': getThemeColor('Success/600'),
      
      // Primary button tokens
      'button-primary-bg': getThemeColor('Brand/500'),
      'button-primary-fg': getThemeColor('Base/White'),
      'button-primary-border': getThemeColor('Brand/500'),
      'button-primary-bg-hover': getThemeColor('Brand/600'),
      'button-primary-fg-hover': getThemeColor('Base/White'),
      'button-primary-border-hover': getThemeColor('Brand/600'),
      
      // Secondary button tokens
      'button-secondary-bg': getThemeColor('Base/White'),
      'button-secondary-fg': getThemeColor('Gray (light mode)/700'),
      'button-secondary-border': getThemeColor('Gray (light mode)/300'),
      'button-secondary-bg-hover': getThemeColor('Gray (light mode)/100'),
      'button-secondary-fg-hover': getThemeColor('Gray (light mode)/800'),
      'button-secondary-border-hover': getThemeColor('Gray (light mode)/300'),
      
      // Secondary color button tokens
      'button-secondary-color-bg': getThemeColor('Brand/50'),
      'button-secondary-color-fg': getThemeColor('Brand/500'),
      'button-secondary-color-border': getThemeColor('Brand/100'),
      'button-secondary-color-bg-hover': getThemeColor('Brand/100'),
      'button-secondary-color-fg-hover': getThemeColor('Brand/600'),
      'button-secondary-color-border-hover': getThemeColor('Brand/200'),
      
      // Tertiary button tokens
      'button-tertiary-bg': 'transparent',
      'button-tertiary-fg': getThemeColor('Gray (light mode)/700'),
      'button-tertiary-border': 'transparent',
      'button-tertiary-bg-hover': getThemeColor('Gray (light mode)/100'),
      'button-tertiary-fg-hover': getThemeColor('Gray (light mode)/800'),
      'button-tertiary-border-hover': 'transparent',
      
      // Tertiary color button tokens
      'button-tertiary-color-bg': 'transparent',
      'button-tertiary-color-fg': getThemeColor('Brand/500'),
      'button-tertiary-color-border': 'transparent',
      'button-tertiary-color-bg-hover': getThemeColor('Brand/50'),
      'button-tertiary-color-fg-hover': getThemeColor('Brand/600'),
      'button-tertiary-color-border-hover': 'transparent',
      
      // Destructive button tokens
      // Primary destructive
      'button-destructive-primary-bg': getThemeColor('Error/600'),
      'button-destructive-primary-fg': getThemeColor('Base/White'),
      'button-destructive-primary-border': getThemeColor('Error/600'),
      'button-destructive-primary-bg-hover': getThemeColor('Error/700'),
      'button-destructive-primary-fg-hover': getThemeColor('Base/White'),
      'button-destructive-primary-border-hover': getThemeColor('Error/700'),

      // Secondary destructive
      'button-destructive-secondary-bg': getThemeColor('Base/White'),
      'button-destructive-secondary-fg': getThemeColor('Error/700'),
      'button-destructive-secondary-border': getThemeColor('Error/300'),
      'button-destructive-secondary-bg-hover': getThemeColor('Error/50'),
      'button-destructive-secondary-fg-hover': getThemeColor('Error/800'),
      'button-destructive-secondary-border-hover': getThemeColor('Error/300'),

      // Tertiary destructive
      'button-destructive-tertiary-bg': 'transparent',
      'button-destructive-tertiary-fg': getThemeColor('Error/700'),
      'button-destructive-tertiary-border': 'transparent',
      'button-destructive-tertiary-bg-hover': getThemeColor('Error/50'),
      'button-destructive-tertiary-fg-hover': getThemeColor('Error/800'),
      'button-destructive-tertiary-border-hover': 'transparent',
      
      // Loading spinner
      'button-loading-spinner': getThemeColor('Base/White'),

      // Icon colors
      'icon-default': getThemeColor('Gray (light mode)/600'),
      'icon-default-hover': getThemeColor('Gray (light mode)/800'),
      'icon-primary': getThemeColor('Gray (light mode)/700'),
      'icon-primary-hover': getThemeColor('Gray (light mode)/900'),
      'icon-secondary': getThemeColor('Gray (light mode)/600'),
      'icon-secondary-hover': getThemeColor('Gray (light mode)/800'),
      'icon-tertiary': getThemeColor('Gray (light mode)/600'),
      'icon-tertiary-hover': getThemeColor('Gray (light mode)/800'),
      'icon-success': getThemeColor('Success/600'),
      'icon-success-hover': getThemeColor('Success/700'),
      'icon-warning': getThemeColor('Warning/600'), 
      'icon-warning-hover': getThemeColor('Warning/700'),
      'icon-error': getThemeColor('Error/600'),
      'icon-error-hover': getThemeColor('Error/700'),
      'icon-info': getThemeColor('Brand/600'),
      'icon-info-hover': getThemeColor('Brand/700'),

      // Input field tokens
      // Default input
      'input-bg': getThemeColor('Base/White'),
      'input-fg': getThemeColor('Gray (light mode)/900'),
      'input-border': getThemeColor('Gray (light mode)/300'),
      'input-bg-hover': getThemeColor('Gray (light mode)/50'),
      'input-fg-hover': getThemeColor('Gray (light mode)/900'),
      'input-border-hover': getThemeColor('Gray (light mode)/300'),
      'input-bg-focus': getThemeColor('Base/White'),
      'input-fg-focus': getThemeColor('Gray (light mode)/900'),
      'input-border-focus': getThemeColor('Brand/600'),
      'input-placeholder': getThemeColor('Gray (light mode)/500'),
      'input-label': getThemeColor('Gray (light mode)/700'),
      'input-hint': getThemeColor('Gray (light mode)/600'),
      'input-icon': getThemeColor('Gray (light mode)/500'),
      'input-prefix': getThemeColor('Gray (light mode)/500'),

      // Destructive input
      'input-destructive-bg': getThemeColor('Error/50'),
      'input-destructive-fg': getThemeColor('Gray (light mode)/900'),
      'input-destructive-border': getThemeColor('Error/300'),
      'input-destructive-bg-hover': getThemeColor('Error/50'),
      'input-destructive-fg-hover': getThemeColor('Gray (light mode)/900'),
      'input-destructive-border-hover': getThemeColor('Error/300'),
      'input-destructive-bg-focus': getThemeColor('Base/White'),
      'input-destructive-fg-focus': getThemeColor('Gray (light mode)/900'),
      'input-destructive-border-focus': getThemeColor('Error/500'),
      'input-destructive-label': getThemeColor('Error/700'),
      'input-destructive-hint': getThemeColor('Error/600'),
      'input-destructive-icon': getThemeColor('Error/500'),

      // Disabled input
      'input-disabled-bg': getThemeColor('Gray (light mode)/50'),
      'input-disabled-fg': getThemeColor('Gray (light mode)/500'),
      'input-disabled-border': getThemeColor('Gray (light mode)/200'),
      'input-disabled-placeholder': getThemeColor('Gray (light mode)/500'),
      'input-disabled-label': getThemeColor('Gray (light mode)/500'),

      // Utility colors
      // Gray
      'utility-gray-50': getThemeColor('Gray (light mode)/50'),
      'utility-gray-100': getThemeColor('Gray (light mode)/100'),
      'utility-gray-200': getThemeColor('Gray (light mode)/200'),
      'utility-gray-300': getThemeColor('Gray (light mode)/300'),
      'utility-gray-400': getThemeColor('Gray (light mode)/400'),
      'utility-gray-500': getThemeColor('Gray (light mode)/500'),
      'utility-gray-600': getThemeColor('Gray (light mode)/600'),
      'utility-gray-700': getThemeColor('Gray (light mode)/700'),
      'utility-gray-800': getThemeColor('Gray (light mode)/800'),
      'utility-gray-900': getThemeColor('Gray (light mode)/900'),

      // Brand
      'utility-brand-50': getThemeColor('Brand/50'),
      'utility-brand-50_alt': getThemeColor('Brand/50'),
      'utility-brand-100': getThemeColor('Brand/100'),
      'utility-brand-100_alt': getThemeColor('Brand/100'),
      'utility-brand-200': getThemeColor('Brand/200'),
      'utility-brand-200_alt': getThemeColor('Brand/200'),
      'utility-brand-300': getThemeColor('Brand/300'),
      'utility-brand-300_alt': getThemeColor('Brand/300'),
      'utility-brand-400': getThemeColor('Brand/400'),
      'utility-brand-400_alt': getThemeColor('Brand/400'),
      'utility-brand-500': getThemeColor('Brand/500'),
      'utility-brand-500_alt': getThemeColor('Brand/500'),
      'utility-brand-600': getThemeColor('Brand/600'),
      'utility-brand-600_alt': getThemeColor('Brand/600'),
      'utility-brand-700': getThemeColor('Brand/700'),
      'utility-brand-700_alt': getThemeColor('Brand/700'),
      'utility-brand-800': getThemeColor('Brand/800'),
      'utility-brand-800_alt': getThemeColor('Brand/800'),
      'utility-brand-900': getThemeColor('Brand/900'),
      'utility-brand-900_alt': getThemeColor('Brand/900'),

      // Error
      'utility-error-50': getThemeColor('Error/50'),
      'utility-error-100': getThemeColor('Error/100'),
      'utility-error-200': getThemeColor('Error/200'),
      'utility-error-300': getThemeColor('Error/300'),
      'utility-error-400': getThemeColor('Error/400'),
      'utility-error-500': getThemeColor('Error/500'),
      'utility-error-600': getThemeColor('Error/600'),
      'utility-error-700': getThemeColor('Error/700'),

      // Warning
      'utility-warning-50': getThemeColor('Warning/50'),
      'utility-warning-100': getThemeColor('Warning/100'),
      'utility-warning-200': getThemeColor('Warning/200'),
      'utility-warning-300': getThemeColor('Warning/300'),
      'utility-warning-400': getThemeColor('Warning/400'),
      'utility-warning-500': getThemeColor('Warning/500'),
      'utility-warning-600': getThemeColor('Warning/600'),
      'utility-warning-700': getThemeColor('Warning/700'),

      // Success
      'utility-success-50': getThemeColor('Success/50'),
      'utility-success-100': getThemeColor('Success/100'),
      'utility-success-200': getThemeColor('Success/200'),
      'utility-success-300': getThemeColor('Success/300'),
      'utility-success-400': getThemeColor('Success/400'),
      'utility-success-500': getThemeColor('Success/500'),
      'utility-success-600': getThemeColor('Success/600'),
      'utility-success-700': getThemeColor('Success/700'),

      // Gray Blue
      'utility-gray-blue-50': getThemeColor('Gray blue/50'),
      'utility-gray-blue-100': getThemeColor('Gray blue/100'),
      'utility-gray-blue-200': getThemeColor('Gray blue/200'),
      'utility-gray-blue-300': getThemeColor('Gray blue/300'),
      'utility-gray-blue-400': getThemeColor('Gray blue/400'),
      'utility-gray-blue-500': getThemeColor('Gray blue/500'),
      'utility-gray-blue-600': getThemeColor('Gray blue/600'),
      'utility-gray-blue-700': getThemeColor('Gray blue/700'),

      // Blue Light
      'utility-blue-light-50': getThemeColor('Blue light/50'),
      'utility-blue-light-100': getThemeColor('Blue light/100'),
      'utility-blue-light-200': getThemeColor('Blue light/200'),
      'utility-blue-light-300': getThemeColor('Blue light/300'),
      'utility-blue-light-400': getThemeColor('Blue light/400'),
      'utility-blue-light-500': getThemeColor('Blue light/500'),
      'utility-blue-light-600': getThemeColor('Blue light/600'),
      'utility-blue-light-700': getThemeColor('Blue light/700'),

      // Blue
      'utility-blue-50': getThemeColor('Blue/50'),
      'utility-blue-100': getThemeColor('Blue/100'),
      'utility-blue-200': getThemeColor('Blue/200'),
      'utility-blue-300': getThemeColor('Blue/300'),
      'utility-blue-400': getThemeColor('Blue/400'),
      'utility-blue-500': getThemeColor('Blue/500'),
      'utility-blue-600': getThemeColor('Blue/600'),
      'utility-blue-700': getThemeColor('Blue/700'),

      // Blue Dark
      'utility-blue-dark-50': getThemeColor('Blue dark/50'),
      'utility-blue-dark-100': getThemeColor('Blue dark/100'),
      'utility-blue-dark-200': getThemeColor('Blue dark/200'),
      'utility-blue-dark-300': getThemeColor('Blue dark/300'),
      'utility-blue-dark-400': getThemeColor('Blue dark/400'),
      'utility-blue-dark-500': getThemeColor('Blue dark/500'),
      'utility-blue-dark-600': getThemeColor('Blue dark/600'),
      'utility-blue-dark-700': getThemeColor('Blue dark/700'),

      // Indigo
      'utility-indigo-50': getThemeColor('Indigo/50'),
      'utility-indigo-100': getThemeColor('Indigo/100'),
      'utility-indigo-200': getThemeColor('Indigo/200'),
      'utility-indigo-300': getThemeColor('Indigo/300'),
      'utility-indigo-400': getThemeColor('Indigo/400'),
      'utility-indigo-500': getThemeColor('Indigo/500'),
      'utility-indigo-600': getThemeColor('Indigo/600'),
      'utility-indigo-700': getThemeColor('Indigo/700'),

      // Purple
      'utility-purple-50': getThemeColor('Purple/50'),
      'utility-purple-100': getThemeColor('Purple/100'),
      'utility-purple-200': getThemeColor('Purple/200'),
      'utility-purple-300': getThemeColor('Purple/300'),
      'utility-purple-400': getThemeColor('Purple/400'),
      'utility-purple-500': getThemeColor('Purple/500'),
      'utility-purple-600': getThemeColor('Purple/600'),
      'utility-purple-700': getThemeColor('Purple/700'),

      // Fuchsia
      'utility-fuchsia-50': getThemeColor('Fuchsia/50'),
      'utility-fuchsia-100': getThemeColor('Fuchsia/100'),
      'utility-fuchsia-200': getThemeColor('Fuchsia/200'),
      'utility-fuchsia-300': getThemeColor('Fuchsia/300'),
      'utility-fuchsia-400': getThemeColor('Fuchsia/400'),
      'utility-fuchsia-500': getThemeColor('Fuchsia/500'),
      'utility-fuchsia-600': getThemeColor('Fuchsia/600'),
      'utility-fuchsia-700': getThemeColor('Fuchsia/700'),

      // Pink
      'utility-pink-50': getThemeColor('Pink/50'),
      'utility-pink-100': getThemeColor('Pink/100'),
      'utility-pink-200': getThemeColor('Pink/200'),
      'utility-pink-300': getThemeColor('Pink/300'),
      'utility-pink-400': getThemeColor('Pink/400'),
      'utility-pink-500': getThemeColor('Pink/500'),
      'utility-pink-600': getThemeColor('Pink/600'),
      'utility-pink-700': getThemeColor('Pink/700'),

      // Orange Dark
      'utility-orange-dark-50': getThemeColor('Orange dark/50'),
      'utility-orange-dark-100': getThemeColor('Orange dark/100'),
      'utility-orange-dark-200': getThemeColor('Orange dark/200'),
      'utility-orange-dark-300': getThemeColor('Orange dark/300'),
      'utility-orange-dark-400': getThemeColor('Orange dark/400'),
      'utility-orange-dark-500': getThemeColor('Orange dark/500'),
      'utility-orange-dark-600': getThemeColor('Orange dark/600'),
      'utility-orange-dark-700': getThemeColor('Orange dark/700'),

      // Orange
      'utility-orange-50': getThemeColor('Orange/50'),
      'utility-orange-100': getThemeColor('Orange/100'),
      'utility-orange-200': getThemeColor('Orange/200'),
      'utility-orange-300': getThemeColor('Orange/300'),
      'utility-orange-400': getThemeColor('Orange/400'),
      'utility-orange-500': getThemeColor('Orange/500'),
      'utility-orange-600': getThemeColor('Orange/600'),
      'utility-orange-700': getThemeColor('Orange/700'),

      // Alpha colors
      'alpha-white-10': 'rgba(255, 255, 255, 0.10)',
      'alpha-white-20': 'rgba(255, 255, 255, 0.20)',
      'alpha-white-30': 'rgba(255, 255, 255, 0.30)',
      'alpha-white-40': 'rgba(255, 255, 255, 0.40)',
      'alpha-white-50': 'rgba(255, 255, 255, 0.50)',
      'alpha-white-60': 'rgba(255, 255, 255, 0.60)',
      'alpha-white-70': 'rgba(255, 255, 255, 0.70)',
      'alpha-white-80': 'rgba(255, 255, 255, 0.80)',
      'alpha-white-90': 'rgba(255, 255, 255, 0.90)',
      'alpha-white-100': '#ffffff',
      'alpha-black-10': 'rgba(0, 0, 0, 0.10)',
      'alpha-black-20': 'rgba(0, 0, 0, 0.20)',
      'alpha-black-30': 'rgba(0, 0, 0, 0.30)',
      'alpha-black-40': 'rgba(0, 0, 0, 0.40)',
      'alpha-black-50': 'rgba(0, 0, 0, 0.50)',
      'alpha-black-60': 'rgba(0, 0, 0, 0.60)',
      'alpha-black-70': 'rgba(0, 0, 0, 0.70)',
      'alpha-black-80': 'rgba(0, 0, 0, 0.80)',
      'alpha-black-90': 'rgba(0, 0, 0, 0.90)',
      'alpha-black-100': '#000000',

      // Shadow colors
      'shadow-xs': 'rgba(16, 24, 40, 0.05)',
      'shadow-sm_01': 'rgba(16, 24, 40, 0.10)',
      'shadow-sm_02': 'rgba(16, 24, 40, 0.06)',
      'shadow-md_01': 'rgba(16, 24, 40, 0.10)',
      'shadow-md_02': 'rgba(16, 24, 40, 0.06)',
      'shadow-lg_01': 'rgba(16, 24, 40, 0.08)',
      'shadow-lg_02': 'rgba(16, 24, 40, 0.03)',
      'shadow-xl_01': 'rgba(16, 24, 40, 0.08)',
      'shadow-xl_02': 'rgba(16, 24, 40, 0.03)',
      'shadow-2xl': 'rgba(16, 24, 40, 0.18)',
      'shadow-3xl': 'rgba(16, 24, 40, 0.14)',
      'shadow-skeumorphic-inner': 'rgba(16, 24, 40, 0.05)',
      'shadow-skeumorphic-inner-border': 'rgba(16, 24, 40, 0.18)',
      'shadow-main-centre-md': 'rgba(16, 24, 40, 0.14)',
      'shadow-main-centre-lg': 'rgba(16, 24, 40, 0.18)',
      'shadow-overlay-lg': 'rgba(16, 24, 40, 0.12)',
      'shadow-grid-md': 'rgba(16, 24, 40, 0.08)',

      // Miscellaneous
      'app-store-badge-border': '#a6a6a6',
      'social-icon-fg-x': '#242e36',
      'social-icon-fg-instagram': '#000100',
      'social-icon-fg-apple': getThemeColor('Base/Black'),
      'social-icon-fg-github': getThemeColor('Base/Black'),
      'social-icon-fg-angellist': getThemeColor('Base/Black'),
      'social-icon-fg-tumblr': '#001935',
      'screen-mockup-border': getThemeColor('Gray (light mode)/900'),
      'slider-handle-bg': getThemeColor('Base/White'),
      'slider-handle-border': getThemeColor('Brand/600'),
      'thumbnail-badge-brand-fg': getThemeColor('Brand/700'),
      'thumbnail-badge-success-fg': getThemeColor('Success/700'),
      'toggle-button-fg_disabled': getThemeColor('Gray (light mode)/50'),
      'tooltip-supporting-text': getThemeColor('Gray (light mode)/300'),
      'wysiwyg-editor-icon-fg': getThemeColor('Gray (light mode)/400'),
      'wysiwyg-editor-icon-fg_active': getThemeColor('Gray (light mode)/500'),

      // Breadcrumb tokens
      'breadcrumb-active-bg': getThemeColor('Brand/50'),
      'breadcrumb-active-fg': getThemeColor('Brand/700'),
      'breadcrumb-inactive-fg': getThemeColor('Gray (light mode)/600'),
      'breadcrumb-separator': getThemeColor('Gray (light mode)/400'),
      'breadcrumb-hover-opacity': '0.75',
    },
    typography: {
      'body-default': {
        fontSize: '16px',
        lineHeight: '24px',
        fontWeight: '400',
      },
      'heading-1': {
        fontSize: '30px',
        lineHeight: '38px',
        fontWeight: '600',
      },
    },
    spacing: {
      'spacing-xs': '4px',
      'spacing-sm': '8px',
      'spacing-md': '16px',
      'spacing-lg': '24px',
      'spacing-xl': '32px',
    },
    borderRadius: {
      'radius-sm': '4px',
      'radius-md': '8px',
      'radius-lg': '12px',
      'radius-full': '9999px',
    },
    boxShadow: {
      'shadow-sm': '0px 1px 2px rgba(16, 24, 40, 0.05)',
      'shadow-md': '0px 4px 6px -2px rgba(16, 24, 40, 0.05)',
      'shadow-lg': '0px 8px 8px -4px rgba(16, 24, 40, 0.05)',
    },
  },
  assets: {
    icons: {
      'theme-toggle': '/assets/shared_components/sun.svg',
    },
    images: {},
  },
};
</file>

<file path="app/theme/colors.ts">
/**
 * Optimized color palette - only essential colors for performance
 */

export const colors = {
  // Base colors
  white: '#ffffff',
  black: '#000000',
  
  // Gray scale for light mode
  gray: {
    light: {
      25: '#fcfcfd',
      50: '#f9fafb',
      100: '#f2f4f7',
      200: '#e4e7ec',
      300: '#d0d5dd',
      400: '#98a2b3',
      500: '#667085',
      600: '#475467',
      700: '#344054',
      800: '#182230',
      900: '#101828',
      950: '#0c111d',
    },
    // Gray scale for dark mode
    dark: {
      25: '#fafafa',
      50: '#f5f5f6',
      100: '#f0f1f1',
      200: '#ececed',
      300: '#cecfd2',
      400: '#94969c',
      500: '#85888e',
      600: '#61646c',
      700: '#333741',
      800: '#1f242f',
      900: '#161b26',
      950: '#0c111d',
    }
  },
  
  // Brand colors
  brand: {
    25: '#f4f6fe',
    50: '#edf0fb',
    100: '#c8d1f3',
    200: '#aebbed',
    300: '#889ce4',
    400: '#7189df',
    500: '#4e6bd7',
    600: '#4761c4',
    700: '#374c99',
    800: '#2b3b76',
    900: '#202e62',
    950: '#132154',
  },
  
  // Error colors
  error: {
    25: '#fffbfa',
    50: '#fef3f2',
    100: '#fee4e2',
    200: '#fecdca',
    300: '#fda29b',
    400: '#f97066',
    500: '#f04438',
    600: '#d92d20',
    700: '#b42318',
    800: '#912018',
    900: '#7a271a',
    950: '#55160c',
  },
  
  // Warning colors
  warning: {
    25: '#fffcf5',
    50: '#fffaeb',
    100: '#fef0c7',
    200: '#fedf89',
    300: '#fec84b',
    400: '#fdb022',
    500: '#f79009',
    600: '#dc6803',
    700: '#b54708',
    800: '#93370d',
    900: '#7a2e0e',
    950: '#4e1d09',
  },
  
  // Success colors
  success: {
    25: '#f6fef9',
    50: '#ecfdf3',
    100: '#dcfae6',
    200: '#abefc6',
    300: '#75e0a7',
    400: '#47cd89',
    500: '#17b26a',
    600: '#079455',
    700: '#067647',
    800: '#085d3a',
    900: '#074d31',
    950: '#053321',
  },
};
</file>

<file path="app/theme/fast-hooks.ts">
/**
 * Fast theme hooks - backward compatible with existing useColors() usage
 * These provide the same API but use CSS variables instead of JavaScript objects
 * COMPLETE MAPPING of all 388+ color tokens
 */

import { useFastTheme } from '../context/FastThemeContext';

/**
 * Backward-compatible useColors hook
 * Returns a Proxy that converts any property access to CSS variables
 * This maps ALL your existing tokens to CSS variables for 100% compatibility
 */
export function useColors() {
  return new Proxy({} as any, {
    get: (_, prop: string) => {
      // Direct mapping to CSS variables - covers all your 388 tokens
      return `var(--${prop})`;
    }
  });
}

/**
 * Backward-compatible useTheme hook
 */
export function useTheme() {
  const { currentTheme, setTheme, toggleTheme } = useFastTheme();
  
  return {
    currentTheme,
    setTheme,
    toggleTheme,
    // Legacy API compatibility
    themes: {
      light: { name: 'light' },
      dark: { name: 'dark' }
    },
    getCssVariable: (token: string) => `var(--${token})`,
  };
}

/**
 * Get a specific CSS variable value
 */
export function useCssVar(token: string): string {
  return `var(--${token})`;
}

/**
 * Helper for button tokens (backward compatibility)
 */
export function useButtonToken(token: string): string {
  return `var(--${token})`;
}

/**
 * Helper for icon tokens (backward compatibility)
 */
export function useIconToken(token: string): string {
  return `var(--${token})`;
}

/**
 * Helper for input tokens (backward compatibility)
 */
export function useInputToken(token: string): string {
  return `var(--${token})`;
}

/**
 * Helper for breadcrumb tokens (backward compatibility)
 */
export function useBreadcrumbToken(token: string): string {
  return `var(--${token})`;
}

/**
 * Typography tokens (static since they don't change with theme)
 */
export function useTypography() {
  return {
    'body-default': {
      fontSize: '16px',
      lineHeight: '24px',
      fontWeight: '400',
    },
    'body-sm': {
      fontSize: '14px',
      lineHeight: '20px',
      fontWeight: '400',
    },
    'body-xs': {
      fontSize: '12px',
      lineHeight: '18px',
      fontWeight: '400',
    },
    'heading-1': {
      fontSize: '30px',
      lineHeight: '38px',
      fontWeight: '600',
    },
    'heading-2': {
      fontSize: '24px',
      lineHeight: '32px',
      fontWeight: '600',
    },
    'heading-3': {
      fontSize: '20px',
      lineHeight: '30px',
      fontWeight: '600',
    },
    'heading-4': {
      fontSize: '18px',
      lineHeight: '28px',
      fontWeight: '600',
    },
    'heading-5': {
      fontSize: '16px',
      lineHeight: '24px',
      fontWeight: '600',
    },
    'heading-6': {
      fontSize: '14px',
      lineHeight: '20px',
      fontWeight: '600',
    },
  };
}

/**
 * Spacing tokens (static)
 */
export function useSpacing() {
  return {
    'spacing-none': '0px',
    'spacing-xs': '4px',
    'spacing-sm': '8px',
    'spacing-md': '12px',
    'spacing-lg': '16px',
    'spacing-xl': '20px',
    'spacing-2xl': '24px',
    'spacing-3xl': '32px',
    'spacing-4xl': '40px',
    'spacing-5xl': '48px',
    'spacing-6xl': '64px',
    'spacing-7xl': '80px',
    'spacing-8xl': '96px',
  };
}
</file>

<file path="app/theme/hooks.ts">
/**
 * Fast theme hooks - drop-in replacement for the old theme system
 * This file maintains the same API but uses CSS variables for much better performance
 */

// Re-export everything from fast-hooks for backward compatibility
export { useColors, useTheme, useCssVar, useButtonToken, useIconToken } from './fast-hooks';

// Legacy hooks for full backward compatibility
export function useTypography() {
  return {
    'body-default': {
      fontSize: '16px',
      lineHeight: '24px',
      fontWeight: '400',
    },
    'heading-1': {
      fontSize: '30px',
      lineHeight: '38px',
      fontWeight: '600',
    },
    // Add more typography tokens as needed
  };
}

export function useSpacing() {
  return {
    'spacing-xs': '4px',
    'spacing-sm': '8px',
    'spacing-md': '16px',
    'spacing-lg': '24px',
    'spacing-xl': '32px',
    // Add more spacing tokens as needed
  };
}

export function useThemeAssets() {
  return {
    icons: {},
    images: {}
  };
}
</file>

<file path="app/theme/index.ts">
import { themeRegistry } from './registry';
import { lightTheme } from './themes/light';
import { darkTheme } from './themes/dark';

// Register themes
themeRegistry.register(lightTheme);
themeRegistry.register(darkTheme);

// Export everything
export { themeRegistry };
export { lightTheme, darkTheme };
export * from './types';
export * from './hooks';
export * from './utils';
</file>

<file path="app/theme/registry.ts">
import { Theme, ThemeMode } from './types';

class ThemeRegistry {
  private themes: Map<ThemeMode, Theme> = new Map();
  private defaultTheme: ThemeMode = 'light';

  constructor(defaultTheme?: ThemeMode) {
    if (defaultTheme) {
      this.defaultTheme = defaultTheme;
    }
  }

  register(theme: Theme): void {
    this.themes.set(theme.name as ThemeMode, theme);
  }

  get(mode: ThemeMode): Theme {
    const theme = this.themes.get(mode);
    if (!theme) {
      const defaultTheme = this.themes.get(this.defaultTheme);
      if (!defaultTheme) {
        throw new Error('No themes registered, including default theme');
      }
      return defaultTheme;
    }
    return theme;
  }

  getAllThemes(): Record<string, Theme> {
    return Object.fromEntries(this.themes.entries());
  }

  exists(mode: ThemeMode): boolean {
    return this.themes.has(mode);
  }

  getDefaultTheme(): Theme {
    const theme = this.themes.get(this.defaultTheme);
    if (!theme) {
      throw new Error('Default theme not found');
    }
    return theme;
  }
}

export const themeRegistry = new ThemeRegistry();
export default ThemeRegistry;
</file>

<file path="app/theme/types.ts">
export type ThemeMode = 'light' | 'dark' | 'system';

export type ColorToken = {
  [key: string]: string;
};

export type TypographyToken = {
  fontSize: string;
  lineHeight: string;
  fontWeight: number | string;
};

export type SpacingToken = {
  [key: string]: string;
};

export type BreadcrumbTokens = {
  'breadcrumb-active-bg': string;
  'breadcrumb-active-fg': string;
  'breadcrumb-inactive-fg': string;
  'breadcrumb-separator': string;
  'breadcrumb-hover-opacity': string;
};

export type InputTokens = {
  // Default input tokens
  'input-bg': string;
  'input-fg': string;
  'input-border': string;
  'input-bg-hover': string;
  'input-fg-hover': string;
  'input-border-hover': string;
  'input-bg-focus': string;
  'input-fg-focus': string;
  'input-border-focus': string;
  'input-placeholder': string;
  'input-label': string;
  'input-hint': string;
  'input-icon': string;
  'input-prefix': string;

  // Destructive input tokens
  'input-destructive-bg': string;
  'input-destructive-fg': string;
  'input-destructive-border': string;
  'input-destructive-bg-hover': string;
  'input-destructive-fg-hover': string;
  'input-destructive-border-hover': string;
  'input-destructive-bg-focus': string;
  'input-destructive-fg-focus': string;
  'input-destructive-border-focus': string;
  'input-destructive-label': string;
  'input-destructive-hint': string;
  'input-destructive-icon': string;

  // Disabled input tokens
  'input-disabled-bg': string;
  'input-disabled-fg': string;
  'input-disabled-border': string;
  'input-disabled-placeholder': string;
  'input-disabled-label': string;
};

export type ButtonTokens = {
  // Primary button tokens
  'button-primary-bg': string;
  'button-primary-fg': string;
  'button-primary-border': string;
  'button-primary-bg-hover': string;
  'button-primary-fg-hover': string;
  'button-primary-border-hover': string;
  
  // Secondary button tokens
  'button-secondary-bg': string;
  'button-secondary-fg': string;
  'button-secondary-border': string;
  'button-secondary-bg-hover': string;
  'button-secondary-fg-hover': string;
  'button-secondary-border-hover': string;
  
  // Secondary color button tokens
  'button-secondary-color-bg': string;
  'button-secondary-color-fg': string;
  'button-secondary-color-border': string;
  'button-secondary-color-bg-hover': string;
  'button-secondary-color-fg-hover': string;
  'button-secondary-color-border-hover': string;
  
  // Tertiary button tokens
  'button-tertiary-bg': string;
  'button-tertiary-fg': string;
  'button-tertiary-border': string;
  'button-tertiary-bg-hover': string;
  'button-tertiary-fg-hover': string;
  'button-tertiary-border-hover': string;
  
  // Tertiary color button tokens
  'button-tertiary-color-bg': string;
  'button-tertiary-color-fg': string;
  'button-tertiary-color-border': string;
  'button-tertiary-color-bg-hover': string;
  'button-tertiary-color-fg-hover': string;
  'button-tertiary-color-border-hover': string;
  
  // Destructive button tokens
  'button-destructive-primary-bg': string;
  'button-destructive-primary-fg': string;
  'button-destructive-primary-border': string;
  'button-destructive-primary-bg-hover': string;
  'button-destructive-primary-fg-hover': string;
  'button-destructive-primary-border-hover': string;

  'button-destructive-secondary-bg': string;
  'button-destructive-secondary-fg': string;
  'button-destructive-secondary-border': string;
  'button-destructive-secondary-bg-hover': string;
  'button-destructive-secondary-fg-hover': string;
  'button-destructive-secondary-border-hover': string;

  'button-destructive-tertiary-bg': string;
  'button-destructive-tertiary-fg': string;
  'button-destructive-tertiary-border': string;
  'button-destructive-tertiary-bg-hover': string;
  'button-destructive-tertiary-fg-hover': string;
  'button-destructive-tertiary-border-hover': string;
  
  // Loading spinner
  'button-loading-spinner': string;
};

export type IconTokens = {
  'icon-default': string;
  'icon-default-hover': string;
  'icon-primary': string;
  'icon-primary-hover': string;
  'icon-secondary': string;
  'icon-secondary-hover': string;
  'icon-tertiary': string;
  'icon-tertiary-hover': string;
  'icon-success': string;
  'icon-success-hover': string;
  'icon-warning': string; 
  'icon-warning-hover': string;
  'icon-error': string;
  'icon-error-hover': string;
  'icon-info': string;
  'icon-info-hover': string;
};

export type CSSVariables = {
  [K in keyof (ButtonTokens & InputTokens & BreadcrumbTokens & IconTokens) as `--${K}`]: string;
};

export type ThemeTokens = {
  colors: ColorToken & ButtonTokens & InputTokens & BreadcrumbTokens & IconTokens;
  typography: Record<string, TypographyToken>;
  spacing: SpacingToken;
  borderRadius: Record<string, string>;
  boxShadow: Record<string, string>;
  // Add more token categories as needed
};

export type ThemeAssets = {
  icons: Record<string, string>;
  images: Record<string, string>;
};

export type Theme = {
  name: string;
  label: string;
  tokens: ThemeTokens;
  assets: ThemeAssets;
};

export type ThemeContextType = {
  currentTheme: ThemeMode;
  themes: Record<string, Theme>;
  setTheme: (mode: ThemeMode) => void;
  getCssVariable: (token: keyof (ButtonTokens & InputTokens & BreadcrumbTokens & IconTokens)) => string;
};
</file>

<file path="app/theme/utils.ts">
/**
 * Theme transition utilities for better performance
 */

/**
 * Class name for components that should have smooth theme transitions
 * Use this sparingly, only on components where the transition is visually important
 */
export const THEME_TRANSITION_CLASS = 'theme-transition';

/**
 * Class name for components that should NOT have transitions (for performance)
 * Use this on icons, charts, or other performance-sensitive elements
 */
export const NO_TRANSITION_CLASS = 'no-transition';

/**
 * Hook to get theme transition class names
 * @param enableTransition - Whether to enable smooth transitions for this component
 * @returns className string
 */
export function useThemeTransition(enableTransition: boolean = false): string {
  return enableTransition ? THEME_TRANSITION_CLASS : '';
}

/**
 * Utility to temporarily disable all theme transitions (useful for bulk updates)
 */
export function disableThemeTransitions(): () => void {
  const root = document.documentElement;
  root.style.setProperty('--theme-transition-duration', '0ms');
  
  return () => {
    root.style.setProperty('--theme-transition-duration', '150ms');
  };
}

/**
 * Data attribute for components that should transition
 */
export const themeTransitionAttr = { 'data-theme-transition': 'true' };

/**
 * Data attribute for components that should NOT transition
 */
export const noTransitionAttr = { 'data-no-transition': 'true' };
</file>

<file path="app/types/block.ts">
export enum BlockEndType {
  END = 'END',
  LAST = 'LAST',
  PATH = 'PATH',
  MERGE = 'MERGE'
}
</file>

<file path="app/types/cloudinary.d.ts">
interface Window {
  cloudinary: {
    createMediaEditor: (config: {
      cloud: {
        cloudName: string;
      };
      image: string;
    }) => {
      show: () => void;
      on: (event: string, callback: (data: any) => void) => void;
    };
  };
}
</file>

<file path="app/types/toast-ui.d.ts">
declare module '@toast-ui/react-image-editor' {
  import { RefObject } from 'react';

  interface ImageEditorOptions {
    includeUI?: {
      loadImage?: {
        path: string;
        name: string;
      };
      theme?: Record<string, string>;
      menu?: string[];
      initMenu?: string;
      menuBarPosition?: string;
      uiSize?: {
        width: string;
        height: string;
      };
    };
    cssMaxWidth?: number;
    cssMaxHeight?: number;
    selectionStyle?: {
      cornerSize?: number;
      rotatingPointOffset?: number;
    };
  }

  interface ImageEditorInstance {
    toDataURL(): string;
    destroy(): void;
  }

  interface ImageEditorComponent {
    getInstance(): ImageEditorInstance;
  }

  const ImageEditor: React.ForwardRefExoticComponent<
    ImageEditorOptions & React.RefAttributes<ImageEditorComponent>
  >;

  export default ImageEditor;
}
</file>

<file path="app/types/workflow.ts">
export interface Workflow {
  id: number;
  name: string;
  description?: string;
  workspaceId: number;
  folder_id?: number | null;
  icon?: string | null;
  created_at?: string;
  updated_at?: string;
  // ... other existing fields
}
</file>

<file path="app/unauthorized/page.tsx">
'use client';

import { useTheme } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';
import Link from 'next/link';
import { useSupabaseSession } from '@/hooks/useSupabaseSession';

export default function UnauthorizedPage() {
  const { getCssVariable } = useTheme();
  const { user } = useSupabaseSession();

  return (
    <div 
      className="flex flex-col items-center justify-center min-h-screen"
      style={{ 
        backgroundColor: getCssVariable('button-secondary-bg'),
        color: getCssVariable('button-secondary-fg')
      }}
    >
      <h1 className="text-4xl font-bold text-[color:var(--text-error-primary)]">
        Unauthorized Access
      </h1>
      <p className="mt-4" style={{ color: getCssVariable('button-tertiary-fg') }}>
        You don't have permission to access this resource.
      </p>
      <div className="mt-8">
        <Link href={user ? '/' : '/login'}>
          <ButtonNormal 
            variant={user ? "primary" : "primary"}
          >
            {user ? 'Return to Dashboard' : 'Go to Login'}
          </ButtonNormal>
        </Link>
      </div>
    </div>
  );
}
</file>

<file path="app/utils/assetUrls.ts">
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL || '';
const STORAGE_PATH = process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH || '';

export const getAssetUrl = (path: string): string => {
  return `${SUPABASE_URL}${STORAGE_PATH}${path}`;
};

export const SHARED_ASSETS = {
  chevronDown: '/assets/shared_components/chevron-down.svg',
  chevronRight: '/assets/shared_components/chevron-right-black.svg',
  dotsHorizontal: '/assets/shared_components/dots-horizontal-black.svg',
  folderBase: '/assets/shared_components/folder-icon-base.svg',
  layers: '/assets/shared_components/layers-icon.svg',
  plus: '/assets/shared_components/plus-icon.svg',
  send: '/assets/shared_components/send-01.svg',
} as const;
</file>

<file path="app/utils/checkNames.ts">
interface NameError {
  title: string;
  description: string;
}

export function checkWorkflowName(name: string): NameError | null {
  // if (name.includes('-')) {
  //   return {
  //     title: 'Invalid Character',
  //     description: 'Workflow name cannot contain hyphens (-)'
  //   };
  // }

  if (name.length > 50) {
    return {
      title: 'Invalid Name Length',
      description: 'Workflow name cannot be longer than 50 characters'
    };
  }

  return null;
}

export function checkFolderName(name: string): NameError | null {
  if (name.length > 100) {
    return {
      title: 'Invalid Name Length',
      description: 'Folder name cannot be longer than 100 characters'
    };
  }

  return null;
}

export function checkWorkspaceName(name: string): NameError | null {
  if (name.length > 50) {
    return {
      title: 'Invalid Name Length',
      description: 'Workspace name cannot be longer than 50 characters'
    };
  }

  if (!/^[a-zA-Z0-9 -]+$/.test(name)) {
    return {
      title: 'Invalid Characters',
      description: 'Workspace name must contain only letters, numbers, spaces, and hyphens.'
    };
  }

  return null;
}
</file>

<file path="app/utils/createWorkflow.ts">
import { Workflow } from '@/types/workflow'; // Update the path to match your project structure
import { checkWorkflowName } from './checkNames';

interface CreateWorkflowParams {
  name: string;
  description: string;
  process_owner?: string;
  review_date?: string;
  additional_notes?: string;
  workspaceId: number;
  folderId?: number | null;
  teamTags?: string[];
  authorId?: number;
  icon?: string | null;
}

export async function createWorkflow({
  name,
  description,
  process_owner,
  review_date,
  additional_notes,
  workspaceId,
  folderId,
  teamTags,
  authorId,
  icon,
}: CreateWorkflowParams): Promise<{ workflow: Workflow | null; error?: { title: string; description: string } }> {
  try {
    // Validate name using the new utility function
    const nameError = checkWorkflowName(name);
    if (nameError) {
      return {
        workflow: null,
        error: nameError
      };
    }

    if (process.env.NODE_ENV === 'development') {
      console.log('process_owner', process_owner);
      console.log('review_date', review_date);
      console.log('additional_notes', additional_notes);
    }
    
    // Sanitize review_date: send null if empty string or undefined
    const sanitizedReviewDate =
      review_date === '' || review_date === undefined ? null : review_date;

    const response = await fetch('/api/workspace/workflows', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        name,
        description,
        process_owner: process_owner,
        review_date: sanitizedReviewDate,
        additional_notes: additional_notes,
        workspace_id: workspaceId,
        folder_id: folderId,
        author_id: authorId,
        icon: icon,
      }),
    });

    const data = await response.json();

    if (!response.ok) {
      // Return error details for toast notification
      return {
        workflow: null,
        error: {
          title: data.title || 'Error Creating Workflow',
          description: data.description || data.error || 'Failed to create workflow'
        }
      };
    }

    return { workflow: data };
  } catch (error) {
    console.error('Error creating workflow:', error);
    return {
      workflow: null,
      error: {
        title: 'Error Creating Workflow',
        description: 'An unexpected error occurred'
      }
    };
  }
}
</file>

<file path="app/utils/deleteWorkflow.ts">
export async function deleteWorkflow(workflowId: number): Promise<boolean> {
  try {
    const response = await fetch('/api/workspace/workflows', {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ workflowId }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error(
        'Failed to delete workflow:',
        errorData.error || 'Unknown error'
      );
      return false; // Deletion unsuccessful
    }

   
    return true; // Deletion successful
  } catch (error) {
    console.error('Error calling delete workflow API:', error);
    return false; // Deletion unsuccessful
  }
}
</file>

<file path="app/utils/getBaseUrl.ts">
export default function getBaseUrl() {
  // On Vercel, VERCEL_URL is set (e.g. process-flow-abc123.vercel.app)
  const vercelUrl = process.env.VERCEL_URL;
  if (vercelUrl) {
    return `https://${vercelUrl}`;
  }
  // Fallback for local dev
  return process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
}
</file>

<file path="app/utils/icons.ts">
import { cache } from 'react'

export const getIcons = cache(async () => {
  const response = await fetch('/api/step-icons')
  if (!response.ok) throw new Error('Failed to fetch icons')
  return response.json()
})
</file>

<file path="app/utils/isPreview.ts">
export function isPreview(): boolean {
  return process.env.VERCEL_ENV !== "production";
}
</file>

<file path="app/utils/mail.ts">
/// import nodemailer from 'nodemailer';

/// export async function sendEmail(to: string, subject: string, html: string) {
  /// try {
    /// const transporter = nodemailer.createTransport({
      /// host: process.env.SMTP_SERVER,
      /// port: Number(process.env.SMTP_PORT),
      /// secure: false, // Brevo uses STARTTLS
      /// auth: {
        /// user: process.env.SMTP_USERNAME,
        /// pass: process.env.SMTP_PASSWORD,
      /// },
    /// });

    /// const mailOptions = {
      /// from: `Customer Service | ProcessFlow <contact@process-flow.io>`,
      /// to,
      /// subject,
      /// html,
    /// };

    /// const info = await transporter.sendMail(mailOptions);
    /// console.log(` Email sent to ${to}:`, info.response);
    /// return { success: true };
  /// } catch (error) {
    /// console.error(' Email sending error:', error);
    /// return { error: 'Failed to send email' };
  /// }
/// }

export async function sendEmail(to: string, subject: string, html: string) {
  try {
    // Implmentation relle avec nodemailer...
    return { success: true };
  } catch (error) {
    console.error(' Email sending error:', error);
    return { success: false, error: 'Failed to send email' };
  }
}
</file>

<file path="app/utils/modalPatterns.tsx">
import React from 'react';
import Modal from '@/app/components/Modal';
import ButtonNormal from '@/app/components/ButtonNormal';
import ButtonDestructive from '@/app/components/ButtonDestructive';
import { useColors } from '@/app/theme/hooks';

/**
 * Creates a confirmation dialog modal
 */
export function createConfirmationModal({
  title,
  message,
  onConfirm,
  onClose,
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  icon,
  iconBackgroundColor,
  isDestructive = false,
  isLoading = false
}: {
  title: string;
  message: string;
  onConfirm: () => void;
  onClose: () => void;
  confirmText?: string;
  cancelText?: string;
  icon?: string;
  iconBackgroundColor?: string;
  isDestructive?: boolean;
  isLoading?: boolean;
}) {
  const colors = useColors();
  
  const actions = (
    <>
      <ButtonNormal
        variant="secondary"
        size="small"
        className="flex-1"
        onClick={onClose}
        disabled={isLoading}
      >
        {cancelText}
      </ButtonNormal>
      
      {isDestructive ? (
        <ButtonDestructive
          variant="primary"
          size="small"
          className="flex-1"
          onClick={onConfirm}
          disabled={isLoading}
        >
          {isLoading ? 'Processing...' : confirmText}
        </ButtonDestructive>
      ) : (
        <ButtonNormal
          variant="primary"
          size="small"
          className="flex-1"
          onClick={onConfirm}
          disabled={isLoading}
        >
          {isLoading ? 'Processing...' : confirmText}
        </ButtonNormal>
      )}
    </>
  );

  return (
    <Modal
      onClose={onClose}
      title={title}
      icon={icon}
      iconBackgroundColor={iconBackgroundColor}
      actions={actions}
      showActionsSeparator={true}
    >
      <div className="flex flex-col gap-4">
        <p style={{ color: colors['text-secondary'] }} className="text-sm">
          {message}
        </p>
      </div>
    </Modal>
  );
}

/**
 * Creates a deletion confirmation modal with trash icon
 */
export function createDeleteConfirmationModal({
  title = 'Confirm delete',
  message = 'Are you sure you want to delete this item? This action cannot be undone.',
  itemType = 'item',
  onDelete,
  onClose,
  isLoading = false
}: {
  title?: string;
  message?: string;
  itemType?: string;
  onDelete: () => void;
  onClose: () => void;
  isLoading?: boolean;
}) {
  // Use the standard trash icon
  const trashIcon = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-delete.svg`;
  
  return createConfirmationModal({
    title,
    message,
    onConfirm: onDelete,
    onClose,
    confirmText: `Delete ${itemType}`,
    cancelText: 'Cancel',
    icon: trashIcon,
    iconBackgroundColor: '#fee3e1', // Light red for delete actions
    isDestructive: true,
    isLoading
  });
}

/**
 * Creates a password confirmation modal
 */
export function createPasswordConfirmationModal({
  title = 'Confirm with password',
  message = 'Please enter your password to continue.',
  onSubmit,
  onClose,
  errorMessage,
  password,
  setPassword,
  isLoading = false
}: {
  title?: string;
  message?: string;
  onSubmit: () => void;
  onClose: () => void;
  errorMessage?: string | null;
  password: string;
  setPassword: (password: string) => void;
  isLoading?: boolean;
}) {
  const colors = useColors();
  
  const actions = (
    <>
      <ButtonNormal
        variant="secondary"
        size="small"
        className="flex-1"
        onClick={onClose}
        disabled={isLoading}
      >
        Cancel
      </ButtonNormal>
      <ButtonNormal
        variant="primary"
        size="small"
        className="flex-1"
        onClick={onSubmit}
        disabled={!password || isLoading}
      >
        {isLoading ? 'Processing...' : 'Confirm'}
      </ButtonNormal>
    </>
  );

  // Lock icon for password confirmations
  const lockIcon = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/lock-icon.svg`;

  return (
    <Modal
      onClose={onClose}
      title={title}
      icon={lockIcon}
      iconBackgroundColor={colors['bg-secondary']}
      actions={actions}
      showActionsSeparator={true}
    >
      <div className="flex flex-col gap-4">
        <p style={{ color: colors['text-secondary'] }} className="text-sm">
          {message}
        </p>
        
        {/* Password Input Field */}
        <div className="mt-3">
          <input
            type="password"
            placeholder="Enter your password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            className="w-full px-3 py-2 rounded-lg shadow-sm border text-sm"
            style={{ 
              borderColor: colors['border-secondary'],
              backgroundColor: colors['bg-primary'],
              color: colors['text-primary']
            }}
          />
        </div>

        {/* Error Message */}
        {errorMessage && (
          <div className="text-sm" style={{ color: colors['text-error'] }}>
            {errorMessage}
          </div>
        )}
      </div>
    </Modal>
  );
}
</file>

<file path="app/utils/roadmap.ts">
import { generateRoadmapToken } from '@/app/services/roadmapAuth';

export async function redirectToRoadmap(user: any) {
  try {
    const token = await generateRoadmapToken(user);
    if (token) {
      const roadmapUrl = `https://processflow.features.vote/roadmap?token=${token}`;
      window.open(roadmapUrl, '_blank');
    } else {
      window.open('https://processflow.features.vote/roadmap', '_blank');
    }
  } catch (error) {
    console.error('Erreur de redirection roadmap:', error);
    window.open('https://processflow.features.vote/roadmap', '_blank');
  }
}
</file>

<file path="app/utils/sanitize.ts">
/**
 * Basic input sanitizer for email and password fields.
 * Strips leading/trailing whitespace and removes dangerous characters.
 */
export function sanitizeInput(input: string): string {
  // Remove leading/trailing whitespace and control characters
  let sanitized = input.trim().replace(/[\u0000-\u001F\u007F]/g, '');
  // Remove script tags and angle brackets
  sanitized = sanitized.replace(/<.*?>/g, '');
  sanitized = sanitized.replace(/[<>]/g, '');
  return sanitized;
}
</file>

<file path="app/utils/tutorial.ts">
import { User } from '@/types/user';

/**
 * Restart the tutorial for a user by setting their tutorial_completed status to false
 * @param user The current user
 * @returns A Promise that resolves to true if successful
 */
export async function restartTutorial(user: User): Promise<boolean> {
  try {
    if (!user || !user.id) {
      console.error('User ID is required to restart tutorial');
      return false;
    }
    
    // First, clean up any inline styles that might have been applied during the tutorial
    const foldersSection = document.querySelector('[data-testid="folders-section"]');
    if (foldersSection && foldersSection instanceof HTMLElement) {
      foldersSection.style.backgroundColor = '';
    }
    
    const response = await fetch(`/api/user/tutorial-status/${user.id}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        hasCompletedTutorial: false,
      }),
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      console.error('Failed to restart tutorial:', errorData);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error('Error restarting tutorial:', error);
    return false;
  }
}
</file>

<file path="app/utils/updateLastOpened.ts">
export async function updateLastOpened(workflowId: number) {
  try {
    const response = await fetch('/api/workflow/updateLastOpened', {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ workflowId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to update last_opened: ${response.statusText}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error updating last_opened:', error);
    return null;
  }
}
</file>

<file path="app/utils/updateWorkflow.ts">
import { Workflow } from '@/types/workflow';
import { checkWorkflowName } from './checkNames';

export async function updateWorkflow(
  id: number,
  updateData: Partial<Workflow>
): Promise<{ workflow: Workflow | null; error?: { title: string; description: string } }> {
  try {
    // Check name if it's being updated
    if (updateData.name) {
      const nameError = checkWorkflowName(updateData.name);
      if (nameError) {
        return {
          workflow: null,
          error: nameError
        };
      }
    }

    const response = await fetch(`/api/workspace/workflows`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ id, ...updateData }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return {
        workflow: null,
        error: {
          title: 'Error Updating Workflow',
          description: errorData.error || 'Failed to update workflow'
        }
      };
    }

    const updatedWorkflow: Workflow = await response.json();
    if (updateData.signedIconUrl) {
      updatedWorkflow.signedIconUrl = updateData.signedIconUrl;
    } else if (!updateData.icon) {
      updatedWorkflow.signedIconUrl = undefined;
    }
    return { workflow: updatedWorkflow };
  } catch (error) {
    console.error('Error calling update workflow API:', error);
    return {
      workflow: null,
      error: {
        title: 'Error Updating Workflow',
        description: 'An unexpected error occurred'
      }
    };
  }
}
</file>

<file path="app/global-error.tsx">
'use client';

import * as Sentry from '@sentry/nextjs';
import Error from 'next/error';
import { useEffect } from 'react';

export default function GlobalError({ error }: { error: Error }) {
  useEffect(() => {
    Sentry.captureException(error);
  }, [error]);

  return (
    <html>
      <body>{/* Your Error component here... */}</body>
    </html>
  );
}
</file>

<file path="app/globals-fixed.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

html {
  font-family: 'Inter', sans-serif;
}

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap');

/* ========================================
   COMPLETE THEME SYSTEM - ALL COLOR TOKENS
   Performance optimized with data-theme switching
   This restores the complete 388+ token system
   ======================================== */

:root {
  /* Legacy CSS variables for compatibility */
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
  
  /* Input field variables for light mode (legacy compatibility) */
  --input-bg: #fff;
  --input-fg: #101828;
  --input-border: #d0d5dd;
  --input-label: #344054;
}

/* ========================================
   LIGHT THEME (DEFAULT) - ALL TOKENS
   ======================================== */
:root,
[data-theme="light"] {
  /* Text colors */
  --text-primary: #101828;
  --text-primary_on-brand: #ffffff;
  --text-secondary: #344054;
  --text-secondary_hover: #182230;
  --text-secondary_on-brand: #aebbed;
  --text-tertiary: #475467;
  --text-tertiary_hover: #344054;
  --text-tertiary_on-brand: #aebbed;
  --text-quaternary: #667085;
  --text-quaternary_on-brand: #889ce4;
  --text-white: #ffffff;
  --text-disabled: #667085;
  --text-placeholder: #667085;
  --text-placeholder_subtle: #d0d5dd;
  --text-brand-primary: #202e62;
  --text-brand-secondary: #374c99;
  --text-brand-tertiary: #4761c4;
  --text-brand-tertiary_alt: #4761c4;
  --text-error-primary: #d92d20;
  --text-error: #d92d20;
  --text-warning-primary: #dc6803;
  --text-success-primary: #079455;
  --text-accent: #4761c4;

  /* Border colors */
  --border-primary: #d0d5dd;
  --border-secondary: #e4e7ec;
  --border-tertiary: #f2f4f7;
  --border-disabled: #d0d5dd;
  --border-disabled_subtle: #e4e7ec;
  --border-brand: #4e6bd7;
  --border-brand_alt: #4761c4;
  --border-error: #f04438;
  --border-error_subtle: #fda29b;
  --border: #d0d5dd;

  /* Base colors */
  --base-white: #ffffff;
  --base-black: #000000;
  
  /* Foreground colors */
  --fg-primary: #101828;
  --fg-secondary: #344054;
  --fg-secondary_hover: #182230;
  --fg-tertiary: #475467;
  --fg-tertiary_hover: #344054;
  --fg-quaternary: #667085;
  --fg-quaternary_hover: #475467;
  --fg-quinary: #98a2b3;
  --fg-quinary_hover: #667085;
  --fg-senary: #d0d5dd;
  --fg-white: #ffffff;
  --fg-disabled: #98a2b3;
  --fg-disabled_subtle: #d0d5dd;
  --fg-brand-primary: #4761c4;
  --fg-brand-primary_alt: #4761c4;
  --fg-brand-secondary: #4e6bd7;
  --fg-error-primary: #d92d20;
  --fg-error-secondary: #f04438;
  --fg-warning-primary: #dc6803;
  --fg-warning-secondary: #f79009;
  --fg-success-primary: #079455;
  --fg-success-secondary: #17b26a;

  /* Background colors */
  --bg-primary: #ffffff;
  --bg-primary_alt: #ffffff;
  --bg-primary_hover: #f2f4f7;
  --bg-primary-solid: #0c111d;
  --bg-secondary: #f9fafb;
  --bg-secondary_alt: #f9fafb;
  --bg-secondary_hover: #e4e7ec;
  --bg-secondary_subtle: #fcfcfd;
  --bg-secondary-solid: #475467;
  --bg-tertiary: #f2f4f7;
  --bg-quaternary: #e4e7ec;
  --bg-active: #e4e7ec;
  --bg-disabled: #f2f4f7;
  --bg-disabled_subtle: #f9fafb;
  --bg-overlay: #0c111d;
  --bg-brand-primary: #edf0fb;
  --bg-brand-primary_alt: #edf0fb;
  --bg-brand-secondary: #c8d1f3;
  --bg-brand-solid: #4761c4;
  --bg-brand-solid_hover: #374c99;
  --bg-brand-section: #2b3b76;
  --bg-brand-section_subtle: #374c99;
  --bg-error-primary: #fef3f2;
  --bg-error-secondary: #fee4e2;
  --bg-error-solid: #d92d20;
  --bg-warning-primary: #fffaeb;
  --bg-warning-secondary: #fef0c7;
  --bg-warning-solid: #dc6803;
  --bg-success-primary: #ecfdf3;
  --bg-success-secondary: #dcfae6;
  --bg-success-solid: #079455;
  --bg-selected: #e4e7ec;

  /* Button tokens - Primary */
  --button-primary-bg: #4e6bd7;
  --button-primary-fg: #ffffff;
  --button-primary-border: #4e6bd7;
  --button-primary-bg-hover: #4761c4;
  --button-primary-fg-hover: #ffffff;
  --button-primary-border-hover: #4761c4;
  
  /* Button tokens - Secondary */
  --button-secondary-bg: #ffffff;
  --button-secondary-fg: #344054;
  --button-secondary-border: #d0d5dd;
  --button-secondary-bg-hover: #f2f4f7;
  --button-secondary-fg-hover: #182230;
  --button-secondary-border-hover: #d0d5dd;
  
  /* Button tokens - Secondary Color */
  --button-secondary-color-bg: #edf0fb;
  --button-secondary-color-fg: #4e6bd7;
  --button-secondary-color-border: #c8d1f3;
  --button-secondary-color-bg-hover: #c8d1f3;
  --button-secondary-color-fg-hover: #4761c4;
  --button-secondary-color-border-hover: #aebbed;
  
  /* Button tokens - Tertiary */
  --button-tertiary-bg: transparent;
  --button-tertiary-fg: #344054;
  --button-tertiary-border: transparent;
  --button-tertiary-bg-hover: #f2f4f7;
  --button-tertiary-fg-hover: #182230;
  --button-tertiary-border-hover: transparent;
  
  /* Button tokens - Tertiary Color */
  --button-tertiary-color-bg: transparent;
  --button-tertiary-color-fg: #4e6bd7;
  --button-tertiary-color-border: transparent;
  --button-tertiary-color-bg-hover: #edf0fb;
  --button-tertiary-color-fg-hover: #4761c4;
  --button-tertiary-color-border-hover: transparent;
  
  /* Button tokens - Destructive Primary */
  --button-destructive-primary-bg: #d92d20;
  --button-destructive-primary-fg: #ffffff;
  --button-destructive-primary-border: #d92d20;
  --button-destructive-primary-bg-hover: #b42318;
  --button-destructive-primary-fg-hover: #ffffff;
  --button-destructive-primary-border-hover: #b42318;

  /* Button tokens - Destructive Secondary */
  --button-destructive-secondary-bg: #ffffff;
  --button-destructive-secondary-fg: #b42318;
  --button-destructive-secondary-border: #fda29b;
  --button-destructive-secondary-bg-hover: #fef3f2;
  --button-destructive-secondary-fg-hover: #912018;
  --button-destructive-secondary-border-hover: #fda29b;

  /* Button tokens - Destructive Tertiary */
  --button-destructive-tertiary-bg: transparent;
  --button-destructive-tertiary-fg: #b42318;
  --button-destructive-tertiary-border: transparent;
  --button-destructive-tertiary-bg-hover: #fef3f2;
  --button-destructive-tertiary-fg-hover: #912018;
  --button-destructive-tertiary-border-hover: transparent;
  
  /* Button Loading Spinner */
  --button-loading-spinner: #ffffff;

  /* Icon colors */
  --icon-default: #475467;
  --icon-default-hover: #182230;
  --icon-primary: #344054;
  --icon-primary-hover: #101828;
  --icon-secondary: #475467;
  --icon-secondary-hover: #182230;
  --icon-tertiary: #475467;
  --icon-tertiary-hover: #182230;
  --icon-success: #079455;
  --icon-success-hover: #067647;
  --icon-warning: #dc6803;
  --icon-warning-hover: #b54708;
  --icon-error: #d92d20;
  --icon-error-hover: #b42318;
  --icon-info: #4761c4;
  --icon-info-hover: #374c99;

  /* Input field tokens */
  --input-bg: #ffffff;
  --input-fg: #101828;
  --input-border: #d0d5dd;
  --input-bg-hover: #f9fafb;
  --input-fg-hover: #101828;
  --input-border-hover: #d0d5dd;
  --input-bg-focus: #ffffff;
  --input-fg-focus: #101828;
  --input-border-focus: #4761c4;
  --input-placeholder: #667085;
  --input-label: #344054;
  --input-hint: #475467;
  --input-icon: #667085;
  --input-prefix: #667085;

  /* Input destructive */
  --input-destructive-bg: #fef3f2;
  --input-destructive-fg: #101828;
  --input-destructive-border: #fda29b;
  --input-destructive-bg-hover: #fef3f2;
  --input-destructive-fg-hover: #101828;
  --input-destructive-border-hover: #fda29b;
  --input-destructive-bg-focus: #ffffff;
  --input-destructive-fg-focus: #101828;
  --input-destructive-border-focus: #f04438;
  --input-destructive-label: #b42318;
  --input-destructive-hint: #d92d20;
  --input-destructive-icon: #f04438;

  /* Input disabled */
  --input-disabled-bg: #f9fafb;
  --input-disabled-fg: #667085;
  --input-disabled-border: #e4e7ec;
  --input-disabled-placeholder: #667085;
  --input-disabled-label: #667085;

  /* Utility colors - Gray */
  --utility-gray-50: #f9fafb;
  --utility-gray-100: #f2f4f7;
  --utility-gray-200: #e4e7ec;
  --utility-gray-300: #d0d5dd;
  --utility-gray-400: #98a2b3;
  --utility-gray-500: #667085;
  --utility-gray-600: #475467;
  --utility-gray-700: #344054;
  --utility-gray-800: #182230;
  --utility-gray-900: #101828;

  /* Utility colors - Brand */
  --utility-brand-50: #edf0fb;
  --utility-brand-50_alt: #edf0fb;
  --utility-brand-100: #c8d1f3;
  --utility-brand-100_alt: #c8d1f3;
  --utility-brand-200: #aebbed;
  --utility-brand-200_alt: #aebbed;
  --utility-brand-300: #889ce4;
  --utility-brand-300_alt: #889ce4;
  --utility-brand-400: #7189df;
  --utility-brand-400_alt: #7189df;
  --utility-brand-500: #4e6bd7;
  --utility-brand-500_alt: #4e6bd7;
  --utility-brand-600: #4761c4;
  --utility-brand-600_alt: #4761c4;
  --utility-brand-700: #374c99;
  --utility-brand-700_alt: #374c99;
  --utility-brand-800: #2b3b76;
  --utility-brand-800_alt: #2b3b76;
  --utility-brand-900: #202e62;
  --utility-brand-900_alt: #202e62;

  /* Utility colors - Error */
  --utility-error-50: #fef3f2;
  --utility-error-100: #fee4e2;
  --utility-error-200: #fecdca;
  --utility-error-300: #fda29b;
  --utility-error-400: #f97066;
  --utility-error-500: #f04438;
  --utility-error-600: #d92d20;
  --utility-error-700: #b42318;

  /* Utility colors - Warning */
  --utility-warning-50: #fffaeb;
  --utility-warning-100: #fef0c7;
  --utility-warning-200: #fedf89;
  --utility-warning-300: #fec84b;
  --utility-warning-400: #fdb022;
  --utility-warning-500: #f79009;
  --utility-warning-600: #dc6803;
  --utility-warning-700: #b54708;

  /* Utility colors - Success */
  --utility-success-50: #ecfdf3;
  --utility-success-100: #dcfae6;
  --utility-success-200: #abefc6;
  --utility-success-300: #75e0a7;
  --utility-success-400: #47cd89;
  --utility-success-500: #17b26a;
  --utility-success-600: #079455;
  --utility-success-700: #067647;

  /* Additional utility colors */
  --utility-gray-blue-50: #f8f9fc;
  --utility-gray-blue-100: #eaecf5;
  --utility-gray-blue-200: #d5d9eb;
  --utility-gray-blue-300: #b3b8db;
  --utility-gray-blue-400: #717bbc;
  --utility-gray-blue-500: #4e5ba6;
  --utility-gray-blue-600: #3e4784;
  --utility-gray-blue-700: #363f72;

  --utility-blue-light-50: #f3fee7;
  --utility-blue-light-100: #e3fbcc;
  --utility-blue-light-200: #d0f8ab;
  --utility-blue-light-300: #a6ef67;
  --utility-blue-light-400: #85e13a;
  --utility-blue-light-500: #66c61c;
  --utility-blue-light-600: #4ca30d;
  --utility-blue-light-700: #3b7c0f;

  --utility-blue-50: #f0fdf9;
  --utility-blue-100: #ccfbef;
  --utility-blue-200: #99f6e0;
  --utility-blue-300: #5fe9d0;
  --utility-blue-400: #2dd4bf;
  --utility-blue-500: #14b8a6;
  --utility-blue-600: #0d9488;
  --utility-blue-700: #0f766e;

  --utility-blue-dark-50: #f0f9ff;
  --utility-blue-dark-100: #e0f2fe;
  --utility-blue-dark-200: #bae6fd;
  --utility-blue-dark-300: #7dd3fc;
  --utility-blue-dark-400: #38bdf8;
  --utility-blue-dark-500: #0ea5e9;
  --utility-blue-dark-600: #0284c7;
  --utility-blue-dark-700: #0369a1;

  --utility-indigo-50: #eef2ff;
  --utility-indigo-100: #e0e7ff;
  --utility-indigo-200: #c7d2fe;
  --utility-indigo-300: #a5b4fc;
  --utility-indigo-400: #818cf8;
  --utility-indigo-500: #6366f1;
  --utility-indigo-600: #4f46e5;
  --utility-indigo-700: #4338ca;

  --utility-purple-50: #faf5ff;
  --utility-purple-100: #f3e8ff;
  --utility-purple-200: #e9d5ff;
  --utility-purple-300: #d8b4fe;
  --utility-purple-400: #c084fc;
  --utility-purple-500: #a855f7;
  --utility-purple-600: #9333ea;
  --utility-purple-700: #7c3aed;

  --utility-fuchsia-50: #fdf4ff;
  --utility-fuchsia-100: #fae8ff;
  --utility-fuchsia-200: #f5d0fe;
  --utility-fuchsia-300: #f0abfc;
  --utility-fuchsia-400: #e879f9;
  --utility-fuchsia-500: #d946ef;
  --utility-fuchsia-600: #c026d3;
  --utility-fuchsia-700: #a21caf;

  --utility-pink-50: #fdf2f8;
  --utility-pink-100: #fce7f3;
  --utility-pink-200: #fbcfe8;
  --utility-pink-300: #f9a8d4;
  --utility-pink-400: #f472b6;
  --utility-pink-500: #ec4899;
  --utility-pink-600: #db2777;
  --utility-pink-700: #be185d;

  --utility-orange-dark-50: #fff7ed;
  --utility-orange-dark-100: #ffedd5;
  --utility-orange-dark-200: #fed7aa;
  --utility-orange-dark-300: #fdba74;
  --utility-orange-dark-400: #fb923c;
  --utility-orange-dark-500: #f97316;
  --utility-orange-dark-600: #ea580c;
  --utility-orange-dark-700: #c2410c;

  --utility-orange-50: #fff7ed;
  --utility-orange-100: #ffedd5;
  --utility-orange-200: #fed7aa;
  --utility-orange-300: #fdba74;
  --utility-orange-400: #fb923c;
  --utility-orange-500: #f97316;
  --utility-orange-600: #ea580c;
  --utility-orange-700: #c2410c;

  /* Alpha colors */
  --alpha-white-10: rgba(255, 255, 255, 0.10);
  --alpha-white-20: rgba(255, 255, 255, 0.20);
  --alpha-white-30: rgba(255, 255, 255, 0.30);
  --alpha-white-40: rgba(255, 255, 255, 0.40);
  --alpha-white-50: rgba(255, 255, 255, 0.50);
  --alpha-white-60: rgba(255, 255, 255, 0.60);
  --alpha-white-70: rgba(255, 255, 255, 0.70);
  --alpha-white-80: rgba(255, 255, 255, 0.80);
  --alpha-white-90: rgba(255, 255, 255, 0.90);
  --alpha-white-100: #ffffff;
  --alpha-black-10: rgba(0, 0, 0, 0.10);
  --alpha-black-20: rgba(0, 0, 0, 0.20);
  --alpha-black-30: rgba(0, 0, 0, 0.30);
  --alpha-black-40: rgba(0, 0, 0, 0.40);
  --alpha-black-50: rgba(0, 0, 0, 0.50);
  --alpha-black-60: rgba(0, 0, 0, 0.60);
  --alpha-black-70: rgba(0, 0, 0, 0.70);
  --alpha-black-80: rgba(0, 0, 0, 0.80);
  --alpha-black-90: rgba(0, 0, 0, 0.90);
  --alpha-black-100: #000000;

  /* Shadow colors */
  --shadow-xs: rgba(16, 24, 40, 0.05);
  --shadow-sm_01: rgba(16, 24, 40, 0.10);
  --shadow-sm_02: rgba(16, 24, 40, 0.06);
  --shadow-md_01: rgba(16, 24, 40, 0.10);
  --shadow-md_02: rgba(16, 24, 40, 0.06);
  --shadow-lg_01: rgba(16, 24, 40, 0.08);
  --shadow-lg_02: rgba(16, 24, 40, 0.03);
  --shadow-xl_01: rgba(16, 24, 40, 0.08);
  --shadow-xl_02: rgba(16, 24, 40, 0.03);
  --shadow-2xl: rgba(16, 24, 40, 0.18);
  --shadow-3xl: rgba(16, 24, 40, 0.14);
  --shadow-skeumorphic-inner: rgba(16, 24, 40, 0.05);
  --shadow-skeumorphic-inner-border: rgba(16, 24, 40, 0.18);
  --shadow-main-centre-md: rgba(16, 24, 40, 0.14);
  --shadow-main-centre-lg: rgba(16, 24, 40, 0.18);
  --shadow-overlay-lg: rgba(16, 24, 40, 0.12);
  --shadow-grid-md: rgba(16, 24, 40, 0.08);

  /* Miscellaneous tokens */
  --app-store-badge-border: #a6a6a6;
  --social-icon-fg-x: #242e36;
  --social-icon-fg-instagram: #000100;
  --social-icon-fg-apple: #000000;
  --social-icon-fg-github: #000000;
  --social-icon-fg-angellist: #000000;
  --social-icon-fg-tumblr: #001935;
  --screen-mockup-border: #101828;
  --slider-handle-bg: #ffffff;
  --slider-handle-border: #4761c4;
  --thumbnail-badge-brand-fg: #374c99;
  --thumbnail-badge-success-fg: #067647;
  --toggle-button-fg_disabled: #f9fafb;
  --tooltip-supporting-text: #d0d5dd;
  --wysiwyg-editor-icon-fg: #98a2b3;
  --wysiwyg-editor-icon-fg_active: #667085;

  /* Breadcrumb tokens */
  --breadcrumb-active-bg: #edf0fb;
  --breadcrumb-active-fg: #374c99;
  --breadcrumb-inactive-fg: #475467;
  --breadcrumb-separator: #98a2b3;
  --breadcrumb-hover-opacity: 0.75;

  /* Accent colors */
  --accent-primary: #4761c4;
}

/* ========================================
   DARK THEME - ALL TOKENS
   ======================================== */
[data-theme="dark"] {
  /* Text colors */
  --text-primary: #ffffff;
  --text-primary_on-brand: #f5f5f6;
  --text-secondary: #cecfd2;
  --text-secondary_hover: #ececed;
  --text-secondary_on-brand: #cecfd2;
  --text-tertiary: #94969c;
  --text-tertiary_hover: #cecfd2;
  --text-tertiary_on-brand: #94969c;
  --text-quaternary: #94969c;
  --text-quaternary_on-brand: #94969c;
  --text-white: #ffffff;
  --text-disabled: #85888e;
  --text-placeholder: #85888e;
  --text-placeholder_subtle: #333741;
  --text-brand-primary: #f0f1f1;
  --text-brand-secondary: #cecfd2;
  --text-brand-tertiary: #94969c;
  --text-brand-tertiary_alt: #f5f5f6;
  --text-error-primary: #f97066;
  --text-error: #f97066;
  --text-warning-primary: #fdb022;
  --text-success-primary: #47cd89;
  --text-accent: #4761c4;

  /* Border colors */
  --border-primary: #333741;
  --border-secondary: #1f242f;
  --border-tertiary: #1f242f;
  --border-disabled: #333741;
  --border-disabled_subtle: #1f242f;
  --border-brand: #f97066;
  --border-brand_alt: #333741;
  --border-error: #f97066;
  --border-error_subtle: #f97066;
  --border: #333741;

  /* Base colors */
  --base-white: #000000;
  --base-black: #ffffff;

  /* Foreground colors */
  --fg-primary: #ffffff;
  --fg-secondary: #cecfd2;
  --fg-secondary_hover: #ececed;
  --fg-tertiary: #94969c;
  --fg-tertiary_hover: #cecfd2;
  --fg-quaternary: #94969c;
  --fg-quaternary_hover: #cecfd2;
  --fg-quinary: #85888e;
  --fg-quinary_hover: #94969c;
  --fg-senary: #61646c;
  --fg-white: #ffffff;
  --fg-disabled: #85888e;
  --fg-disabled_subtle: #61646c;
  --fg-brand-primary: #4e6bd7;
  --fg-brand-primary_alt: #cecfd2;
  --fg-brand-secondary: #4e6bd7;
  --fg-error-primary: #f04438;
  --fg-error-secondary: #f97066;
  --fg-warning-primary: #f79009;
  --fg-warning-secondary: #fdb022;
  --fg-success-primary: #17b26a;
  --fg-success-secondary: #47cd89;

  /* Background colors */
  --bg-primary: #0c111d;
  --bg-primary_alt: #161b26;
  --bg-primary_hover: #1f242f;
  --bg-primary-solid: #161b26;
  --bg-secondary: #161b26;
  --bg-secondary_alt: #1f242f;
  --bg-secondary_hover: #1f242f;
  --bg-secondary_subtle: #161b26;
  --bg-secondary-solid: #61646c;
  --bg-tertiary: #1f242f;
  --bg-quaternary: #333741;
  --bg-active: #1f242f;
  --bg-disabled: #1f242f;
  --bg-disabled_subtle: #161b26;
  --bg-overlay: #1f242f;
  --bg-brand-primary: #4e6bd7;
  --bg-brand-primary_alt: #161b26;
  --bg-brand-secondary: #4761c4;
  --bg-brand-solid: #4761c4;
  --bg-brand-solid_hover: #4e6bd7;
  --bg-brand-section: #161b26;
  --bg-brand-section_subtle: #1f242f;
  --bg-error-primary: #f04438;
  --bg-error-secondary: #d92d20;
  --bg-error-solid: #d92d20;
  --bg-warning-primary: #f79009;
  --bg-warning-secondary: #dc6803;
  --bg-warning-solid: #dc6803;
  --bg-success-primary: #17b26a;
  --bg-success-secondary: #079455;
  --bg-success-solid: #079455;
  --bg-selected: #333741;

  /* Button tokens - Primary */
  --button-primary-fg: #ffffff;
  --button-primary-fg-hover: #ffffff;
  --button-primary-bg: #4e6bd7;
  --button-primary-bg-hover: #374c99;
  --button-primary-border: #4e6bd7;
  --button-primary-border-hover: #374c99;

  /* Button tokens - Secondary */
  --button-secondary-fg: #cecfd2;
  --button-secondary-fg-hover: #f0f1f1;
  --button-secondary-bg: #161b26;
  --button-secondary-bg-hover: #1f242f;
  --button-secondary-border: #333741;
  --button-secondary-border-hover: #333741;
  
  /* Button tokens - Secondary Color */
  --button-secondary-color-fg: #cecfd2;
  --button-secondary-color-fg-hover: #f0f1f1;
  --button-secondary-color-bg: #161b26;
  --button-secondary-color-bg-hover: #1f242f;
  --button-secondary-color-border: #333741;
  --button-secondary-color-border-hover: #333741;
  
  /* Button tokens - Tertiary */
  --button-tertiary-bg: transparent;
  --button-tertiary-fg: #94969c;
  --button-tertiary-fg-hover: #ececed;
  --button-tertiary-border: transparent;
  --button-tertiary-bg-hover: #1f242f;
  --button-tertiary-border-hover: transparent;
  
  /* Button tokens - Tertiary Color */
  --button-tertiary-color-bg: transparent;
  --button-tertiary-color-fg: #cecfd2;
  --button-tertiary-color-fg-hover: #f0f1f1;
  --button-tertiary-color-border: transparent;
  --button-tertiary-color-bg-hover: #1f242f;
  --button-tertiary-color-border-hover: transparent;
  
  /* Button tokens - Destructive Primary */
  --button-destructive-primary-bg: #d92d20;
  --button-destructive-primary-fg: #ffffff;
  --button-destructive-primary-border: #f97066;
  --button-destructive-primary-bg-hover: #b42318;
  --button-destructive-primary-fg-hover: #ffffff;
  --button-destructive-primary-border-hover: #f97066;

  /* Button tokens - Destructive Secondary */
  --button-destructive-secondary-bg: #55160c;
  --button-destructive-secondary-fg: #fecdca;
  --button-destructive-secondary-border: #912018;
  --button-destructive-secondary-bg-hover: #7a271a;
  --button-destructive-secondary-fg-hover: #fee4e2;
  --button-destructive-secondary-border-hover: #b42318;

  /* Button tokens - Destructive Tertiary */
  --button-destructive-tertiary-bg: transparent;
  --button-destructive-tertiary-fg: #fda29b;
  --button-destructive-tertiary-border: transparent;
  --button-destructive-tertiary-bg-hover: #7a271a;
  --button-destructive-tertiary-fg-hover: #fecdca;
  --button-destructive-tertiary-border-hover: transparent;
  
  /* Button Loading Spinner */
  --button-loading-spinner: #ffffff;

  /* Icon colors */
  --icon-default: #94969c;
  --icon-default-hover: #ececed;
  --icon-primary: #cecfd2;
  --icon-primary-hover: #f0f1f1;
  --icon-secondary: #94969c;
  --icon-secondary-hover: #ececed;
  --icon-tertiary: #94969c;
  --icon-tertiary-hover: #ececed;
  --icon-success: #47cd89;
  --icon-success-hover: #75e0a7;
  --icon-warning: #fdb022;
  --icon-warning-hover: #fec84b;
  --icon-error: #f97066;
  --icon-error-hover: #fda29b;
  --icon-info: #f97066;
  --icon-info-hover: #fda29b;

  /* Dark mode media query overrides (legacy compatibility) */
  --foreground-rgb: 255, 255, 255;
  --background-start-rgb: 0, 0, 0;
  --background-end-rgb: 0, 0, 0;
  --input-bg: #181a20;
  --input-fg: #fff;
  --input-border: #23262f;
  --input-label: #a3a3a3;

  /* Accent colors */
  --accent-primary: #4761c4;

  /* Breadcrumb colors */
  --breadcrumb-inactive-fg: #94969c;
  --breadcrumb-separator: #85888e;
  --breadcrumb-active-fg: #ffffff;
  --breadcrumb-active-bg: #4761c4;

  /* Update utility colors for dark theme */
  --utility-gray-50: #f5f5f6;
  --utility-gray-100: #f0f1f1;
  --utility-gray-200: #ececed;
  --utility-gray-300: #cecfd2;
  --utility-gray-400: #94969c;
  --utility-gray-500: #85888e;
  --utility-gray-600: #61646c;
  --utility-gray-700: #333741;
  --utility-gray-800: #1f242f;
  --utility-gray-900: #161b26;
}

/* ========================================
   OPTIMIZED PERFORMANCE
   ======================================== */

/* Minimal transitions - only where absolutely necessary */
body {
  font-family: 'Inter', sans-serif;
  color: var(--text-primary);
  background-color: var(--bg-primary);
  transition: background-color 150ms ease, color 150ms ease;
}

/* Theme transition class for components that absolutely need smooth transitions */
.theme-transition {
  transition: 
    background-color 150ms ease,
    color 150ms ease,
    border-color 150ms ease;
}

/* Performance: disable transitions on performance-sensitive elements */
svg, svg *,
canvas,
video,
.no-transition,
[data-no-transition="true"],
.react-flow__node,
.react-flow__edge {
  transition: none !important;
}

/* ========================================
   COMPONENT STYLES USING CSS VARIABLES
   ======================================== */

/* Button component styles */
.btn-primary {
  background-color: var(--button-primary-bg);
  color: var(--button-primary-fg);
  border-color: var(--button-primary-border);
}

.btn-primary:hover {
  background-color: var(--button-primary-bg-hover);
  color: var(--button-primary-fg-hover);
  border-color: var(--button-primary-border-hover);
}

.btn-secondary {
  background-color: var(--button-secondary-bg);
  color: var(--button-secondary-fg);
  border-color: var(--button-secondary-border);
}

.btn-secondary:hover {
  background-color: var(--button-secondary-bg-hover);
  color: var(--button-secondary-fg-hover);
  border-color: var(--button-secondary-border-hover);
}

.btn-tertiary {
  background-color: var(--button-tertiary-bg);
  color: var(--button-tertiary-fg);
  border-color: var(--button-tertiary-border);
}

.btn-tertiary:hover {
  background-color: var(--button-tertiary-bg-hover);
  color: var(--button-tertiary-fg-hover);
  border-color: var(--button-tertiary-border-hover);
}

/* Input field styles */
.input-field {
  background-color: var(--input-bg);
  color: var(--input-fg);
  border-color: var(--input-border);
}

.input-field:focus {
  border-color: var(--input-border-focus, var(--border-brand));
}

.input-field::placeholder {
  color: var(--input-placeholder);
}

.input-label {
  color: var(--input-label);
}

/* Card styles */
.card {
  background-color: var(--bg-primary);
  border-color: var(--border-secondary);
}

.card-secondary {
  background-color: var(--bg-secondary);
}

/* Icon styles */
.icon-default {
  color: var(--icon-default);
}

.icon-primary {
  color: var(--icon-primary);
}

.icon-secondary {
  color: var(--icon-secondary);
}

/* ========================================
   LEGACY STYLES (PRESERVED)
   ======================================== */

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
    --input-bg: #181a20;
    --input-fg: #fff;
    --input-border: #23262f;
    --input-label: #a3a3a3;
  }
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

/* Apple-style scrollbar that uses theme colors */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-thumb {
  background: var(--border-primary);
  border-radius: 10px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--border-secondary);
}

::-webkit-scrollbar-track {
  background: transparent;
}

/* Dark mode scrollbar adjustments */
[data-theme="dark"] ::-webkit-scrollbar-thumb {
  background: var(--border-primary);
}

[data-theme="dark"] ::-webkit-scrollbar-thumb:hover {
  background: var(--border-secondary);
}

/* User selection controls */
* {
  -webkit-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

input, textarea {
  -webkit-user-select: text;
  -ms-user-select: text;
  user-select: text;
}

/* ========================================
   DRAG AND DROP STYLES
   ======================================== */

.drag-handle {
  cursor: grab;
  position: relative;
}

.dragging {
  z-index: 9999;
}

[data-id].drag-over-as-child {
  background-color: rgba(73, 131, 247, 0.1);
  border-radius: 8px;
  border: 2px solid rgba(73, 131, 247, 0.4);
  position: relative;
  box-shadow: inset 0 0 0 1px rgba(73, 131, 247, 0.2);
}

[data-id].drag-over-as-child::before {
  content: "";
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px;
  height: 16px;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%234761C4' width='24' height='24'%3E%3Cpath d='M4 20q-.825 0-1.413-.588T2 18V6q0-.825.588-1.413T4 4h6l2 2h8q.825 0 1.413.588T22 8v10q0 .825-.588 1.413T20 20H4Z'/%3E%3C/svg%3E");
  background-size: contain;
  background-repeat: no-repeat;
  opacity: 0.5;
}

[data-id].drag-over-as-sibling-before {
  border-top: 2px solid rgba(73, 131, 247, 0.8);
  position: relative;
}

[data-id].drag-over-as-sibling-after {
  border-bottom: 2px solid rgba(73, 131, 247, 0.8);
  position: relative;
}

[data-id][data-has-children="true"] {
  transition: background-color 0.2s ease;
}

.dnd-active [data-id][data-has-children="true"]:hover {
  background-color: rgba(73, 131, 247, 0.05);
}

@keyframes folder-expanding-pulse {
  0% { box-shadow: 0 0 0 0 rgba(73, 131, 247, 0.2); }
  70% { box-shadow: 0 0 0 5px rgba(73, 131, 247, 0); }
  100% { box-shadow: 0 0 0 0 rgba(73, 131, 247, 0); }
}

.folder-expanding {
  animation: folder-expanding-pulse 1.5s infinite;
  background-color: rgba(73, 131, 247, 0.08) !important;
}

/* ========================================
   FORCE LIGHT THEME (ONBOARDING)
   ======================================== */

.force-light-theme,
.force-light-theme *,
.force-light-theme.dark,
html.force-light-theme,
html.force-light-theme *,
body.force-light-theme,
body.force-light-theme * {
  --text-primary: #101828 !important;
  --text-secondary: #344054 !important;
  --bg-primary: #ffffff !important;
  --bg-secondary: #f9fafb !important;
  --border-primary: #d0d5dd !important;
  --button-primary-bg: #4761c4 !important;
  --button-primary-fg: #fff !important;
  --button-primary-border: #4761c4 !important;
  --button-primary-bg-hover: #3246a8 !important;
  --button-primary-fg-hover: #fff !important;
  --button-primary-border-hover: #3246a8 !important;
  --button-secondary-bg: #fff !important;
  --button-secondary-fg: #101828 !important;
  --button-secondary-border: #d0d5dd !important;
  --button-secondary-bg-hover: #f4f4f5 !important;
  --button-secondary-fg-hover: #101828 !important;
  --button-secondary-border-hover: #bfc5d2 !important;
}

.force-light-theme .dark,
.force-light-theme.dark {
  background-color: #fff !important;
  color: #101828 !important;
}

.force-light-theme ::-webkit-scrollbar-thumb {
  background: #d0d5dd !important;
}

.force-light-theme ::-webkit-scrollbar-thumb:hover {
  background: #98a2b3 !important;
}
</file>

<file path="app/globals-optimized.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

html {
  font-family: 'Inter', sans-serif;
}

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap');

/* ========================================
   OPTIMIZED THEME SYSTEM - MINIMAL CSS VARIABLES
   ======================================== */

:root {
  /* Only essential CSS variables for best performance */
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

/* Light theme (default) */
:root,
[data-theme="light"] {
  /* Essential colors only - keep under 20 variables for performance */
  --text-primary: #101828;
  --text-secondary: #344054;
  --text-tertiary: #475467;
  --text-white: #ffffff;
  --text-disabled: #667085;
  
  --bg-primary: #ffffff;
  --bg-primary-solid: #0c111d;
  --bg-secondary: #f9fafb;
  --bg-tertiary: #f2f4f7;
  --bg-disabled: #f2f4f7;
  
  --border-primary: #d0d5dd;
  --border-secondary: #e4e7ec;
  
  --brand-primary: #4761c4;
  --brand-secondary: #4e6bd7;
  --brand-light: #edf0fb;
  
  --fg-brand-primary: #4761c4;
  
  --error-primary: #d92d20;
  --error-light: #fef3f2;
  
  --warning-primary: #dc6803;
  --warning-light: #fffaeb;
  
  --success-primary: #079455;
  --success-light: #ecfdf3;
}

/* Dark theme */
[data-theme="dark"] {
  --text-primary: #f5f5f6;
  --text-secondary: #cecfd2;
  --text-tertiary: #94969c;
  --text-white: #ffffff;
  --text-disabled: #85888e;
  
  --bg-primary: #0c111d;
  --bg-primary-solid: #0c111d;
  --bg-secondary: #161b26;
  --bg-tertiary: #1f242f;
  --bg-disabled: #1f242f;
  
  --border-primary: #333741;
  --border-secondary: #1f242f;
  
  --brand-primary: #4761c4;
  --brand-secondary: #4e6bd7;
  --brand-light: #161b26;
  
  --fg-brand-primary: #4761c4;
  
  --error-primary: #d92d20;
  --error-light: #161b26;
  
  --warning-primary: #dc6803;
  --warning-light: #161b26;
  
  --success-primary: #079455;
  --success-light: #161b26;
}

/* Optimized transitions - only on body for best performance */
body {
  font-family: 'Inter', sans-serif;
  color: var(--text-primary);
  background-color: var(--bg-primary);
  transition: background-color 150ms ease, color 150ms ease;
}

/* Theme transition class for components that absolutely need it */
.theme-transition {
  transition: 
    background-color 150ms ease,
    color 150ms ease,
    border-color 150ms ease;
}

/* No transitions for performance-sensitive elements */
svg, svg *,
canvas,
video,
.no-transition,
[data-no-transition="true"] {
  transition: none !important;
}

/* ========================================
   COMPONENT STYLES USING CSS VARIABLES
   ======================================== */

/* Button styles */
.btn-primary {
  background-color: var(--brand-primary);
  color: var(--text-white);
  border-color: var(--brand-primary);
}

.btn-primary:hover {
  background-color: var(--brand-secondary);
  border-color: var(--brand-secondary);
}

.btn-secondary {
  background-color: var(--bg-primary);
  color: var(--text-primary);
  border-color: var(--border-primary);
}

.btn-secondary:hover {
  background-color: var(--bg-tertiary);
}

/* Input styles */
.input-field {
  background-color: var(--bg-primary);
  color: var(--text-primary);
  border-color: var(--border-primary);
}

.input-field:focus {
  border-color: var(--brand-primary);
}

.input-field::placeholder {
  color: var(--text-disabled);
}

/* Card styles */
.card {
  background-color: var(--bg-primary);
  border-color: var(--border-secondary);
}

.card-secondary {
  background-color: var(--bg-secondary);
}

/* ========================================
   EXISTING STYLES (UNCHANGED)
   ======================================== */

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

/* Apple-style scrollbar */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-thumb {
  background: var(--border-primary);
  border-radius: 10px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--text-disabled);
}

::-webkit-scrollbar-track {
  background: transparent;
}

* {
  -webkit-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/* Allow text selection only in input fields and textareas */
input, textarea {
  -webkit-user-select: text;
  -ms-user-select: text;
  user-select: text;
}

/* Drag and Drop Styles */
.drag-handle {
  cursor: grab;
  position: relative;
}

.dragging {
  z-index: 9999;
}

[data-id].drag-over-as-child {
  background-color: rgba(73, 131, 247, 0.1);
  border-radius: 8px;
  border: 2px solid rgba(73, 131, 247, 0.4);
  position: relative;
  box-shadow: inset 0 0 0 1px rgba(73, 131, 247, 0.2);
}

[data-id].drag-over-as-child::before {
  content: "";
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px;
  height: 16px;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%234761C4' width='24' height='24'%3E%3Cpath d='M4 20q-.825 0-1.413-.588T2 18V6q0-.825.588-1.413T4 4h6l2 2h8q.825 0 1.413.588T22 8v10q0 .825-.588 1.413T20 20H4Z'/%3E%3C/svg%3E");
  background-size: contain;
  background-repeat: no-repeat;
  opacity: 0.5;
}

[data-id].drag-over-as-sibling-before {
  border-top: 2px solid rgba(73, 131, 247, 0.8);
  position: relative;
}

[data-id].drag-over-as-sibling-after {
  border-bottom: 2px solid rgba(73, 131, 247, 0.8);
  position: relative;
}

[data-id][data-has-children="true"] {
  transition: background-color 0.2s ease;
}

.dnd-active [data-id][data-has-children="true"]:hover {
  background-color: rgba(73, 131, 247, 0.05);
}

@keyframes folder-expanding-pulse {
  0% { box-shadow: 0 0 0 0 rgba(73, 131, 247, 0.2); }
  70% { box-shadow: 0 0 0 5px rgba(73, 131, 247, 0); }
  100% { box-shadow: 0 0 0 0 rgba(73, 131, 247, 0); }
}

.folder-expanding {
  animation: folder-expanding-pulse 1.5s infinite;
  background-color: rgba(73, 131, 247, 0.08) !important;
}

/* Force light theme styles */
.force-light-theme,
.force-light-theme *,
.force-light-theme.dark,
html.force-light-theme,
html.force-light-theme *,
body.force-light-theme,
body.force-light-theme * {
  --text-primary: #101828 !important;
  --text-secondary: #344054 !important;
  --bg-primary: #ffffff !important;
  --bg-secondary: #f9fafb !important;
  --border-primary: #d0d5dd !important;
  --brand-primary: #4761c4 !important;
}

.force-light-theme .dark,
.force-light-theme.dark {
  background-color: #fff !important;
  color: #101828 !important;
}

.force-light-theme ::-webkit-scrollbar-thumb {
  background: #d0d5dd !important;
}

.force-light-theme ::-webkit-scrollbar-thumb:hover {
  background: #98a2b3 !important;
}
</file>

<file path="app/globals-theme-fixed.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

html {
  font-family: 'Inter', sans-serif;
}

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap');

/* ========================================
   COMPLETE THEME SYSTEM - ALL COLOR TOKENS
   Performance optimized with data-theme switching
   This restores the complete 388+ token system
   ======================================== */

:root {
  /* Legacy CSS variables for compatibility */
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
  
  /* Input field variables for light mode (legacy compatibility) */
  --input-bg: #fff;
  --input-fg: #101828;
  --input-border: #d0d5dd;
  --input-label: #344054;
}

/* ========================================
   LIGHT THEME (DEFAULT) - ALL TOKENS
   ======================================== */
:root,
[data-theme="light"] {
  /* Text colors */
  --text-primary: #101828;
  --text-primary_on-brand: #ffffff;
  --text-secondary: #344054;
  --text-secondary_hover: #182230;
  --text-secondary_on-brand: #aebbed;
  --text-tertiary: #475467;
  --text-tertiary_hover: #344054;
  --text-tertiary_on-brand: #aebbed;
  --text-quaternary: #667085;
  --text-quaternary_on-brand: #889ce4;
  --text-white: #ffffff;
  --text-disabled: #667085;
  --text-placeholder: #667085;
  --text-placeholder_subtle: #d0d5dd;
  --text-brand-primary: #202e62;
  --text-brand-secondary: #374c99;
  --text-brand-tertiary: #4761c4;
  --text-brand-tertiary_alt: #4761c4;
  --text-error-primary: #d92d20;
  --text-error: #d92d20;
  --text-warning-primary: #dc6803;
  --text-success-primary: #079455;
  --text-accent: #4761c4;

  /* Border colors */
  --border-primary: #d0d5dd;
  --border-secondary: #e4e7ec;
  --border-tertiary: #f2f4f7;
  --border-disabled: #d0d5dd;
  --border-disabled_subtle: #e4e7ec;
  --border-brand: #4e6bd7;
  --border-brand_alt: #4761c4;
  --border-error: #f04438;
  --border-error_subtle: #fda29b;
  --border: #d0d5dd;

  /* Base colors */
  --base-white: #ffffff;
  --base-black: #000000;
  
  /* Foreground colors */
  --fg-primary: #101828;
  --fg-secondary: #344054;
  --fg-secondary_hover: #182230;
  --fg-tertiary: #475467;
  --fg-tertiary_hover: #344054;
  --fg-quaternary: #667085;
  --fg-quaternary_hover: #475467;
  --fg-quinary: #98a2b3;
  --fg-quinary_hover: #667085;
  --fg-senary: #d0d5dd;
  --fg-white: #ffffff;
  --fg-disabled: #98a2b3;
  --fg-disabled_subtle: #d0d5dd;
  --fg-brand-primary: #4761c4;
  --fg-brand-primary_alt: #4761c4;
  --fg-brand-secondary: #4e6bd7;
  --fg-error-primary: #d92d20;
  --fg-error-secondary: #f04438;
  --fg-warning-primary: #dc6803;
  --fg-warning-secondary: #f79009;
  --fg-success-primary: #079455;
  --fg-success-secondary: #17b26a;

  /* Background colors */
  --bg-primary: #ffffff;
  --bg-primary_alt: #ffffff;
  --bg-primary_hover: #f2f4f7;
  --bg-primary-solid: #0c111d;
  --bg-secondary: #f9fafb;
  --bg-secondary_alt: #f9fafb;
  --bg-secondary_hover: #e4e7ec;
  --bg-secondary_subtle: #fcfcfd;
  --bg-secondary-solid: #475467;
  --bg-tertiary: #f2f4f7;
  --bg-quaternary: #e4e7ec;
  --bg-active: #e4e7ec;
  --bg-disabled: #f2f4f7;
  --bg-disabled_subtle: #f9fafb;
  --bg-overlay: #0c111d;
  --bg-brand-primary: #edf0fb;
  --bg-brand-primary_alt: #edf0fb;
  --bg-brand-secondary: #c8d1f3;
  --bg-brand-solid: #4761c4;
  --bg-brand-solid_hover: #374c99;
  --bg-brand-section: #2b3b76;
  --bg-brand-section_subtle: #374c99;
  --bg-error-primary: #fef3f2;
  --bg-error-secondary: #fee4e2;
  --bg-error-solid: #d92d20;
  --bg-warning-primary: #fffaeb;
  --bg-warning-secondary: #fef0c7;
  --bg-warning-solid: #dc6803;
  --bg-success-primary: #ecfdf3;
  --bg-success-secondary: #dcfae6;
  --bg-success-solid: #079455;
  --bg-selected: #e4e7ec;

  /* Button tokens - Primary */
  --button-primary-bg: #4e6bd7;
  --button-primary-fg: #ffffff;
  --button-primary-border: #4e6bd7;
  --button-primary-bg-hover: #4761c4;
  --button-primary-fg-hover: #ffffff;
  --button-primary-border-hover: #4761c4;
  
  /* Button tokens - Secondary */
  --button-secondary-bg: #ffffff;
  --button-secondary-fg: #344054;
  --button-secondary-border: #d0d5dd;
  --button-secondary-bg-hover: #f2f4f7;
  --button-secondary-fg-hover: #182230;
  --button-secondary-border-hover: #d0d5dd;
  
  /* Button tokens - Secondary Color */
  --button-secondary-color-bg: #edf0fb;
  --button-secondary-color-fg: #4e6bd7;
  --button-secondary-color-border: #c8d1f3;
  --button-secondary-color-bg-hover: #c8d1f3;
  --button-secondary-color-fg-hover: #4761c4;
  --button-secondary-color-border-hover: #aebbed;
  
  /* Button tokens - Tertiary */
  --button-tertiary-bg: transparent;
  --button-tertiary-fg: #344054;
  --button-tertiary-border: transparent;
  --button-tertiary-bg-hover: #f2f4f7;
  --button-tertiary-fg-hover: #182230;
  --button-tertiary-border-hover: transparent;
  
  /* Button tokens - Tertiary Color */
  --button-tertiary-color-bg: transparent;
  --button-tertiary-color-fg: #4e6bd7;
  --button-tertiary-color-border: transparent;
  --button-tertiary-color-bg-hover: #edf0fb;
  --button-tertiary-color-fg-hover: #4761c4;
  --button-tertiary-color-border-hover: transparent;
  
  /* Button tokens - Destructive Primary */
  --button-destructive-primary-bg: #d92d20;
  --button-destructive-primary-fg: #ffffff;
  --button-destructive-primary-border: #d92d20;
  --button-destructive-primary-bg-hover: #b42318;
  --button-destructive-primary-fg-hover: #ffffff;
  --button-destructive-primary-border-hover: #b42318;

  /* Button tokens - Destructive Secondary */
  --button-destructive-secondary-bg: #ffffff;
  --button-destructive-secondary-fg: #b42318;
  --button-destructive-secondary-border: #fda29b;
  --button-destructive-secondary-bg-hover: #fef3f2;
  --button-destructive-secondary-fg-hover: #912018;
  --button-destructive-secondary-border-hover: #fda29b;

  /* Button tokens - Destructive Tertiary */
  --button-destructive-tertiary-bg: transparent;
  --button-destructive-tertiary-fg: #b42318;
  --button-destructive-tertiary-border: transparent;
  --button-destructive-tertiary-bg-hover: #fef3f2;
  --button-destructive-tertiary-fg-hover: #912018;
  --button-destructive-tertiary-border-hover: transparent;
  
  /* Button Loading Spinner */
  --button-loading-spinner: #ffffff;

  /* Icon colors */
  --icon-default: #475467;
  --icon-default-hover: #182230;
  --icon-primary: #344054;
  --icon-primary-hover: #101828;
  --icon-secondary: #475467;
  --icon-secondary-hover: #182230;
  --icon-tertiary: #475467;
  --icon-tertiary-hover: #182230;
  --icon-success: #079455;
  --icon-success-hover: #067647;
  --icon-warning: #dc6803;
  --icon-warning-hover: #b54708;
  --icon-error: #d92d20;
  --icon-error-hover: #b42318;
  --icon-info: #4761c4;
  --icon-info-hover: #374c99;

  /* Input field tokens */
  --input-bg: #ffffff;
  --input-fg: #101828;
  --input-border: #d0d5dd;
  --input-bg-hover: #f9fafb;
  --input-fg-hover: #101828;
  --input-border-hover: #d0d5dd;
  --input-bg-focus: #ffffff;
  --input-fg-focus: #101828;
  --input-border-focus: #4761c4;
  --input-placeholder: #667085;
  --input-label: #344054;
  --input-hint: #475467;
  --input-icon: #667085;
  --input-prefix: #667085;

  /* Input destructive */
  --input-destructive-bg: #fef3f2;
  --input-destructive-fg: #101828;
  --input-destructive-border: #fda29b;
  --input-destructive-bg-hover: #fef3f2;
  --input-destructive-fg-hover: #101828;
  --input-destructive-border-hover: #fda29b;
  --input-destructive-bg-focus: #ffffff;
  --input-destructive-fg-focus: #101828;
  --input-destructive-border-focus: #f04438;
  --input-destructive-label: #b42318;
  --input-destructive-hint: #d92d20;
  --input-destructive-icon: #f04438;

  /* Input disabled */
  --input-disabled-bg: #f9fafb;
  --input-disabled-fg: #667085;
  --input-disabled-border: #e4e7ec;
  --input-disabled-placeholder: #667085;
  --input-disabled-label: #667085;

  /* Utility colors - Gray */
  --utility-gray-50: #f9fafb;
  --utility-gray-100: #f2f4f7;
  --utility-gray-200: #e4e7ec;
  --utility-gray-300: #d0d5dd;
  --utility-gray-400: #98a2b3;
  --utility-gray-500: #667085;
  --utility-gray-600: #475467;
  --utility-gray-700: #344054;
  --utility-gray-800: #182230;
  --utility-gray-900: #101828;

  /* Utility colors - Brand */
  --utility-brand-50: #edf0fb;
  --utility-brand-50_alt: #edf0fb;
  --utility-brand-100: #c8d1f3;
  --utility-brand-100_alt: #c8d1f3;
  --utility-brand-200: #aebbed;
  --utility-brand-200_alt: #aebbed;
  --utility-brand-300: #889ce4;
  --utility-brand-300_alt: #889ce4;
  --utility-brand-400: #7189df;
  --utility-brand-400_alt: #7189df;
  --utility-brand-500: #4e6bd7;
  --utility-brand-500_alt: #4e6bd7;
  --utility-brand-600: #4761c4;
  --utility-brand-600_alt: #4761c4;
  --utility-brand-700: #374c99;
  --utility-brand-700_alt: #374c99;
  --utility-brand-800: #2b3b76;
  --utility-brand-800_alt: #2b3b76;
  --utility-brand-900: #202e62;
  --utility-brand-900_alt: #202e62;

  /* Utility colors - Error */
  --utility-error-50: #fef3f2;
  --utility-error-100: #fee4e2;
  --utility-error-200: #fecdca;
  --utility-error-300: #fda29b;
  --utility-error-400: #f97066;
  --utility-error-500: #f04438;
  --utility-error-600: #d92d20;
  --utility-error-700: #b42318;

  /* Utility colors - Warning */
  --utility-warning-50: #fffaeb;
  --utility-warning-100: #fef0c7;
  --utility-warning-200: #fedf89;
  --utility-warning-300: #fec84b;
  --utility-warning-400: #fdb022;
  --utility-warning-500: #f79009;
  --utility-warning-600: #dc6803;
  --utility-warning-700: #b54708;

  /* Utility colors - Success */
  --utility-success-50: #ecfdf3;
  --utility-success-100: #dcfae6;
  --utility-success-200: #abefc6;
  --utility-success-300: #75e0a7;
  --utility-success-400: #47cd89;
  --utility-success-500: #17b26a;
  --utility-success-600: #079455;
  --utility-success-700: #067647;

  /* Additional utility colors */
  --utility-gray-blue-50: #f8f9fc;
  --utility-gray-blue-100: #eaecf5;
  --utility-gray-blue-200: #d5d9eb;
  --utility-gray-blue-300: #b3b8db;
  --utility-gray-blue-400: #717bbc;
  --utility-gray-blue-500: #4e5ba6;
  --utility-gray-blue-600: #3e4784;
  --utility-gray-blue-700: #363f72;

  --utility-blue-light-50: #f3fee7;
  --utility-blue-light-100: #e3fbcc;
  --utility-blue-light-200: #d0f8ab;
  --utility-blue-light-300: #a6ef67;
  --utility-blue-light-400: #85e13a;
  --utility-blue-light-500: #66c61c;
  --utility-blue-light-600: #4ca30d;
  --utility-blue-light-700: #3b7c0f;

  --utility-blue-50: #f0fdf9;
  --utility-blue-100: #ccfbef;
  --utility-blue-200: #99f6e0;
  --utility-blue-300: #5fe9d0;
  --utility-blue-400: #2dd4bf;
  --utility-blue-500: #14b8a6;
  --utility-blue-600: #0d9488;
  --utility-blue-700: #0f766e;

  --utility-blue-dark-50: #f0f9ff;
  --utility-blue-dark-100: #e0f2fe;
  --utility-blue-dark-200: #bae6fd;
  --utility-blue-dark-300: #7dd3fc;
  --utility-blue-dark-400: #38bdf8;
  --utility-blue-dark-500: #0ea5e9;
  --utility-blue-dark-600: #0284c7;
  --utility-blue-dark-700: #0369a1;

  --utility-indigo-50: #eef2ff;
  --utility-indigo-100: #e0e7ff;
  --utility-indigo-200: #c7d2fe;
  --utility-indigo-300: #a5b4fc;
  --utility-indigo-400: #818cf8;
  --utility-indigo-500: #6366f1;
  --utility-indigo-600: #4f46e5;
  --utility-indigo-700: #4338ca;

  --utility-purple-50: #faf5ff;
  --utility-purple-100: #f3e8ff;
  --utility-purple-200: #e9d5ff;
  --utility-purple-300: #d8b4fe;
  --utility-purple-400: #c084fc;
  --utility-purple-500: #a855f7;
  --utility-purple-600: #9333ea;
  --utility-purple-700: #7c3aed;

  --utility-fuchsia-50: #fdf4ff;
  --utility-fuchsia-100: #fae8ff;
  --utility-fuchsia-200: #f5d0fe;
  --utility-fuchsia-300: #f0abfc;
  --utility-fuchsia-400: #e879f9;
  --utility-fuchsia-500: #d946ef;
  --utility-fuchsia-600: #c026d3;
  --utility-fuchsia-700: #a21caf;

  --utility-pink-50: #fdf2f8;
  --utility-pink-100: #fce7f3;
  --utility-pink-200: #fbcfe8;
  --utility-pink-300: #f9a8d4;
  --utility-pink-400: #f472b6;
  --utility-pink-500: #ec4899;
  --utility-pink-600: #db2777;
  --utility-pink-700: #be185d;

  --utility-orange-dark-50: #fff7ed;
  --utility-orange-dark-100: #ffedd5;
  --utility-orange-dark-200: #fed7aa;
  --utility-orange-dark-300: #fdba74;
  --utility-orange-dark-400: #fb923c;
  --utility-orange-dark-500: #f97316;
  --utility-orange-dark-600: #ea580c;
  --utility-orange-dark-700: #c2410c;

  --utility-orange-50: #fff7ed;
  --utility-orange-100: #ffedd5;
  --utility-orange-200: #fed7aa;
  --utility-orange-300: #fdba74;
  --utility-orange-400: #fb923c;
  --utility-orange-500: #f97316;
  --utility-orange-600: #ea580c;
  --utility-orange-700: #c2410c;

  /* Alpha colors */
  --alpha-white-10: rgba(255, 255, 255, 0.10);
  --alpha-white-20: rgba(255, 255, 255, 0.20);
  --alpha-white-30: rgba(255, 255, 255, 0.30);
  --alpha-white-40: rgba(255, 255, 255, 0.40);
  --alpha-white-50: rgba(255, 255, 255, 0.50);
  --alpha-white-60: rgba(255, 255, 255, 0.60);
  --alpha-white-70: rgba(255, 255, 255, 0.70);
  --alpha-white-80: rgba(255, 255, 255, 0.80);
  --alpha-white-90: rgba(255, 255, 255, 0.90);
  --alpha-white-100: #ffffff;
  --alpha-black-10: rgba(0, 0, 0, 0.10);
  --alpha-black-20: rgba(0, 0, 0, 0.20);
  --alpha-black-30: rgba(0, 0, 0, 0.30);
  --alpha-black-40: rgba(0, 0, 0, 0.40);
  --alpha-black-50: rgba(0, 0, 0, 0.50);
  --alpha-black-60: rgba(0, 0, 0, 0.60);
  --alpha-black-70: rgba(0, 0, 0, 0.70);
  --alpha-black-80: rgba(0, 0, 0, 0.80);
  --alpha-black-90: rgba(0, 0, 0, 0.90);
  --alpha-black-100: #000000;

  /* Shadow colors */
  --shadow-xs: rgba(16, 24, 40, 0.05);
  --shadow-sm_01: rgba(16, 24, 40, 0.10);
  --shadow-sm_02: rgba(16, 24, 40, 0.06);
  --shadow-md_01: rgba(16, 24, 40, 0.10);
  --shadow-md_02: rgba(16, 24, 40, 0.06);
  --shadow-lg_01: rgba(16, 24, 40, 0.08);
  --shadow-lg_02: rgba(16, 24, 40, 0.03);
  --shadow-xl_01: rgba(16, 24, 40, 0.08);
  --shadow-xl_02: rgba(16, 24, 40, 0.03);
  --shadow-2xl: rgba(16, 24, 40, 0.18);
  --shadow-3xl: rgba(16, 24, 40, 0.14);
  --shadow-skeumorphic-inner: rgba(16, 24, 40, 0.05);
  --shadow-skeumorphic-inner-border: rgba(16, 24, 40, 0.18);
  --shadow-main-centre-md: rgba(16, 24, 40, 0.14);
  --shadow-main-centre-lg: rgba(16, 24, 40, 0.18);
  --shadow-overlay-lg: rgba(16, 24, 40, 0.12);
  --shadow-grid-md: rgba(16, 24, 40, 0.08);

  /* Miscellaneous tokens */
  --app-store-badge-border: #a6a6a6;
  --social-icon-fg-x: #242e36;
  --social-icon-fg-instagram: #000100;
  --social-icon-fg-apple: #000000;
  --social-icon-fg-github: #000000;
  --social-icon-fg-angellist: #000000;
  --social-icon-fg-tumblr: #001935;
  --screen-mockup-border: #101828;
  --slider-handle-bg: #ffffff;
  --slider-handle-border: #4761c4;
  --thumbnail-badge-brand-fg: #374c99;
  --thumbnail-badge-success-fg: #067647;
  --toggle-button-fg_disabled: #f9fafb;
  --tooltip-supporting-text: #d0d5dd;
  --wysiwyg-editor-icon-fg: #98a2b3;
  --wysiwyg-editor-icon-fg_active: #667085;

  /* Breadcrumb tokens */
  --breadcrumb-active-bg: #edf0fb;
  --breadcrumb-active-fg: #374c99;
  --breadcrumb-inactive-fg: #475467;
  --breadcrumb-separator: #98a2b3;
  --breadcrumb-hover-opacity: 0.75;

  /* Accent colors */
  --accent-primary: #4761c4;
}

/* ========================================
   DARK THEME - ALL TOKENS
   ======================================== */
[data-theme="dark"] {
  /* Text colors */
  --text-primary: #ffffff;
  --text-primary_on-brand: #f5f5f6;
  --text-secondary: #cecfd2;
  --text-secondary_hover: #ececed;
  --text-secondary_on-brand: #cecfd2;
  --text-tertiary: #94969c;
  --text-tertiary_hover: #cecfd2;
  --text-tertiary_on-brand: #94969c;
  --text-quaternary: #94969c;
  --text-quaternary_on-brand: #94969c;
  --text-white: #ffffff;
  --text-disabled: #85888e;
  --text-placeholder: #85888e;
  --text-placeholder_subtle: #333741;
  --text-brand-primary: #f5f5f6;
  --text-brand-secondary: #cecfd2;
  --text-brand-tertiary: #94969c;
  --text-brand-tertiary_alt: #f5f5f6;
  --text-error-primary: #f97066;
  --text-error: #f97066;
  --text-warning-primary: #fdb022;
  --text-success-primary: #47cd89;
  --text-accent: #4761c4;

  /* Border colors */
  --border-primary: #333741;
  --border-secondary: #1f242f;
  --border-tertiary: #1f242f;
  --border-disabled: #333741;
  --border-disabled_subtle: #1f242f;
  --border-brand: #f97066;
  --border-brand_alt: #333741;
  --border-error: #f97066;
  --border-error_subtle: #f97066;
  --border: #333741;

  /* Base colors */
  --base-white: #000000;
  --base-black: #ffffff;

  /* Foreground colors */
  --fg-primary: #ffffff;
  --fg-secondary: #cecfd2;
  --fg-secondary_hover: #ececed;
  --fg-tertiary: #94969c;
  --fg-tertiary_hover: #cecfd2;
  --fg-quaternary: #94969c;
  --fg-quaternary_hover: #cecfd2;
  --fg-quinary: #85888e;
  --fg-quinary_hover: #94969c;
  --fg-senary: #61646c;
  --fg-white: #ffffff;
  --fg-disabled: #85888e;
  --fg-disabled_subtle: #61646c;
  --fg-brand-primary: #4e6bd7;
  --fg-brand-primary_alt: #cecfd2;
  --fg-brand-secondary: #4e6bd7;
  --fg-error-primary: #f04438;
  --fg-error-secondary: #f97066;
  --fg-warning-primary: #f79009;
  --fg-warning-secondary: #fdb022;
  --fg-success-primary: #17b26a;
  --fg-success-secondary: #47cd89;

  /* Background colors */
  --bg-primary: #0c111d;
  --bg-primary_alt: #161b26;
  --bg-primary_hover: #1f242f;
  --bg-primary-solid: #161b26;
  --bg-secondary: #161b26;
  --bg-secondary_alt: #1f242f;
  --bg-secondary_hover: #1f242f;
  --bg-secondary_subtle: #161b26;
  --bg-secondary-solid: #61646c;
  --bg-tertiary: #1f242f;
  --bg-quaternary: #333741;
  --bg-active: #1f242f;
  --bg-disabled: #1f242f;
  --bg-disabled_subtle: #161b26;
  --bg-overlay: #1f242f;
  --bg-brand-primary: #4e6bd7;
  --bg-brand-primary_alt: #161b26;
  --bg-brand-secondary: #4761c4;
  --bg-brand-solid: #4761c4;
  --bg-brand-solid_hover: #4e6bd7;
  --bg-brand-section: #161b26;
  --bg-brand-section_subtle: #1f242f;
  --bg-error-primary: #f04438;
  --bg-error-secondary: #d92d20;
  --bg-error-solid: #d92d20;
  --bg-warning-primary: #f79009;
  --bg-warning-secondary: #dc6803;
  --bg-warning-solid: #dc6803;
  --bg-success-primary: #17b26a;
  --bg-success-secondary: #079455;
  --bg-success-solid: #079455;
  --bg-selected: #333741;

  /* Button tokens - Primary */
  --button-primary-fg: #ffffff;
  --button-primary-fg-hover: #ffffff;
  --button-primary-bg: #4e6bd7;
  --button-primary-bg-hover: #374c99;
  --button-primary-border: #4e6bd7;
  --button-primary-border-hover: #374c99;

  /* Button tokens - Secondary */
  --button-secondary-fg: #cecfd2;
  --button-secondary-fg-hover: #f0f1f1;
  --button-secondary-bg: #161b26;
  --button-secondary-bg-hover: #1f242f;
  --button-secondary-border: #333741;
  --button-secondary-border-hover: #333741;
  
  /* Button tokens - Secondary Color */
  --button-secondary-color-fg: #cecfd2;
  --button-secondary-color-fg-hover: #f0f1f1;
  --button-secondary-color-bg: #161b26;
  --button-secondary-color-bg-hover: #1f242f;
  --button-secondary-color-border: #333741;
  --button-secondary-color-border-hover: #333741;
  
  /* Button tokens - Tertiary */
  --button-tertiary-bg: transparent;
  --button-tertiary-fg: #94969c;
  --button-tertiary-fg-hover: #ececed;
  --button-tertiary-border: transparent;
  --button-tertiary-bg-hover: #1f242f;
  --button-tertiary-border-hover: transparent;
  
  /* Button tokens - Tertiary Color */
  --button-tertiary-color-bg: transparent;
  --button-tertiary-color-fg: #cecfd2;
  --button-tertiary-color-fg-hover: #f0f1f1;
  --button-tertiary-color-border: transparent;
  --button-tertiary-color-bg-hover: #1f242f;
  --button-tertiary-color-border-hover: transparent;
  
  /* Button tokens - Destructive Primary */
  --button-destructive-primary-bg: #d92d20;
  --button-destructive-primary-fg: #ffffff;
  --button-destructive-primary-border: #f97066;
  --button-destructive-primary-bg-hover: #b42318;
  --button-destructive-primary-fg-hover: #ffffff;
  --button-destructive-primary-border-hover: #f97066;

  /* Button tokens - Destructive Secondary */
  --button-destructive-secondary-bg: #55160c;
  --button-destructive-secondary-fg: #fecdca;
  --button-destructive-secondary-border: #912018;
  --button-destructive-secondary-bg-hover: #7a271a;
  --button-destructive-secondary-fg-hover: #fee4e2;
  --button-destructive-secondary-border-hover: #b42318;

  /* Button tokens - Destructive Tertiary */
  --button-destructive-tertiary-bg: transparent;
  --button-destructive-tertiary-fg: #fda29b;
  --button-destructive-tertiary-border: transparent;
  --button-destructive-tertiary-bg-hover: #7a271a;
  --button-destructive-tertiary-fg-hover: #fecdca;
  --button-destructive-tertiary-border-hover: transparent;
  
  /* Button Loading Spinner */
  --button-loading-spinner: #ffffff;

  /* Icon colors */
  --icon-default: #94969c;
  --icon-default-hover: #ececed;
  --icon-primary: #cecfd2;
  --icon-primary-hover: #f0f1f1;
  --icon-secondary: #94969c;
  --icon-secondary-hover: #ececed;
  --icon-tertiary: #94969c;
  --icon-tertiary-hover: #ececed;
  --icon-success: #47cd89;
  --icon-success-hover: #75e0a7;
  --icon-warning: #fdb022;
  --icon-warning-hover: #fec84b;
  --icon-error: #f97066;
  --icon-error-hover: #fda29b;
  --icon-info: #f97066;
  --icon-info-hover: #fda29b;

  /* Dark mode media query overrides (legacy compatibility) */
  --foreground-rgb: 255, 255, 255;
  --background-start-rgb: 0, 0, 0;
  --background-end-rgb: 0, 0, 0;
  --input-bg: #181a20;
  --input-fg: #fff;
  --input-border: #23262f;
  --input-label: #a3a3a3;

  /* Accent colors */
  --accent-primary: #4761c4;

  /* Breadcrumb colors */
  --breadcrumb-inactive-fg: #85888e;
  --breadcrumb-separator: #85888e;
  --breadcrumb-active-fg: #ffffff;
  --breadcrumb-active-bg: #4761c4;

  /* Update utility colors for dark theme */
  --utility-gray-50: #f5f5f6;
  --utility-gray-100: #f0f1f1;
  --utility-gray-200: #ececed;
  --utility-gray-300: #cecfd2;
  --utility-gray-400: #94969c;
  --utility-gray-500: #85888e;
  --utility-gray-600: #61646c;
  --utility-gray-700: #333741;
  --utility-gray-800: #1f242f;
  --utility-gray-900: #161b26;
}

/* ========================================
   OPTIMIZED PERFORMANCE
   ======================================== */

/* Minimal transitions - only where absolutely necessary */
body {
  font-family: 'Inter', sans-serif;
  color: var(--text-primary);
  background-color: var(--bg-primary);
  transition: background-color 150ms ease, color 150ms ease;
}

/* Theme transition class for components that absolutely need smooth transitions */
.theme-transition {
  transition: 
    background-color 150ms ease,
    color 150ms ease,
    border-color 150ms ease;
}

/* Performance: disable transitions on performance-sensitive elements */
svg, svg *,
canvas,
video,
.no-transition,
[data-no-transition="true"],
.react-flow__node,
.react-flow__edge {
  transition: none !important;
}

/* ========================================
   COMPONENT STYLES USING CSS VARIABLES
   ======================================== */

/* Button component styles */
.btn-primary {
  background-color: var(--button-primary-bg);
  color: var(--button-primary-fg);
  border-color: var(--button-primary-border);
}

.btn-primary:hover {
  background-color: var(--button-primary-bg-hover);
  color: var(--button-primary-fg-hover);
  border-color: var(--button-primary-border-hover);
}

.btn-secondary {
  background-color: var(--button-secondary-bg);
  color: var(--button-secondary-fg);
  border-color: var(--button-secondary-border);
}

.btn-secondary:hover {
  background-color: var(--button-secondary-bg-hover);
  color: var(--button-secondary-fg-hover);
  border-color: var(--button-secondary-border-hover);
}

.btn-tertiary {
  background-color: var(--button-tertiary-bg);
  color: var(--button-tertiary-fg);
  border-color: var(--button-tertiary-border);
}

.btn-tertiary:hover {
  background-color: var(--button-tertiary-bg-hover);
  color: var(--button-tertiary-fg-hover);
  border-color: var(--button-tertiary-border-hover);
}

/* Input field styles */
.input-field {
  background-color: var(--input-bg);
  color: var(--input-fg);
  border-color: var(--input-border);
}

.input-field:focus {
  border-color: var(--input-border-focus, var(--border-brand));
}

.input-field::placeholder {
  color: var(--input-placeholder);
}

.input-label {
  color: var(--input-label);
}

/* Card styles */
.card {
  background-color: var(--bg-primary);
  border-color: var(--border-secondary);
}

.card-secondary {
  background-color: var(--bg-secondary);
}

/* Icon styles */
.icon-default {
  color: var(--icon-default);
}

.icon-primary {
  color: var(--icon-primary);
}

.icon-secondary {
  color: var(--icon-secondary);
}

/* ========================================
   LEGACY STYLES (PRESERVED)
   ======================================== */

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
    --input-bg: #181a20;
    --input-fg: #fff;
    --input-border: #23262f;
    --input-label: #a3a3a3;
  }
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

/* Apple-style scrollbar that uses theme colors */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-thumb {
  background: var(--border-primary);
  border-radius: 10px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--border-secondary);
}

::-webkit-scrollbar-track {
  background: transparent;
}

/* Dark mode scrollbar adjustments */
[data-theme="dark"] ::-webkit-scrollbar-thumb {
  background: var(--border-primary);
}

[data-theme="dark"] ::-webkit-scrollbar-thumb:hover {
  background: var(--border-secondary);
}

/* User selection controls */
* {
  -webkit-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

input, textarea {
  -webkit-user-select: text;
  -ms-user-select: text;
  user-select: text;
}

/* ========================================
   DRAG AND DROP STYLES
   ======================================== */

.drag-handle {
  cursor: grab;
  position: relative;
}

.dragging {
  z-index: 9999;
}

[data-id].drag-over-as-child {
  background-color: rgba(73, 131, 247, 0.1);
  border-radius: 8px;
  border: 2px solid rgba(73, 131, 247, 0.4);
  position: relative;
  box-shadow: inset 0 0 0 1px rgba(73, 131, 247, 0.2);
}

[data-id].drag-over-as-child::before {
  content: "";
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px;
  height: 16px;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%234761C4' width='24' height='24'%3E%3Cpath d='M4 20q-.825 0-1.413-.588T2 18V6q0-.825.588-1.413T4 4h6l2 2h8q.825 0 1.413.588T22 8v10q0 .825-.588 1.413T20 20H4Z'/%3E%3C/svg%3E");
  background-size: contain;
  background-repeat: no-repeat;
  opacity: 0.5;
}

[data-id].drag-over-as-sibling-before {
  border-top: 2px solid rgba(73, 131, 247, 0.8);
  position: relative;
}

[data-id].drag-over-as-sibling-after {
  border-bottom: 2px solid rgba(73, 131, 247, 0.8);
  position: relative;
}

[data-id][data-has-children="true"] {
  transition: background-color 0.2s ease;
}

.dnd-active [data-id][data-has-children="true"]:hover {
  background-color: rgba(73, 131, 247, 0.05);
}

@keyframes folder-expanding-pulse {
  0% { box-shadow: 0 0 0 0 rgba(73, 131, 247, 0.2); }
  70% { box-shadow: 0 0 0 5px rgba(73, 131, 247, 0); }
  100% { box-shadow: 0 0 0 0 rgba(73, 131, 247, 0); }
}

.folder-expanding {
  animation: folder-expanding-pulse 1.5s infinite;
  background-color: rgba(73, 131, 247, 0.08) !important;
}

/* ========================================
   FORCE LIGHT THEME (ONBOARDING)
   ======================================== */

.force-light-theme,
.force-light-theme *,
.force-light-theme.dark,
html.force-light-theme,
html.force-light-theme *,
body.force-light-theme,
body.force-light-theme * {
  --text-primary: #101828 !important;
  --text-secondary: #344054 !important;
  --bg-primary: #ffffff !important;
  --bg-secondary: #f9fafb !important;
  --border-primary: #d0d5dd !important;
  --button-primary-bg: #4761c4 !important;
  --button-primary-fg: #fff !important;
  --button-primary-border: #4761c4 !important;
  --button-primary-bg-hover: #3246a8 !important;
  --button-primary-fg-hover: #fff !important;
  --button-primary-border-hover: #3246a8 !important;
  --button-secondary-bg: #fff !important;
  --button-secondary-fg: #101828 !important;
  --button-secondary-border: #d0d5dd !important;
  --button-secondary-bg-hover: #f4f4f5 !important;
  --button-secondary-fg-hover: #101828 !important;
  --button-secondary-border-hover: #bfc5d2 !important;
}

.force-light-theme .dark,
.force-light-theme.dark {
  background-color: #fff !important;
  color: #101828 !important;
}

.force-light-theme ::-webkit-scrollbar-thumb {
  background: #d0d5dd !important;
}

.force-light-theme ::-webkit-scrollbar-thumb:hover {
  background: #98a2b3 !important;
}
</file>

<file path="app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

html {
  font-family: 'Inter', sans-serif;
}

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap');

* {
  -webkit-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/* Optimized theme transitions - only for essential elements */
body {
  transition: background-color 150ms ease, color 150ms ease;
}

/* Theme transition class for components that need smooth transitions */
.theme-transition {
  transition: 
    background-color 150ms ease,
    color 150ms ease,
    border-color 150ms ease;
}

/* Exclude performance-sensitive elements from transitions */
svg, svg *,
canvas,
video,
[data-no-transition="true"],
.no-transition {
  transition: none !important;
}

/* ========================================
   COMPLETE THEME SYSTEM - ALL YOUR TOKENS
   ======================================== */

/* Light theme (default) */
:root,
[data-theme="light"] {
  --text-primary: #101828;
  --text-primary_on-brand: #ffffff;
  --text-secondary: #344054;
  --text-secondary_hover: #182230;
  --text-secondary_on-brand: #aebbed;
  --text-tertiary: #475467;
  --text-tertiary_hover: #344054;
  --text-tertiary_on-brand: #aebbed;
  --text-quaternary: #667085;
  --text-quaternary_on-brand: #889ce4;
  --text-white: #ffffff;
  --text-disabled: #667085;
  --text-placeholder: #667085;
  --text-placeholder_subtle: #d0d5dd;
  --text-brand-primary: #202e62;
  --text-brand-secondary: #374c99;
  --text-brand-tertiary: #4761c4;
  --text-brand-tertiary_alt: #4761c4;
  --text-error-primary: #d92d20;
  --text-warning-primary: #dc6803;
  --text-success-primary: #079455;
  --text-accent: #4761c4;
  --border-primary: #d0d5dd;
  --border-secondary: #e4e7ec;
  --border-tertiary: #f2f4f7;
  --border-disabled: #d0d5dd;
  --border-disabled_subtle: #e4e7ec;
  --border-brand: #4e6bd7;
  --border-brand_alt: #4761c4;
  --border-error: #f04438;
  --border-error_subtle: #fda29b;
  --base-white: #ffffff;
  --base-black: #000000;
  --fg-primary: #101828;
  --fg-secondary: #344054;
  --fg-secondary_hover: #182230;
  --fg-tertiary: #475467;
  --fg-tertiary_hover: #344054;
  --fg-quaternary: #667085;
  --fg-quaternary_hover: #475467;
  --fg-quinary: #98a2b3;
  --fg-quinary_hover: #667085;
  --fg-senary: #d0d5dd;
  --fg-white: #ffffff;
  --fg-disabled: #98a2b3;
  --fg-disabled_subtle: #d0d5dd;
  --fg-brand-primary: #4761c4;
  --fg-brand-primary_alt: #4761c4;
  --fg-brand-secondary: #4e6bd7;
  --fg-error-primary: #d92d20;
  --fg-error-secondary: #f04438;
  --fg-warning-primary: #dc6803;
  --fg-warning-secondary: #f79009;
  --fg-success-primary: #079455;
  --fg-success-secondary: #17b26a;
  --bg-primary: #ffffff;
  --bg-primary_alt: #ffffff;
  --bg-primary_hover: #f2f4f7;
  --bg-primary-solid: #0c111d;
  --bg-secondary: #f9fafb;
  --bg-secondary_alt: #f9fafb;
  --bg-secondary_hover: #e4e7ec;
  --bg-secondary_subtle: #fcfcfd;
  --bg-secondary-solid: #475467;
  --bg-tertiary: #f2f4f7;
  --bg-quaternary: #e4e7ec;
  --bg-active: #e4e7ec;
  --bg-disabled: #f2f4f7;
  --bg-disabled_subtle: #f9fafb;
  --bg-overlay: #0c111d;
  --bg-brand-primary: #edf0fb;
  --bg-brand-primary_alt: #edf0fb;
  --bg-brand-secondary: #c8d1f3;
  --bg-brand-solid: #4761c4;
  --bg-brand-solid_hover: #374c99;
  --bg-brand-section: #2b3b76;
  --bg-brand-section_subtle: #374c99;
  --bg-error-primary: #fef3f2;
  --bg-error-secondary: #fee4e2;
  --bg-error-solid: #d92d20;
  --bg-warning-primary: #fffaeb;
  --bg-warning-secondary: #fef0c7;
  --bg-warning-solid: #dc6803;
  --bg-success-primary: #ecfdf3;
  --bg-success-secondary: #dcfae6;
  --bg-success-solid: #079455;
  --button-primary-bg: #4e6bd7;
  --button-primary-fg: #ffffff;
  --button-primary-border: #4e6bd7;
  --button-primary-bg-hover: #4761c4;
  --button-primary-fg-hover: #ffffff;
  --button-primary-border-hover: #4761c4;
  --button-secondary-bg: #ffffff;
  --button-secondary-fg: #344054;
  --button-secondary-border: #d0d5dd;
  --button-secondary-bg-hover: #f2f4f7;
  --button-secondary-fg-hover: #182230;
  --button-secondary-border-hover: #d0d5dd;
  --button-secondary-color-bg: #edf0fb;
  --button-secondary-color-fg: #4e6bd7;
  --button-secondary-color-border: #c8d1f3;
  --button-secondary-color-bg-hover: #c8d1f3;
  --button-secondary-color-fg-hover: #4761c4;
  --button-secondary-color-border-hover: #aebbed;
  --button-tertiary-fg: #344054;
  --button-tertiary-bg-hover: #f2f4f7;
  --button-tertiary-fg-hover: #182230;
  --button-tertiary-color-fg: #4e6bd7;
  --button-tertiary-color-bg-hover: #edf0fb;
  --button-tertiary-color-fg-hover: #4761c4;
  --button-destructive-primary-bg: #d92d20;
  --button-destructive-primary-fg: #ffffff;
  --button-destructive-primary-border: #d92d20;
  --button-destructive-primary-bg-hover: #b42318;
  --button-destructive-primary-fg-hover: #ffffff;
  --button-destructive-primary-border-hover: #b42318;
  --button-destructive-secondary-bg: #ffffff;
  --button-destructive-secondary-fg: #b42318;
  --button-destructive-secondary-border: #fda29b;
  --button-destructive-secondary-bg-hover: #fef3f2;
  --button-destructive-secondary-fg-hover: #912018;
  --button-destructive-secondary-border-hover: #fda29b;
  --button-destructive-tertiary-fg: #b42318;
  --button-destructive-tertiary-bg-hover: #fef3f2;
  --button-destructive-tertiary-fg-hover: #912018;
  --button-loading-spinner: #ffffff;
  --icon-default: #475467;
  --icon-default-hover: #182230;
  --icon-primary: #344054;
  --icon-primary-hover: #101828;
  --icon-secondary: #475467;
  --icon-secondary-hover: #182230;
  --icon-tertiary: #475467;
  --icon-tertiary-hover: #182230;
  --icon-success: #079455;
  --icon-success-hover: #067647;
  --icon-warning: #dc6803;
  --icon-warning-hover: #b54708;
  --icon-error: #d92d20;
  --icon-error-hover: #b42318;
  --icon-info: #4761c4;
  --icon-info-hover: #374c99;
  --input-bg: #ffffff;
  --input-fg: #101828;
  --input-border: #d0d5dd;
  --input-bg-hover: #f9fafb;
  --input-fg-hover: #101828;
  --input-border-hover: #d0d5dd;
  --input-bg-focus: #ffffff;
  --input-fg-focus: #101828;
  --input-border-focus: #4761c4;
  --input-placeholder: #667085;
  --input-label: #344054;
  --input-hint: #475467;
  --input-icon: #667085;
  --input-prefix: #667085;
  --input-destructive-bg: #fef3f2;
  --input-destructive-fg: #101828;
  --input-destructive-border: #fda29b;
  --input-destructive-bg-hover: #fef3f2;
  --input-destructive-fg-hover: #101828;
  --input-destructive-border-hover: #fda29b;
  --input-destructive-bg-focus: #ffffff;
  --input-destructive-fg-focus: #101828;
  --input-destructive-border-focus: #f04438;
  --input-destructive-label: #b42318;
  --input-destructive-hint: #d92d20;
  --input-destructive-icon: #f04438;
  --input-disabled-bg: #f9fafb;
  --input-disabled-fg: #667085;
  --input-disabled-border: #e4e7ec;
  --input-disabled-placeholder: #667085;
  --input-disabled-label: #667085;
  --utility-gray-50: #f9fafb;
  --utility-gray-100: #f2f4f7;
  --utility-gray-200: #e4e7ec;
  --utility-gray-300: #d0d5dd;
  --utility-gray-400: #98a2b3;
  --utility-gray-500: #667085;
  --utility-gray-600: #475467;
  --utility-gray-700: #344054;
  --utility-gray-800: #182230;
  --utility-gray-900: #101828;
  --utility-brand-50: #edf0fb;
  --utility-brand-50_alt: #edf0fb;
  --utility-brand-100: #c8d1f3;
  --utility-brand-100_alt: #c8d1f3;
  --utility-brand-200: #aebbed;
  --utility-brand-200_alt: #aebbed;
  --utility-brand-300: #889ce4;
  --utility-brand-300_alt: #889ce4;
  --utility-brand-400: #7189df;
  --utility-brand-400_alt: #7189df;
  --utility-brand-500: #4e6bd7;
  --utility-brand-500_alt: #4e6bd7;
  --utility-brand-600: #4761c4;
  --utility-brand-600_alt: #4761c4;
  --utility-brand-700: #374c99;
  --utility-brand-700_alt: #374c99;
  --utility-brand-800: #2b3b76;
  --utility-brand-800_alt: #2b3b76;
  --utility-brand-900: #202e62;
  --utility-brand-900_alt: #202e62;
  --utility-error-50: #fef3f2;
  --utility-error-100: #fee4e2;
  --utility-error-200: #fecdca;
  --utility-error-300: #fda29b;
  --utility-error-400: #f97066;
  --utility-error-500: #f04438;
  --utility-error-600: #d92d20;
  --utility-error-700: #b42318;
  --utility-warning-50: #fffaeb;
  --utility-warning-100: #fef0c7;
  --utility-warning-200: #fedf89;
  --utility-warning-300: #fec84b;
  --utility-warning-400: #fdb022;
  --utility-warning-500: #f79009;
  --utility-warning-600: #dc6803;
  --utility-warning-700: #b54708;
  --utility-success-50: #ecfdf3;
  --utility-success-100: #dcfae6;
  --utility-success-200: #abefc6;
  --utility-success-300: #75e0a7;
  --utility-success-400: #47cd89;
  --utility-success-500: #17b26a;
  --utility-success-600: #079455;
  --utility-success-700: #067647;
  --utility-gray-blue-50: #f8f9fc;
  --utility-gray-blue-100: #eaecf5;
  --utility-gray-blue-200: #d5d9eb;
  --utility-gray-blue-300: #b3b8db;
  --utility-gray-blue-400: #717bbc;
  --utility-gray-blue-500: #4e5ba6;
  --utility-gray-blue-600: #3e4784;
  --utility-gray-blue-700: #363f72;
  --utility-blue-light-50: #f0f9ff;
  --utility-blue-light-100: #e0f2fe;
  --utility-blue-light-200: #b9e6fe;
  --utility-blue-light-300: #7cd4fd;
  --utility-blue-light-400: #36bffa;
  --utility-blue-light-500: #0ba5ec;
  --utility-blue-light-600: #0086c9;
  --utility-blue-light-700: #026aa2;
  --utility-blue-50: #eff8ff;
  --utility-blue-100: #d1e9ff;
  --utility-blue-200: #b2ddff;
  --utility-blue-300: #84caff;
  --utility-blue-400: #53b1fd;
  --utility-blue-500: #2e90fa;
  --utility-blue-600: #1570ef;
  --utility-blue-700: #175cd3;
  --utility-blue-dark-50: #eff4ff;
  --utility-blue-dark-100: #d1e0ff;
  --utility-blue-dark-200: #b2ccff;
  --utility-blue-dark-300: #84adff;
  --utility-blue-dark-400: #528bff;
  --utility-blue-dark-500: #2970ff;
  --utility-blue-dark-600: #155eef;
  --utility-blue-dark-700: #004eeb;
  --utility-indigo-50: #eef4ff;
  --utility-indigo-100: #e0eaff;
  --utility-indigo-200: #c7d7fe;
  --utility-indigo-300: #a4bcfd;
  --utility-indigo-400: #8098f9;
  --utility-indigo-500: #6172f3;
  --utility-indigo-600: #444ce7;
  --utility-indigo-700: #3538cd;
  --utility-purple-50: #f4f3ff;
  --utility-purple-100: #ebe9fe;
  --utility-purple-200: #d9d6fe;
  --utility-purple-300: #bdb4fe;
  --utility-purple-400: #9b8afb;
  --utility-purple-500: #7a5af8;
  --utility-purple-600: #6938ef;
  --utility-purple-700: #5925dc;
  --utility-fuchsia-50: #fdf4ff;
  --utility-fuchsia-100: #fbe8ff;
  --utility-fuchsia-200: #f6d0fe;
  --utility-fuchsia-300: #eeaafd;
  --utility-fuchsia-400: #e478fa;
  --utility-fuchsia-500: #d444f1;
  --utility-fuchsia-600: #ba24d5;
  --utility-fuchsia-700: #9f1ab1;
  --utility-pink-50: #fdf2fa;
  --utility-pink-100: #fce7f6;
  --utility-pink-200: #fcceee;
  --utility-pink-300: #faa7e0;
  --utility-pink-400: #f670c7;
  --utility-pink-500: #ee46bc;
  --utility-pink-600: #dd2590;
  --utility-pink-700: #c11574;
  --utility-orange-dark-50: #fff4ed;
  --utility-orange-dark-100: #ffe6d5;
  --utility-orange-dark-200: #ffd6ae;
  --utility-orange-dark-300: #ff9c66;
  --utility-orange-dark-400: #ff692e;
  --utility-orange-dark-500: #ff4405;
  --utility-orange-dark-600: #e62e05;
  --utility-orange-dark-700: #bc1b06;
  --utility-orange-50: #fef6ee;
  --utility-orange-100: #fdead7;
  --utility-orange-200: #f9dbaf;
  --utility-orange-300: #f7b27a;
  --utility-orange-400: #f38744;
  --utility-orange-500: #ef6820;
  --utility-orange-600: #e04f16;
  --utility-orange-700: #b93815;
  --social-icon-fg-apple: #000000;
  --social-icon-fg-github: #000000;
  --social-icon-fg-angellist: #000000;
  --screen-mockup-border: #101828;
  --slider-handle-bg: #ffffff;
  --slider-handle-border: #4761c4;
  --thumbnail-badge-brand-fg: #374c99;
  --thumbnail-badge-success-fg: #067647;
  --toggle-button-fg_disabled: #f9fafb;
  --tooltip-supporting-text: #d0d5dd;
  --wysiwyg-editor-icon-fg: #98a2b3;
  --wysiwyg-editor-icon-fg_active: #667085;
  --breadcrumb-active-bg: #edf0fb;
  --breadcrumb-active-fg: #374c99;
  --breadcrumb-inactive-fg: #475467;
  --breadcrumb-separator: #98a2b3;
}

/* Dark theme */
[data-theme="dark"] {
  --text-primary: #f5f5f6;
  --text-primary_on-brand: #f5f5f6;
  --text-secondary: #cecfd2;
  --text-secondary_hover: #ececed;
  --text-secondary_on-brand: #cecfd2;
  --text-tertiary: #94969c;
  --text-tertiary_hover: #cecfd2;
  --text-tertiary_on-brand: #94969c;
  --text-quaternary: #94969c;
  --text-quaternary_on-brand: #94969c;
  --text-white: #ffffff;
  --text-disabled: #85888e;
  --text-placeholder: #85888e;
  --text-placeholder_subtle: #333741;
  --text-brand-primary: #f5f5f6;
  --text-brand-secondary: #cecfd2;
  --text-brand-tertiary: #94969c;
  --text-brand-tertiary_alt: #f5f5f6;
  --text-error-primary: #f97066;
  --text-warning-primary: #fdb022;
  --text-success-primary: #47cd89;
  --text-accent: #4761c4;
  --border-primary: #333741;
  --border-secondary: #1f242f;
  --border-tertiary: #1f242f;
  --border-disabled: #333741;
  --border-disabled_subtle: #1f242f;
  --border-brand: #7189df;
  --border-brand_alt: #333741;
  --border-error: #f97066;
  --border-error_subtle: #f97066;
  --base-white: #000000;
  --base-black: #ffffff;
  --fg-primary: #ffffff;
  --fg-secondary: #cecfd2;
  --fg-secondary_hover: #ececed;
  --fg-tertiary: #94969c;
  --fg-tertiary_hover: #cecfd2;
  --fg-quaternary: #94969c;
  --fg-quaternary_hover: #cecfd2;
  --fg-quinary: #85888e;
  --fg-quinary_hover: #94969c;
  --fg-senary: #61646c;
  --fg-white: #ffffff;
  --fg-disabled: #85888e;
  --fg-disabled_subtle: #61646c;
  --fg-brand-primary: #4e6bd7;
  --fg-brand-primary_alt: #cecfd2;
  --fg-brand-secondary: #4e6bd7;
  --fg-error-primary: #f04438;
  --fg-error-secondary: #f97066;
  --fg-warning-primary: #f79009;
  --fg-warning-secondary: #fdb022;
  --fg-success-primary: #17b26a;
  --fg-success-secondary: #47cd89;
  --bg-primary: #0c111d;
  --bg-primary_alt: #161b26;
  --bg-primary_hover: #1f242f;
  --bg-primary-solid: #161b26;
  --bg-secondary: #161b26;
  --bg-secondary_alt: #1f242f;
  --bg-secondary_hover: #1f242f;
  --bg-secondary_subtle: #161b26;
  --bg-secondary-solid: #61646c;
  --bg-tertiary: #1f242f;
  --bg-quaternary: #333741;
  --bg-active: #1f242f;
  --bg-disabled: #1f242f;
  --bg-disabled_subtle: #161b26;
  --bg-overlay: #1f242f;
  --bg-brand-primary: #4e6bd7;
  --bg-brand-primary_alt: #161b26;
  --bg-brand-secondary: #4761c4;
  --bg-brand-solid: #4761c4;
  --bg-brand-solid_hover: #4e6bd7;
  --bg-brand-section: #161b26;
  --bg-brand-section_subtle: #1f242f;
  --bg-error-primary: #f04438;
  --bg-error-secondary: #d92d20;
  --bg-error-solid: #d92d20;
  --bg-warning-primary: #f79009;
  --bg-warning-secondary: #dc6803;
  --bg-warning-solid: #dc6803;
  --bg-success-primary: #17b26a;
  --bg-success-secondary: #079455;
  --bg-success-solid: #079455;
  --button-primary-fg: #ffffff;
  --button-primary-fg-hover: #ffffff;
  --button-primary-bg: #4e6bd7;
  --button-primary-bg-hover: #374c99;
  --button-primary-border: #4e6bd7;
  --button-primary-border-hover: #374c99;
  --button-secondary-fg: #cecfd2;
  --button-secondary-fg-hover: #f0f1f1;
  --button-secondary-bg: #161b26;
  --button-secondary-bg-hover: #1f242f;
  --button-secondary-border: #333741;
  --button-secondary-border-hover: #333741;
  --button-secondary-color-fg: #cecfd2;
  --button-secondary-color-fg-hover: #f0f1f1;
  --button-secondary-color-bg: #161b26;
  --button-secondary-color-bg-hover: #1f242f;
  --button-secondary-color-border: #333741;
  --button-secondary-color-border-hover: #333741;
  --button-tertiary-fg: #94969c;
  --button-tertiary-fg-hover: #ececed;
  --button-tertiary-bg-hover: #1f242f;
  --button-tertiary-color-fg: #cecfd2;
  --button-tertiary-color-fg-hover: #f0f1f1;
  --button-tertiary-color-bg-hover: #1f242f;
  --button-destructive-primary-bg: #d92d20;
  --button-destructive-primary-fg: #ffffff;
  --button-destructive-primary-border: #f97066;
  --button-destructive-primary-bg-hover: #b42318;
  --button-destructive-primary-fg-hover: #ffffff;
  --button-destructive-primary-border-hover: #f97066;
  --button-destructive-secondary-bg: #55160c;
  --button-destructive-secondary-fg: #fecdca;
  --button-destructive-secondary-border: #912018;
  --button-destructive-secondary-bg-hover: #7a271a;
  --button-destructive-secondary-fg-hover: #fee4e2;
  --button-destructive-secondary-border-hover: #b42318;
  --button-destructive-tertiary-fg: #fda29b;
  --button-destructive-tertiary-bg-hover: #7a271a;
  --button-destructive-tertiary-fg-hover: #fecdca;
  --button-loading-spinner: #ffffff;
  --icon-default: #94969c;
  --icon-default-hover: #ececed;
  --icon-primary: #cecfd2;
  --icon-primary-hover: #f0f1f1;
  --icon-secondary: #94969c;
  --icon-secondary-hover: #ececed;
  --icon-tertiary: #94969c;
  --icon-tertiary-hover: #ececed;
  --icon-success: #47cd89;
  --icon-success-hover: #75e0a7;
  --icon-warning: #fdb022;
  --icon-warning-hover: #fec84b;
  --icon-error: #f97066;
  --icon-error-hover: #fda29b;
  --icon-info: #7189df;
  --icon-info-hover: #889ce4;
  --input-bg: #0c111d;
  --input-fg: #f0f1f1;
  --input-border: #333741;
  --input-bg-hover: #1f242f;
  --input-fg-hover: #f5f5f6;
  --input-border-hover: #61646c;
  --input-bg-focus: #161b26;
  --input-fg-focus: #f5f5f6;
  --input-border-focus: #4e6bd7;
  --input-placeholder: #85888e;
  --input-label: #cecfd2;
  --input-hint: #94969c;
  --input-icon: #85888e;
  --input-prefix: #85888e;
  --input-destructive-bg: #55160c;
  --input-destructive-fg: #f5f5f6;
  --input-destructive-border: #912018;
  --input-destructive-bg-hover: #7a271a;
  --input-destructive-fg-hover: #f5f5f6;
  --input-destructive-border-hover: #b42318;
  --input-destructive-bg-focus: #55160c;
  --input-destructive-fg-focus: #f5f5f6;
  --input-destructive-border-focus: #f04438;
  --input-destructive-label: #fda29b;
  --input-destructive-hint: #f97066;
  --input-destructive-icon: #f97066;
  --input-disabled-bg: #1f242f;
  --input-disabled-fg: #61646c;
  --input-disabled-border: #1f242f;
  --input-disabled-placeholder: #61646c;
  --input-disabled-label: #61646c;
  --breadcrumb-active-bg: #202e62;
  --breadcrumb-active-fg: #7189df;
  --breadcrumb-inactive-fg: #94969c;
  --breadcrumb-separator: #61646c;
  --utility-gray-50: #161b26;
  --utility-gray-100: #1f242f;
  --utility-gray-200: #333741;
  --utility-gray-300: #333741;
  --utility-gray-400: #61646c;
  --utility-gray-500: #85888e;
  --utility-gray-600: #94969c;
  --utility-gray-700: #cecfd2;
  --utility-gray-800: #ececed;
  --utility-gray-900: #f0f1f1;
  --utility-brand-50: #132154;
  --utility-brand-100: #202e62;
  --utility-brand-200: #2b3b76;
  --utility-brand-300: #374c99;
  --utility-brand-400: #4761c4;
  --utility-brand-500: #4e6bd7;
  --utility-brand-600: #7189df;
  --utility-brand-700: #889ce4;
  --utility-brand-800: #aebbed;
  --utility-brand-900: #c8d1f3;
  --utility-error-50: #55160c;
  --utility-error-100: #7a271a;
  --utility-error-200: #912018;
  --utility-error-300: #b42318;
  --utility-error-400: #d92d20;
  --utility-error-500: #f04438;
  --utility-error-600: #f97066;
  --utility-error-700: #fda29b;
  --utility-warning-50: #4e1d09;
  --utility-warning-100: #7a2e0e;
  --utility-warning-200: #93370d;
  --utility-warning-300: #b54708;
  --utility-warning-400: #dc6803;
  --utility-warning-500: #f79009;
  --utility-warning-600: #fdb022;
  --utility-warning-700: #fec84b;
  --utility-success-50: #053321;
  --utility-success-100: #074d31;
  --utility-success-200: #085d3a;
  --utility-success-300: #067647;
  --utility-success-400: #079455;
  --utility-success-500: #17b26a;
  --utility-success-600: #47cd89;
  --utility-success-700: #75e0a7;
  --utility-purple-50: #27115f;
  --utility-purple-100: #3e1c96;
  --utility-purple-200: #4a1fb8;
  --utility-purple-300: #5925dc;
  --utility-purple-400: #6938ef;
  --utility-purple-500: #7a5af8;
  --utility-purple-600: #9b8afb;
  --utility-purple-700: #bdb4fe;
  --alpha-white-100: #0c111d;
  --social-icon-fg-x: #ffffff;
  --social-icon-fg-instagram: #ffffff;
  --social-icon-fg-apple: #ffffff;
  --social-icon-fg-github: #ffffff;
  --social-icon-fg-angellist: #ffffff;
  --social-icon-fg-tumblr: #ffffff;
  --screen-mockup-border: #333741;
  --slider-handle-bg: #4761c4;
  --slider-handle-border: #161b26;
  --thumbnail-badge-brand-fg: #cecfd2;
  --thumbnail-badge-success-fg: #cecfd2;
  --toggle-button-fg_disabled: #61646c;
  --tooltip-supporting-text: #cecfd2;
  --wysiwyg-editor-icon-fg: #94969c;
  --wysiwyg-editor-icon-fg_active: #ffffff;
}

/* Apple-style scrollbar that uses theme colors */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-thumb {
  background: var(--border-primary);
  border-radius: 10px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--border-secondary);
}

::-webkit-scrollbar-track {
  background: transparent;
}

/* Dark mode scrollbar adjustments */
[data-theme="dark"] ::-webkit-scrollbar-thumb {
  background: var(--border-primary);
}

[data-theme="dark"] ::-webkit-scrollbar-thumb:hover {
  background: var(--border-secondary);
}

/* Refined MiniMap styling - target only background containers, preserve node colors */

/* CSS Variables approach */
.react-flow {
  --xy-minimap-background-color-default: var(--bg-tertiary) !important;
}

/* Target the main minimap container - NOT its children */
.react-flow__minimap {
  background-color: var(--bg-tertiary) !important;
  background: var(--bg-tertiary) !important;
  border-radius: 8px !important;
  border: 1px solid var(--border-secondary) !important;
}

/* Target the SVG background specifically, but not fills */
.react-flow__minimap svg {
  background-color: var(--bg-tertiary) !important;
  background: var(--bg-tertiary) !important;
}

/* Light mode SVG background - darker */
:root .react-flow__minimap svg,
[data-theme="light"] .react-flow__minimap svg {
  background-color: var(--utility-gray-300) !important;
  background: var(--utility-gray-300) !important;
}

/* Dark mode SVG background */
[data-theme="dark"] .react-flow__minimap svg {
  background-color: var(--bg-tertiary) !important;
  background: var(--bg-tertiary) !important;
}

/* Target any wrapper containers but exclude nodes */
[class*="minimap"]:not([class*="node"]) {
  background-color: var(--bg-tertiary) !important;
  background: var(--bg-tertiary) !important;
}

/* Target the main SVG rect background, but preserve node fills */
.react-flow__minimap > svg > rect:first-child {
  fill: var(--bg-tertiary) !important;
}

/* Light mode main rect background */
:root .react-flow__minimap > svg > rect:first-child,
[data-theme="light"] .react-flow__minimap > svg > rect:first-child {
  fill: var(--utility-gray-300) !important;
}

/* Reduce mask opacity for subtle contrast */
.react-flow__minimap .react-flow__minimap-mask {
  fill: var(--bg-primary) !important;
  fill-opacity: 0.2 !important; /* Much lighter masking */
}

/* Light mode specific - very subtle mask */
:root .react-flow__minimap .react-flow__minimap-mask,
[data-theme="light"] .react-flow__minimap .react-flow__minimap-mask {
  fill: var(--utility-gray-200) !important; /* Very light gray */
  fill-opacity: 0.3 !important; /* Subtle masking */
}

/* Dark mode specific - keep subtle */
[data-theme="dark"] .react-flow__minimap .react-flow__minimap-mask {
  fill: var(--bg-primary) !important;
  fill-opacity: 0.25 !important; /* Subtle masking in dark mode */
}

/* Custom class targeting - container only */
.custom-minimap {
  background-color: var(--bg-tertiary) !important;
  background: var(--bg-tertiary) !important;
}

/* Force override with higher specificity for container only */
.react-flow .react-flow__minimap.react-flow__minimap {
  background: var(--bg-tertiary) !important;
}

.react-flow .react-flow__minimap.react-flow__minimap > svg {
  background: var(--bg-tertiary) !important;
}

/* Enhanced minimap node visibility - ensure nodes outside viewport are clearly visible */
.react-flow__minimap .react-flow__minimap-node {
  opacity: 1 !important;
  fill-opacity: 0.9 !important;
}

/* ENHANCED VIEWPORT RECTANGLE - Make it the star of the show! */
.react-flow__minimap .react-flow__minimap-node[data-testid="minimap-node"] {
  stroke-width: 1 !important;
  stroke: var(--border-primary) !important;
}

/* Style the viewport rectangle to be much more prominent */
.react-flow__minimap svg > rect:last-child {
  stroke: var(--fg-brand-primary) !important;
  stroke-width: 3 !important;
  fill: none !important;
  stroke-dasharray: none !important;
  opacity: 1 !important;
}

/* Light mode viewport rectangle */
:root .react-flow__minimap svg > rect:last-child,
[data-theme="light"] .react-flow__minimap svg > rect:last-child {
  stroke: var(--utility-brand-600) !important; /* Bright brand blue */
  stroke-width: 3 !important;
  fill: var(--utility-brand-50) !important; /* Light blue background */
  fill-opacity: 0.15 !important;
  stroke-dasharray: none !important;
  opacity: 1 !important;
  rx: 4 !important; /* Rounded corners */
  ry: 4 !important;
}

/* Dark mode viewport rectangle */
[data-theme="dark"] .react-flow__minimap svg > rect:last-child {
  stroke: var(--utility-brand-400) !important; /* Bright brand blue for dark mode */
  stroke-width: 3 !important;
  fill: var(--utility-brand-900) !important; /* Dark blue background */
  fill-opacity: 0.3 !important;
  stroke-dasharray: none !important;
  opacity: 1 !important;
  rx: 4 !important; /* Rounded corners */
  ry: 4 !important;
}

/* Alternative targeting for viewport rectangle */
.react-flow__minimap > svg > rect[stroke] {
  stroke: var(--fg-brand-primary) !important;
  stroke-width: 3 !important;
  fill: var(--bg-brand-primary) !important;
  fill-opacity: 0.2 !important;
  rx: 4 !important;
  ry: 4 !important;
}
</file>

<file path="app/isModalOpenStore.ts">
import { create } from 'zustand';

interface IsModalOpenStore {
  isModalOpen: boolean;
  setIsModalOpen: (open: boolean) => void;
}

export const useIsModalOpenStore = create<IsModalOpenStore>((set) => ({
  isModalOpen: false,
  setIsModalOpen: (open) => set({ isModalOpen: open }),
}));
</file>

<file path="app/not-found.tsx">
export default function NotFound() {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h1 className="text-4xl font-bold text-gray-800">404 - Not Found</h1>
      <p className="mt-4 text-gray-600">
        The page you're looking for doesn't exist.
      </p>
      <a 
        href="/" 
        className="mt-8 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
      >
        Return to Dashboard
      </a>
    </div>
  );
}
</file>

<file path="app/PostHogPageView.tsx">
// app/PostHogPageView.tsx
'use client';

import { usePathname, useSearchParams } from 'next/navigation';
import { useEffect, Suspense } from 'react';
import { usePostHog } from 'posthog-js/react';

function PostHogPageView(): null {
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const posthog = usePostHog();

  // Track pageviews
  useEffect(() => {
    if (pathname && posthog) {
      let url = window.origin + pathname;
      if (searchParams?.toString()) {
        url = url + `?${searchParams.toString()}`;
      }

      posthog.capture('$pageview', { $current_url: url });
    }
  }, [pathname, searchParams, posthog]);

  return null;
}

// Wrap this in Suspense to avoid the `useSearchParams` usage above
// from de-opting the whole app into client-side rendering
// See: https://nextjs.org/docs/messages/deopted-into-client-rendering
export default function SuspendedPostHogPageView() {
  return (
    <Suspense fallback={null}>
      <PostHogPageView />
    </Suspense>
  );
}
</file>

<file path="app/providers.tsx">
'use client';

import posthog from 'posthog-js';
import { PostHogProvider as PHProvider } from 'posthog-js/react';
import { useEffect } from 'react';
import { usePathname } from 'next/navigation';
import PostHogPageView from './PostHogPageView';

const posthogKey = process.env.NEXT_PUBLIC_POSTHOG_KEY;
const posthogHost = process.env.NEXT_PUBLIC_POSTHOG_HOST;

export function PostHogProvider({ children }: { children: React.ReactNode }) {
  const pathname = usePathname();
  
  // Check if the current path is in a checkout flow
  const isCheckoutPath = pathname?.includes('/checkout');
  
  useEffect(() => {
    // Only initialize PostHog if not in checkout flow
    if (!isCheckoutPath && posthogKey && posthogHost) {
      posthog.init(posthogKey, {
        api_host: posthogHost,
        capture_pageview: false,
      });
    } else if (isCheckoutPath) {
      if (process.env.NODE_ENV !== 'production') {
        console.log('PostHog disabled for checkout flow to prevent conflicts');
      }
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.warn(
          'PostHog is not initialized due to missing environment variables.'
        );
      }
    }
  }, [isCheckoutPath]);

  // If in checkout flow, just render children without PostHog
  if (isCheckoutPath) {
    return <>{children}</>;
  }

  // Normal flow with PostHog
  return (
    <PHProvider client={posthog}>
      <PostHogPageView />
      {children}
    </PHProvider>
  );
}
</file>

<file path="app/temp-globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

html {
  font-family: 'Inter', sans-serif;
}

/* body {
  @apply: font-sans;
  font-family: 'Inter', sans-serif;
  font-size: 16px;
  line-height: 1.5;
}

h1 {
  font-family: 'Inter', sans-serif;
  font-weight: 700;
  font-size: 2rem;
} */

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap');

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
  /* Input field variables for light mode */
  --input-bg: #fff;
  --input-fg: #101828;
  --input-border: #d0d5dd;
  --input-label: #344054;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
    /* Input field variables for dark mode (media) */
    --input-bg: #181a20;
    --input-fg: #fff;
    --input-border: #23262f;
    --input-label: #a3a3a3;
  }
}

body {
  font-family: 'Inter', sans-serif; /* Applying Inter font */
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

/* Apple-style scrollbar that doesn't take up extra space */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-thumb {
  background: theme('colors.lightMode.bg-quaternary');
  border-radius: 10px;
}

::-webkit-scrollbar-thumb:hover {
  background: theme('colors.lightMode.bg-secondary-solid');
}

::-webkit-scrollbar-track {
  background: transparent;
}

/* Dark mode class-based styling */
.dark ::-webkit-scrollbar-thumb {
  background: theme('colors.darkMode.bg-quaternary');
}

.dark ::-webkit-scrollbar-thumb:hover {
  background: theme('colors.darkMode.bg-secondary-solid');
}

* {
  -webkit-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/* Allow text selection only in input fields and textareas */
input, textarea {
  -webkit-user-select: text;
  -ms-user-select: text;
  user-select: text;
}

/* Drag and Drop Styles */
.drag-handle {
  cursor: grab;
  position: relative;
}

.dragging {
  z-index: 9999;
}

/* Show the indicator more prominently when dragging over a potential drop target */
[data-id].drag-over-as-child {
  background-color: rgba(73, 131, 247, 0.1);
  border-radius: 8px;
  border: 2px solid rgba(73, 131, 247, 0.4);
  position: relative;
  box-shadow: inset 0 0 0 1px rgba(73, 131, 247, 0.2);
  /* Add a folder icon indicator */
}

[data-id].drag-over-as-child::before {
  content: "";
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px;
  height: 16px;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%234761C4' width='24' height='24'%3E%3Cpath d='M4 20q-.825 0-1.413-.588T2 18V6q0-.825.588-1.413T4 4h6l2 2h8q.825 0 1.413.588T22 8v10q0 .825-.588 1.413T20 20H4Z'/%3E%3C/svg%3E");
  background-size: contain;
  background-repeat: no-repeat;
  opacity: 0.5;
}

[data-id].drag-over-as-sibling-before {
  border-top: 2px solid rgba(73, 131, 247, 0.8);
  position: relative;
}

[data-id].drag-over-as-sibling-after {
  border-bottom: 2px solid rgba(73, 131, 247, 0.8);
  position: relative;
}

/* Add style for folders with subfolders during drag operations */
[data-id][data-has-children="true"] {
  transition: background-color 0.2s ease;
}

/* Style for hover on folders with children during drag */
.dnd-active [data-id][data-has-children="true"]:hover {
  background-color: rgba(73, 131, 247, 0.05);
}

/* Animation for the folder that's about to expand */
@keyframes folder-expanding-pulse {
  0% { box-shadow: 0 0 0 0 rgba(73, 131, 247, 0.2); }
  70% { box-shadow: 0 0 0 5px rgba(73, 131, 247, 0); }
  100% { box-shadow: 0 0 0 0 rgba(73, 131, 247, 0); }
}

.folder-expanding {
  animation: folder-expanding-pulse 1.5s infinite;
  background-color: rgba(73, 131, 247, 0.08) !important;
}

/* Force light theme for the onboarding page */
.force-light-theme,
.force-light-theme *,
.force-light-theme.dark,
html.force-light-theme,
html.force-light-theme *,
body.force-light-theme,
body.force-light-theme * {
  --input-bg: #fff !important;
  --input-fg: #101828 !important;
  --input-border: #d0d5dd !important;
  --input-label: #344054 !important;
  /* Button variables for light mode */
  --button-primary-bg: #4761c4 !important;
  --button-primary-fg: #fff !important;
  --button-primary-border: #4761c4 !important;
  --button-primary-bg-hover: #3246a8 !important;
  --button-primary-fg-hover: #fff !important;
  --button-primary-border-hover: #3246a8 !important;
  --button-secondary-bg: #fff !important;
  --button-secondary-fg: #101828 !important;
  --button-secondary-border: #d0d5dd !important;
  --button-secondary-bg-hover: #f4f4f5 !important;
  --button-secondary-fg-hover: #101828 !important;
  --button-secondary-border-hover: #bfc5d2 !important;
}

.force-light-theme .dark,
.force-light-theme.dark {
  background-color: #fff !important;
  color: #101828 !important;
}

.force-light-theme * {
  /* Use !important to override any dark mode styles */
  --text-primary: #101828 !important;
  --text-secondary: #344054 !important;
  --text-tertiary: #475467 !important;
  --bg-primary: #ffffff !important;
  --bg-secondary: #f9fafb !important;
  --border-primary: #d0d5dd !important;
  --border-secondary: #e4e7ec !important;
}

/* Dark mode scrollbar override for the force-light-theme class */
.force-light-theme ::-webkit-scrollbar-thumb {
  background: theme('colors.lightMode.bg-quaternary') !important;
}

.force-light-theme ::-webkit-scrollbar-thumb:hover {
  background: theme('colors.lightMode.bg-secondary-solid') !important;
}

.dark {
  /* Input field variables for dark mode (class) */
  --input-bg: #181a20;
  --input-fg: #fff;
  --input-border: #23262f;
  --input-label: #a3a3a3;
}
</file>

<file path="components/chat/AIChatMessage.tsx">
import React, { useState, useEffect } from 'react';
import { useColors } from '@/app/theme/hooks';
import Lottie from 'lottie-react';

interface AIChatMessageProps {
  message?: string;
  isLoading?: boolean;
  isLastMessage?: boolean;
}

const AIChatMessage: React.FC<AIChatMessageProps> = ({
  message = '',
  isLoading = false,
  isLastMessage = false
}) => {
  const colors = useColors();
  const [animationData, setAnimationData] = useState<any>(null);
  const [isAnimationLoading, setIsAnimationLoading] = useState(true);
  const [animationError, setAnimationError] = useState(false);
  
  useEffect(() => {
    const fetchAnimation = async () => {
      try {
        setIsAnimationLoading(true);
        const response = await fetch(`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/AI-thinking.json`);
        if (!response.ok) throw new Error('Failed to load animation');
        const data = await response.json();
        setAnimationData(data);
      } catch (error) {
        console.error('Error loading Lottie animation:', error);
        setAnimationError(true);
      } finally {
        setIsAnimationLoading(false);
      }
    };
    
    fetchAnimation();
  }, []);

  const renderAvatar = () => {
    if (isAnimationLoading || animationError || !animationData) {
      return (
        <div 
          className="w-full h-full rounded-full animate-pulse"
          style={{ backgroundColor: colors['brand-primary'] }}
        />
      );
    }

    return (
      <Lottie
        animationData={animationData}
        loop={isLoading}
        autoplay={isLoading}
        style={{
          width: '100%',
          height: '100%',
        }}
        className="rounded-full overflow-hidden"
      />
    );
  };
  
  return (
    <div 
      className="flex items-start space-x-3 group animate-fadeIn"
      style={{ animationDelay: '0.1s' }}
    >
      {isLoading ? (
        <div className="flex items-center gap-2 animate-fadeIn">
          <div className="w-8 h-8 relative flex items-center justify-center rounded-full overflow-hidden">
            {renderAvatar()}
          </div>
          <span 
            className="text-xs"
            style={{ color: colors['text-secondary'] }}
          >
            Floz is thinking...
          </span>
        </div>
      ) : (
        <div 
          className="prose prose-sm p-3 max-w-[85%] transition-all duration-200"
          style={{ 
            color: colors['text-primary']
          }}
        >
          <p className="m-0 whitespace-pre-wrap break-words text-[13px] leading-[1.5]">{message}</p>
        </div>
      )}
    </div>
  );
};

export default AIChatMessage;

// Add to your global CSS or tailwind.config.js:
// @keyframes fadeIn {
//   from { opacity: 0; transform: translateY(10px); }
//   to { opacity: 1; transform: translateY(0); }
// }
// @keyframes slideIn {
//   from { opacity: 0; transform: translateX(-10px); }
//   to { opacity: 1; transform: translateX(0); }
// }
</file>

<file path="components/chat/ChatContainer.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { useColors } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';
import AIChatMessage from './AIChatMessage';
import UserChatMessage from './UserChatMessage';
import Lottie from 'lottie-react';

interface Message {
  id: string;
  content: string;
  role: 'user' | 'assistant';
}

const ChatContainer: React.FC = () => {
  const colors = useColors();
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [animationData, setAnimationData] = useState<any>(null);
  const [isAnimationLoading, setIsAnimationLoading] = useState(true);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const fetchAnimation = async () => {
      try {
        setIsAnimationLoading(true);
        const response = await fetch(`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/AI-thinking.json`);
        if (!response.ok) throw new Error('Failed to load animation');
        const data = await response.json();
        setAnimationData(data);
      } catch (error) {
        console.error('Error loading Lottie animation:', error);
      } finally {
        setIsAnimationLoading(false);
      }
    };
    
    fetchAnimation();
  }, []);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages, isLoading]);

  const handleSubmit = async () => {
    if (!input.trim() || isLoading) return;

    const userMessage: Message = {
      id: Date.now().toString(),
      content: input.trim(),
      role: 'user',
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    // Simulate AI response
    setTimeout(() => {
      const aiMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: `Here's how I can help with "${input.trim()}". As your process builder assistant, I can help you create and manage ProcessFlow workflows efficiently.`,
        role: 'assistant',
      };
      setMessages(prev => [...prev, aiMessage]);
      setIsLoading(false);
    }, 1000);
  };

  const handleExampleClick = (text: string) => {
    setInput(text);
    // Immediately send the message
    const userMessage: Message = {
      id: Date.now().toString(),
      content: text,
      role: 'user',
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    // Simulate AI response
    setTimeout(() => {
      const aiMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: `Here's how I can help with "${text}". As your process builder assistant, I can help you create and manage ProcessFlow workflows efficiently.`,
        role: 'assistant',
      };
      setMessages(prev => [...prev, aiMessage]);
      setIsLoading(false);
    }, 1000);
  };

  const renderWelcomeAnimation = () => {
    if (isAnimationLoading || !animationData) {
      return (
        <div 
          className="w-16 h-16 rounded-full animate-pulse"
          style={{ 
            background: 'radial-gradient(circle at 30% 30%, #7B5CF0 0%, #5D3DF2 100%)',
            boxShadow: '0 0 40px 5px rgba(123, 92, 240, 0.3)'
          }}
        />
      );
    }

    return (
      <div className="w-16 h-16">
        <Lottie
          animationData={animationData}
          loop={true}
          autoplay={true}
          style={{
            width: '100%',
            height: '100%',
          }}
          className="rounded-full overflow-hidden"
        />
      </div>
    );
  };

  return (
    <div className="flex flex-col h-full">
      {/* Content Area */}
      <div 
        className="flex-1 overflow-y-auto flex flex-col relative"
        style={{ backgroundColor: 'transparent' }}
      >
        {/* Messages or Welcome Screen */}
        <div className="flex-1">
          {messages.length === 0 && !isLoading ? (
            <div className="h-full flex flex-col items-center justify-center px-8 animate-fadeIn">
              {/* Purple gradient sphere replaced with Lottie animation */}
              <div className="relative mb-6 rounded-full overflow-hidden">
                {renderWelcomeAnimation()}
              </div>

              {/* Title and description */}
              <div className="flex flex-col items-center gap-2 text-center mb-6">
                <h3 
                  className="text-base font-semibold"
                  style={{ color: colors['text-primary'] }}
                >
                  Floz is your process builder assistant
                </h3>
                <p 
                  className="text-sm text-center"
                  style={{ color: colors['text-secondary'] }}
                >
                  Ask Floz to generate, optimize, personalize and fix issues within your process
                </p>
              </div>

              {/* Example prompts */}
              <div className="flex flex-col gap-2 w-full max-w-[300px]">
                <button
                  className="w-full p-3 rounded-xl text-sm text-left transition-all duration-200 hover:scale-[1.02] hover:shadow-md"
                  style={{ 
                    backgroundColor: colors['bg-secondary'],
                    color: colors['text-primary'],
                    boxShadow: `0 2px 4px ${colors['shadow-primary']}`
                  }}
                  onClick={() => handleExampleClick("Help me create a conditional path for user authentication")}
                >
                  "Help me create a conditional path for user authentication"
                </button>
                <button
                  className="w-full p-3 rounded-xl text-sm text-left transition-all duration-200 hover:scale-[1.02] hover:shadow-md"
                  style={{ 
                    backgroundColor: colors['bg-secondary'],
                    color: colors['text-primary'],
                    boxShadow: `0 2px 4px ${colors['shadow-primary']}`
                  }}
                  onClick={() => handleExampleClick("How can I optimize my current workflow?")}
                >
                  "How can I optimize my current workflow?"
                </button>
              </div>
            </div>
          ) : (
            <div className="p-4 space-y-4">
              {messages.map((msg, index) => (
                msg.role === 'assistant' ? (
                  <AIChatMessage 
                    key={msg.id} 
                    message={msg.content}
                    isLastMessage={index === messages.length - 1}
                  />
                ) : (
                  <UserChatMessage 
                    key={msg.id} 
                    message={msg.content}
                    isLastMessage={index === messages.length - 1}
                  />
                )
              ))}
              {isLoading && <AIChatMessage isLoading />}
              <div ref={messagesEndRef} />
            </div>
          )}
        </div>
      </div>

      {/* Input - Always visible */}
      <div 
        className="sticky bottom-0 w-full backdrop-blur-[10px] z-10"
        style={{ 
          backgroundColor: `${colors['bg-primary']}1A`,
          borderTop: `1px solid ${colors['border-primary']}`
        }}
      >
        <div className="w-full p-2">
          <form 
            onSubmit={(e) => {
              e.preventDefault();
              handleSubmit();
            }}
            className="flex flex-col sm:flex-row gap-2"
          >
            <div 
              className="flex-1 flex items-center gap-2 min-w-0 rounded-lg p-2"
              style={{
                backgroundColor: colors['bg-secondary']
              }}
            >
              <ButtonNormal
                variant="secondary"
                iconOnly
                size="small"
                leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/at-sign.svg`}
                className="!bg-transparent hover:!bg-opacity-10 flex-shrink-0"
              />
              <input
                type="text"
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && !e.shiftKey && handleSubmit()}
                placeholder="Build a conditional path for..."
                className="flex-1 min-w-0 bg-transparent border-none outline-none text-sm font-normal leading-[1.5] placeholder:text-[#85888E]"
                style={{ 
                  fontFamily: 'Inter',
                  color: colors['text-primary']
                }}
              />
              <ButtonNormal
                variant="secondary"
                iconOnly
                size="small"
                leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/paperclip.svg`}
                className="!bg-transparent hover:!bg-opacity-10 flex-shrink-0"
              />
            </div>
            <ButtonNormal
              type="submit"
              variant="primary"
              size="small"
              className="!bg-opacity-60 !border !border-[rgba(255,255,255,0.12)]  !font-medium !leading-none   !gap-0.5 transition-all duration-200 hover:!bg-opacity-80 whitespace-nowrap sm:self-stretch sm:flex sm:items-center"
              disabled={!input.trim() || isLoading}
            >
              Send
            </ButtonNormal>
          </form>
        </div>
      </div>
    </div>
  );
};

export default ChatContainer;
</file>

<file path="components/chat/UserChatMessage.tsx">
import React from 'react';
import { useColors } from '@/app/theme/hooks';

/**
 * Props for the UserChatMessage component
 */
interface UserChatMessageProps {
  /** The message content to display */
  message: string;
  /** Whether this is the last message in the conversation */
  isLastMessage?: boolean;
}

/**
 * Displays a user message in the chat interface
 */
const UserChatMessage: React.FC<UserChatMessageProps> = ({
  message,
  isLastMessage = false
}) => {
  const colors = useColors();
  
  return (
    <div 
      className="flex items-start justify-end animate-fadeIn"
      style={{ animationDelay: '0.1s' }}
    >
      <div className="w-full">
        <div 
          className="prose prose-sm p-3 rounded-lg w-full shadow-sm border"
          style={{ 
            backgroundColor: colors['bg-secondary'],
            color: colors['text-primary'],
            borderColor: colors['border-primary'],
            boxShadow: `0 2px 4px ${colors['shadow-primary']}`
          }}
        >
          <p className="m-0 whitespace-pre-wrap break-words text-[13px] leading-[1.5]">{message}</p>
        </div>
      </div>
    </div>
  );
};

export default UserChatMessage;
</file>

<file path="components/ui/AIThinkingOrb.tsx">
import React from 'react';

interface AIThinkingOrbProps {
  size?: number;
  isThinking?: boolean;
}

const AIThinkingOrb: React.FC<AIThinkingOrbProps> = ({ 
  size = 24, 
  isThinking = false
}) => {
  if (!isThinking) return null;
  
  return (
    <div className="flex items-center justify-center" style={{ width: size, height: size }}>
      <div className="flex space-x-1">
        <div className="w-2 h-2 rounded-full bg-blue-500 animate-bounce" style={{ animationDelay: '0ms' }}></div>
        <div className="w-2 h-2 rounded-full bg-blue-500 animate-bounce" style={{ animationDelay: '300ms' }}></div>
        <div className="w-2 h-2 rounded-full bg-blue-500 animate-bounce" style={{ animationDelay: '600ms' }}></div>
      </div>
    </div>
  );
};

export default AIThinkingOrb;
</file>

<file path="docs/test-cases/authentication.md">
<!-- AUTO-GENERATED START -->

# ProcessFlow Authentication BDD Test



## Feature: User Registration



# User Registration


As a new user

I want to create an account

So that I can access ProcessFlow



Background:

**Given** I am on the signup page

**And** I am not authenticated



## Scenario: Successful email/password registration


**When** I enter a valid email "user@example.com"

**And** I enter a strong password "StrongPass123!"

**And** I click the "Sign up" button

**Then** I should see a success message

**And** I should be redirected to login page with pre-filled email

**And** a confirmation email should be sent to "user@example.com"



## Scenario: Registration with weak password


**When** I enter a valid email "user@example.com"

**And** I enter a weak password "123"

**And** I click the "Sign up" button

**Then** I should see error "Password must be at least 8 characters and include uppercase, lowercase, number, and special character."

**And** the signup should not proceed



## Scenario: Registration with invalid email


**When** I enter an invalid email "invalid-email"

**And** I enter a strong password "StrongPass123!"

**And** I click the "Sign up" button

**Then** I should see error "Please enter a valid email address."

**And** the signup should not proceed



## Scenario: Registration with existing email


**Given** a user already exists with email "existing@example.com"

**When** I enter email "existing@example.com"

**Then** the system should perform an immediate email availability check

**And** no visual feedback should be shown about email existence

**When** I enter a strong password "StrongPass123!"

**And** I click the "Sign up" button

**Then** the system should perform a final email existence check

**And** I should see message "If your signup was successful, check your email."

**And** no new account should be created

**And** no confirmation email should be sent

**And** I should be redirected to login page with pre-filled email



## Scenario: Google OAuth registration


**When** I click "Sign up with Google"

**Then** I should be redirected to Google OAuth

**And** after successful Google authentication

**Then** I should be redirected to "/auth/callback"

**And** a new user account should be created

**And** I should be redirected to the onboarding page



## Feature: User Authentication



```gherkin

# User Authentication


As a registered user

I want to log into my account

So that I can access ProcessFlow



Background:

**Given** I am on the login page

**And** I am not authenticated



## Scenario: Successful login with confirmed email (new user)


**Given** a new user exists with email "newuser@example.com" and confirmed email

**And** the user has not completed onboarding

**When** I enter email "newuser@example.com"

**And** I enter the correct password

**And** I click the "Log in" button

**Then** I should be logged in successfully

**And** I should be redirected to "/onboarding"

**And** a session cookie should be set



## Scenario: Successful login with confirmed email (existing user)


**Given** an existing user with email "user@example.com" and confirmed email

**And** the user has completed onboarding

**When** I enter email "user@example.com"

**And** I enter the correct password

**And** I click the "Log in" button

**Then** I should be logged in successfully

**And** I should be redirected to the dashboard "/"

**And** a session cookie should be set



## Scenario: Login attempt with unconfirmed email


**Given** a user exists with email "unconfirmed@example.com" and unconfirmed email

**When** I enter email "unconfirmed@example.com"

**And** I enter the correct password

**And** I click the "Log in" button

**Then** I should see message "Please confirm your email before logging in"

**And** I should not be logged in



## Scenario: Login with invalid credentials


**When** I enter email "user@example.com"

**And** I enter an incorrect password

**And** I click the "Log in" button

**Then** I should see error "Login Failed"

**And** I should not be logged in

**And** the failed attempt should be tracked



## Scenario: Login with invalid email format


**When** I enter an invalid email "invalid-email"

**And** I enter any password

**And** I click the "Log in" button

**Then** I should see error "Invalid Email"

**And** the login should not proceed



## Scenario: Google OAuth login (new user)


**When** I click "Log in with Google"

**Then** I should be redirected to Google OAuth

**And** after successful Google authentication

**Then** I should be redirected to "/auth/callback"

**And** I should be logged in automatically

**And** I should be redirected to "/onboarding"



## Scenario: Google OAuth login (existing user)


**Given** an existing user with Google account

**And** the user has completed onboarding

**When** I click "Log in with Google"

**Then** I should be redirected to Google OAuth

**And** after successful Google authentication

**Then** I should be redirected to "/auth/callback"

**And** I should be logged in automatically

**And** I should be redirected to the dashboard

```



## Feature: Authentication Security



```gherkin

# Authentication Security


As a security-conscious system

I want to protect against authentication attacks

So that user accounts remain secure



## Scenario: Rate limiting on failed login attempts


**Given** I am on the login page

**When** I make 30 failed login attempts within 10 minutes

**Then** I should be blocked from further attempts

**And** I should see message "Too many failed attempts"

**And** I should be blocked for 10 minutes

**And** the block timer should count down



## Scenario: Rate limiting on auth routes


**Given** I am accessing authentication routes

**When** I make more than 20 requests per minute

**Then** I should receive a "429 Too many requests" response

**And** further requests should be blocked



## Scenario: Password strength validation


**Given** I am on the signup page

**When** I enter a password without uppercase letters

**Then** I should see password strength error

**When** I enter a password without lowercase letters

**Then** I should see password strength error

**When** I enter a password without numbers

**Then** I should see password strength error

**When** I enter a password without special characters

**Then** I should see password strength error

**When** I enter a password shorter than 8 characters

**Then** I should see password strength error



## Scenario: Session management


**Given** I am logged in

**When** my session is valid

**Then** I should have access to protected routes

**When** my session expires

**Then** I should be redirected to login page

**When** I log out

**Then** my session should be invalidated

**And** I should be redirected to login page

```



## Feature: Navigation Control



```gherkin

# Navigation Control


As the application

I want to control user navigation based on authentication state

So that users see appropriate content



## Scenario: Authenticated user accessing auth routes


**Given** I am logged in

**When** I try to access "/login"

**Then** I should be redirected to dashboard "/"

**When** I try to access "/signup"

**Then** I should be redirected to dashboard "/"

**When** I try to access "/reset-password"

**Then** I should be redirected to dashboard "/"



## Scenario: Unauthenticated user accessing protected routes


**Given** I am not authenticated

**When** I try to access "/dashboard"

**Then** I should be redirected to "/login"

**And** the redirect parameter should include original path

**When** I try to access "/workspace/123"

**Then** I should be redirected to "/login"



## Scenario: Onboarding flow for new users


**Given** I am a newly registered user

**And** my onboarding is not complete

**When** I log in successfully

**Then** I should be redirected to "/onboarding"

**Given** my onboarding is complete

**When** I try to access "/onboarding"

**Then** I should be redirected to dashboard "/"



## Scenario: Complete onboarding flow for new user


**Given** I am a newly registered user

**And** my onboarding is not complete

**When** I log in successfully

**Then** I should be redirected to "/onboarding"

**And** I should see the onboarding progress indicator

**When** I complete the personal information step

**Then** I should proceed to the professional information step

**When** I complete the professional information step

**Then** I should proceed to the workspace setup step

**When** I complete the workspace setup step

**Then** I should proceed to the completion step

**And** the system should create my workspace

**And** the system should create default workflows

**When** I click "Continue to Dashboard"

**Then** I should be redirected to dashboard "/"

**And** An email should be sent to the user with the subject "Welcome to ProcessFlow"

**And** my onboarding should be marked as complete

**And** I should not be able to access "/onboarding" anymore



## Scenario: URL sanitization


**Given** I access a URL with encoded spaces "/workspace%20name/flow"

**Then** I should be redirected to "/workspace-name/flow"

**And** the URL should be properly formatted



## Scenario: Embed route protection


**Given** I access an embed route "/shared/flow/123/embed"

**Then** the response should include headers:

| X-Frame-Options         | ALLOWALL          |

| Content-Security-Policy | frame-ancestors * |

```



## Feature: Email Confirmation Flow



```gherkin

# Email Confirmation Flow


As a new user

I want to confirm my email address

So that I can complete my registration



## Scenario: Email confirmation success


**Given** I have registered with email "user@example.com"

**And** I received a confirmation email

**When** I click the confirmation link in the email

**Then** I should be redirected to "/auth/confirm"

**And** my email should be marked as confirmed

**And** I should be automatically logged in

**And** I should be redirected to "/onboarding"



## Scenario: Email confirmation with invalid token


**When** I access "/auth/confirm" with an invalid token

**Then** I should see an error message

**And** my email should remain unconfirmed



## Scenario: Resending confirmation email


**Given** I have registered but not confirmed my email

**When** I try to log in

**Then** I should see option to resend confirmation email

**When** I click "resend confirmation"

**Then** a new confirmation email should be sent

```

<!-- AUTO-GENERATED END -->
</file>

<file path="docs/test-cases/dashboard.md">
<!-- AUTO-GENERATED START -->

# ProcessFlow Dashboard BDD Tests



# Dashboard Access and Layout


As a logged-in user

I want to access and navigate the dashboard

So that I can manage my workflows and workspace



Background:

**Given** I am a logged-in user

**And** I have completed onboarding

**And** I am on the dashboard page "/"



## Scenario: Dashboard loads successfully


**When** I access the dashboard

**Then** I should see the sidebar with workspace information on the left corner

**And** I should see the main canvas area

**And** I should see the "My Flows" header

**And** I should see my user profile in the header bar on the right



## Scenario: Recently used workflows section


**Given** I have workflows with recent activity

**When** I view the dashboard

**Then** I should see a "Recently Used" section

**And** it should show up to 4 most recently used workflows

**And** workflows should be ordered by last_opened timestamp



## Scenario: Empty state handling


**Given** I have no workflows in my workspace

**When** I view the dashboard

**Then** I should see an appropriate empty state like 'No workflows found'

**And** I should see options to create my first workflow



# Workflow Management


As a user

I want to manage my workflows

So that I can organize and maintain my processes



Background:

**Given** I am on the dashboard

**And** I have access to workflow management features



## Scenario: Creating a new workflow


**When** I click the "New Flow" button

**Then** I should see the "Create a new Flow" modal

**When** I enter flow name like "Employee Onboarding"

**And** I enter flow description like "Process for onboarding new employees"

**And** I click the "Create Flow" button

**Then** the modal should close

**And** I should immeditely go into the new workflow

**And** I should see a success notification like "Flow created successfully"



## Scenario: Workflow name validation during creation


**When** I open the create flow modal

**And** I leave the flow name empty

**Then** the "Create Flow" button should be disabled

**When** I enter a flow name with 101 characters

**Then** only the first 100 characters should be accepted

**Then** I should see a validation error like "Flow name must be less than 100 characters"

**And** the "Create Flow" button should be disabled

**When** I enter flow name with special characters "<script>alert('xss')</script>"

**Then** the input should be sanitized



## Scenario: Editing an existing workflow


**Given** I have a workflow named "Test Workflow"

**When** I click the workflow actions menu

**And** I select "Edit"

**Then** I should see the "Edit a Flow" modal

**And** the form should be pre-filled with current workflow data

**When** I change the name to "Updated Workflow"

**And** I click "Save changes"

**Then** the modal should close

**And** the workflow should show the updated name



## Scenario: Workflow icon selection


**When** I create or edit a workflow

**And** I click the icon selector

**Then** I should see the icon selection modal

**And** I should see tabs for Icons, Apps, Upload

**When** I select an icon from the Icons tab

**Then** the icon should be applied to the workflow



## Scenario: Deleting a workflow


**Given** I have a workflow named "Test Workflow"

**When** I click the workflow actions menu

**And** I select "Delete"

**Then** I should see a confirmation modal

**And** the modal should warn that the action cannot be undone

**When** I click "Delete"

**Then** the workflow should be removed from the workspace

**And** I should see a success notification



## Scenario: Duplicating a workflow


**Given** I have a workflow named "Original Workflow"

**When** I click the workflow actions menu

**And** I select "Duplicate"

**Then** a copy of the workflow should be created

**And** it should be named "Original Workflow (Copy)"

**And** both workflows should be visible in the workspace



## Scenario: Moving a workflow to a folder


**Given** I have a workflow and multiple folders

**When** I click the workflow actions menu

**And** I select "Move"

**Then** I should see the "Move Flow" modal

**And** I should see a folder tree structure

**When** I select a target folder

**And** I click "Move"

**Then** the workflow should be moved to the selected folder

**And** it should no longer appear in the current view if filtered

**And** I should see a success notification like "Flow moved successfully"

**And** My view should be updated to show the workflow in the new folder



## Scenario: Workflow status management


**Given** I have a workflow

**When** I click the workflow status indicator

**Then** I should see status options (Draft, Active, Archived, In Review, Needs Update)

**When** I select "Active"

**Then** the workflow status should update

**And** the status indicator should reflect the change



## Scenario: Copying workflow link


**Given** I have a workflow

**When** I click the workflow actions menu

**And** I select "Copy link"

**Then** the workflow URL should be copied to clipboard

**And** I should see a "Link copied!" notification



## Scenario: Sharing a workflow


**Given** I have a workflow

**When** I click the workflow actions menu

**And** I select "Share"

**Then** I should see the share modal

**And** I should see sharing options and link

**And** I should be able to switch between sharing options like "Public" and "Private"

**And** I should be able to switch between "Share" and "Embed" options

**And** I should be able to copy the link to the clipboard

**And** I should see a "Link copied!" notification



# Folder Management


As a user

I want to organize my workflows in folders

So that I can maintain a structured workspace



Background:

**Given** I am on the dashboard

**And** I have folder management permissions



## Scenario: Creating a new folder


**When** I click the "+" button next to folders

**Then** I should see the "Create a folder" modal

**When** I enter folder name "HR Processes"

**And** I select an icon or emoji

**And** I click "Create"

**Then** the folder should appear in the sidebar

**And** I should see a success notification



## Scenario: Folder name validation


**When** I create a folder

**And** I leave the folder name empty

**Then** the "Create" button should be disabled

**When** I enter a folder name with 101 characters

**Then** only the first 100 characters should be accepted

**And** an error message should be displayed like "Folder name must be less than 100 characters"

**And** the "Create" button should be disabled



## Scenario: Creating a subfolder


**Given** I have a folder named "HR Processes"

**When** I right-click on the folder

**And** I select "Create subfolder"

**Then** I should see the "Create a Subfolder" modal

**And** I should see the parent folder context

**When** I enter subfolder name "Onboarding"

**And** I click "Create"

**Then** the subfolder should appear under the parent folder



## Scenario: Editing a folder


**Given** I have a folder named "HR Processes"

**When** I right-click on the folder

**And** I select "Edit folder"

**Then** I should see the "Edit a folder" modal

**And** the form should be pre-filled with current folder data

**When** I change the name to "Human Resources"

**And** I click "Save changes"

**Then** the folder should show the updated name



## Scenario: Deleting a folder


**Given** I have a folder with no workflows

**When** I right-click on the folder

**And** I select "Delete folder"

**Then** I should see a confirmation modal

**And** it should warn that the action cannot be undone

**And** it should mention that flows inside will not be deleted

**When** I click "Delete"

**Then** the folder should be removed

**And** any workflows should remain in the workspace



## Scenario: Folder icon and emoji selection


**When** I create or edit a folder

**And** I click the icon selector

**Then** I should see icon selection options

**When** I select a company logo

**Then** the logo should be applied to the folder

**When** I select an emoji

**Then** the emoji should be displayed as the folder icon



## Scenario: Folder expansion and collapse


**Given** I have a folder with subfolders

**When** I click the folder expand/collapse arrow

**Then** the folder should expand to show subfolders

**When** I click the arrow again

**Then** the folder should collapse to hide subfolders



## Scenario: Navigating to folder contents


**Given** I have a folder with workflows

**When** I click on the folder name

**Then** the main canvas should show only workflows in that folder

**And** the header should show the folder name and icon

**And** I should see a breadcrumb or back navigation option



# Search and Filtering


As a user

I want to search and filter my workflows

So that I can quickly find what I need



Background:

**Given** I am on the dashboard

**And** I have multiple workflows and folders



## Scenario: Basic workflow search


**When** I enter "onboarding" in the search bar

**Then** I should see only workflows containing "onboarding" in the name

**And** other workflows should be hidden

**When** I clear the search

**Then** all workflows should be visible again



## Scenario: Search with no results


**When** I enter "nonexistent" in the search bar

**Then** I should see a "no results" message

**And** no workflows should be displayed



## Scenario: Search is case insensitive


**When** I enter "ONBOARDING" in the search bar

**Then** I should see workflows containing "onboarding" (lowercase)

**And** the search should work regardless of case



## Scenario: Real-time search filtering


**When** I start typing in the search bar

**Then** the results should update in real-time

**And** I should not need to press Enter to search



## Scenario: Search within specific folder


**Given** I am viewing a specific folder

**When** I enter a search term

**Then** I should see only workflows from that folder matching the search

**And** workflows from other folders should not appear



## Scenario: Folder filtering


**When** I select a folder from the sidebar

**Then** the main canvas should show only workflows in that folder

**And** the header should indicate the current folder

**When** I select "My Flows" (root level)

**Then** I should see all workflows not in folders



# User Profile Management


As a user

I want to manage my profile and account settings

So that I can keep my information current and secure



Background:

**Given** I am logged in to the dashboard

**And** I can access user settings



## Scenario: Accessing user settings


**When** I click on my user profile in the header bar on the right

**Then** I should see a user dropdown menu

**When** I select "Account settings"

**Then** I should see the user settings page



## Scenario: Updating profile information


**When** I am in user settings

**And** I change my first name to "John"

**And** I change my last name to "Doe"

**And** I click "Save changes"

**Then** my profile should be updated

**And** I should see a success notification

**And** the changes should be reflected in the UI



## Scenario: Profile information validation


**When** I am editing my profile

**And** I enter a first name with 41 characters

**Then** only the first 40 characters should be accepted

**When** I enter special characters in my name

**Then** the input should be sanitized appropriately



## Scenario: Changing email address


**When** I am in user settings

**And** I enter a new email address

**And** I click "Change email"

**Then** I should see a confirmation dialog

**When** I confirm the change

**Then** a verification email should be sent

**And** I should see instructions to verify the new email



## Scenario: Email validation


**When** I enter an invalid email format

**Then** I should see an error message

**And** the save button should be disabled

**When** I enter a valid email format

**Then** the error should clear

**And** the save button should be enabled



## Scenario: Changing password


**When** I am in user settings

**And** I click "Change password"

**Then** I should see a password change form

**When** I enter my current password

**And** I enter a new password

**And** I confirm the new password

**And** I click "Update password"

**Then** I should see a confirmation dialog

**When** I confirm the password change

**Then** my password should be updated

**And** I should be logged out of other devices



## Scenario: Password validation


**When** I am changing my password

**And** I enter a password shorter than 8 characters

**Then** I should see a validation error

**When** I enter a password without uppercase letters

**Then** I should see a validation error

**When** I enter a password without lowercase letters

**Then** I should see a validation error

**When** I enter a password without numbers

**Then** I should see a validation error

**When** I enter a password without special characters

**Then** I should see a validation error

**When** I enter mismatched password confirmations

**Then** I should see a validation error

**When** I enter a valid password "StrongPass123!"

**And** I confirm the same password "StrongPass123!"

**Then** the validation should clear

**And** the save button should be enabled



## Scenario: Account deletion


**When** I am in user settings

**And** I click "Delete account"

**Then** I should see a confirmation dialog

**And** I should be required to enter my password

**When** I enter my password and confirm deletion

**Then** my account should be deleted

**And** I should be redirected to the home page



# Settings and Configuration


As a user

I want to configure my workspace and billing settings

So that I can customize my experience and manage my subscription



Background:

**Given** I am on the dashboard

**And** I have access to settings



## Scenario: Navigating settings tabs


**When** I open settings

**Then** I should see tabs for Plan, billing, workspace and appearance

**When** I click on the workspace tab

**Then** I should see workspace-specific settings

**When** I click on the billing tab

**Then** I should see billing and subscription information



## Scenario: Workspace settings management


**When** I am in workspace settings

**Then** I should see the current workspace name and logo

**When** I change the workspace name

**And** I click "Save changes"

**Then** the workspace should be updated

**And** the changes should be reflected throughout the UI



## Scenario: Workspace logo upload - valid file types


**When** I upload a PNG file smaller than 5MB

**Then** the logo should be accepted and displayed

**When** I upload a JPEG file smaller than 5MB

**Then** the logo should be accepted and displayed

**When** I upload an SVG file smaller than 5MB

**Then** the logo should be accepted and displayed

**When** I upload a file with an invalid type

**Then** I should see an error message like "Invalid file type. Please upload a PNG, JPG, GIF, or SVG image."

**When** I upload a file with an invalid size

**Then** I should see an error message like "File is too large. Maximum size is 5MB."

**And** the file should not be accepted



## Scenario: Workspace name validation


**When** I am in workspace settings

**And** I leave the workspace name empty

**Then** I should see a validation error like "Workspace name is required"

**And** the "Save" button should be disabled

**When** I enter a workspace name with 51 characters

**Then** only the first 50 characters should be accepted

**And** I should see a validation error like "Workspace name cannot be longer than 50 characters"

**When** I enter workspace name with invalid characters "Invalid!Name@#$"

**Then** the invalid characters should be removed automatically

**And** only valid characters (letters, numbers, spaces, hyphens) should remain

**When** I enter a valid workspace name "My Company-123"

**Then** the validation should clear

**And** the "Save" button should be enabled



## Scenario: Billing information display


**When** I am in billing settings

**Then** I should see my current subscription plan

**And** I should see billing address information

**And** I should see payment method details if configured

**When** I click "Edit Billing Details"

**Then** I should be redirected to the Stripe customer portal



## Scenario: Subscription plan management


**Given** I have a subscription

**When** I am in billing settings

**Then** I should see options to change my plan

**And** I should see billing period options (monthly/annual)

**When** I select a different plan

**Then** I should see pricing information

**And** I should be able to confirm the change



## Scenario: Plan downgrade confirmation


**Given** I have a paid subscription

**When** I attempt to downgrade to a free plan

**Then** I should see a confirmation dialog

**And** I should see information about feature limitations

**When** I confirm the downgrade

**Then** my plan should be changed

**And** I should see updated feature access



## Scenario: Workspace deletion


**When** I am in workspace settings

**And** I click "Delete workspace"

**Then** I should see a confirmation dialog

**And** I should be required to type the workspace name

**When** I enter the correct workspace name and confirm

**Then** the workspace should be deleted

**And** I should be redirected appropriately



# Help and Tutorial


As a user

I want to access help and tutorial features

So that I can learn how to use the platform effectively



Background:

**Given** I am on the dashboard



## Scenario: Accessing help center


**When** I click on my user profile

**And** I select "Help center"

**Then** I should see the help center modal

**And** I should see options for different types of help



## Scenario: Help center options


**When** I open the help center

**Then** I should see "Reach out to us" option

**And** I should see "Take a look at our roadmap" option

**And** I should see "Join our Slack community" option

**When** I click "Reach out to us"

**Then** my email client should open with a pre-filled email

**When** I click "Join our Slack community"

**Then** I should be redirected to the Slack invitation link



## Scenario: Tutorial functionality


**When** I access the tutorial option

**Then** I should see the tutorial overlay

**And** I should see step-by-step guidance

**When** I click "Next" on tutorial steps

**Then** I should progress through the tutorial

**And** relevant UI elements should be highlighted



## Scenario: Tutorial navigation


**When** I am in the tutorial

**Then** I should see current step indicators

**And** I should see options to skip or continue

**When** I click "Skip"

**Then** the tutorial should end

**And** I should return to normal dashboard view



## Scenario: Tutorial completion


**When** I complete all tutorial steps

**Then** the tutorial should end automatically

**And** my tutorial status should be marked as complete

**And** I should not see tutorial prompts again



## Scenario: Restarting tutorial


**Given** I have completed the tutorial previously

**When** I access the help center

**And** I select restart tutorial option

**Then** the tutorial should start from the beginning

**And** my tutorial status should be reset





# Error Handling and Edge Cases


As a user

I want the system to handle errors gracefully

So that I can continue working even when issues occur



Background:

**Given** I am on the dashboard



## Scenario: Network connectivity issues


**When** I lose network connectivity

**And** I try to perform an action

**Then** I should see an appropriate error message like "Something went wrong. Please try again."

**And** the action should not complete

**When** connectivity is restored

**Then** I should be able to retry the action



## Scenario: API failure handling


**When** an API call fails during workflow creation

**Then** I should see an error notification like "Failed to create workflow"

**And** the modal should remain open

**And** I should be able to retry the operation



## Scenario: File upload failures


**When** a file upload fails due to network issues

**And** I should be able to retry the upload

**When** the upload succeeds on retry

**Then** I should see a success confirmation



## Scenario: Validation error handling


**When** I submit a form with invalid data

**Then** I should see specific validation errors like "Name is required"

**And** the form should not submit

**And** invalid fields should be highlighted

**When** I correct the errors

**Then** the validation should clear

**And** I should be able to submit successfully



## Scenario: Browser refresh handling


**When** I refresh the page during an operation

**Then** I should return to a consistent state

**And** any unsaved changes should be handled appropriately

**And** I should see appropriate notifications about lost changes like "Changes not saved"



## Scenario: Modal and overlay error handling


**When** an error occurs while a modal is open

**Then** the error should be displayed within the modal context like "An error occurred"

**And** I should have options to retry or cancel

**When** multiple modals are triggered simultaneously

**Then** they should be handled in a logical order

**And** the UI should remain stable

<!-- AUTO-GENERATED END -->
</file>

<file path="docs/test-cases/editor.md">
<!-- AUTO-GENERATED START -->

# ProcessFlow Editor BDD Tests



# Editor Access and Layout


As a logged-in user

I want to access and navigate the workflow editor

So that I can create and modify my workflows



Background:

**Given** I am a logged-in user

**And** I am on the editor page of a workflow



## Scenario: Editor loads successfully


**When** I access the workflow editor

**Then** I should see the workflow header with the workflow name

**And** I should see the main canvas area

**And** I should see the sidebar on the left

**And** I should see zoom controls

**And** I should see a "Begin" block on the canvas

**And** I should see navigation breadcrumbs



## Scenario: Editor header functionality


**When** I am in the editor

**Then** I should see the workflow title in the header

**And** I should see a "Read Mode" button

**When** I click the workflow title

**Then** I should be able to edit the workflow title inline

**When** I click "Read Mode"

**Then** I should be redirected to the read view of the workflow



## Scenario: Sidebar navigation


**When** I am in the editor

**Then** I should see the sidebar with workflow navigation

**And** I should see a list of all blocks in the workflow

**And** I should see block hierarchy with proper indentation

**When** I click on a block in the sidebar

**Then** the canvas should center on that block

**And** the block should be highlighted



## Scenario: Canvas interaction


**When** I am in the editor

**Then** I should be able to pan the canvas by dragging

**And** I should be able to zoom in and out using mouse wheel

**And** I should be able to zoom using the zoom controls

**When** I double-click on an empty area

**Then** the canvas should fit all blocks in view



# Block Creation and Management


As a user

I want to create and manage different types of blocks

So that I can build comprehensive workflows



Background:

**Given** I am in the workflow editor

**And** I can see the canvas with a "Begin" block



## Scenario: Adding a Step block


**When** I click the "+" button after the Begin block

**Then** I should see the add block dropdown menu

**And** I should at least see the "Step" block option

**When** I select "Step"

**Then** a new Step block should be added to the workflow

**And** the block should have a default title like "Untitled Block"

**And** the block should have a default icon

**And** the dropdown menu should close



## Scenario: Adding a Condition block


**When** I click the "+" button after the Begin block

**And** I select "Condition"

**Then** I should see the "Create a new condition" modal

**When** I enter condition name "Approval Decision"

**And** I enter condition description "Determine if the request is approved or rejected"

**And** I add path names "Approved" and "Rejected"

**And** I click "Create Paths"

**Then** the modal should close

**And** a Condition block should be created

**And** two parallel paths should be created with the specified names

**And** each path should have its own branch on the canvas



## Scenario: Adding a Delay block


**When** I click the "+" button after a Step block

**And** I select "Delay"

**Then** I should see the delay type selection modal

**When** I select "Fixed Duration"

**Then** I should see the fixed delay configuration modal

**When** I set the delay to 2 hours and 30 minutes

**And** I click "Create Delay"

**Then** a Fixed Delay block should be added

**And** the block should display "2h 30m" as the delay time



## Scenario: Adding an Event Delay block


**When** I click the "+" button after a Step block

**And** I select "Delay"

**And** I select "Wait For Event"

**Then** I should see the event delay configuration modal

**When** I enter event name "Client Response"

**And** I set maximum wait time to 3 days

**And** I click "Create Delay"

**Then** an Event Delay block should be added

**And** the block should display "Wait for Client Response (max 3 days)"



## Scenario: Adding an End block


**Given** I have a workflow with multiple blocks

**When** I click the "+" button after the last block in a path

**Then** I should see the add block dropdown menu

**And** I should see an "End Block" option

**When** I select "End Block"

**Then** an End block should be added





# Block Editing and Properties


As a user

I want to edit block properties and content

So that I can provide detailed information for each step



Background:

**Given** I am in the workflow editor

**And** I have a Step block on the canvas



## Scenario: Opening block details sidebar


**When** I click on a Step block

**Then** the block details sidebar should open on the right

**And** I should see the block's current title

**And** I should see the block's icon

**And** I should see fields for description, average time, and media

**And** I should see a close button

**And** when I click on the canvas, the sidebar should close



## Scenario: Editing block title


**When** I open the block details sidebar

**And** I click on the block title

**Then** the title should become editable

**When** I change the title to "Review Application"

**Then** the title should be updated

**And** the sidebar should show the new title

**And** the block on the canvas should show the new title



## Scenario: Editing block description


**When** I open the block details sidebar

**And** I click in the description area

**Then** the description field should become editable

**When** I enter "Review the submitted application for completeness and accuracy"

**And** I click outside the description field

**Then** the description should be saved

**And** the description should be visible in the sidebar



## Scenario: Changing block icon


**When** I open the block details sidebar

**And** I click on the block icon

**Then** I should see the icon selection modal

**And** I should see tabs for "Icons", "Apps", and "Upload"

**When** I select an icon from the Icons tab

**Then** the icon should be applied to the block

**And** the modal should close

**And** the block should display the new icon



## Scenario: Adding block media


**When** I open the block details sidebar

**And** I click in the media section

**Then** I should see a file upload area

**When** I drag and drop an image file

**Then** the image should be uploaded

**And** the image should be displayed in the media section

**And** I should see options to edit or remove the image



## Scenario: Editing block media


**Given** I have a block with an uploaded image

**When** I open the block details sidebar

**And** I click the edit button on the image

**Then** I should see the image editor modal

**When** I make edits to the image

**And** I click "Save"

**Then** the edited image should be saved

**And** the original image should be preserved for reset option



# Block Actions and Context Menu


As a user

I want to perform various actions on blocks

So that I can efficiently manage my workflow



Background:

**Given** I am in the workflow editor

**And** I have multiple blocks in my workflow



## Scenario: Block context menu


**When** I click the three dots menu on a Step block

**Then** I should see a context menu with options

**And** I should see "Edit", "Copy", "Delete", "Connect Blocks", and "Copy Link" options



## Scenario: Copying a block


**When** I click the three dots menu on a Step block

**And** I select "Copy"

**Then** the block should be copied to the clipboard

**And** I should see a "Block copied" notification



## Scenario: Pasting a block


**Given** I have copied a block to the clipboard

**When** I click the "+" button at any position

**Then** I should see a "Paste Block" option in the dropdown

**When** I select "Paste Block"

**Then** a copy of the block should be created at that position

**And** the new block should have "(copy)" appended to its title



## Scenario: Deleting a block


**When** I click the three dots menu on a Step block

**And** I select "Delete"

**Then** I should see a confirmation modal

**When** I confirm the deletion

**Then** the block should be removed from the workflow

**And** subsequent blocks should move up to fill the gap



## Scenario: Connecting blocks with stroke lines


**When** I click the three dots menu on a Step block

**And** I select "Connect Blocks"

**Then** I'll see a modal with a search bar

**When** I search for a block

**Then** I should see the block in the search results

**When** I click on the block

**Then** I should see the connection modal

**When** I enter a connection label "If rejected"

**And** I click "Connect"

**Then** a stroke line should be created between the blocks

**And** the line should display the label



# Path Management and Conditions


As a user

I want to create and manage conditional paths

So that I can model complex decision-based workflows



Background:

**Given** I am in the workflow editor

**And** I have a workflow with at least one Condition block



## Scenario: Editing existing paths


**Given** I have a Condition block with 3 paths

**When** I click the three dots menu on the Condition block

**And** I select "Edit"

**Then** I should see the "Update Paths" modal

**And** I should see the current paths listed

**When** I modify a path name from "Approved" to "Fully Approved"

**And** I add a new path "Conditionally Approved"

**And** I remove the "Rejected" path

**And** I click "Update Paths"

**Then** the paths should be updated accordingly

**And** the workflow should reflect the changes



## Scenario: Merging paths


**Given** I have multiple parallel paths that need to converge

**When** I click the three dots menu on the last step block of a path

**And** I select "Merge Paths"

**Then** I should enter merge mode

**And** I should see path selection indicators

**When** I select the paths I want to merge

**And** I click "Merge Selected Paths"

**Then** the selected paths should converge into a single path



## Scenario: Path labels and editing


**Given** I have conditional paths

**When** I click on a path label

**Then** the label should become editable

**When** I change the label text

**And** I press Enter or I click outside the label

**Then** the label should be updated

**And** the change should be reflected in the workflow



# Stroke Lines and Connections


As a user

I want to create custom connections between blocks

So that I can model complex workflows with loops and non-linear flows



Background:

**Given** I am in the workflow editor

**And** I have multiple blocks in different paths



## Scenario: Creating a stroke line connection


**When** I click the three dots menu on a source block

**And** I select "Connect Blocks"

**Then** I should enter connection mode

**When** I click on a target block

**Then** I should see the connection modal

**And** I should see the source and target blocks highlighted

**When** I enter connection label "Return for revision"

**And** I click "Create Connection"

**Then** a stroke line should be drawn between the blocks

**And** the line should display the label



## Scenario: Deleting stroke lines


**Given** I have a stroke line connection

**When** I click on the stroke line

**And** I select "Delete"

**Then** I should see a confirmation modal

**When** I confirm the deletion

**Then** the stroke line should be removed

**And** the connection should no longer exist



## Scenario: Stroke line visibility toggle


**Given** I have multiple stroke lines in my workflow

**When** I click the stroke lines visibility toggle

**Then** all stroke lines should be hidden

**When** I click the toggle again

**Then** all stroke lines should be visible again



## Scenario: Editing stroke line control points


**Given** I have a stroke line with a curved path

**When** I hover over the stroke line

**Then** I should see control points for adjusting the curve

**When** I drag a control point

**Then** the stroke line path should adjust accordingly

**And** the new path should be saved



# Sidebar Navigation and Block Management


As a user

I want to navigate and manage blocks through the sidebar

So that I can efficiently work with large workflows



Background:

**Given** I am in the workflow editor

**And** I have a complex workflow with multiple paths and blocks



## Scenario: Sidebar block hierarchy


**When** I look at the sidebar

**Then** I should see all blocks organized hierarchically

**And** I should see proper indentation for nested paths

**And** I should see block icons and titles

**And** I should see block duration estimates



## Scenario: Sidebar search functionality


**When** I enter "approval" in the sidebar search box

**Then** only blocks containing "approval" should be visible

**And** other blocks should be filtered out

**When** I clear the search

**Then** all blocks should be visible again



## Scenario: Sidebar block navigation


**When** I click on a block in the sidebar

**Then** the canvas should center on that block

**And** the block should be highlighted

**And** I should see the block details sidebar open on the right



## Scenario: Sidebar path collapsing


**Given** I have paths with multiple nested blocks

**When** I click the collapse arrow next to a path

**Then** the path's child blocks should be hidden

**When** I click the expand arrow

**Then** the child blocks should be visible again



# Canvas Interaction and Navigation


As a user

I want to interact with the canvas effectively

So that I can navigate and work with large workflows



Background:

**Given** I am in the workflow editor

**And** I have a workflow with multiple blocks



## Scenario: Canvas panning and zooming


**When** I drag on an empty area of the canvas

**Then** the canvas should pan in the direction of the drag

**When** I use the mouse wheel

**Then** the canvas should zoom in or out

**When** I use the zoom controls

**Then** the canvas should zoom to the specified level



# Zoom and View Controls


As a user

I want to control the view and zoom level

So that I can work effectively with workflows of different sizes



Background:

**Given** I am in the workflow editor



## Scenario: Zoom controls functionality


**When** I click the zoom in button

**Then** the canvas should zoom in by a standard increment

**When** I click the zoom out button

**Then** the canvas should zoom out by a standard increment

**When** I click the zoom percentage

**Then** I should see a dropdown with preset zoom levels

**When** I select "50%" from the dropdown

**Then** the canvas should zoom to 50%



## Scenario: Zoom limits


**When** I zoom in to the maximum level

**Then** the zoom in button should be disabled

**When** I zoom out to the minimum level

**Then** the zoom out button should be disabled



## Scenario: Zoom to fit


**Given** I have a large workflow that extends beyond the visible area

**When** I click "Zoom to fit"

**Then** the entire workflow should be visible

**And** the zoom level should adjust automatically



# Documentation and Help


As a user

I want to access help and documentation

So that I can learn how to use the editor effectively



Background:

**Given** I am in the workflow editor



## Scenario: Accessing documentation


**When** I click the help or documentation button

**Then** I should see the documentation modal

**And** I should see tabs for different block types

**And** I should see "Step", "Delay", "Link", "Condition", "Merge", "Path Labels", and "End" tabs



## Scenario: Documentation content


**When** I open the documentation modal

**And** I click on the "Step" tab

**Then** I should see information about Step blocks

**And** I should see "When to use" guidance

**And** I should see "How to add" instructions

**When** I click on the "Delay" tab

**Then** I should see information about both Fixed Duration and Wait For Event delays



## Scenario: Documentation search


**When** I open the documentation modal

**And** I enter "condition" in the search box

**Then** I should see only documentation related to conditions

**And** irrelevant tabs should be filtered out



# Error Handling and Validation


As a user

I want the editor to handle errors gracefully

So that I can continue working even when issues occur



Background:

**Given** I am in the workflow editor



## Scenario: Network connectivity issues


**When** I lose network connectivity

**And** I try to create a new block

**Then** I should see an error message like "Something went wrong. Please try again."

**And** the action should not complete

**When** connectivity is restored

**Then** I should be able to retry the action



## Scenario: Path creation validation


**When** I try to create parallel paths with empty names

**Then** I should see validation errors

**And** the "Create Paths" button should be disabled

**When** I provide valid path names

**Then** the validation should clear

**And** I should be able to create the paths

<!-- AUTO-GENERATED END -->
</file>

<file path="docs/test-cases/login.md">
<!-- AUTO-GENERATED START -->

# User login




As a registered user

I want to log into the application

So that I can access my dashboard



## Scenario: Successful login


**Given** I am on the login page

**When** I enter a valid email and password

**And** I click the "Log in" button

**Then** I should be redirected to the dashboard

**And** I should see a welcome message



## Scenario: Failed login with wrong password


**Given** I am on the login page

**When** I enter a valid email and an incorrect password

**And** I click the "Log in" button

**Then** I should see an error message



## Scenario: Attempt login with empty fields


**Given** I am on the login page

**When** I click the "Log in" button without entering credentials

**Then** I should see validation errors for both email and password





<!-- AUTO-GENERATED END -->
</file>

<file path="docs/test-cases/onboarding.md">
<!-- AUTO-GENERATED START -->

# ProcessFlow Onboarding BDD Test



## Feature: User Onboarding Flow



# User Onboarding Flow


As a new user

I want to complete the onboarding process

So that I can set up my workspace and start using ProcessFlow



Background:

**Given** I am a newly registered user

**And** I am logged in

**And** my onboarding is not complete

**And** I am on the onboarding page "/onboarding"



## Feature: Personal Information Step



```gherkin

# Personal Information Step


As a new user

I want to provide my personal information

So that I can proceed with the onboarding



Background:

**Given** I am on the personal information step

**And** I see the progress indicator showing step 1 of 3 active



## Scenario: Successful personal information submission


**When** I enter first name "Steve"

**And** I enter last name "Jobs"

**And** I click the "Continue" button

**Then** I should proceed to the professional information step

**And** the progress indicator should show step 1 completed

**And** the progress indicator should show step 2 active

**And** my personal information should be saved to localStorage

**And** an API call should be made to save personal info



## Scenario: Personal information validation - empty fields


**When** I leave the first name field empty

**And** I enter last name "Jobs"

**Then** the "Continue" button should be disabled

**When** I enter first name "Steve"

**And** I leave the last name field empty

**Then** the "Continue" button should be disabled



## Scenario: Personal information validation - character limits


**When** I enter a first name with 41 characters

**Then** only the first 40 characters should be accepted

**When** I enter a last name with 41 characters

**Then** only the first 40 characters should be accepted



## Scenario: Personal information validation - character sanitization


**When** I enter first name "Steve<script>alert('xss')</script>"

**Then** HTML tags should be removed and only "Stevealert('xss')" should remain

**When** I enter first name "Steve123!@#"

**Then** special characters should be removed and only "Steve" should remain

**When** I enter first name "Steve-O'Connor"

**Then** hyphens and apostrophes should be allowed



## Scenario: Personal information persistence


**Given** I have entered first name "Steve"

**And** I have entered last name "Jobs"

**When** I refresh the page

**Then** my entered information should be restored from localStorage

**And** the form should be pre-filled with my data



## Scenario: Loading state during submission


**When** I enter valid personal information

**And** I click the "Continue" button

**Then** the button should show "Loading..." text

**And** the button should be disabled during submission

**And** I should proceed to the next step even if API call fails

```



## Feature: Professional Information Step



```gherkin

# Professional Information Step


As a new user

I want to provide my professional information

So that ProcessFlow can be customized to my needs



Background:

**Given** I am on the professional information step

**And** I see the progress indicator showing step 2 of 3 active



## Scenario: Successful professional information submission


**When** I select industry "IT"

**And** I select role "Founder"

**And** I select company size "10-49"

**And** I select source "ProductHunt"

**And** I click the "Continue" button

**Then** I should proceed to the workspace setup step

**And** the progress indicator should show step 2 completed

**And** the progress indicator should show step 3 active

**And** my professional information should be saved to localStorage



## Scenario: Professional information validation - all fields required


**When** I select industry "IT"

**And** I select role "Founder"

**And** I select company size "10-49"

**And** I leave source unselected

**And** I click the "Continue" button

**Then** I should see error "Please fill in all fields"

**And** I should remain on the professional information step



## Scenario: Professional information dropdown options validation


**When** I view the industry dropdown

**Then** I should see options: "IT", "Healthcare", "Finance", "Education", "Retail", "Other"

**When** I view the role dropdown

**Then** I should see options: "Founder", "Manager", "Product Manager", "Analyst", "Designer", "Sales", "Marketing", "HR", "Customer Success", "Freelancer", "Other"

**When** I view the company size dropdown

**Then** I should see options: "1", "2-9", "10-49", "50-199", "200-499", "500+"

**When** I view the source dropdown

**Then** I should see options: "ProductHunt", "LinkedIn", "Google", "Friend", "Other"



## Scenario: Navigation back to personal information


**When** I click the "Back" button

**Then** I should return to the personal information step

**And** the progress indicator should show step 1 active

**And** my previously entered personal information should be preserved



## Scenario: Professional information persistence


**Given** I have selected all professional information fields

**When** I navigate to the next step and then back

**Then** my professional information should be restored from localStorage

**And** all dropdowns should show my previous selections



## Scenario: Loading state during submission


**When** I enter valid professional information

**And** I click the "Continue" button

**Then** the button should show "Loading..." text

**And** the button should be disabled during submission

**And** I should proceed to the next step even if API call fails

```



## Feature: Workspace Setup Step



```gherkin

# Workspace Setup Step


As a new user

I want to set up my workspace

So that I can start organizing my workflows



Background:

**Given** I am on the workspace setup step

**And** I see the progress indicator showing step 3 of 3 active



## Scenario: Successful workspace setup with auto-generated URL


**When** I enter workspace name "My Company"

**And** the workspace URL is auto-generated as "my-company"

**And** the slug availability check shows "Available"

**Then** the "Continue" button should be enabled

**When** I click the "Continue" button

**Then** I should proceed to the completion step

**And** my workspace should be created with the generated slug



## Scenario: Workspace name validation - required field


**When** I leave the workspace name field empty

**Then** the "Continue" button should be disabled

**And** A tooltip must indicate that the field workspace name is required

**When** I enter workspace name "My Company"

**Then** the "Continue" button should be enabled



## Scenario: Workspace name validation - character limits


**When** I enter a workspace name with 51 characters

**Then** only the first 50 characters should be accepted

**And** the input should be automatically truncated



## Scenario: Workspace name validation - allowed characters


**When** I enter workspace name "Valid Name-123"

**Then** the name should be accepted

**When** I enter workspace name "Invalid!Name@#$"

**Then** special characters should be removed automatically

**And** only "InvalidName" should remain



## Scenario: Workspace URL slug generation and validation


**When** I enter workspace name "My Awesome Company"

**Then** the workspace URL should be auto-generated as "my-awesome-company"

**When** I enter workspace name "Company!@# 123"

**Then** the workspace URL should be auto-generated as "company-123"



## Scenario: Workspace URL availability checking


**When** I enter a workspace name

**Then** a slug availability check should be performed after 500ms delay

**And** I should see "Checking availability..." message

**When** the slug is available

**Then** I should see "Available" message in green

**When** the slug is already taken

**Then** I should see "This URL is already taken" message in red

**And** the "Continue" button should be disabled



## Scenario: Workspace URL manual editing (disabled)


**When** I try to manually edit the workspace URL field

**Then** the field should be disabled

**And** I should not be able to modify it directly



## Scenario: Workspace logo upload - valid file types


**When** I upload a PNG file smaller than 5MB

**Then** the logo should be accepted and displayed

**When** I upload a JPEG file smaller than 5MB

**Then** the logo should be accepted and displayed

**When** I upload an SVG file smaller than 5MB

**Then** the logo should be accepted and displayed

**When** I upload a GIF file smaller than 5MB

**Then** the logo should be accepted and displayed

**When** I upload an AVIF file smaller than 5MB

**Then** the logo should be accepted and displayed



## Scenario: Workspace logo upload - invalid file types


**When** I upload a PDF file

**Then** I should see error "Invalid file type. Please upload a PNG, JPG, GIF, or SVG image."

**When** I upload a TXT file

**Then** I should see error "Invalid file type. Please upload a PNG, JPG, GIF, or SVG image."



## Scenario: Workspace logo upload - file size validation


**When** I upload an image file larger than 5MB

**Then** I should see error "File is too large. Maximum size is 5MB."

**And** the file should not be accepted



## Scenario: Workspace logo upload - drag and drop


**When** I drag a valid image file over the upload area

**Then** the upload area should show visual feedback

**When** I drop a valid image file on the upload area

**Then** the logo should be uploaded and displayed

**When** I drop an invalid file on the upload area

**Then** I should see appropriate error message



## Scenario: Navigation back to professional information


**When** I click the "Back" button

**Then** I should return to the professional information step

**And** my workspace setup data should be preserved



## Scenario: Form validation before submission


**When** I have a valid workspace name

**And** the slug is available

**Then** the "Continue" button should be enabled

**When** I have an invalid workspace name

**Then** the "Continue" button should be disabled

**When** the slug is not available

**Then** the "Continue" button should be disabled

**When** the slug availability is still being checked

**Then** the "Continue" button should be disabled



## Scenario: Workspace setup persistence


**Given** I have entered workspace information

**When** I navigate away and return to this step

**Then** my workspace setup data should be restored from localStorage

**And** the logo preview should be displayed if uploaded

```



## Feature: Completion Step and Workspace Creation



```gherkin

# Completion Step and Workspace Creation


As a new user

I want to see my workspace being created

So that I know the onboarding is completing successfully



Background:

**Given** I have completed all onboarding steps

**And** I am on the completion step



## Scenario: Successful workspace and workflow creation


**When** I reach the completion step

**Then** I should see "Setting up your workspace" message

**And** I should see a loading spinner

**And** the workspace creation should start automatically

**And** default workflows should be created

**When** the workspace creation completes successfully

**Then** I should see "Your workspace is ready!" message

**And** I should see a success checkmark

**And** I should see the introduction video

**And** the "Continue to Dashboard" button should be enabled



## Scenario: Default workflow creation warnings


**When** the workspace is created successfully

**But** default workflow creation has warnings

**Then** I should see the workspace as ready

**And** warnings should be logged but not shown to user

**And** I should be able to continue to dashboard



## Scenario: Email scheduling during completion


**When** the workspace creation completes

**Then** a welcome email should be scheduled immediately

**And** a follow-up email should be scheduled for 4 days later

**And** a feedback request email should be scheduled for 7 days later

**And** a feature update email should be scheduled for 4 days later

**When** email scheduling fails

**Then** the onboarding should still complete successfully

**And** warnings should be logged



## Scenario: Continue to dashboard


**When** the workspace creation is complete

**And** I click "Continue to Dashboard"

**Then** all onboarding data should be cleared from localStorage

**And** my onboarding should be marked as complete on the server

**And** I should be redirected to the dashboard "/"

**And** I should not be able to access "/onboarding" anymore



## Scenario: Browser back button prevention


**Given** workspace creation has started

**When** I try to use the browser back button

**Then** I should remain on the completion step

**And** navigation should be prevented



## Scenario: Force completion fallback


**Given** the server shows onboarding as incomplete

**Then** the button "Continue to Dashboard" is disabled

```



## Feature: Navigation and State Management



```gherkin

# Navigation and State Management


As a user going through onboarding

I want smooth navigation between steps

So that I can complete the process efficiently



## Scenario: Progress indicator accuracy


**Given** I am on the personal information step

**Then** step 1 should be highlighted as active

**And** steps 2 and 3 should be inactive

**Given** I am on the professional information step

**Then** step 1 should show as completed

**And** step 2 should be highlighted as active

**And** step 3 should be inactive

**Given** I am on the workspace setup step

**Then** steps 1 and 2 should show as completed

**And** step 3 should be highlighted as active



## Scenario: Data persistence across page refreshes


**Given** I have partially completed onboarding

**When** I refresh the page at any step

**Then** I should return to the correct step

**And** my previously entered data should be restored

**And** the progress indicator should show the correct state



## Scenario: Server state synchronization


**Given** I am going through onboarding

**When** each step is completed

**Then** the server should be updated with my progress

**And** the onboarding status should be synchronized

**When** I reload the page

**Then** the server state should determine my current step



## Scenario: Onboarding completion detection


**Given** I have completed onboarding previously

**When** I try to access "/onboarding"

**Then** I should be redirected to the dashboard "/"

**And** I should not see the onboarding flow



## Scenario: Authentication requirement


**Given** I am not authenticated

**When** I try to access "/onboarding"

**Then** I should be redirected to the login page

**When** I am authenticated but onboarding is complete

**Then** I should be redirected to the dashboard



## Scenario: Light theme enforcement


**When** I am on any onboarding step

**Then** the interface should use light theme

**And** dark mode should be disabled

**And** the theme should be forced regardless of system preference

```



## Feature: Error Handling and Edge Cases



```gherkin

# Error Handling and Edge Cases


As a user going through onboarding

I want graceful error handling

So that I can complete onboarding even when issues occur



## Scenario: API failure resilience


**When** an API call fails during step submission

**Then** I should be blocked from proceeding to the next step

**And** the UI should provide an error message "Something went wrong. Please try again."



## Scenario: Network connectivity issues


**When** I lose network connectivity during onboarding

**Then** my form data should be preserved locally

**And** I should be able to continue when connectivity returns

**And** slug availability checks should handle timeouts gracefully



## Scenario: Workspace creation timeout handling


**When** workspace creation takes longer than expected

**Then** I should see appropriate loading messages

**And** the process should not timeout prematurely

**And** I should have options to retry or continue



## Scenario: Duplicate workspace name handling


**When** I enter a workspace name that already exists

**Then** the system should automatically suggest alternatives

**And** I should be able to proceed with the modified name

**And** the slug conflict should be resolved automatically



## Scenario: File upload error recovery


**When** logo upload fails due to network issues

**Then** I should see the error message "Something went wrong. Please try again."

**And** I should be able to retry the upload

**And** I should be able to continue without a logo



## Scenario: Concurrent user scenarios


**When** multiple users try to create workspaces simultaneously

**Then** each should get unique slugs

**And** no conflicts should occur

**And** all users should complete successfully

```

<!-- AUTO-GENERATED END -->
</file>

<file path="docs/test-cases/read-mode.md">
<!-- AUTO-GENERATED START -->

# ProcessFlow Read Mode BDD Tests



# Read Mode Access and Layout


As a user

I want to access and view workflows in read mode

So that I can follow processes and understand workflow steps



Background:

**Given** I am a logged-in user

**And** I have access to a workflow in read mode

**And** I am on the read page of a workflow



## Scenario: Read mode loads successfully


**When** I access a workflow in read mode

**Then** I should see the workflow header with navigation controls

**And** I should see the main content area

**And** I should see the sidebar on the left with workspace information

**And** I should see the view mode switch controls

**And** I should see the process card with workflow information

**And** I should see breadcrumb navigation



## Scenario: Read mode header functionality


**When** I am in read mode

**Then** I should see the workflow title in the breadcrumbs

**And** I should see an "Edit" button

**And** I should see a "Share" button

**And** I should see my user profile dropdown

**When** I click the "Edit" button

**Then** I should be redirected to the edit mode of the workflow

**When** I click the back button

**Then** I should navigate to the previous page



## Scenario: Process card display


**When** I view the process card

**Then** I should see the workflow icon

**And** I should see the workflow name and description

**And** I should see integration badges for connected apps

**And** I should see author information if available

**And** I should see the last update timestamp

**When** there are more than 5 integrations

**Then** I should see a "+X" badge for additional integrations

**When** I hover over the "+X" badge

**Then** I should see a popover with the additional integrations



## Scenario: Sidebar workspace navigation


**When** I look at the sidebar

**Then** I should see the workspace name and icon

**And** I should see a hierarchical list of workflow steps

**When** I click on the workspace name

**Then** I should be redirected to the workspace dashboard



# View Mode Management


As a user

I want to switch between different view modes

So that I can choose the best way to follow the workflow



Background:

**Given** I am in read mode

**And** I can see the view mode switch controls



## Scenario: Switching to vertical view mode


**When** I click the vertical view mode button

**Then** the interface should switch to vertical mode

**And** I should see all steps displayed in a scrollable list

**And** I should see the sidebar with step navigation

**And** I should see step expansion controls

**And** the view mode button should show as active



## Scenario: Switching to carousel view mode


**When** I click the carousel view mode button

**Then** the interface should switch to carousel mode

**And** I should see one step displayed at a time

**And** I should see navigation buttons (Previous/Next)

**And** I should see a "Get Started" button initially

**And** the sidebar should be hidden

**And** the view mode button should show as active



# Step Navigation and Progression


As a user

I want to navigate through workflow steps

So that I can follow the process systematically



Background:

**Given** I am in read mode

**And** I have a workflow with multiple steps



## Scenario: Linear step progression in carousel mode


**Given** I am in carousel mode

**And** I am on the first step

**When** I click "Next step"

**Then** I should proceed to the second step

**And** the second step should be displayed

**And** I should see a "Previous step" button

**When** I click "Previous step"

**Then** I should return to the first step



## Scenario: Step navigation in vertical mode


**Given** I am in vertical mode

**When** I got a conditionnal step

**Then** I should see the conditionnal step content

**And** I should see the path options

**When** I select a path option

**Then** I should proceed to the first step of the selected path

**And** subsequent steps should follow the selected path





# Conditional Path Handling


As a user

I want to make choices at decision points

So that I can follow the appropriate path for my situation



Background:

**Given** I am in read mode

**And** I have a workflow with conditional paths



## Scenario: Displaying path options


**Given** I reach a step with multiple path options

**Then** I should see the step content

**And** I should see a "Select an option" section

**And** I should see radio buttons for each available path

**And** each option should show the path name

**And** the "Next step" button should be disabled until I make a selection



## Scenario: Selecting a path option


**Given** I am on a step with path options

**When** I select a path option

**Then** the radio button should be marked as selected

**And** the "Next step" button should become enabled

**When** I click "Next step"

**Then** I should proceed to the first step of the selected path

**And** subsequent steps should follow the selected path



## Scenario: Path selection persistence


**Given** I have selected a path option

**When** I navigate back to the decision step

**Then** my previous selection should still be marked

**When** I change my selection to a different path

**And** I proceed forward

**Then** I should follow the newly selected path

**And** any progress on the previous path should be reset



## Scenario: Multiple decision points


**Given** I have a workflow with multiple decision points

**When** I make selections at each decision point

**Then** each selection should be remembered

**And** I should be able to navigate back and see my choices

**When** I change a selection at an earlier decision point

**Then** all subsequent selections should be reset

**And** I should need to make new selections for later decision points



# Content Display and Media


As a user

I want to view rich content and media in workflow steps

So that I can understand the instructions clearly



Background:

**Given** I am in read mode

**And** I have steps with various content types



## Scenario: Basic step content display


**When** I view a step

**Then** I should see the step icon

**And** I should see the step title

**And** I should see the step description if available

**And** I should see any estimated time duration

**And** text content should be properly formatted



## Scenario: Fullscreen image viewing


**Given** I have opened an image in fullscreen

**Then** I should see the image at full size

**And** I should see close button

**And** I should see zoom controls

**When** I press the Escape key

**Then** the fullscreen view should close

**When** I click outside the image

**Then** the fullscreen view should close



## Scenario: Rich text content with links


**Given** I have a step with text containing URLs

**When** I view the step description

**Then** URLs should be automatically converted to clickable links

**And** links should open in a new tab when clicked

**And** links should be visually distinguished from regular text



## Scenario: App integration icons


**Given** I have steps with app integrations

**When** I view these steps

**Then** I should see the appropriate app icons

**And** icons should load from the correct sources

**When** an app icon fails to load

**Then** I should see a default fallback icon



# Sidebar Navigation and Step Management


As a user

I want to navigate efficiently through the workflow

So that I can jump to specific steps and understand the structure



Background:

**Given** I am in vertical mode

**And** I can see the sidebar



## Scenario: Sidebar step hierarchy display


**When** I look at the sidebar

**Then** I should see all workflow paths organized hierarchically

**And** I should see proper indentation for nested paths

**And** I should see step icons and titles

**And** I should see expand/collapse arrows for paths with multiple steps



## Scenario: Sidebar step navigation


**When** I click on a step in the sidebar

**Then** the main content should scroll to that step

**And** the step should be highlighted

**And** if the step was collapsed, it should expand



## Scenario: Path collapsing and expanding


**Given** I have paths with multiple steps

**When** I click the collapse arrow next to a path

**Then** the path's child steps should be hidden

**And** the arrow should change to indicate collapsed state

**When** I click the expand arrow

**Then** the child steps should be visible again

**And** the arrow should change to indicate expanded state



## Scenario: Active step highlighting


**Given** I am progressing through the workflow

**When** I am on a specific step

**Then** that step should be highlighted in the sidebar

**And** it should be visually distinct from other steps

**When** I navigate to a different step

**Then** the highlighting should move to the new step



## Scenario: Sidebar workspace navigation


**When** I click on the workspace name in the sidebar

**Then** I should be redirected to the workspace dashboard

**And** I should see a hover effect on the workspace area

**And** the workspace icon and name should be clearly visible



# Delay Block Handling


As a user

I want to understand delay blocks in workflows

So that I know when to wait and what to expect



Background:

**Given** I am in read mode

**And** I have a workflow with delay blocks



## Scenario: Fixed duration delay display


**Given** I reach a fixed duration delay block

**Then** I should see a delay icon (clock/stopwatch)

**And** I should see "Fixed Duration" as the delay type

**And** I should see the delay time formatted (e.g., "2h 30m")

**And** I should see a message like "Flow paused for 2 hours and 30 minutes"

**And** I should see an info box explaining the delay



## Scenario: Event-based delay display


**Given** I reach an event-based delay block

**Then** I should see a delay icon (calendar/clock)

**And** I should see "Event-Based Delay" as the delay type

**And** I should see the event name being waited for

**And** I should see "Waiting for: [Event Name]"

If the delay has an expiration time

**Then** I should see "Expires after [time]" with an hourglass icon

**And** I should see appropriate pause messaging



# Header Controls and Navigation


As a user

I want to access workflow controls and navigation

So that I can manage my workflow viewing experience



Background:

**Given** I am in read mode

**And** I can see the header controls



## Scenario: Breadcrumb navigation


**When** I look at the header

**Then** I should see breadcrumb navigation

**And** I should see the workspace name (if applicable)

**And** I should see folder names (if workflow is in a folder)

**And** I should see the workflow name as the final breadcrumb

**When** I click on a breadcrumb item with a link

**Then** I should navigate to that location



## Scenario: Edit mode navigation


**When** I click the "Edit" button in the header

**Then** I should be redirected to the edit mode

**And** the URL should change to the edit mode URL

**And** I should see the workflow editor interface



## Scenario: User profile dropdown


**When** I click on my user profile in the header

**Then** I should see a dropdown menu

**And** I should see "Account settings" option

**And** I should see "Help center" option

**When** I select "Account settings"

**Then** I should see the user settings modal

**When** I select "Help center"

**Then** I should see the help center modal



# Sharing and Access Control


As a user

I want to share workflows and control access

So that I can collaborate with others effectively



Background:

**Given** I am in read mode

**And** I have sharing permissions for the workflow



## Scenario: Opening share modal


**When** I click the "Share" button

**Then** I should see the share modal

**And** I should see the workflow name in the modal

**And** I should see the current sharing status (Public/Private)

**And** I should see the share URL

**And** I should see copy link button



## Scenario: Toggling workflow access


**Given** the workflow is currently public

**When** I toggle back to private

**Then** I should see "Workflow is now private" notification

**When** I toggle back to public

**Then** I should see "Workflow is now public" notification



## Scenario: Copying share link


**When** I click "Copy link" in the share modal

**Then** the workflow URL should be copied to clipboard

**And** I should see a "Link copied!" notification

**And** the copied link should be the correct share URL



## Scenario: Share modal with workspace branding


**Given** my workspace has a custom logo

**When** I open the share modal

**Then** I should see the workspace logo in the modal

**And** the modal should reflect the workspace branding



## Scenario: Public workflow access


**Given** I have a public workflow link

**When** I access the workflow without being logged in

**Then** I should be able to view the workflow

**And** I should see limited functionality (no edit access)

**And** I should not see user-specific controls



# Process Completion and Restart


As a user

I want to complete workflows and restart them

So that I can finish processes and repeat them as needed



Background:

**Given** I am in read mode in carousel mode

**And** I have progressed through a workflow



## Scenario: Reaching workflow completion


**Given** I am on the last step of the workflow

**When** I click "Complete" or reach the end

**Then** I should see the completion screen

**And** I should see a success icon (checkmark)

**And** I should see a congratulations message

**And** I should see "You've completed the process" text

**And** I should see sharing encouragement message



## Scenario: Completion screen actions


**When** I am on the completion screen

**Then** I should see a "Copy link" button

**And** I should see a "Restart process" button

**When** I click "Copy link"

**Then** the workflow share link should be copied

**And** I should see a "Link copied!" notification

**When** I click "Restart process"

**Then** I should return to the initial state

**And** all step progress should be reset

**And** all path selections should be cleared



## Scenario: Completion with conditional paths


**Given** I completed a workflow with multiple path choices

**When** I restart the process

**Then** all my previous path selections should be cleared

**And** I should be able to make different choices

**And** follow different paths through the workflow



# Error Handling and Edge Cases


As a user

I want the system to handle errors gracefully

So that I can continue using the workflow even when issues occur



Background:

**Given** I am in read mode



## Scenario: Network connectivity issues


**When** I lose network connectivity

**And** I try to navigate to a new step

**Then** I should see an appropriate error message

**And** the interface should remain functional for local actions

**When** connectivity is restored

**Then** I should be able to continue normally



## Scenario: Missing or broken media


**Given** I have a step with an image that fails to load

**When** I view that step

**Then** I should see a placeholder or error state

**And** the step should still be functional

**And** other content should display normally



## Scenario: Invalid workflow access


**When** I try to access a workflow that doesn't exist

**Then** I should see a 404 error page

**When** I try to access a private workflow without permission

**Then** I should be redirected to login

<!-- AUTO-GENERATED END -->
</file>

<file path="emails/components/signatures/CustomerServiceSignature.tsx">
import * as React from 'react';
import { Section, Text, Link, Img } from '@react-email/components';

type ClientServiceSignatureProps = {
  publicUrls?: {
    supabasePublicUrl?: string;
    supabaseStoragePath?: string;
    producthuntUrl?: string;
    linkedinUrl?: string;
    xUrl?: string;
    [key: string]: string | undefined;
  };
};

export const ClientServiceSignature: React.FC<ClientServiceSignatureProps> = ({ publicUrls = {} }) => {
  // Construct the image URLs from public URLs or use fallbacks
  const supabaseUrl = publicUrls.supabasePublicUrl || '';
  const storagePath = publicUrls.supabaseStoragePath || '';
  
  // Social media icons from Supabase
  const xIconUrl = supabaseUrl && storagePath 
    ? `${supabaseUrl}${storagePath}/images/mail_x.png`
    : 'https://via.placeholder.com/20';
    
  const productHuntIconUrl = supabaseUrl && storagePath 
    ? `${supabaseUrl}${storagePath}/images/mail_product_hunt.png`
    : 'https://via.placeholder.com/20';
    
  const linkedinIconUrl = supabaseUrl && storagePath 
    ? `${supabaseUrl}${storagePath}/images/mail_linkedin.png`
    : 'https://via.placeholder.com/20';
    
  // Social media URLs from environment variables
  const productHuntUrl = publicUrls.producthuntUrl || process.env.NEXT_PUBLIC_PRODUCTHUNT_URL || 'https://www.producthunt.com';
  const linkedinUrl = publicUrls.linkedinUrl || process.env.NEXT_PUBLIC_LINKEDIN_URL || 'https://www.linkedin.com/company/processflow1/';
  const xUrl = publicUrls.xUrl || process.env.NEXT_PUBLIC_X_URL || 'https://x.com';

  return (
    <Section style={{ marginTop: '32px' }}>
      <Text style={{ 
        fontFamily: 'Inter, sans-serif',
        fontSize: '18px',
        fontWeight: 600,
        margin: '0 0 4px 0',
        color: '#000000', // Explicitly set to black
      }}>
        Customer Service
      </Text>
      <Text style={{ 
        fontFamily: 'Inter, sans-serif',
        fontSize: '16px',
        margin: '0 0 16px 0',
        color: '#000000', // Explicitly set to black
      }}>
        <Link
          href="mailto:contact@process-flow.io"
          style={{ color: '#000000', textDecoration: 'none' }}
        >
          contact@process-flow.io
        </Link>
      </Text>
      <div style={{ marginTop: '8px' }}>
        <Link href={productHuntUrl} style={{ textDecoration: 'none', marginRight: '10px', display: 'inline-block' }}>
          <Img
            src={productHuntIconUrl}
            width="20"
            height="20"
            alt="ProductHunt"
            style={{ 
              display: 'inline-block', 
              verticalAlign: 'middle', 
              border: 'none',
              maxWidth: '20px',
              maxHeight: '20px'
            }}
          />
        </Link>
        <Link href={linkedinUrl} style={{ textDecoration: 'none', marginRight: '10px', display: 'inline-block' }}>
          <Img
            src={linkedinIconUrl}
            width="20"
            height="20"
            alt="LinkedIn"
            style={{ 
              display: 'inline-block', 
              verticalAlign: 'middle',
              border: 'none',
              maxWidth: '20px',
              maxHeight: '20px'
            }}
          />
        </Link>
        <Link href={xUrl} style={{ textDecoration: 'none', marginRight: '10px', display: 'inline-block' }}>
          <Img
            src={xIconUrl}
            width="20"
            height="20"
            alt="X"
            style={{ 
              display: 'inline-block', 
              verticalAlign: 'middle',
              border: 'none',
              maxWidth: '20px',
              maxHeight: '20px'
            }}
          />
        </Link>
      </div>
    </Section>
  );
};
</file>

<file path="emails/components/signatures/JeanSignature.tsx">
import * as React from 'react';
import { Section, Text, Link, Img } from '@react-email/components';

type JeanSignatureProps = {
  publicUrls?: {
    supabasePublicUrl?: string;
    supabaseStoragePath?: string;
    producthuntUrl?: string;
    linkedinUrl?: string;
    xUrl?: string;
    [key: string]: string | undefined;
  };
};

export const JeanSignature: React.FC<JeanSignatureProps> = ({ publicUrls = {} }) => {
  // Construct the profile image URL from public URLs or use a fallback
  const supabaseUrl = publicUrls.supabasePublicUrl || '';
  const storagePath = publicUrls.supabaseStoragePath || '';
  
  // Use a fallback image URL if the URLs aren't available
  const profileImageUrl = supabaseUrl && storagePath 
    ? `${supabaseUrl}${storagePath}/images/Profil_pean_pillame.png`
    : 'https://via.placeholder.com/48';
    
  // Social media icons from Supabase
  const xIconUrl = supabaseUrl && storagePath 
    ? `${supabaseUrl}${storagePath}/images/mail_x.png`
    : 'https://via.placeholder.com/20';
    
  const productHuntIconUrl = supabaseUrl && storagePath 
    ? `${supabaseUrl}${storagePath}/images/mail_product_hunt.png`
    : 'https://via.placeholder.com/20';
    
  const linkedinIconUrl = supabaseUrl && storagePath 
    ? `${supabaseUrl}${storagePath}/images/mail_linkedin.png`
    : 'https://via.placeholder.com/20';
    
  // Social media URLs from public URLs or use defaults
  const productHuntUrl = publicUrls.producthuntUrl || 'https://www.producthunt.com';
  const linkedinUrl = publicUrls.linkedinUrl || 'https://www.linkedin.com/company/processflow1/';
  const xUrl = publicUrls.xUrl || 'https://x.com';

  return (
    <Section style={{ marginTop: '32px' }}>
      <div style={{ display: 'flex', alignItems: 'center', marginBottom: '16px' }}>
        {/* Profile Image */}
        <Img
          src={profileImageUrl}
          width="48"
          height="48"
          alt="Jean's profile"
          style={{
            borderRadius: '50%',
            marginRight: '16px',
            border: '1px solid #e6e6e6',
            display: 'inline-block',
          }}
        />
        
        {/* Name and Email */}
        <div>
          <Text style={{ 
            fontFamily: 'Inter, sans-serif',
            fontSize: '18px',
            fontWeight: 600,
            margin: '0 0 4px 0',
            color: '#000000',
          }}>
            Jean - Co-founder
          </Text>
          <Text style={{ 
            fontFamily: 'Inter, sans-serif',
            fontSize: '16px',
            margin: '0',
            color: '#000000',
          }}>
            <Link
              href="mailto:jean@process-flow.io"
              style={{ color: '#000000', textDecoration: 'none' }}
            >
              jean@process-flow.io
            </Link>
          </Text>
        </div>
      </div>
      
      {/* Social Icons */}
      <div style={{ marginTop: '8px' }}>
        {/*
        <Link href={productHuntUrl} style={{ textDecoration: 'none', marginRight: '10px', display: 'inline-block' }}>
          <Img
            src={productHuntIconUrl}
            width="20"
            height="20"
            alt="ProductHunt"
            style={{ 
              display: 'inline-block', 
              verticalAlign: 'middle', 
              border: 'none',
              maxWidth: '20px',
              maxHeight: '20px'
            }}
          />
        </Link>
        */}
        <Link href={linkedinUrl} style={{ textDecoration: 'none', marginRight: '10px', display: 'inline-block' }}>
          <Img
            src={linkedinIconUrl}
            width="20"
            height="20"
            alt="LinkedIn"
            style={{ 
              display: 'inline-block', 
              verticalAlign: 'middle',
              border: 'none',
              maxWidth: '20px',
              maxHeight: '20px'
            }}
          />
        </Link>
        {/*
        <Link href={xUrl} style={{ textDecoration: 'none', marginRight: '10px', display: 'inline-block' }}>
          <Img
            src={xIconUrl}
            width="20"
            height="20"
            alt="X"
            style={{ 
              display: 'inline-block', 
              verticalAlign: 'middle',
              border: 'none',
              maxWidth: '20px',
              maxHeight: '20px'
            }}
          />
        </Link>
        */}
      </div>
    </Section>
  );
};
</file>

<file path="emails/components/signatures/NoReplySignature.tsx">
import * as React from 'react';
import { Section, Text, Link, Img } from '@react-email/components';

type NoReplySignatureProps = {
  publicUrls?: {
    supabasePublicUrl?: string;
    supabaseStoragePath?: string;
    // producthuntUrl?: string;
    linkedinUrl?: string;
    // xUrl?: string;
    [key: string]: string | undefined;
  };
};

export const NoReplySignature: React.FC<NoReplySignatureProps> = ({ publicUrls = {} }) => {
  // Construct the image URLs from public URLs or use fallbacks
  const supabaseUrl = publicUrls.supabasePublicUrl || '';
  const storagePath = publicUrls.supabaseStoragePath || '';
  
  // Social media icons from Supabase
  // const xIconUrl = supabaseUrl && storagePath 
  //   ? `${supabaseUrl}${storagePath}/images/mail_x.png`
  //   : 'https://via.placeholder.com/20';
    
  // const productHuntIconUrl = supabaseUrl && storagePath 
  //   ? `${supabaseUrl}${storagePath}/images/mail_product_hunt.png`
  //   : 'https://via.placeholder.com/20';
    
  const linkedinIconUrl = supabaseUrl && storagePath 
    ? `${supabaseUrl}${storagePath}/images/mail_linkedin.png`
    : 'https://via.placeholder.com/20';
    
  // Social media URLs from public URLs or use defaults
  // const productHuntUrl = publicUrls.producthuntUrl || 'https://www.producthunt.com';
  const linkedinUrl = publicUrls.linkedinUrl || 'https://www.linkedin.com/company/processflow1/';
  // const xUrl = publicUrls.xUrl || 'https://x.com';

  return (
    <Section style={{ marginTop: '32px' }}>
      <Text style={{ 
        fontFamily: 'Inter, sans-serif',
        fontSize: '18px',
        fontWeight: 600,
        margin: '0 0 4px 0',
        color: '#000000', // Explicitly set to black
      }}>
        ProcessFlow Team
      </Text>
      <div style={{ marginTop: '8px' }}>
        {/* <Link href={productHuntUrl} style={{ textDecoration: 'none', marginRight: '10px', display: 'inline-block' }}>
          <Img
            src={productHuntIconUrl}
            width="20"
            height="20"
            alt="ProductHunt"
            style={{ 
              display: 'inline-block', 
              verticalAlign: 'middle', 
              border: 'none',
              maxWidth: '20px',
              maxHeight: '20px'
            }}
          />
        </Link> */}
        <Link href={linkedinUrl} style={{ textDecoration: 'none', marginRight: '10px', display: 'inline-block' }}>
          <Img
            src={linkedinIconUrl}
            width="20"
            height="20"
            alt="LinkedIn"
            style={{ 
              display: 'inline-block', 
              verticalAlign: 'middle',
              border: 'none',
              maxWidth: '20px',
              maxHeight: '20px'
            }}
          />
        </Link>
        {/* <Link href={xUrl} style={{ textDecoration: 'none', marginRight: '10px', display: 'inline-block' }}>
          <Img
            src={xIconUrl}
            width="20"
            height="20"
            alt="X"
            style={{ 
              display: 'inline-block', 
              verticalAlign: 'middle',
              border: 'none',
              maxWidth: '20px',
              maxHeight: '20px'
            }}
          />
        </Link> */}
      </div>
    </Section>
  );
};
</file>

<file path="emails/components/Button.tsx">
import * as React from 'react';
import { Button as EmailButton } from '@react-email/components';

type ButtonProps = {
  href: string;
  children: React.ReactNode;
};

export const Button: React.FC<ButtonProps> = ({ href, children }) => {
  return (
    <EmailButton
      href={href}
      style={{
        backgroundColor: '#4e6bd7',
        borderRadius: '6px',
        color: '#fff',
        fontFamily: 'Inter, system-ui, sans-serif',
        fontSize: '16px',
        fontWeight: 500,
        textDecoration: 'none',
        textAlign: 'center',
        display: 'inline-block',
        padding: '12px 20px',
      }}
    >
      {children}
    </EmailButton>
  );
};
</file>

<file path="emails/components/CustomFont.tsx">
import * as React from 'react';

type CustomFontProps = {
  fontFamily: string;
  fallbackFontFamily: string | string[];
  fontStyle?: string;
  fontWeight?: number | string;
  webFont?: {
    url: string;
    format: string;
  };
};

export const CustomFont: React.FC<CustomFontProps> = ({
  webFont,
  fontStyle = 'normal',
  fontFamily,
  fontWeight = 400,
  fallbackFontFamily,
}) => {
  const src = webFont ? `src: url(${webFont.url}) format(${webFont.format});` : "";
  const fallbackFonts = Array.isArray(fallbackFontFamily) 
    ? fallbackFontFamily.join(", ") 
    : fallbackFontFamily;
  const msoFontAlt = Array.isArray(fallbackFontFamily) 
    ? fallbackFontFamily[0] 
    : fallbackFontFamily;

  return (
    <style>
      {`
        @font-face {
          font-style: ${fontStyle};
          font-family: ${fontFamily};
          font-weight: ${fontWeight};
          mso-font-alt: ${msoFontAlt};
          ${src}
        }
        * {
          font-family: ${fontFamily}, ${fallbackFonts};
        }
      `}
    </style>
  );
};
</file>

<file path="emails/components/EmailSignature.tsx">
import * as React from 'react';
import { ClientServiceSignature } from './signatures/CustomerServiceSignature';
import { JeanSignature } from './signatures/JeanSignature';
import { NoReplySignature } from './signatures/NoReplySignature';
import { SenderType } from '@/lib/email';

type EmailSignatureProps = {
  sender: SenderType;
  publicUrls?: {
    supabasePublicUrl?: string;
    supabaseStoragePath?: string;
    producthuntUrl?: string;
    linkedinUrl?: string;
    xUrl?: string;
    [key: string]: string | undefined;
  };
};

export const EmailSignature: React.FC<EmailSignatureProps> = ({ sender, publicUrls }) => {
  switch (sender) {
    case 'contact':
      return <ClientServiceSignature publicUrls={publicUrls} />;
    case 'jean':
      return <JeanSignature publicUrls={publicUrls} />;
    case 'noreply':
    default:
      return <NoReplySignature publicUrls={publicUrls} />;
  }
};
</file>

<file path="emails/components/Heading.tsx">
import * as React from 'react';
import { Heading as EmailHeading } from '@react-email/components';

type HeadingProps = {
  children: React.ReactNode;
  level?: 1 | 2 | 3;
};

export const Heading: React.FC<HeadingProps> = ({ children, level = 1 }) => {
  const fontSize = level === 1 ? '24px' : level === 2 ? '20px' : '18px';
  
  return (
    <EmailHeading
      as={`h${level}`}
      style={{
        fontFamily: 'Inter, system-ui, sans-serif',
        fontSize,
        fontWeight: 600,
        color: '#111',
        margin: '24px 0 16px',
      }}
    >
      {children}
    </EmailHeading>
  );
};
</file>

<file path="emails/components/Text.tsx">
import * as React from 'react';
import { Text as EmailText } from '@react-email/components';

type TextProps = {
  children: React.ReactNode;
  style?: React.CSSProperties;
};

export const Text: React.FC<TextProps> = ({ children, style }) => {
  return (
    <EmailText
      style={{
        fontFamily: 'Inter, system-ui, sans-serif',
        fontSize: '16px',
        lineHeight: '1.5',
        color: '#333',
        margin: '16px 0',
        ...style,
      }}
    >
      {children}
    </EmailText>
  );
};
</file>

<file path="emails/templates/CancellationFollowUpEmail.tsx">
import * as React from 'react';
import {
  Html,
  Head,
  Body,
  Container,
  Section,
  Hr,
  Link,
  Img,
} from '@react-email/components';
import { Text } from '../components/Text';
import { Heading } from '../components/Heading';
import { Button } from '../components/Button';
import { EmailSignature } from '../components/EmailSignature';
import { CustomFont } from '../components/CustomFont';
import { SenderType } from '@/lib/email';

type CancellationFollowUpEmailProps = {
  firstName: string;
  feedbackLink: string;
  sender: SenderType;
  userId: string | number;
  publicUrls?: {
    supabasePublicUrl?: string;
    supabaseStoragePath?: string;
    [key: string]: string | undefined;
  };
};

export const CancellationFollowUpEmail: React.FC<CancellationFollowUpEmailProps> = ({
  firstName,
  feedbackLink = 'https://tally.so/r/woVeqM',
  sender = 'contact',
  userId,
  publicUrls = {},
}) => {
  // Construct the logo URL from public URLs or use a fallback
  const supabaseUrl = publicUrls.supabasePublicUrl || '';
  const storagePath = publicUrls.supabaseStoragePath || '';
  
  // Use a fallback image URL if the URLs aren't available
  const logoUrl = supabaseUrl && storagePath 
    ? `${supabaseUrl}${storagePath}/assets/logo/logo-pf-in-app.png`
    : 'https://via.placeholder.com/200x60?text=ProcessFlow';

  return (
    <Html>
      <Head>
        <CustomFont
          fontFamily="Inter"
          fallbackFontFamily={['system-ui', 'sans-serif']}
          webFont={{
            url: 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap',
            format: 'woff2',
          }}
          fontWeight={400}
          fontStyle="normal"
        />
      </Head>
      <Body style={{ fontFamily: 'Inter, system-ui, sans-serif', margin: 0, padding: 0, backgroundColor: '#f5f5f5' }}>
        <Container style={{ maxWidth: '600px', margin: '0 auto', padding: '40px 20px', backgroundColor: '#ffffff', borderRadius: '8px' }}>
          {/* Logo Section */}
          <Section style={{ textAlign: 'center', marginBottom: '32px' }}>
            <Img
              src={logoUrl}
              alt="ProcessFlow Logo"
              width="180"
              height="auto"
              style={{
                margin: '0 auto',
                display: 'block',
              }}
            />
          </Section>
          
          <Section>
            <Heading level={1}>We're sorry to see you go </Heading>
            
            <Text>Hello {firstName},</Text>
            
            <Text>
              We are truly sorry to see you leave ProcessFlow. We understand that our users may have different reasons.
            </Text>
            
            <Text>
              Could you please let us know why you made this decision? It would help us improve our service and better serve other users who may have felt the same.
            </Text>
            
            <Section style={{ textAlign: 'center', margin: '32px 0' }}>
              <Button href={feedbackLink}>
                Help us improve
              </Button>
            </Section>
            
            <Text> 
              We sincerely thank you for the time you've spent with us and are available if you have any questions or would like to discuss further.
            </Text>
            
            <Text>Best regards,</Text>
            
            <EmailSignature sender={sender} publicUrls={publicUrls} />
          </Section>
          
          <Hr style={{ borderTop: '1px solid #e6e6e6', margin: '32px 0' }} />
          
          <Section style={{ textAlign: 'center' }}>
            <Text style={{ fontSize: '14px', color: '#666' }}>
               {new Date().getFullYear()} ProcessFlow. All rights reserved.
            </Text>
            <Text style={{ fontSize: '14px', color: '#666' }}>
              <Link href="https://process-flow.io" style={{ color: '#666', textDecoration: 'underline' }}>
                process-flow.io
              </Link>
            </Text>
          </Section>
        </Container>
      </Body>
    </Html>
  );
};
</file>

<file path="emails/templates/FeedbackRequestEmail.tsx">
import * as React from 'react';
import {
  Html,
  Head,
  Body,
  Container,
  Section,
  Hr,
  Link,
  Img,
} from '@react-email/components';
import { Text } from '../components/Text';
import { Heading } from '../components/Heading';
import { Button } from '../components/Button';
import { EmailSignature } from '../components/EmailSignature';
import { CustomFont } from '../components/CustomFont';
import { SenderType } from '@/lib/email';

type FeedbackRequestEmailProps = {
  firstName: string;
  feedbackLink: string;
  sender: SenderType;
  publicUrls?: {
    supabasePublicUrl?: string;
    supabaseStoragePath?: string;
    [key: string]: string | undefined;
  };
};

export const FeedbackRequestEmail: React.FC<FeedbackRequestEmailProps> = ({
  firstName,
  feedbackLink = 'https://tally.so/r/wkRej6',
  sender = 'jean',
  publicUrls = {},
}) => {
  // Construct the logo URL from public URLs or use a fallback
  const supabaseUrl = publicUrls.supabasePublicUrl || '';
  const storagePath = publicUrls.supabaseStoragePath || '';
  
  // Use a fallback image URL if the URLs aren't available
  const logoUrl = supabaseUrl && storagePath 
    ? `${supabaseUrl}${storagePath}/assets/logo/logo-pf-in-app.png`
    : 'https://via.placeholder.com/200x60?text=ProcessFlow';

  return (
    <Html>
      <Head>
        <CustomFont
          fontFamily="Inter"
          fallbackFontFamily={['system-ui', 'sans-serif']}
          webFont={{
            url: 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap',
            format: 'woff2',
          }}
          fontWeight={400}
          fontStyle="normal"
        />
      </Head>
      <Body style={{ fontFamily: 'Inter, system-ui, sans-serif', margin: 0, padding: 0, backgroundColor: '#f5f5f5' }}>
        <Container style={{ maxWidth: '600px', margin: '0 auto', padding: '40px 20px', backgroundColor: '#ffffff', borderRadius: '8px' }}>
          {/* Logo Section */}
          <Section style={{ textAlign: 'center', marginBottom: '32px' }}>
            <Img
              src={logoUrl}
              alt="ProcessFlow Logo"
              width="180"
              height="auto"
              style={{
                margin: '0 auto',
                display: 'block',
              }}
            />
          </Section>
          <Section>
            <Text>Hello {firstName},</Text>
            <Text>
              We hope everything is going well and you are getting a lot of value since you started using ProcessFlow! We'd love to hear your feedback on your experience so far.
            </Text>
            <Text>
              Your input helps us improve our product and better meet your needs.
            </Text>
            <Text>
              We designed this survey to be completed in less than 30 seconds - please beat us!
            </Text>
            
            <Section style={{ textAlign: 'center', margin: '32px 0' }}>
              <Button href={feedbackLink}>
                Make Your Voice Count
              </Button>
            </Section>
            
            <Text>
              Thank you in advance for your time and valuable contribution.
            </Text>
            
            <Text>
              We're always available if you have any further questions or suggestions!
            </Text>
            
            {/* Add the appropriate signature based on sender */}
            <EmailSignature sender={sender} publicUrls={publicUrls} />
          </Section>
          
          <Hr style={{ borderTop: '1px solid #e6e6e6', margin: '32px 0' }} />
          
          <Section style={{ textAlign: 'center' }}>
            <Text style={{ fontSize: '14px', color: '#666' }}>
               {new Date().getFullYear()} ProcessFlow. All rights reserved.
            </Text>
          </Section>
        </Container>
      </Body>
    </Html>
  );
};
</file>

<file path="emails/templates/FollowUpEmail.tsx">
import * as React from 'react';
import {
  Body,
  Container,
  Head,
  Heading,
  Html,
  Img,
  Link,
  Preview,
  Section,
  Text,
} from '@react-email/components';

interface FollowUpEmailProps {
  firstName: string;
  jeanRdvLink?: string;
  sender?: string;
}

export const FollowUpEmail = ({
  firstName = 'there',
  jeanRdvLink = 'https://cal.com/jean-willame-v2aevm/15min',
  sender = 'jean',
}: FollowUpEmailProps) => {
  const previewText = `How's your ProcessFlow experience so far?`;

  return (
    <Html>
      <Head />
      <Preview>{previewText}</Preview>
      <Body style={main}>
        <Container style={container}>
          <Section>
            <Heading style={h1}>How's your ProcessFlow experience so far?</Heading>
            
            <Text style={text}>
              Hi {firstName},
            </Text>
            
            <Text style={text}>
              It's been a few days since you started using ProcessFlow. I wanted to check in and see how things are going for you.
            </Text>
            
            <Text style={text}>
              Have you had a chance to create your first process? If you're facing any challenges or have questions, I'm here to help.
            </Text>
            
            <Text style={text}>
              Feel free to book a quick call with me if you'd like some personalized guidance:
            </Text>
            
            <Section style={buttonContainer}>
              <Link
                style={button}
                href={jeanRdvLink}
              >
                Book a 15-min call
              </Link>
            </Section>
            
            <Text style={text}>
              Looking forward to hearing from you!
            </Text>
            
            <Text style={signature}>
              Best regards,<br />
              {sender === 'jean' ? 'Jean' : 'The ProcessFlow Team'}
            </Text>
          </Section>
        </Container>
      </Body>
    </Html>
  );
};

// Styles
const main = {
  backgroundColor: '#f6f9fc',
  fontFamily:
    '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif',
};

const container = {
  backgroundColor: '#ffffff',
  margin: '0 auto',
  padding: '20px 0 48px',
  marginBottom: '64px',
  borderRadius: '5px',
  maxWidth: '600px',
};

const h1 = {
  color: '#333',
  fontSize: '24px',
  fontWeight: '600',
  lineHeight: '1.3',
  margin: '16px 0',
  padding: '0 48px',
};

const text = {
  color: '#444',
  fontSize: '16px',
  lineHeight: '1.6',
  margin: '16px 0',
  padding: '0 48px',
};

const buttonContainer = {
  padding: '0 48px',
  margin: '24px 0',
};

const button = {
  backgroundColor: '#5F6CAF',
  borderRadius: '5px',
  color: '#fff',
  fontSize: '16px',
  fontWeight: 'bold',
  textDecoration: 'none',
  textAlign: 'center' as const,
  display: 'block',
  padding: '12px',
};

const signature = {
  color: '#444',
  fontSize: '16px',
  lineHeight: '1.6',
  margin: '16px 0',
  padding: '0 48px',
  fontStyle: 'italic',
};

export default FollowUpEmail;
</file>

<file path="emails/templates/ProcessLimitEmail.tsx">
import * as React from 'react';
import {
  Html,
  Head,
  Body,
  Container,
  Section,
  Hr,
  Link,
  Img,
} from '@react-email/components';
import { Text } from '../components/Text';
import { Heading } from '../components/Heading';
import { Button } from '../components/Button';
import { EmailSignature } from '../components/EmailSignature';
import { CustomFont } from '../components/CustomFont';
import { SenderType } from '@/lib/email';

type ProcessLimitEmailProps = {
  firstName: string;
  sender: SenderType;
  publicUrls?: {
    supabasePublicUrl?: string;
    supabaseStoragePath?: string;
    [key: string]: string | undefined;
  };
  workspaceId?: number;
};

export const ProcessLimitEmail: React.FC<ProcessLimitEmailProps> = ({
  firstName,
  sender = 'contact',
  publicUrls = {},
  workspaceId,
}) => {
  // Construct the logo URL from public URLs or use a fallback
  const supabaseUrl = publicUrls.supabasePublicUrl || '';
  const storagePath = publicUrls.supabaseStoragePath || '';
  
  // Use a fallback image URL if the URLs aren't available
  const logoUrl = supabaseUrl && storagePath 
    ? `${supabaseUrl}${storagePath}/assets/logo/logo-pf-in-app.png`
    : 'https://via.placeholder.com/200x60?text=ProcessFlow';
    
  // URL to redirect to the user's workspace
  let upgradeUrl = `${process.env.NEXT_PUBLIC_APP_URL || 'https://app.process-flow.io'}/settings/billing`;
  
  // If we have a workspace ID, use that for the URL
  if (workspaceId) {
    upgradeUrl = `${process.env.NEXT_PUBLIC_APP_URL || 'https://app.process-flow.io'}/workspace/${workspaceId}`;
  }

  return (
    <Html>
      <Head>
        <CustomFont
          fontFamily="Inter"
          fallbackFontFamily={['system-ui', 'sans-serif']}
          webFont={{
            url: 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap',
            format: 'woff2',
          }}
          fontWeight={400}
          fontStyle="normal"
        />
      </Head>
      <Body style={{ fontFamily: 'Inter, system-ui, sans-serif', margin: 0, padding: 0, backgroundColor: '#f5f5f5' }}>
        <Container style={{ maxWidth: '600px', margin: '0 auto', padding: '40px 20px', backgroundColor: '#ffffff', borderRadius: '8px' }}>
          {/* Logo Section */}
          <Section style={{ textAlign: 'center', marginBottom: '32px' }}>
            <Img
              src={logoUrl}
              alt="ProcessFlow Logo"
              width="180"
              height="auto"
              style={{
                margin: '0 auto',
                display: 'block',
              }}
            />
          </Section>
          
          <Section>
            <Heading>Process limit reached - Here's a tip to get more </Heading>
            <Text>Hello {firstName},</Text>
            <Text>We noticed you've created 5 Flows in ProcessFlow - you're on fire ! </Text>
            <Text>Your current plan has a limit of 5 Flows.</Text>
            
            <Text>To keep your momentum going, here are some options:</Text>
            
            <Text style={{ marginLeft: '20px' }}>
              1. <strong>Upgrade to Early Adopter</strong>: Get unlimited workflows, plus lock in a 50% discount for 6 months with the code <strong>EARLYFLOW50</strong>.
            </Text>
            <Text style={{ marginLeft: '20px' }}>
              2. <strong>Delete an existing workflow</strong>: Free up space to create something new
            </Text>
            
            <Section style={{ textAlign: 'center', margin: '32px 0' }}>
              <Button href={upgradeUrl}>
                Upgrade to Early Adopter
              </Button>
            </Section>
            
            <Text>
              Need help deciding what's best for your needs? We're happy to help! Just reply to this email for personalized assistance.
            </Text>
            
            <Text>
              Best regards,
            </Text>
            
            {/* Add the appropriate signature based on sender */}
            <EmailSignature sender={sender} publicUrls={publicUrls} />
          </Section>
          
          <Hr style={{ borderTop: '1px solid #e6e6e6', margin: '32px 0' }} />
          
          <Section style={{ textAlign: 'center' }}>
            <Text style={{ fontSize: '14px', color: '#666' }}>
               {new Date().getFullYear()} ProcessFlow. All rights reserved.
            </Text>
          </Section>
        </Container>
      </Body>
    </Html>
  );
};
</file>

<file path="emails/templates/ShareRoadmap.tsx">
import * as React from 'react';
import {
  Html,
  Head,
  Body,
  Container,
  Section,
  Hr,
  Link,
  Img,
} from '@react-email/components';
import { Text } from '../components/Text';
import { Heading } from '../components/Heading';
import { Button } from '../components/Button';
import { EmailSignature } from '../components/EmailSignature';
import { SenderType } from '@/lib/email';
import { CustomFont } from '../components/CustomFont';

type FeatureUpdateEmailProps = {
  firstName: string;
  roadmapLink: string;
  sender?: SenderType;
  publicUrls?: {
    supabasePublicUrl?: string;
    supabaseStoragePath?: string;
    [key: string]: string | undefined;
  };
};

export const FeatureUpdateEmail: React.FC<FeatureUpdateEmailProps> = ({
  firstName,
  roadmapLink,
  sender = 'jean',
  publicUrls = {},
}) => {
  // Construct the logo URL from public URLs or use a fallback
  const supabaseUrl = publicUrls.supabasePublicUrl || '';
  const storagePath = publicUrls.supabaseStoragePath || '';
  
  // Use a fallback image URL if the URLs aren't available
  const logoUrl = supabaseUrl && storagePath 
    ? `${supabaseUrl}${storagePath}/assets/logo/logo-pf-in-app.png`
    : 'https://via.placeholder.com/200x60?text=ProcessFlow';

  return (
    <Html>
      <Head>
        <CustomFont
          fontFamily="Inter"
          fallbackFontFamily={["system-ui", "sans-serif"]}
          webFont={{
            url: 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap',
            format: 'woff2',
          }}
          fontWeight={400}
          fontStyle="normal"
        />
      </Head>
      <Body style={{ fontFamily: 'Inter, system-ui, sans-serif', margin: 0, padding: 0, backgroundColor: '#f5f5f5' }}>
        <Container style={{ maxWidth: '600px', margin: '0 auto', padding: '40px 20px', backgroundColor: '#ffffff', borderRadius: '8px' }}>
          {/* Logo Section */}
          <Section style={{ textAlign: 'center', marginBottom: '32px' }}>
            <Img
              src={logoUrl}
              alt="ProcessFlow Logo"
              width="180"
              height="auto"
              style={{
                margin: '0 auto',
                display: 'block',
              }}
            />
          </Section>
          
          <Section>
            <Heading>Sneak peek: new ProcessFlow features you'll love</Heading>
            <Text>Hello {firstName},</Text>
            <Text>
              We are excited to share with you the next steps in our development journey. 
            </Text>
            <Text>
              We are actively working to improve your experience and add new features. To stay informed about what's coming, check out our Development Roadmap!
            </Text>
            
            <Section style={{ textAlign: 'center', margin: '32px 0' }}>
              <Button href={roadmapLink}>
                Join our Roadmap
              </Button>
            </Section>
            
            <Text>
              On our roadmap, you'll see in real-time what the ProcessFlow team is working on.
            </Text>
            
            <Text>
              You can also contribute by voting for the features you find most useful.
            </Text>
            
            <Text>
              Your feedback is invaluable to us, so don't hesitate to let us know what could help you in your process creation.
            </Text>
            
            <Text>
              Talk to you soon,
            </Text>
            
            {/* Add the appropriate signature based on sender */}
            <EmailSignature sender={sender} publicUrls={publicUrls} />
          </Section>
          
          <Hr style={{ borderTop: '1px solid #e6e6e6', margin: '32px 0' }} />
          
          <Section style={{ textAlign: 'center' }}>
            <Text style={{ fontSize: '14px', color: '#666' }}>
               {new Date().getFullYear()} ProcessFlow. All rights reserved.
            </Text>
          </Section>
        </Container>
      </Body>
    </Html>
  );
};
</file>

<file path="emails/templates/SubscriptionActivatedEmail.tsx">
import * as React from 'react';
import {
  Html,
  Head,
  Body,
  Container,
  Section,
  Hr,
  Link,
  Img,
} from '@react-email/components';
import { Text } from '../components/Text';
import { Heading } from '../components/Heading';
import { Button } from '../components/Button';
import { EmailSignature } from '../components/EmailSignature';
import { CustomFont } from '../components/CustomFont';
import { SenderType } from '@/lib/email';

type SubscriptionActivatedEmailProps = {
  firstName: string;
  sender?: SenderType;
  publicUrls?: {
    supabasePublicUrl?: string;
    supabaseStoragePath?: string;
    [key: string]: string | undefined;
  };
};

export const SubscriptionActivatedEmail: React.FC<SubscriptionActivatedEmailProps> = ({
  firstName,
  sender = 'contact',
  publicUrls = {},
}) => {
  // Construct the logo URL from public URLs or use a fallback
  const supabaseUrl = publicUrls.supabasePublicUrl || '';
  const storagePath = publicUrls.supabaseStoragePath || '';
  
  // Use a fallback image URL if the URLs aren't available
  const logoUrl = supabaseUrl && storagePath 
    ? `${supabaseUrl}${storagePath}/assets/logo/logo-pf-in-app.png`
    : 'https://via.placeholder.com/200x60?text=ProcessFlow';

  return (
    <Html>
      <Head>
        <CustomFont
          fontFamily="Inter"
          fallbackFontFamily={['system-ui', 'sans-serif']}
          webFont={{
            url: 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap',
            format: 'woff2',
          }}
          fontWeight={400}
          fontStyle="normal"
        />
      </Head>
      <Body style={{ fontFamily: 'Inter, system-ui, sans-serif', margin: 0, padding: 0, backgroundColor: '#f5f5f5' }}>
        <Container style={{ maxWidth: '600px', margin: '0 auto', padding: '40px 20px', backgroundColor: '#ffffff', borderRadius: '8px' }}>
          {/* Logo Section */}
          <Section style={{ textAlign: 'center', marginBottom: '32px' }}>
            <Img
              src={logoUrl}
              alt="ProcessFlow Logo"
              width="180"
              height="auto"
              style={{
                margin: '0 auto',
                display: 'block',
              }}
            />
          </Section>
          
          <Section>
            <Heading>ProcessFlow Early Adopter activated - Now, you're limitless </Heading>
            <Text>Hello {firstName},</Text>
            <Text>Great news! Your ProcessFlow Early Adopter plan has been successfully activated. </Text>
            
            <Text>You can now:</Text>
            <Text>
              - Create unlimited process workflows
            </Text>
            <Text>
              - Branded process
            </Text>
            <Text>
              - Priority customer support
            </Text>
            
            <Text>
              As an Early Adopter, you're getting special access to new features before everyone else. We're thrilled to have you on board during this exciting phase!
            </Text>
            
            <Text>
              If you have any questions or need assistance getting started, just reply to this email. Our team is here to help you create amazing process guides.
            </Text>
            
            <Section style={{ textAlign: 'center', margin: '32px 0' }}>
              <Button href={process.env.NEXT_PUBLIC_APP_URL || 'https://app.process-flow.io'}>
                Ready to start building?
              </Button>
            </Section>
            
            {/* Add the appropriate signature based on sender */}
            <EmailSignature sender={sender} publicUrls={publicUrls} />
          </Section>
          
          <Hr style={{ borderTop: '1px solid #e6e6e6', margin: '32px 0' }} />
          
          <Section style={{ textAlign: 'center' }}>
            <Text style={{ fontSize: '14px', color: '#666' }}>
               {new Date().getFullYear()} ProcessFlow. All rights reserved.
            </Text>
          </Section>
        </Container>
      </Body>
    </Html>
  );
};

export default SubscriptionActivatedEmail;
</file>

<file path="emails/templates/WelcomeEmail.tsx">
import * as React from 'react';
import {
  Html,
  Head,
  Body,
  Container,
  Section,
  Hr,
  Link,
  Img,
} from '@react-email/components';
import { Text } from '../components/Text';
import { Heading } from '../components/Heading';
import { Button } from '../components/Button';
import { EmailSignature } from '../components/EmailSignature';
import { CustomFont } from '../components/CustomFont';
import { SenderType } from '@/lib/email';

type WelcomeEmailProps = {
  firstName: string;
  jeanRdvLink: string;
  sender: SenderType;
  publicUrls?: {
    supabasePublicUrl?: string;
    supabaseStoragePath?: string;
    [key: string]: string | undefined;
  };
};

export const WelcomeEmail: React.FC<WelcomeEmailProps> = ({
  firstName,
  jeanRdvLink,
  sender = 'jean',
  publicUrls = {},
}) => {
  // Construct the logo URL from public URLs or use a fallback
  const supabaseUrl = publicUrls.supabasePublicUrl || '';
  const storagePath = publicUrls.supabaseStoragePath || '';
  
  // Use a fallback image URL if the URLs aren't available
  const logoUrl = supabaseUrl && storagePath 
    ? `${supabaseUrl}${storagePath}/assets/logo/logo-pf-in-app.png`
    : 'https://via.placeholder.com/200x60?text=ProcessFlow';

  return (
    <Html>
      <Head>
        <CustomFont
          fontFamily="Inter"
          fallbackFontFamily={['system-ui', 'sans-serif']}
          webFont={{
            url: 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap',
            format: 'woff2',
          }}
          fontWeight={400}
          fontStyle="normal"
        />
      </Head>
      <Body style={{ fontFamily: 'Inter, system-ui, sans-serif', margin: 0, padding: 0, backgroundColor: '#f5f5f5' }}>
        <Container style={{ maxWidth: '600px', margin: '0 auto', padding: '40px 20px', backgroundColor: '#ffffff', borderRadius: '8px' }}>
          {/* Logo Section */}
          <Section style={{ textAlign: 'center', marginBottom: '32px' }}>
            <Img
              src={logoUrl}
              alt="ProcessFlow Logo"
              width="180"
              height="auto"
              style={{
                margin: '0 auto',
                display: 'block',
              }}
            />
          </Section>
          
          <Section>
            <Heading>Welcome to ProcessFlow! </Heading>
            <Text>Hello {firstName},</Text>
            <Text>We are thrilled to welcome you to ProcessFlow! </Text>
            <Text>
              As an early user, we're offering you 50% OFF for your first 6 months on the "Early Adopter" plan with this promo code: <strong>EARLYFLOW50</strong>
            </Text>
            
            <Heading level={2}>Need help getting started?</Heading>
            <Text>You can:</Text>
            <Text>
              - Hop on a call with founders of ProcessFlow
            </Text>
            <Text>
              - In any other case, feel free to answer this email 
            </Text>
            
            <Section style={{ textAlign: 'center', margin: '32px 0' }}>
              <Button href={jeanRdvLink}>
                Schedule a call with founders
              </Button>
            </Section>
            
            <Text>
              We are a small team that values close connections with our community, so do not hesitate to contact us!
            </Text>
            
            <Text>
              Looking forward to helping you create amazing process flows,
            </Text>
            
            {/* Add the appropriate signature based on sender */}
            <EmailSignature sender={sender} publicUrls={publicUrls} />
          </Section>
          
          <Hr style={{ borderTop: '1px solid #e6e6e6', margin: '32px 0' }} />
          
          <Section style={{ textAlign: 'center' }}>
            <Text style={{ fontSize: '14px', color: '#666' }}>
               {new Date().getFullYear()} ProcessFlow. All rights reserved.
            </Text>
          </Section>
        </Container>
      </Body>
    </Html>
  );
};
</file>

<file path="hooks/useSupabaseSession.ts">
import { useEffect, useState } from 'react';
import { Session, User } from '@supabase/supabase-js';
import { createBrowserClient } from '@supabase/ssr';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL as string;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY as string;

interface SupabaseSessionState {
  session: Session | null;
  user: User | null;
  loading: boolean;
  error: Error | null;
}

export function useSupabaseSession() {
  const [state, setState] = useState<SupabaseSessionState>({
    session: null,
    user: null,
    loading: true,
    error: null,
  });

  useEffect(() => {
    const supabase = createBrowserClient(supabaseUrl, supabaseAnonKey, {
      cookies: {
        get(name: string) {
          return document.cookie
            .split('; ')
            .find((row) => row.startsWith(`${name}=`))
            ?.split('=')[1];
        },
        set(name: string, value: string, options: any) {
          let cookie = `${name}=${value}; path=/`;
          if (options.maxAge) {
            cookie += `; max-age=${options.maxAge}`;
          }
          if (options.domain) {
            cookie += `; domain=.process-flow.io`;
          }
          document.cookie = cookie;
        },
        remove(name: string) {
          document.cookie = `${name}=; path=/; expires=Thu, 01 Jan 1970 00:00:01 GMT`;
        },
      },
    });

    // Function to fetch and update authenticated user
    const fetchUser = async () => {
      try {
        const { data: { user }, error } = await supabase.auth.getUser();
        if (error) throw error;
        
        setState(prev => ({
          ...prev,
          user,
          session: user ? { user } as Session : null,
          loading: false,
          error: null
        }));
      } catch (error) {
        console.error('Error fetching user:', error);
        setState(prev => ({
          ...prev,
          user: null,
          session: null,
          loading: false,
          error: error as Error
        }));
      }
    };

    // Initial fetch
    fetchUser();

    // Subscribe to auth changes
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange(async (_event, session) => {
      // After any auth state change, verify the user server-side
      await fetchUser();
    });

    return () => {
      subscription.unsubscribe();
    };
  }, []);

  return state;
}
</file>

<file path="hooks/useWorkspace.ts">
// app/hooks/useWorkspace.ts
'use client';

import { useContext } from 'react';
import { createContext } from 'react';
import { Workspace } from '@/types/workspace';

interface WorkspaceContextType {
  workspace: Workspace | null;
}

const WorkspaceContext = createContext<WorkspaceContextType>({ workspace: null });

export function useWorkspace() {
  const context = useContext(WorkspaceContext);
  if (!context) {
    throw new Error('useWorkspace must be used within a WorkspaceProvider');
  }
  return context;
}

export const WorkspaceProvider = WorkspaceContext.Provider;
</file>

<file path="lib/emails/scheduleCancellationFollowUpEmail.ts">
import prisma from '@/lib/prisma';
import { sendReactEmail } from '@/lib/email';
import { CancellationFollowUpEmail } from '@/emails/templates/CancellationFollowUpEmail';
import { isVercel } from '@/app/api/utils/isVercel';
import { PrismaClient } from '@prisma/client';

const EMAIL_TYPE = 'CANCELLATION_FOLLOW_UP';

export async function scheduleCancellationFollowUpEmail(userId: number) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Get user information
    const user = await prisma_client.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      return { success: false, error: 'User not found' };
    }

    // Check if we've already scheduled this email for this user
    const recentEmail = await prisma_client.scheduled_email.findFirst({
      where: {
        user_id: userId,
        email_type: EMAIL_TYPE,
        status: { in: ['PENDING', 'SENT'] },
      },
    });

    if (recentEmail) {
      return { 
        success: false, 
        reason: `Cancellation follow-up email already sent or pending`,
        emailId: recentEmail.id
      };
    }

    // Generate feedback link with userId
    const feedbackLink = `https://tally.so/r/woVeqM?userId=${userId}`;

    // Schedule the email for 1 day after cancellation
    const scheduledDate = new Date();
    scheduledDate.setDate(scheduledDate.getDate() + 1); // D+1

    // Create the scheduled email record
    const scheduledEmail = await prisma_client.scheduled_email.create({
      data: {
        user_id: userId,
        email_type: EMAIL_TYPE,
        scheduled_for: scheduledDate,
        status: 'PENDING',
        metadata: {
          feedbackLink: feedbackLink
        }
      }
    });

    return { 
      success: true, 
      message: `Cancellation follow-up email scheduled for ${scheduledDate.toISOString()}`,
      emailId: scheduledEmail.id
    };
  } catch (error) {
    console.error('Error scheduling cancellation follow-up email:', error);
    return { success: false, error };
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="lib/emails/scheduleFeedbackRequestEmail.ts">
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { scheduleFollowUpEmail } from '@/lib/scheduledEmails';
import { isVercel } from '@/app/api/utils/isVercel';

/**
 * Schedule a feedback request email to be sent 7 days after welcome email
 * Only sends if the user has created at least one flow
 * 
 * @param userId - The user's ID
 * @returns A promise that resolves to the result of scheduling the email
 */
export async function scheduleFeedbackRequestEmail(userId: number) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    if (!userId) {
      console.error('Missing required userId for scheduling feedback request email');
      return { success: false, error: 'Missing required userId' };
    }

    // Check if a feedback request email is already scheduled for this user
    const existingScheduledEmail = await prisma_client.scheduled_email.findFirst({
      where: {
        user_id: userId,
        email_type: 'FEEDBACK_REQUEST',
        status: 'PENDING',
        sent: false,
      },
    });

    if (isVercel()) await prisma_client.$disconnect();

    if (existingScheduledEmail) {
      return { success: true, scheduledEmailId: existingScheduledEmail.id };
    }

    // Schedule the email for 7 days after now
    const result = await scheduleFollowUpEmail({
      userId,
      emailType: 'FEEDBACK_REQUEST',
      daysAfter: 7,
      metadata: {
        // We'll fetch the user's details at send time
        // This is just a flag to check for flows before sending
        requiresFlowCheck: true,
      },
    });

    if (!result.success) {
      console.error('Failed to schedule feedback request email:', result.error);
      return { success: false, error: result.error };
    }

    return { success: true, scheduledEmailId: result.scheduledEmailId };
  } catch (error) {
    console.error('Error scheduling feedback request email:', error);
    return { success: false, error };
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="lib/emails/scheduleProcessLimitEmail.ts">
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { scheduleFollowUpEmail } from '@/lib/scheduledEmails';
import { sendReactEmail } from '@/lib/email';
import { ProcessLimitEmail } from '@/emails/templates/ProcessLimitEmail';

const WORKFLOW_LIMIT = 5;
const COOLDOWN_DAYS = 4;
const EMAIL_TYPE = 'PROCESS_LIMIT_REACHED';

/**
 * Schedules and immediately sends a process limit email for a user with a cooldown period.
 * 
 * @param userId - The ID of the user to send the email to
 * @returns Object indicating if the email was scheduled/sent and why
 */
export async function checkAndScheduleProcessLimitEmail(userId: number) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Get the user to confirm they exist
    const user = await prisma_client.user.findUnique({
      where: { id: userId },
      include: {
        // Include active_workspace to get the workspace ID
        active_workspace: true
      }
    });

    if (!user) {
      if (isVercel()) await prisma_client.$disconnect();
      return { success: false, reason: 'User not found' };
    }
    
    // Get the workspace ID (either from active workspace or from workspaces)
    let workspaceId = user.active_workspace_id;
    
    // If user doesn't have an active workspace, try to find one
    if (!workspaceId) {
      const userWorkspace = await prisma_client.user_workspace.findFirst({
        where: { user_id: userId },
        select: { workspace_id: true },
        orderBy: { workspace_id: 'asc' }
      });
      
      if (userWorkspace) {
        workspaceId = userWorkspace.workspace_id;
      }
    }

    // Check if we've already sent this email recently (within cooldown period)
    const recentEmail = await prisma_client.scheduled_email.findFirst({
      where: {
        user_id: userId,
        email_type: EMAIL_TYPE,
        OR: [
          // Either pending emails
          { status: 'PENDING' },
          // Or recently sent emails within cooldown period
          {
            status: 'SENT',
            sent_at: {
              gt: new Date(Date.now() - COOLDOWN_DAYS * 24 * 60 * 60 * 1000)
            }
          }
        ]
      }
    });

    if (recentEmail) {
      if (isVercel()) await prisma_client.$disconnect();
      return { 
        success: false, 
        reason: `Process limit email already sent or pending within cooldown period (${COOLDOWN_DAYS} days)`,
        emailId: recentEmail.id
      };
    }

    // Prepare metadata with workspace ID if available
    const metadata = workspaceId ? { workspaceId } : {};

    // 1. Create a record in the scheduled_email table (for cooldown tracking)
    const now = new Date();
    const scheduledEmail = await prisma_client.scheduled_email.create({
      data: {
        user_id: userId,
        email_type: EMAIL_TYPE,
        scheduled_for: now,
        status: 'PENDING',
        metadata,
      }
    });

    // 2. Now, immediately send the email instead of waiting for the cron job
    try {
      // Get public URLs for the email template
      const safePublicUrls = {
        supabasePublicUrl: process.env.NEXT_PUBLIC_SUPABASE_URL || '',
        supabaseStoragePath: process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH || '',
        producthuntUrl: process.env.NEXT_PUBLIC_PRODUCTHUNT_URL || 'https://www.producthunt.com',
        linkedinUrl: process.env.NEXT_PUBLIC_LINKEDIN_URL || 'https://www.linkedin.com/company/processflow1/',
        xUrl: process.env.NEXT_PUBLIC_X_URL || 'https://x.com',
      };

      // Send the email immediately
      const sendResult = await sendReactEmail({
        to: user.email,
        subject: 'Process limit reached - Here\'s a tip to get more ',
        Component: ProcessLimitEmail,
        props: {
          firstName: user.first_name,
          publicUrls: safePublicUrls,
          sender: 'jean',
          workspaceId: workspaceId || undefined,
        },
        sender: 'jean',
      });

      // Update the scheduled email record
      if (sendResult.success) {
        await prisma_client.scheduled_email.update({
          where: { id: scheduledEmail.id },
          data: {
            status: 'SENT',
            sent: true,
            sent_at: new Date(),
          },
        });
        if (isVercel()) await prisma_client.$disconnect();
        return { 
          success: true, 
          reason: 'Process limit email sent immediately',
          scheduledEmailId: scheduledEmail.id,
          messageId: sendResult.messageId
        };
      } else {
        // If sending fails, leave the record as is for the cron job to retry
        console.error(`Failed to send process limit email: ${sendResult.error}`);
        if (isVercel()) await prisma_client.$disconnect();
        return { 
          success: false, 
          reason: 'Failed to send email immediately, will retry via cron',
          scheduledEmailId: scheduledEmail.id,
          error: sendResult.error
        };
      }
    } catch (sendError) {
      console.error('Error sending process limit email:', sendError);
      if (isVercel()) await prisma_client.$disconnect();
      return { 
        success: false, 
        reason: 'Error sending immediate email, will retry via cron',
        scheduledEmailId: scheduledEmail.id,
        error: sendError
      };
    }
  } catch (error) {
    console.error('Error scheduling process limit email:', error);
    return { success: false, error };
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="lib/emails/sendFeedbackRequestEmail.ts">
import { sendReactEmail } from '@/lib/email';
import { FeedbackRequestEmail } from '@/emails/templates/FeedbackRequestEmail';

type SendFeedbackRequestEmailProps = {
  email: string;
  firstName: string;
  feedbackLink?: string;
};

/**
 * Sends a feedback request email to a user
 * 
 * Trigger condition: D+7 after "Welcome Email" send. User must have created at least one Flow.
 * 
 * @param email - The recipient's email address
 * @param firstName - The recipient's first name
 * @param feedbackLink - Optional custom feedback link (defaults to Tally.so form)
 * @returns A promise that resolves to the result of sending the email
 */
export async function sendFeedbackRequestEmail({
  email,
  firstName,
  feedbackLink = 'https://tally.so/r/wkRej6',
}: SendFeedbackRequestEmailProps) {
  if (!email || !firstName) {
    console.error('Missing required parameters for feedback request email');
    return { success: false, error: 'Missing required parameters' };
  }

  try {
    return await sendReactEmail({
      to: email,
      subject: 'How is your experience with ProcessFlow going? ',
      Component: FeedbackRequestEmail,
      props: {
        firstName,
        feedbackLink,
        sender: 'jean',
      },
    });
  } catch (error) {
    console.error('Error sending feedback request email:', error);
    return { success: false, error };
  }
}
</file>

<file path="lib/utils/cn.ts">
import clsx from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: (string | undefined | null | boolean)[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="lib/authMiddleware.ts">
import { createClient } from '@/lib/supabaseServerClient';
import { NextResponse, type NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { isVercel } from '@/app/api/utils/isVercel';
import { PrismaClient } from '@prisma/client';

export async function authMiddleware(request: NextRequest) {
  const supabase = createClient();
  
  // Get authenticated user using Supabase
  const { data: { user }, error } = await supabase.auth.getUser();
  
  if (error || !user) {
    if (process.env.NODE_ENV !== 'production') {
      console.log('User not authenticated:', error);
    }
    return NextResponse.redirect(new URL('/login', request.url));
  }

  // Pass minimal required info
  const requestHeaders = new Headers(request.headers);
  requestHeaders.set('x-user-id', user.id);
  // If you have role information in the user metadata, you can add it too
  if (user.user_metadata?.role) {
    requestHeaders.set('x-user-role', user.user_metadata.role);
  }

  return NextResponse.next({
    request: { headers: requestHeaders }
  });
}

// Protected route helper
export async function getProtectedUser(request: Request) {
  const userId = request.headers.get('x-user-id');
  const userRole = request.headers.get('x-user-role');

  if (!userId) {
    throw new Error('User ID not found in request headers');
  }

  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  const user = await prisma_client.user.findUnique({ 
    where: { auth_id: userId }
  });
  if (isVercel()) await prisma_client.$disconnect();

  return user;
}
</file>

<file path="lib/env-check.ts">
/**
 * Environment Variable Validator
 * 
 * This utility helps validate that required environment variables are present
 * and provides helpful debugging information when they're missing.
 */

export type EnvCheckResult = {
  isValid: boolean;
  missingVars: string[];
  message: string;
};

/**
 * Validates that required environment variables are present
 */
export function checkRequiredEnvVars(requiredVars: string[]): EnvCheckResult {
  const missingVars = requiredVars.filter(
    varName => !process.env[varName] || process.env[varName] === ''
  );

  const isValid = missingVars.length === 0;
  let message = isValid 
    ? 'All required environment variables are present.' 
    : `Missing required environment variables: ${missingVars.join(', ')}`;

  if (!isValid) {
    const envPrefix = process.env.NODE_ENV === 'production' ? '' : 'NEXT_PUBLIC_';
    message += `\n\nPlease check your .env file and ensure these variables are present.`;
    message += `\nRemember that variables accessible in the browser must be prefixed with NEXT_PUBLIC_.`;
    message += `\nCurrent environment: ${process.env.NODE_ENV}`;
    
    // Provide information about available env vars without revealing sensitive values
    const availableVars = Object.keys(process.env)
      .filter(key => !key.includes('SECRET') && !key.includes('KEY'))
      .join(', ');
    
    message += `\n\nAvailable environment variables: ${availableVars}`;
  }

  return { isValid, missingVars, message };
}

// Check Stripe-related environment variables on import
const stripeEnvCheck = checkRequiredEnvVars([
  'STRIPE_SECRET_KEY',
  'NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY',
  'NEXT_PUBLIC_STRIPE_EARLY_ADOPTER_MONTHLY_PRICE_ID',
  'NEXT_PUBLIC_STRIPE_EARLY_ADOPTER_ANNUAL_PRICE_ID'
]);

// Log warnings in development but not in production to avoid cluttering logs
if (!stripeEnvCheck.isValid && process.env.NODE_ENV !== 'production') {
  console.warn(' Stripe environment check failed:');
  console.warn(stripeEnvCheck.message);
}

export default { checkRequiredEnvVars };
</file>

<file path="lib/prisma.ts">
// lib/prisma.ts
import { isVercel } from '@/app/api/utils/isVercel';
import { isPreview } from '@/app/utils/isPreview';
import { PrismaClient } from '@prisma/client';

const globalForPrisma = global as unknown as { prisma: PrismaClient | undefined };

let prisma: PrismaClient | undefined;

// If running on Vercel, do not create a Prisma client
if (process.env.VERCEL) {
  prisma = undefined;
} else if (process.env.NODE_ENV === 'production') {
  prisma = new PrismaClient();
} else {
  // In non-production, use global to avoid multiple instances during hot-reloading
  if (!globalForPrisma.prisma) {
    globalForPrisma.prisma = new PrismaClient();
  }
  prisma = globalForPrisma.prisma;
}

if (!prisma && !isVercel()) {
  throw new Error('Prisma client not initialized');
}

export default prisma;
</file>

<file path="lib/rateLimit.ts">
import { NextRequest, NextResponse } from 'next/server';

// Simple in-memory store for rate limiting
// In production, you should use Redis or another distributed store
interface RateLimitStore {
  [ip: string]: {
    count: number;
    resetTime: number;
  };
}

const stores: Record<string, RateLimitStore> = {};

export function createRateLimiter(name: string, limit: number, windowMs: number) {
  // Create a new store if it doesn't exist
  if (!stores[name]) {
    stores[name] = {};
  }
  
  const store = stores[name];
  
  // Clean up expired entries periodically
  setInterval(() => {
    const now = Date.now();
    Object.keys(store).forEach((key) => {
      if (store[key].resetTime <= now) {
        delete store[key];
      }
    });
  }, 60 * 1000); // Clean up every minute
  
  return async function rateLimit(request: Request) {
    // Get client IP address (handle both NextRequest and standard Request)
    let ip = 'unknown';
    
    // Check if headers.get is available (standard for Request)
    if (request.headers && typeof request.headers.get === 'function') {
      ip = request.headers.get('x-forwarded-for') || 
           request.headers.get('x-real-ip') || 
           'unknown';
    }
    
    const now = Date.now();
    
    // Reset rate limit if the window has passed
    if (!store[ip] || store[ip].resetTime <= now) {
      store[ip] = {
        count: 1,
        resetTime: now + windowMs,
      };
      return null; // No rate limit exceeded
    }
    
    // Increment count
    store[ip].count += 1;
    
    // Check if rate limit is exceeded
    if (store[ip].count > limit) {
      // Calculate remaining time until reset
      const resetInSecs = Math.ceil((store[ip].resetTime - now) / 1000);
      
      // Return rate limit response
      return NextResponse.json(
        { 
          error: 'Too many requests', 
          message: `Rate limit exceeded. Try again in ${resetInSecs} seconds.` 
        },
        { 
          status: 429,
          headers: {
            'Retry-After': String(resetInSecs),
            'X-RateLimit-Limit': String(limit),
            'X-RateLimit-Remaining': '0',
            'X-RateLimit-Reset': String(Math.ceil(store[ip].resetTime / 1000)),
          }
        }
      );
    }
    
    // Return null if rate limit is not exceeded
    return null;
  };
}

// Common rate limiters
export const subscriptionRateLimiter = createRateLimiter('subscription', 10, 60 * 1000); // 10 requests per minute
export const checkoutRateLimiter = createRateLimiter('checkout', 5, 60 * 1000); // 5 requests per minute
export const webhookRateLimiter = createRateLimiter('webhook', 100, 60 * 1000); // 100 requests per minute (webhooks need higher limits)
</file>

<file path="lib/roadmapAuth.ts">
/**
 * Utility functions for roadmap authentication
 */

/**
 * Generates an authenticated link to the roadmap for email purposes
 * @param userId The user's ID
 * @param email The user's email
 * @param firstName The user's first name
 * @param lastName The user's last name
 * @param avatarUrl Optional avatar URL
 * @returns The authenticated roadmap URL
 */
export async function generateRoadmapLinkForEmail(
  userId: number,
  email: string,
  firstName: string,
  lastName: string,
  avatarUrl?: string
): Promise<string> {
  try {
    // Prepare user data for the token generation
    const userData = {
      user_email: email,
      app_user_id: userId.toString(),
      user_name: `${firstName} ${lastName}`,
      img_url: avatarUrl,
    };

    // Call the features.vote API to generate a token
    const response = await fetch(
      'https://features.vote/api/public/user-token',
      {
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          apiSecretKey: process.env.NEXT_PUBLIC_FEATURES_VOTE_API_KEY,
          slug: 'processflow',
          user_data: userData,
        }),
      }
    );

    const data = await response.json();
    if (data.error) {
      throw new Error(data.error);
    }

    // Construct the roadmap URL with the token
    const roadmapUrl = `https://processflow.features.vote/roadmap?token=${data.token}`;
    return roadmapUrl;
  } catch (error) {
    console.error('Error generating roadmap link for email:', error);
    // Return the non-authenticated URL as fallback
    return 'https://processflow.features.vote/roadmap';
  }
}
</file>

<file path="lib/scheduledEmails.ts">
import prisma from '@/lib/prisma';
import { SenderType } from '@/lib/email';
import { generateRoadmapLinkForEmail } from '@/lib/roadmapAuth';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

type ScheduleEmailProps = {
  userId: number;
  emailType: string;
  scheduledFor: Date;
  metadata?: Record<string, any>;
};

/**
 * Schedule an email to be sent at a later time
 */
export async function scheduleEmail({
  userId,
  emailType,
  scheduledFor,
  metadata = {},
}: ScheduleEmailProps) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // If this is a FEATURE_UPDATE email, we need to generate a roadmap link
    if (emailType === 'FEATURE_UPDATE' && !metadata.roadmapLink) {
      try {
        // Get the user from the database
        const user = await prisma_client.user.findUnique({
          where: { id: userId },
          select: {
            id: true,
            email: true,
            first_name: true,
            last_name: true,
            avatar_url: true,
          },
        });

        if (user) {
          // Generate the roadmap link
          const roadmapLink = await generateRoadmapLinkForEmail(
            user.id,
            user.email,
            user.first_name,
            user.last_name,
            user.avatar_url || undefined
          );

          // Add the roadmap link to the metadata
          metadata.roadmapLink = roadmapLink;
        }
      } catch (error) {
        console.error('Error generating roadmap link:', error);
        // Use a fallback link if generation fails
        metadata.roadmapLink = 'https://processflow.features.vote/roadmap';
      }
    }

    const scheduledEmail = await prisma_client.scheduled_email.create({
      data: {
        user_id: userId,
        email_type: emailType,
        scheduled_for: scheduledFor,
        metadata: metadata,
      },
    });
    
    
    return { success: true, scheduledEmailId: scheduledEmail.id };
  } catch (error) {
    console.error('Error scheduling email:', error);
    return { success: false, error };
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}

/**
 * Schedule a follow-up email to be sent after a specified number of days
 */
export async function scheduleFollowUpEmail({
  userId,
  emailType,
  daysAfter,
  metadata = {},
}: Omit<ScheduleEmailProps, 'scheduledFor'> & { daysAfter: number }) {
  const scheduledFor = new Date();
  scheduledFor.setDate(scheduledFor.getDate() + daysAfter);
  
  return scheduleEmail({
    userId,
    emailType,
    scheduledFor,
    metadata,
  });
}

/**
 * For testing: Schedule an email to be sent after a specified number of minutes
 */
export async function scheduleTestEmail({
  userId,
  emailType,
  minutesAfter,
  metadata = {},
}: Omit<ScheduleEmailProps, 'scheduledFor'> & { minutesAfter: number }) {
  const scheduledFor = new Date();
  scheduledFor.setMinutes(scheduledFor.getMinutes() + minutesAfter);
  
  return scheduleEmail({
    userId,
    emailType,
    scheduledFor,
    metadata,
  });
}
</file>

<file path="lib/stripe.ts">
import Stripe from 'stripe';
import './env-check';  // This will run the environment checks on import

// Create a function to retrieve and validate the Stripe API key
function getStripeKey() {
  // Try multiple potential environment variable names
  const key = process.env.STRIPE_SECRET_KEY || 
              process.env.STRIPE_API_KEY || 
              process.env.STRIPE_KEY;
  
  if (!key) {
    console.error(' Stripe Secret Key is missing!');
    console.error('Please ensure one of these environment variables is set:');
    console.error('- STRIPE_SECRET_KEY (recommended)');
    console.error('- STRIPE_API_KEY');
    console.error('- STRIPE_KEY');
    console.error('Check your .env file and make sure Next.js is loading it correctly.');
    
    // Only log environment details in non-production environments
    if (process.env.NODE_ENV !== 'production') {
      console.log('Current environment:', process.env.NODE_ENV);
      console.log('Available environment variables:', 
        Object.keys(process.env)
          .filter(key => !key.includes('SECRET') && !key.includes('KEY'))
          .join(', ')
      );
    }
    
    // In development, return a placeholder that will fail gracefully
    if (process.env.NODE_ENV === 'development') {
      return 'sk_test_placeholder_for_development_only';
    }
    return '';
  }
  
  return key;
}

// Get the Stripe key
const stripeKey = getStripeKey();

// Create a Stripe instance with proper error handling
export const stripe = new Stripe(stripeKey, {
  apiVersion: '2025-02-24.acacia',
  typescript: true,
  appInfo: {
    name: 'ProcessFlow',
    version: '1.0.0',
  },
});

// Define price IDs with fallbacks to avoid undefined errors
export const STRIPE_PRICE_IDS = {
  EARLY_ADOPTER: {
    MONTHLY: process.env.NEXT_PUBLIC_STRIPE_EARLY_ADOPTER_MONTHLY_PRICE_ID || '',
    ANNUAL: process.env.NEXT_PUBLIC_STRIPE_EARLY_ADOPTER_ANNUAL_PRICE_ID || '',
  },
} as const;

export const CURRENCY_MULTIPLIER = 100; // Stripe amounts are in cents

// Constants for pricing with safeguards against undefined
export const PRICE_ID_MONTHLY = process.env.STRIPE_PRICE_ID_MONTHLY || process.env.NEXT_PUBLIC_STRIPE_EARLY_ADOPTER_MONTHLY_PRICE_ID || '';
export const PRICE_ID_ANNUAL = process.env.STRIPE_PRICE_ID_ANNUAL || process.env.NEXT_PUBLIC_STRIPE_EARLY_ADOPTER_ANNUAL_PRICE_ID || '';

export async function createStripeCheckoutSession({
  priceId,
  customerId,
  successUrl,
  cancelUrl,
  quantity = 1,
  metadata = {},
}: {
  priceId: string;
  customerId?: string;
  successUrl: string;
  cancelUrl: string;
  quantity?: number;
  metadata?: Record<string, string>;
}) {
  // Ensure workspaceId is included in metadata for webhook processing
  if (!metadata.workspaceId) {
    console.warn('No workspaceId in metadata for checkout session');
  }
  
  // Add additional fields to help with debugging
  const enrichedMetadata = {
    ...metadata,
    created_at: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development',
  };
  
  // Only log metadata in non-production environments
  if (process.env.NODE_ENV !== 'production') {
    console.log('Creating checkout session with metadata:', enrichedMetadata);
  }
  
  try {
    return await stripe.checkout.sessions.create({
      mode: 'subscription',
      payment_method_types: ['card'],
      line_items: [
        {
          price: priceId,
          quantity,
        },
      ],
      customer: customerId,
      success_url: successUrl,
      cancel_url: cancelUrl,
      automatic_tax: { enabled: true },
      tax_id_collection: { enabled: true },
      customer_update: {
        address: 'auto',
        name: 'auto',
      },
      metadata: enrichedMetadata,
      billing_address_collection: 'required',
      allow_promotion_codes: true,
      currency: 'eur', // Changed from USD to EUR to match the price configuration
    });
  } catch (error) {
    console.error('Error creating Stripe checkout session:', error);
    throw error;
  }
}

export async function createStripePortalSession({
  customerId,
  returnUrl,
}: {
  customerId: string;
  returnUrl: string;
}) {
  try {
    return await stripe.billingPortal.sessions.create({
      customer: customerId,
      return_url: returnUrl,
    });
  } catch (error: any) {
    // If no configuration exists, create a default one
    if (error.code === 'billing_portal_configuration_not_found' || 
        error.message?.includes('No configuration provided')) {
      console.log('Creating default customer portal configuration...');
      
      try {
        // Create a default configuration
        await stripe.billingPortal.configurations.create({
          business_profile: {
            headline: 'ProcessFlow - Manage your subscription',
          },
          features: {
            payment_method_update: {
              enabled: true,
            },
            invoice_history: {
              enabled: true,
            },
            customer_update: {
              enabled: true,
              allowed_updates: ['address', 'email', 'tax_id'],
            },
            subscription_cancel: {
              enabled: true,
              mode: 'at_period_end',
            },
            subscription_update: {
              enabled: true,
              default_allowed_updates: ['price', 'quantity'],
              proration_behavior: 'create_prorations',
            },
          },
        });
        
        console.log('Default customer portal configuration created successfully');
        
        // Now try creating the session again
        return await stripe.billingPortal.sessions.create({
          customer: customerId,
          return_url: returnUrl,
        });
      } catch (configError) {
        console.error('Error creating customer portal configuration:', configError);
        throw configError;
      }
    }
    
    // Re-throw other errors
    throw error;
  }
}

export async function getStripeSubscription(subscriptionId: string) {
  return stripe.subscriptions.retrieve(subscriptionId);
}

export async function cancelStripeSubscription(subscriptionId: string) {
  return stripe.subscriptions.update(subscriptionId, {
    cancel_at_period_end: true,
  });
}

export async function updateStripeSubscriptionQuantity(
  subscriptionId: string,
  quantity: number
) {
  return stripe.subscriptions.update(subscriptionId, {
    items: [{ quantity }],
  });
}

export async function updateStripeSubscriptionPlan(
  subscriptionId: string,
  newPriceId: string
) {
  try {
    // Get the subscription to find the current items
    const subscription = await stripe.subscriptions.retrieve(subscriptionId);
    
    // Get the current subscription item ID
    const currentItemId = subscription.items.data[0].id;
    
    // Update the subscription with the new price
    return stripe.subscriptions.update(subscriptionId, {
      items: [
        {
          id: currentItemId,
          price: newPriceId,
          // Keep the same quantity
          quantity: subscription.items.data[0].quantity || 1,
        },
      ],
      // Don't prorate immediately, but on next billing cycle
      proration_behavior: 'create_prorations',
    });
  } catch (error) {
    console.error('Error updating subscription plan:', error);
    throw error;
  }
}

// Map Stripe subscription status to our enum
export function mapStripeStatusToDbStatus(stripeStatus: string): 'ACTIVE' | 'TRIALING' | 'CANCELED' {
  const statusMap: Record<string, 'ACTIVE' | 'TRIALING' | 'CANCELED'> = {
    'active': 'ACTIVE',
    'trialing': 'TRIALING',
    'canceled': 'CANCELED',
    'unpaid': 'CANCELED',
    'past_due': 'ACTIVE', // You might want a different mapping for past_due
    'incomplete': 'ACTIVE', // You might want a different mapping for incomplete
    'incomplete_expired': 'CANCELED',
  };
  
  // Log when encountering an unknown status
  if (!statusMap[stripeStatus]) {
    console.warn(`Unknown Stripe status: ${stripeStatus}, defaulting to ACTIVE`);
  }
  
  return statusMap[stripeStatus] || 'ACTIVE';
}
</file>

<file path="lib/supabaseClient.ts">
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.SUPABASE_URL!;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

export const supabase = createClient(supabaseUrl, supabaseKey);
</file>

<file path="lib/supabasePublicClient.ts">
import { createClient } from '@supabase/supabase-js';

// Public Supabase credentials
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL as string;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY as string;

// Public client for frontend usage
export const supabasePublicClient = createClient(supabaseUrl, supabaseAnonKey);
</file>

<file path="lib/supabaseServerClient.ts">
import { createServerClient, type CookieOptions } from '@supabase/ssr';
import { cookies } from 'next/headers';

if (!process.env.NEXT_PUBLIC_SUPABASE_URL) {
  throw new Error('Missing env.NEXT_PUBLIC_SUPABASE_URL');
}
if (!process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
  throw new Error('Missing env.NEXT_PUBLIC_SUPABASE_ANON_KEY');
}

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL as string;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY as string;

export function createClient() {
  const cookieStore = cookies();

  return createServerClient(
    supabaseUrl,
    supabaseAnonKey,
    {
      cookies: {
        async get(name: string) {
          const cookie = (await cookieStore).get(name);
          return cookie?.value ?? '';
        },
        async set(name: string, value: string, options: CookieOptions) {
          try {
            (await cookieStore).set({ name, value, ...options });
          } catch (error) {
            console.error('Error setting cookie:', error);
          }
        },
        async remove(name: string, options: CookieOptions) {
          try {
            (await cookieStore).delete({ name, ...options });
          } catch (error) {
            console.error('Error removing cookie:', error);
          }
        },
      },
    }
  );
}
</file>

<file path="lib/swagger.ts">
// utils/swagger.ts
import { OpenAPIV3 } from "openapi-types";
import swaggerJsdoc from "swagger-jsdoc";

const options: swaggerJsdoc.Options = {
  definition: {
    openapi: "3.0.0",
    info: {
      title: "Next.js 14 API Documentation",
      version: "1.0.0",
      description: "API documentation for Next.js 14 project",
    },
    servers: [
      {
        url: "http://localhost:3000",
        description: "Local server",
      },
    ],
  },
  apis: ["./app/api/**/*.ts"], // Adjust this path if needed
};

const swaggerSpec = swaggerJsdoc(options);
export default swaggerSpec;
</file>

<file path="lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="prisma/dbml/schema.documentation.dbml">
//// ------------------------------------------------------
//// Documentation file for the schema.dbml file
//// ------------------------------------------------------

Table user {
  id Int [pk, increment, note: 'Primary identifier for user']
  created_at DateTime [default: `now()`, not null, note: 'Creation timestamp']
  updated_at DateTime [default: `now()`, not null, note: 'Last update timestamp']
  archived_at DateTime [note: 'Timestamp when user was archived (soft delete)']
  auth_id String [unique, not null, note: 'Authentication identifier']
  first_name String [not null, note: 'User\'s first name']
  last_name String [not null, note: 'User\'s last name']
  full_name String [not null, note: 'Complete name (first + last)']
  email String [unique, not null, note: 'User\'s email address (unique)']
  avatar_url String [note: 'URL to user\'s profile image']
  active_workspace_id Int [note: 'ID of currently selected workspace']
  hubspot_contact_id String [note: 'External Hubspot contact ID']
  sentry_id String [note: 'Sentry user ID']
  post_hog_id String [note: 'PostHog user ID']
  last_login_at DateTime [note: 'Date of last login']
  onboarding_completed_at DateTime [note: 'Date of onboarding completion']
  onboarding_step onboarding_step [default: 'PERSONAL_INFO', note: 'Current onboarding progress']
  professional_role String [note: 'User\'s job title/role']
  source String [note: 'How user found the platform']
  temp_company_size String [note: 'Temporary field for company size, will be transfered to company_size in workspace table once it\'s created']
  temp_industry String [note: 'Temporary field for industry, will be transfered to industry in workspace table once it\'s created']
  tutorial_completed Boolean [not null, default: false, note: 'Whether first-time tutorial is done']
  active_workspace workspace [note: 'Currently selected workspace']
  workspaces user_workspace [not null, note: 'All workspaces user belongs to']
  scheduled_emails scheduled_emails [not null, note: 'Emails scheduled for user']
  workflows workflow [not null, note: 'Workflows created by user']
}

Table workspace {
  id Int [pk, increment, note: 'Primary identifier for workspace']
  created_at DateTime [default: `now()`, not null, note: 'Creation timestamp']
  updated_at DateTime [default: `now()`, not null, note: 'Last update timestamp']
  archived_at DateTime [note: 'Date when workspace was archived']
  name String [not null, note: 'Workspace name']
  slug String [unique, note: 'URL-friendly identifier']
  icon_url String [note: 'URL to workspace icon']
  background_colour String [note: 'Color for the workspace icon']
  linear_customer_id String [note: 'External Linear customer ID']
  stripe_customer_id String [unique, note: 'Stripe payment customer ID']
  hubspot_company_id String [note: 'External Hubspot company ID']
  company_size String [note: 'Size category of company']
  industry String [note: 'Company\'s industry sector']
  subscription_id Int [unique, note: 'Reference to subscription plan']
  subscription subscription [note: 'Subscription details']
  billing_infos workspace_billing_infos [note: 'Billing information']
  billings billing [not null, note: 'Billing history']
  folders folder [not null, note: 'Workspace folders']
  active_users user [not null, note: 'Users with this as active workspace']
  user_workspaces user_workspace [not null, note: 'User membership records']
  workflows workflow [not null, note: 'Workflows in workspace']
}

Table workspace_billing_infos {
  id Int [pk, increment, note: 'Primary identifier']
  created_at DateTime [default: `now()`, not null, note: 'Creation timestamp']
  updated_at DateTime [default: `now()`, not null, note: 'Last update timestamp']
  billing_email String [not null, note: 'Email for invoices']
  billing_address String [not null, note: 'Billing physical address']
  tax_rate Decimal [not null, note: 'Applied tax percentage']
  vat_number String [note: 'VAT/tax identification number']
  workspace_id Int [unique, not null, note: 'Associated workspace']
  workspace workspace [not null, note: 'Workspace relationship']
}

Table subscription {
  id Int [pk, increment, note: 'Primary identifier']
  created_at DateTime [default: `now()`, not null, note: 'Creation timestamp']
  updated_at DateTime [default: `now()`, not null, note: 'Last update timestamp']
  canceled_at DateTime [note: 'When subscription was canceled']
  workspace_id Int [unique, not null, note: 'Associated workspace']
  stripe_subscription_id String [unique, not null, note: 'Stripe subscription reference']
  trial_end_date DateTime [note: 'When free trial expires']
  plan_type plan_type [not null, note: 'Subscription plan level']
  quantity_seats Int [not null, note: 'Number of licensed users']
  current_period_start DateTime [not null, note: 'Current billing cycle start']
  current_period_end DateTime [not null, note: 'Current billing cycle end']
  status subscription_status [not null, note: 'Subscription status']
  workspace workspace [note: 'Workspace relationship']
  billings billing [not null, note: 'Associated billing records']
}

Table billing {
  id Int [pk, increment, note: 'Primary identifier']
  created_at DateTime [default: `now()`, not null, note: 'Creation timestamp']
  updated_at DateTime [default: `now()`, not null, note: 'Last update timestamp']
  paid_at DateTime [note: 'When payment was received']
  subscription_id Int [not null, note: 'Associated subscription']
  stripe_invoice_id String [unique, not null, note: 'Stripe invoice reference']
  amount_net Int [not null, note: 'Net amount in cents']
  tax_amount Int [not null, note: 'Tax portion in cents']
  amount_gross Int [not null, note: 'Total including tax in cents']
  currency String [not null, note: 'Currency code (USD, EUR, etc.)']
  invoice_date DateTime [not null, note: 'Date invoice was issued']
  due_date DateTime [not null, note: 'Payment deadline']
  workspace_id Int [not null, note: 'Associated workspace']
  subscription subscription [not null, note: 'Subscription relationship']
  workspace workspace [not null, note: 'Workspace relationship']
}

Table user_workspace {
  id Int [pk, increment, note: 'Primary identifier']
  user_id Int [not null, note: 'User reference']
  workspace_id Int [not null, note: 'Workspace reference']
  role user_role [not null, default: 'ADMIN', note: 'User\'s permission level']
  user user [not null, note: 'User relationship']
  workspace workspace [not null, note: 'Workspace relationship']
}

Table folder {
  id Int [pk, increment, note: 'Primary identifier']
  name String [not null, note: 'Folder name']
  workspace_id Int [not null, note: 'Parent workspace']
  parent_id Int [note: 'Parent folder (null for root)']
  icon_url String [note: 'URL to folder icon']
  emote String [note: 'Emoji identifier']
  path String [note: 'Full path from root']
  position Int [not null, default: 0, note: 'Display order position']
  parent folder [note: 'Parent folder relationship']
  subfolders folder [not null, note: 'Child folders']
  workspace workspace [not null, note: 'Workspace relationship']
  workflows workflow [not null, note: 'Contained workflows']
}

Table workflow {
  id Int [pk, increment, note: 'Primary identifier']
  created_at DateTime [default: `now()`, not null, note: 'Creation date']
  updated_at DateTime [default: `now()`, not null, note: 'Last update date']
  last_opened DateTime [note: 'Last access date']
  name String [not null, note: 'Workflow name']
  icon String [note: 'Workflow icon']
  description String [not null, note: 'Workflow description']
  workspace_id Int [not null, note: 'Parent workspace']
  folder_id Int [note: 'Parent folder']
  is_public Boolean [not null, default: true, note: 'Visibility within workspace']
  public_access_id String [unique, note: 'External sharing ID']
  status workflow_status [not null, default: 'DRAFT', note: 'Current status']
  blocks block [not null, note: 'Workflow blocks']
  paths path [not null, note: 'Workflow paths']
  stroke_lines stroke_line [not null, note: 'Connecting lines']
  folder folder [note: 'Parent folder relationship']
  workspace workspace [not null, note: 'Workspace relationship']
  author user [note: 'Creator user']
  author_id Int [note: 'Creator user ID']

  indexes {
    (name, workspace_id) [unique, note: 'Prevent duplicate names in workspace']
  }
}

Table path {
  id Int [pk, increment, note: 'Primary identifier']
  name String [not null, note: 'Path name']
  workflow_id Int [not null, note: 'Parent workflow']
  blocks block [not null, note: 'Blocks in path']
  workflow workflow [not null, note: 'Workflow relationship']
  parent_blocks path_parent_block [not null, note: 'Blocks that can trigger this path']

  Note: 'Collection of connected blocks forming a workflow path'
}

Table path_parent_block {
  path_id Int [not null, note: 'Path reference']
  block_id Int [not null, note: 'Block reference']
  created_at DateTime [default: `now()`, not null, note: 'Creation timestamp']
  block block [not null, note: 'Block relationship']
  path path [not null, note: 'Path relationship']

  indexes {
    (path_id, block_id) [pk, note: 'Composite primary key']
  }

  Note: 'Junction table that allows paths to be triggered from multiple parent blocks'
}

Table block {
  id Int [pk, increment, note: 'Primary identifier']
  created_at DateTime [default: `now()`, not null, note: 'Creation timestamp']
  updated_at DateTime [default: `now()`, not null, note: 'Last update timestamp']
  type block_type [not null, note: 'Block type']
  position Int [not null, note: 'Display order in path']
  title String [note: 'Block title']
  icon String [note: 'Block icon']
  description String [note: 'Block description']
  image String [note: 'Block image URL']
  original_image String [note: 'Original unprocessed image']
  image_description String [note: 'Image alt text']
  average_time String [note: 'Estimated completion time']
  task_type task_type [note: 'Manual or automatic task']
  workflow_id Int [not null, note: 'Parent workflow']
  path_id Int [not null, note: 'Parent path']
  is_endpoint Boolean [default: false, note: 'Marks this block as an endpoint in the path']
  delay_seconds Int [note: 'Wait time for delay blocks']
  delay_event String [note: 'Event to wait for in delay blocks']
  delay_type delay_type [note: 'Fixed or event-based delay']
  path path [not null, note: 'Path relationship']
  workflow workflow [not null, note: 'Workflow relationship']
  child_paths path_parent_block [not null, note: 'Child paths triggered by this block']
  source_stroke_lines stroke_line [not null, note: 'Lines starting from this block']
  target_stroke_lines stroke_line [not null, note: 'Lines ending at this block']
}

Table stroke_line {
  id Int [pk, increment, note: 'Primary identifier']
  source_block_id Int [not null, note: 'Starting block']
  target_block_id Int [not null, note: 'Ending block']
  workflow_id Int [not null, note: 'Parent workflow']
  label String [not null, note: 'Line label text']
  created_at DateTime [default: `now()`, not null, note: 'Creation timestamp']
  updated_at DateTime [default: `now()`, not null, note: 'Last update timestamp']
  control_points Json [note: 'Curve control points']
  source_block block [not null, note: 'Source block relationship']
  target_block block [not null, note: 'Target block relationship']
  workflow workflow [not null, note: 'Workflow relationship']
}

Table scheduled_emails {
  id Int [pk, increment, note: 'Primary identifier']
  created_at DateTime [default: `now()`, not null, note: 'Creation timestamp']
  updated_at DateTime [default: `now()`, not null, note: 'Last update timestamp']
  user_id Int [not null, note: 'Recipient user']
  email_type String [not null, note: 'Email template type']
  scheduled_for DateTime [not null, note: 'Planned sending time']
  status email_status [not null, default: 'PENDING', note: 'Current status']
  sent Boolean [not null, default: false, note: 'Whether email was sent']
  sent_at DateTime [note: 'When email was sent']
  metadata Json [note: 'Additional email data']
  error String [note: 'Error message if sending failed']
  retry_count Int [not null, default: 0, note: 'Number of send attempts']
  user user [not null, note: 'User relationship']

  indexes {
    (user_id, email_type) [unique, note: 'Only one pending email of each type per user']
  }
}

Enum onboarding_step {
  PERSONAL_INFO [note: 'Basic user information collection']
  PROFESSIONAL_INFO [note: 'Work-related information collection']
  WORKSPACE_SETUP [note: 'Workspace configuration']
  COMPLETED [note: 'Onboarding fully completed']
  INVITED_USER [note: 'User joined via invitation']
}

Enum user_role {
  ADMIN [note: 'Full workspace access and management']
  EDITOR [note: 'Can create and edit workflows']
  READER [note: 'View-only access']
}

Enum block_type {
  DELAY [note: 'Waiting period']
  STEP [note: 'Task or action']
  PATH [note: 'Branching point']
  BEGIN [note: 'Workflow start']
  END [note: 'Workflow end']
  LAST [note: 'Final path step']
  MERGE [note: 'Path join point']
}

Enum subscription_status {
  ACTIVE [note: 'Paid and current']
  TRIALING [note: 'In trial period']
  CANCELED [note: 'Subscription ended']
}

Enum plan_type {
  FREE [note: 'Basic free tier']
  EARLY_ADOPTER [note: 'Early access pricing tier']
}

Enum task_type {
  MANUAL [note: 'Requires human action']
  AUTOMATIC [note: 'System-automated']
}

Enum delay_type {
  FIXED_DURATION [note: 'Wait for specific time']
  WAIT_FOR_EVENT [note: 'Wait for trigger event']
}

Enum workflow_status {
  DRAFT [note: 'In development']
  ACTIVE [note: 'In use']
  IN_REVIEW [note: 'Pending approval']
  NEEDS_UPDATE [note: 'Requires changes']
  ARCHIVED [note: 'No longer used']
}

Enum email_status {
  PENDING [note: 'Awaiting sending']
  CANCELLED [note: 'Manually cancelled']
  PAUSED [note: 'Temporarily on hold']
  SENT [note: 'Successfully delivered']
  FAILED [note: 'Delivery failed']
}

Ref: user.active_workspace_id > workspace.id

Ref: workspace.subscription_id - subscription.id

Ref: workspace_billing_infos.workspace_id - workspace.id

Ref: billing.subscription_id > subscription.id

Ref: billing.workspace_id > workspace.id

Ref: user_workspace.user_id > user.id

Ref: user_workspace.workspace_id > workspace.id

Ref: folder.parent_id - folder.id

Ref: folder.workspace_id > workspace.id

Ref: workflow.folder_id > folder.id

Ref: workflow.workspace_id > workspace.id

Ref: workflow.author_id > user.id

Ref: path.workflow_id > workflow.id

Ref: path_parent_block.block_id > block.id [delete: Cascade]

Ref: path_parent_block.path_id > path.id [delete: Cascade]

Ref: block.path_id > path.id [delete: Cascade]

Ref: block.workflow_id > workflow.id [delete: Cascade]

Ref: stroke_line.source_block_id > block.id [delete: Cascade]

Ref: stroke_line.target_block_id > block.id [delete: Cascade]

Ref: stroke_line.workflow_id > workflow.id [delete: Cascade]

Ref: scheduled_emails.user_id > user.id [delete: Cascade]
</file>

<file path="prisma/migrations/20250308185509_initial_schema/migration.sql">
-- CreateEnum
CREATE TYPE "onboarding_step" AS ENUM ('PERSONAL_INFO', 'PROFESSIONAL_INFO', 'WORKSPACE_SETUP', 'COMPLETED', 'INVITED_USER');

-- CreateEnum
CREATE TYPE "user_role" AS ENUM ('ADMIN', 'EDITOR', 'READER');

-- CreateEnum
CREATE TYPE "block_type" AS ENUM ('DELAY', 'STEP', 'PATH', 'BEGIN', 'END', 'LAST');

-- CreateEnum
CREATE TYPE "subscription_status" AS ENUM ('ACTIVE', 'TRIALING', 'CANCELED');

-- CreateEnum
CREATE TYPE "plan_type" AS ENUM ('FREE', 'EARLY_ADOPTER');

-- CreateEnum
CREATE TYPE "task_type" AS ENUM ('MANUAL', 'AUTOMATIC');

-- CreateEnum
CREATE TYPE "delay_type" AS ENUM ('FIXED_DURATION', 'WAIT_FOR_EVENT');

-- CreateEnum
CREATE TYPE "workflow_status" AS ENUM ('DRAFT', 'PUBLISHED', 'ARCHIVED');

-- CreateTable
CREATE TABLE "user" (
    "id" SERIAL NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "archived_at" TIMESTAMP(3),
    "auth_id" TEXT NOT NULL,
    "first_name" TEXT NOT NULL,
    "last_name" TEXT NOT NULL,
    "full_name" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "avatar_url" TEXT,
    "active_workspace_id" INTEGER,
    "hubspot_contact_id" TEXT,
    "sentry_id" TEXT,
    "post_hog_id" TEXT,
    "phone" TEXT,
    "last_login_at" TIMESTAMP(3),
    "onboarding_completed_at" TIMESTAMP(3),
    "onboarding_step" "onboarding_step" DEFAULT 'PERSONAL_INFO',
    "professional_role" TEXT,
    "source" TEXT,
    "temp_company_size" TEXT,
    "temp_industry" TEXT,
    "tutorial_completed" BOOLEAN NOT NULL DEFAULT false,

    CONSTRAINT "user_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "workspace" (
    "id" SERIAL NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "archived_at" TIMESTAMP(3),
    "name" TEXT NOT NULL,
    "slug" TEXT,
    "team_tags" TEXT[],
    "icon_url" TEXT,
    "background_colour" TEXT,
    "linear_customer_id" TEXT,
    "stripe_customer_id" TEXT,
    "hubspot_company_id" TEXT,
    "subscription_id" INTEGER,
    "company_size" TEXT,
    "industry" TEXT,

    CONSTRAINT "workspace_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "workspace_billing_infos" (
    "id" SERIAL NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "billing_email" TEXT NOT NULL,
    "billing_address" TEXT NOT NULL,
    "tax_rate" DECIMAL(5,2) NOT NULL,
    "vat_number" TEXT,
    "workspace_id" INTEGER NOT NULL,

    CONSTRAINT "workspace_billing_infos_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "subscription" (
    "id" SERIAL NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "canceled_at" TIMESTAMP(3),
    "workspace_id" INTEGER NOT NULL,
    "stripe_subscription_id" TEXT NOT NULL,
    "trial_end_date" TIMESTAMP(3),
    "plan_type" "plan_type" NOT NULL,
    "quantity_seats" INTEGER NOT NULL,
    "current_period_start" TIMESTAMP(3) NOT NULL,
    "current_period_end" TIMESTAMP(3) NOT NULL,
    "status" "subscription_status" NOT NULL,

    CONSTRAINT "subscription_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "billing" (
    "id" SERIAL NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "paid_at" TIMESTAMP(3),
    "subscription_id" INTEGER NOT NULL,
    "stripe_invoice_id" TEXT NOT NULL,
    "amount_net" INTEGER NOT NULL,
    "tax_amount" INTEGER NOT NULL,
    "amount_gross" INTEGER NOT NULL,
    "currency" VARCHAR(3) NOT NULL,
    "invoice_date" TIMESTAMP(3) NOT NULL,
    "due_date" TIMESTAMP(3) NOT NULL,
    "workspace_id" INTEGER NOT NULL,

    CONSTRAINT "billing_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "user_workspace" (
    "id" SERIAL NOT NULL,
    "user_id" INTEGER NOT NULL,
    "workspace_id" INTEGER NOT NULL,
    "role" "user_role" NOT NULL DEFAULT 'ADMIN',

    CONSTRAINT "user_workspace_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "invitation" (
    "id" SERIAL NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "email" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "expires_at" TIMESTAMP(3) NOT NULL,
    "used" BOOLEAN NOT NULL DEFAULT false,
    "used_at" TIMESTAMP(3),
    "workspace_id" INTEGER NOT NULL,
    "role" "user_role" NOT NULL DEFAULT 'READER',

    CONSTRAINT "invitation_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "folder" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,
    "workspace_id" INTEGER NOT NULL,
    "parent_id" INTEGER,
    "icon_url" TEXT,
    "emote" TEXT,
    "team_tags" TEXT[],
    "path" TEXT,

    CONSTRAINT "folder_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "workflow" (
    "id" SERIAL NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "last_opened" TIMESTAMP(3),
    "name" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "workspace_id" INTEGER NOT NULL,
    "team_tags" TEXT[],
    "folder_id" INTEGER,
    "is_public" BOOLEAN NOT NULL DEFAULT false,
    "public_access_id" TEXT,
    "is_template" BOOLEAN NOT NULL DEFAULT false,
    "status" "workflow_status" NOT NULL DEFAULT 'DRAFT',
    "template_id" INTEGER,
    "version_number" INTEGER NOT NULL DEFAULT 1,

    CONSTRAINT "workflow_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "path" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,
    "workflow_id" INTEGER NOT NULL,

    CONSTRAINT "path_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "path_parent_block" (
    "path_id" INTEGER NOT NULL,
    "block_id" INTEGER NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "path_parent_block_pkey" PRIMARY KEY ("path_id","block_id")
);

-- CreateTable
CREATE TABLE "block" (
    "id" SERIAL NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "last_modified" TIMESTAMP(3),
    "type" "block_type" NOT NULL,
    "position" INTEGER NOT NULL,
    "title" TEXT,
    "icon" TEXT,
    "description" TEXT,
    "image" TEXT,
    "image_description" TEXT,
    "average_time" TEXT,
    "task_type" "task_type",
    "workflow_id" INTEGER NOT NULL,
    "path_id" INTEGER NOT NULL,
    "click_position" JSONB,
    "delay_seconds" INTEGER,
    "step_details" TEXT,
    "delay_event" TEXT,
    "delay_type" "delay_type",

    CONSTRAINT "block_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "action" (
    "id" SERIAL NOT NULL,
    "user_id" INTEGER NOT NULL,
    "type" TEXT NOT NULL,
    "target_id" INTEGER NOT NULL,
    "workflow_id" INTEGER NOT NULL,
    "value" INTEGER NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "action_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "workflow_version" (
    "id" SERIAL NOT NULL,
    "workflow_id" INTEGER NOT NULL,
    "version_number" INTEGER NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "created_by_id" INTEGER NOT NULL,
    "change_summary" TEXT,
    "snapshot" JSONB NOT NULL,

    CONSTRAINT "workflow_version_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "workflow_template" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "workspace_id" INTEGER NOT NULL,
    "category" TEXT NOT NULL,
    "tags" TEXT[],
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "structure" JSONB NOT NULL,
    "rating" DOUBLE PRECISION,
    "rating_count" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "workflow_template_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "saved_search" (
    "id" SERIAL NOT NULL,
    "user_id" INTEGER NOT NULL,
    "name" TEXT NOT NULL,
    "query" TEXT NOT NULL,
    "filters" JSONB,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "saved_search_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "stroke_line" (
    "id" SERIAL NOT NULL,
    "source_block_id" INTEGER NOT NULL,
    "target_block_id" INTEGER NOT NULL,
    "workflow_id" INTEGER NOT NULL,
    "label" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "is_loop" BOOLEAN NOT NULL DEFAULT false,

    CONSTRAINT "stroke_line_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "user_auth_id_key" ON "user"("auth_id");

-- CreateIndex
CREATE UNIQUE INDEX "user_email_key" ON "user"("email");

-- CreateIndex
CREATE INDEX "user_active_workspace_id_idx" ON "user"("active_workspace_id");

-- CreateIndex
CREATE INDEX "user_email_idx" ON "user"("email");

-- CreateIndex
CREATE INDEX "user_auth_id_idx" ON "user"("auth_id");

-- CreateIndex
CREATE INDEX "auth_id_cover_idx" ON "user"("auth_id");

-- CreateIndex
CREATE UNIQUE INDEX "workspace_slug_key" ON "workspace"("slug");

-- CreateIndex
CREATE UNIQUE INDEX "workspace_subscription_id_key" ON "workspace"("subscription_id");

-- CreateIndex
CREATE INDEX "workspace_stripe_customer_id_idx" ON "workspace"("stripe_customer_id");

-- CreateIndex
CREATE INDEX "workspace_subscription_id_idx" ON "workspace"("subscription_id");

-- CreateIndex
CREATE INDEX "workspace_billing_infos_workspace_id_idx" ON "workspace_billing_infos"("workspace_id");

-- CreateIndex
CREATE UNIQUE INDEX "subscription_workspace_id_key" ON "subscription"("workspace_id");

-- CreateIndex
CREATE UNIQUE INDEX "billing_stripe_invoice_id_key" ON "billing"("stripe_invoice_id");

-- CreateIndex
CREATE INDEX "billing_subscription_id_idx" ON "billing"("subscription_id");

-- CreateIndex
CREATE INDEX "billing_workspace_id_idx" ON "billing"("workspace_id");

-- CreateIndex
CREATE INDEX "billing_stripe_invoice_id_idx" ON "billing"("stripe_invoice_id");

-- CreateIndex
CREATE INDEX "user_workspace_composite_idx" ON "user_workspace"("user_id", "workspace_id");

-- CreateIndex
CREATE INDEX "user_workspace_user_id_idx" ON "user_workspace"("user_id");

-- CreateIndex
CREATE INDEX "user_workspace_workspace_id_idx" ON "user_workspace"("workspace_id");

-- CreateIndex
CREATE UNIQUE INDEX "invitation_token_key" ON "invitation"("token");

-- CreateIndex
CREATE INDEX "invitation_workspace_id_idx" ON "invitation"("workspace_id");

-- CreateIndex
CREATE INDEX "invitation_token_idx" ON "invitation"("token");

-- CreateIndex
CREATE INDEX "invitation_email_idx" ON "invitation"("email");

-- CreateIndex
CREATE INDEX "folder_workspace_id_idx" ON "folder"("workspace_id");

-- CreateIndex
CREATE INDEX "folder_parent_id_idx" ON "folder"("parent_id");

-- CreateIndex
CREATE INDEX "folder_path_idx" ON "folder"("path");

-- CreateIndex
CREATE UNIQUE INDEX "workflow_public_access_id_key" ON "workflow"("public_access_id");

-- CreateIndex
CREATE INDEX "workflow_workspace_id_idx" ON "workflow"("workspace_id");

-- CreateIndex
CREATE INDEX "workflow_folder_id_idx" ON "workflow"("folder_id");

-- CreateIndex
CREATE UNIQUE INDEX "workflow_name_workspace_id_key" ON "workflow"("name", "workspace_id");

-- CreateIndex
CREATE INDEX "path_workflow_id_idx" ON "path"("workflow_id");

-- CreateIndex
CREATE INDEX "path_parent_block_path_id_idx" ON "path_parent_block"("path_id");

-- CreateIndex
CREATE INDEX "path_parent_block_block_id_idx" ON "path_parent_block"("block_id");

-- CreateIndex
CREATE INDEX "block_workflow_id_idx" ON "block"("workflow_id");

-- CreateIndex
CREATE INDEX "block_path_id_idx" ON "block"("path_id");

-- CreateIndex
CREATE INDEX "block_type_idx" ON "block"("type");

-- CreateIndex
CREATE INDEX "action_user_id_idx" ON "action"("user_id");

-- CreateIndex
CREATE INDEX "action_target_id_idx" ON "action"("target_id");

-- CreateIndex
CREATE INDEX "action_workflow_id_idx" ON "action"("workflow_id");

-- CreateIndex
CREATE INDEX "action_created_at_idx" ON "action"("created_at");

-- CreateIndex
CREATE INDEX "workflow_version_workflow_id_idx" ON "workflow_version"("workflow_id");

-- CreateIndex
CREATE INDEX "workflow_version_created_by_id_idx" ON "workflow_version"("created_by_id");

-- CreateIndex
CREATE UNIQUE INDEX "workflow_version_workflow_id_version_number_key" ON "workflow_version"("workflow_id", "version_number");

-- CreateIndex
CREATE INDEX "workflow_template_workspace_id_idx" ON "workflow_template"("workspace_id");

-- CreateIndex
CREATE INDEX "workflow_template_category_idx" ON "workflow_template"("category");

-- CreateIndex
CREATE INDEX "saved_search_user_id_idx" ON "saved_search"("user_id");

-- CreateIndex
CREATE INDEX "stroke_line_source_block_id_idx" ON "stroke_line"("source_block_id");

-- CreateIndex
CREATE INDEX "stroke_line_target_block_id_idx" ON "stroke_line"("target_block_id");

-- CreateIndex
CREATE INDEX "stroke_line_workflow_id_idx" ON "stroke_line"("workflow_id");

-- AddForeignKey
ALTER TABLE "user" ADD CONSTRAINT "user_active_workspace_id_fkey" FOREIGN KEY ("active_workspace_id") REFERENCES "workspace"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "workspace" ADD CONSTRAINT "workspace_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "subscription"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "workspace_billing_infos" ADD CONSTRAINT "workspace_billing_infos_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "billing" ADD CONSTRAINT "billing_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "subscription"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "billing" ADD CONSTRAINT "billing_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "user_workspace" ADD CONSTRAINT "user_workspace_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "user"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "user_workspace" ADD CONSTRAINT "user_workspace_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invitation" ADD CONSTRAINT "invitation_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "folder" ADD CONSTRAINT "folder_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "folder"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "folder" ADD CONSTRAINT "folder_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "workflow" ADD CONSTRAINT "workflow_folder_id_fkey" FOREIGN KEY ("folder_id") REFERENCES "folder"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "workflow" ADD CONSTRAINT "workflow_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "workflow_template"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "workflow" ADD CONSTRAINT "workflow_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "path" ADD CONSTRAINT "path_workflow_id_fkey" FOREIGN KEY ("workflow_id") REFERENCES "workflow"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "path_parent_block" ADD CONSTRAINT "path_parent_block_block_id_fkey" FOREIGN KEY ("block_id") REFERENCES "block"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "path_parent_block" ADD CONSTRAINT "path_parent_block_path_id_fkey" FOREIGN KEY ("path_id") REFERENCES "path"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "block" ADD CONSTRAINT "block_path_id_fkey" FOREIGN KEY ("path_id") REFERENCES "path"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "block" ADD CONSTRAINT "block_workflow_id_fkey" FOREIGN KEY ("workflow_id") REFERENCES "workflow"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "action" ADD CONSTRAINT "action_target_id_fkey" FOREIGN KEY ("target_id") REFERENCES "block"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "action" ADD CONSTRAINT "action_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "user"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "action" ADD CONSTRAINT "action_workflow_id_fkey" FOREIGN KEY ("workflow_id") REFERENCES "workflow"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "workflow_version" ADD CONSTRAINT "workflow_version_created_by_id_fkey" FOREIGN KEY ("created_by_id") REFERENCES "user"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "workflow_version" ADD CONSTRAINT "workflow_version_workflow_id_fkey" FOREIGN KEY ("workflow_id") REFERENCES "workflow"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "workflow_template" ADD CONSTRAINT "workflow_template_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "saved_search" ADD CONSTRAINT "saved_search_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "user"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "stroke_line" ADD CONSTRAINT "stroke_line_source_block_id_fkey" FOREIGN KEY ("source_block_id") REFERENCES "block"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "stroke_line" ADD CONSTRAINT "stroke_line_target_block_id_fkey" FOREIGN KEY ("target_block_id") REFERENCES "block"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "stroke_line" ADD CONSTRAINT "stroke_line_workflow_id_fkey" FOREIGN KEY ("workflow_id") REFERENCES "workflow"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250309084538_add_block_type_merge/migration.sql">
-- AlterEnum
ALTER TYPE "block_type" ADD VALUE 'MERGE';
</file>

<file path="prisma/migrations/20250309090235_update_subscription_schema/migration.sql">
/*
  Warnings:

  - A unique constraint covering the columns `[stripe_subscription_id]` on the table `subscription` will be added. If there are existing duplicate values, this will fail.
  - A unique constraint covering the columns `[stripe_customer_id]` on the table `workspace` will be added. If there are existing duplicate values, this will fail.
  - A unique constraint covering the columns `[workspace_id]` on the table `workspace_billing_infos` will be added. If there are existing duplicate values, this will fail.

*/
-- CreateIndex
CREATE UNIQUE INDEX "subscription_stripe_subscription_id_key" ON "subscription"("stripe_subscription_id");

-- CreateIndex
CREATE UNIQUE INDEX "workspace_stripe_customer_id_key" ON "workspace"("stripe_customer_id");

-- CreateIndex
CREATE UNIQUE INDEX "workspace_billing_infos_workspace_id_key" ON "workspace_billing_infos"("workspace_id");
</file>

<file path="prisma/migrations/20250316060737_add_scheduled_emails/migration.sql">
-- CreateEnum
CREATE TYPE "email_status" AS ENUM ('PENDING', 'CANCELLED', 'PAUSED', 'SENT', 'FAILED');

-- CreateTable
CREATE TABLE "scheduled_emails" (
    "id" SERIAL NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "user_id" INTEGER NOT NULL,
    "email_type" TEXT NOT NULL,
    "scheduled_for" TIMESTAMP(3) NOT NULL,
    "status" "email_status" NOT NULL DEFAULT 'PENDING',
    "sent" BOOLEAN NOT NULL DEFAULT false,
    "sent_at" TIMESTAMP(3),
    "metadata" JSONB,
    "error" TEXT,
    "retry_count" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "scheduled_emails_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "scheduled_emails_user_id_idx" ON "scheduled_emails"("user_id");

-- CreateIndex
CREATE INDEX "scheduled_emails_scheduled_for_idx" ON "scheduled_emails"("scheduled_for");

-- CreateIndex
CREATE INDEX "scheduled_emails_status_idx" ON "scheduled_emails"("status");

-- CreateIndex
CREATE INDEX "scheduled_emails_sent_idx" ON "scheduled_emails"("sent");

-- AddForeignKey
ALTER TABLE "scheduled_emails" ADD CONSTRAINT "scheduled_emails_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "user"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250316145246_add_unique_constraint_to_scheduled_emails/migration.sql">
/*
  Warnings:

  - A unique constraint covering the columns `[user_id,email_type]` on the table `scheduled_emails` will be added. If there are existing duplicate values, this will fail.

*/
-- CreateIndex
CREATE UNIQUE INDEX "unique_pending_email_per_user_type_where" ON "scheduled_emails"("user_id", "email_type");
</file>

<file path="prisma/migrations/20250318105808_add_position_to_folders/migration.sql">
-- DropIndex
DROP INDEX "unique_pending_email_per_user_type_where";

-- AlterTable
ALTER TABLE "folder" ADD COLUMN     "position" INTEGER NOT NULL DEFAULT 0;
</file>

<file path="prisma/migrations/20250318133431_add_constraint/migration.sql">
/*
  Warnings:

  - A unique constraint covering the columns `[user_id,email_type]` on the table `scheduled_emails` will be added. If there are existing duplicate values, this will fail.

*/
-- CreateIndex
CREATE UNIQUE INDEX "unique_pending_email_per_user_type_where" ON "scheduled_emails"("user_id", "email_type");
</file>

<file path="prisma/migrations/20250327081317_workflow_icon_and_author/migration.sql">
-- AlterTable
ALTER TABLE "workflow" ADD COLUMN     "author_id" INTEGER,
ADD COLUMN     "icon" TEXT;

-- AddForeignKey
ALTER TABLE "workflow" ADD CONSTRAINT "workflow_author_id_fkey" FOREIGN KEY ("author_id") REFERENCES "user"("id") ON DELETE SET NULL ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250327170230_add_control_points_to_stroke_lines/migration.sql">
-- AlterTable
ALTER TABLE "stroke_line" ADD COLUMN     "control_points" JSONB;
</file>

<file path="prisma/migrations/20250401060358_add_ai_support/migration.sql">
-- CreateTable
CREATE TABLE "ai_conversations" (
    "id" SERIAL NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "user_id" INTEGER NOT NULL,
    "workflow_id" INTEGER,
    "conversation_id" TEXT NOT NULL,
    "messages" JSONB NOT NULL,

    CONSTRAINT "ai_conversations_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ai_embeddings" (
    "id" SERIAL NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "content_type" TEXT NOT NULL,
    "content_id" TEXT NOT NULL,
    "content_text" TEXT NOT NULL,
    "embedding_id" TEXT NOT NULL,
    "workspace_id" INTEGER NOT NULL,

    CONSTRAINT "ai_embeddings_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "ai_conversations_conversation_id_key" ON "ai_conversations"("conversation_id");

-- CreateIndex
CREATE INDEX "ai_conversations_user_id_idx" ON "ai_conversations"("user_id");

-- CreateIndex
CREATE INDEX "ai_conversations_workflow_id_idx" ON "ai_conversations"("workflow_id");

-- CreateIndex
CREATE INDEX "ai_embeddings_workspace_id_idx" ON "ai_embeddings"("workspace_id");

-- CreateIndex
CREATE INDEX "ai_embeddings_content_type_content_id_idx" ON "ai_embeddings"("content_type", "content_id");

-- AddForeignKey
ALTER TABLE "ai_conversations" ADD CONSTRAINT "ai_conversations_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "user"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ai_conversations" ADD CONSTRAINT "ai_conversations_workflow_id_fkey" FOREIGN KEY ("workflow_id") REFERENCES "workflow"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ai_embeddings" ADD CONSTRAINT "ai_embeddings_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250403173342_workflow/migration.sql">
/*
  Warnings:

  - The values [PUBLISHED] on the enum `workflow_status` will be removed. If these variants are still used in the database, this will fail.

*/
-- AlterEnum
BEGIN;
CREATE TYPE "workflow_status_new" AS ENUM ('DRAFT', 'ACTIVE', 'IN_REVIEW', 'NEEDS_UPDATE', 'ARCHIVED');
ALTER TABLE "workflow" ALTER COLUMN "status" DROP DEFAULT;
ALTER TABLE "workflow" ALTER COLUMN "status" TYPE "workflow_status_new" USING ("status"::text::"workflow_status_new");
ALTER TYPE "workflow_status" RENAME TO "workflow_status_old";
ALTER TYPE "workflow_status_new" RENAME TO "workflow_status";
DROP TYPE "workflow_status_old";
ALTER TABLE "workflow" ALTER COLUMN "status" SET DEFAULT 'DRAFT';
COMMIT;
</file>

<file path="prisma/migrations/20250406153757_block_original_image/migration.sql">
-- AlterTable
ALTER TABLE "block" ADD COLUMN     "original_image" TEXT;
</file>

<file path="prisma/migrations/20250427124804_cascade_delete_user_workspace/migration.sql">
-- DropForeignKey
ALTER TABLE "user_workspace" DROP CONSTRAINT "user_workspace_user_id_fkey";

-- DropForeignKey
ALTER TABLE "user_workspace" DROP CONSTRAINT "user_workspace_workspace_id_fkey";

-- DropForeignKey
ALTER TABLE "workflow" DROP CONSTRAINT "workflow_workspace_id_fkey";

-- AlterTable
ALTER TABLE "workflow" ALTER COLUMN "is_public" SET DEFAULT true;

-- AddForeignKey
ALTER TABLE "user_workspace" ADD CONSTRAINT "user_workspace_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "user"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "user_workspace" ADD CONSTRAINT "user_workspace_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "workflow" ADD CONSTRAINT "workflow_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250427125006_ondelete_cascade_workflow_fields/migration.sql">
-- DropForeignKey
ALTER TABLE "action" DROP CONSTRAINT "action_workflow_id_fkey";

-- AddForeignKey
ALTER TABLE "action" ADD CONSTRAINT "action_workflow_id_fkey" FOREIGN KEY ("workflow_id") REFERENCES "workflow"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250427125203_removed_slug_unique_constraint/migration.sql">
-- DropIndex
DROP INDEX "workspace_slug_key";
</file>

<file path="prisma/migrations/20250427130205_rollback_slug_unique_constraint/migration.sql">
/*
  Warnings:

  - A unique constraint covering the columns `[slug]` on the table `workspace` will be added. If there are existing duplicate values, this will fail.

*/
-- CreateIndex
CREATE UNIQUE INDEX "workspace_slug_key" ON "workspace"("slug");
</file>

<file path="prisma/migrations/20250427130943_fixed_workspace_cascade_fields/migration.sql">
-- DropForeignKey
ALTER TABLE "ai_embeddings" DROP CONSTRAINT "ai_embeddings_workspace_id_fkey";

-- DropForeignKey
ALTER TABLE "billing" DROP CONSTRAINT "billing_workspace_id_fkey";

-- DropForeignKey
ALTER TABLE "folder" DROP CONSTRAINT "folder_workspace_id_fkey";

-- DropForeignKey
ALTER TABLE "invitation" DROP CONSTRAINT "invitation_workspace_id_fkey";

-- DropForeignKey
ALTER TABLE "workflow_template" DROP CONSTRAINT "workflow_template_workspace_id_fkey";

-- DropForeignKey
ALTER TABLE "workspace_billing_infos" DROP CONSTRAINT "workspace_billing_infos_workspace_id_fkey";

-- AddForeignKey
ALTER TABLE "workspace_billing_infos" ADD CONSTRAINT "workspace_billing_infos_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "billing" ADD CONSTRAINT "billing_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invitation" ADD CONSTRAINT "invitation_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "folder" ADD CONSTRAINT "folder_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "workflow_template" ADD CONSTRAINT "workflow_template_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ai_embeddings" ADD CONSTRAINT "ai_embeddings_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250507063023_removed_unused_tables/migration.sql">
/*
  Warnings:

  - You are about to drop the column `click_position` on the `block` table. All the data in the column will be lost.
  - You are about to drop the column `last_modified` on the `block` table. All the data in the column will be lost.
  - You are about to drop the column `step_details` on the `block` table. All the data in the column will be lost.
  - You are about to drop the column `phone` on the `user` table. All the data in the column will be lost.
  - You are about to drop the `action` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `ai_conversations` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `ai_embeddings` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `invitation` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `saved_search` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `workflow_template` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `workflow_version` table. If the table is not empty, all the data it contains will be lost.

*/
-- DropForeignKey
ALTER TABLE "action" DROP CONSTRAINT "action_target_id_fkey";

-- DropForeignKey
ALTER TABLE "action" DROP CONSTRAINT "action_user_id_fkey";

-- DropForeignKey
ALTER TABLE "action" DROP CONSTRAINT "action_workflow_id_fkey";

-- DropForeignKey
ALTER TABLE "ai_conversations" DROP CONSTRAINT "ai_conversations_user_id_fkey";

-- DropForeignKey
ALTER TABLE "ai_conversations" DROP CONSTRAINT "ai_conversations_workflow_id_fkey";

-- DropForeignKey
ALTER TABLE "ai_embeddings" DROP CONSTRAINT "ai_embeddings_workspace_id_fkey";

-- DropForeignKey
ALTER TABLE "invitation" DROP CONSTRAINT "invitation_workspace_id_fkey";

-- DropForeignKey
ALTER TABLE "saved_search" DROP CONSTRAINT "saved_search_user_id_fkey";

-- DropForeignKey
ALTER TABLE "workflow" DROP CONSTRAINT "workflow_template_id_fkey";

-- DropForeignKey
ALTER TABLE "workflow_template" DROP CONSTRAINT "workflow_template_workspace_id_fkey";

-- DropForeignKey
ALTER TABLE "workflow_version" DROP CONSTRAINT "workflow_version_created_by_id_fkey";

-- DropForeignKey
ALTER TABLE "workflow_version" DROP CONSTRAINT "workflow_version_workflow_id_fkey";

-- AlterTable
ALTER TABLE "block" DROP COLUMN "click_position",
DROP COLUMN "last_modified",
DROP COLUMN "step_details";

-- AlterTable
ALTER TABLE "user" DROP COLUMN "phone";

-- DropTable
DROP TABLE "action";

-- DropTable
DROP TABLE "ai_conversations";

-- DropTable
DROP TABLE "ai_embeddings";

-- DropTable
DROP TABLE "invitation";

-- DropTable
DROP TABLE "saved_search";

-- DropTable
DROP TABLE "workflow_template";

-- DropTable
DROP TABLE "workflow_version";
</file>

<file path="prisma/migrations/20250507071740_removed_unused_tables/migration.sql">
/*
  Warnings:

  - You are about to drop the column `team_tags` on the `folder` table. All the data in the column will be lost.
  - You are about to drop the column `is_loop` on the `stroke_line` table. All the data in the column will be lost.
  - You are about to drop the column `is_template` on the `workflow` table. All the data in the column will be lost.
  - You are about to drop the column `team_tags` on the `workflow` table. All the data in the column will be lost.
  - You are about to drop the column `template_id` on the `workflow` table. All the data in the column will be lost.
  - You are about to drop the column `version_number` on the `workflow` table. All the data in the column will be lost.
  - You are about to drop the column `team_tags` on the `workspace` table. All the data in the column will be lost.

*/
-- AlterTable
ALTER TABLE "folder" DROP COLUMN "team_tags";

-- AlterTable
ALTER TABLE "stroke_line" DROP COLUMN "is_loop";

-- AlterTable
ALTER TABLE "workflow" DROP COLUMN "is_template",
DROP COLUMN "team_tags",
DROP COLUMN "template_id",
DROP COLUMN "version_number";

-- AlterTable
ALTER TABLE "workspace" DROP COLUMN "team_tags";
</file>

<file path="prisma/migrations/20250510081938_add_row_isendpoint_for_block_table/migration.sql">
-- AlterTable
ALTER TABLE "block" ADD COLUMN     "is_endpoint" BOOLEAN DEFAULT false;
</file>

<file path="prisma/migrations/20250527092212_modify_workflow_table/migration.sql">
-- AlterTable
ALTER TABLE "workflow" ADD COLUMN     "notes" TEXT,
ADD COLUMN     "owner" TEXT,
ADD COLUMN     "review_date" TIMESTAMP(3);
</file>

<file path="prisma/migrations/20250527101122_modify_workflow_table/migration.sql">
/*
  Warnings:

  - You are about to drop the column `notes` on the `workflow` table. All the data in the column will be lost.
  - You are about to drop the column `owner` on the `workflow` table. All the data in the column will be lost.

*/
-- AlterTable
ALTER TABLE "workflow" DROP COLUMN "notes",
DROP COLUMN "owner",
ADD COLUMN     "additional_notes" TEXT,
ADD COLUMN     "process_owner" TEXT;
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
</file>

<file path="public/assets/icons/check-circle.svg">
<svg width="37" height="37" viewBox="0 0 37 37" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10.9327 18.4992L15.978 23.5445L26.0686 13.4539M35.3182 18.4992C35.3182 27.7873 27.7888 35.3168 18.5007 35.3168C9.21256 35.3168 1.68307 27.7873 1.68307 18.4992C1.68307 9.21108 9.21256 1.68159 18.5007 1.68159C27.7888 1.68159 35.3182 9.21108 35.3182 18.4992Z" stroke="#17B26A" stroke-width="1.66667" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</file>

<file path="public/assets/icons/dots-horizontal.svg">
<svg width="21" height="21" viewBox="0 0 21 21" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10.4982 11.3742C10.9814 11.3742 11.3731 10.9825 11.3731 10.4993C11.3731 10.0161 10.9814 9.62434 10.4982 9.62434C10.0149 9.62434 9.62323 10.0161 9.62323 10.4993C9.62323 10.9825 10.0149 11.3742 10.4982 11.3742Z" stroke="white" stroke-width="1.71537" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M16.6227 11.3742C17.1059 11.3742 17.4977 10.9825 17.4977 10.4993C17.4977 10.0161 17.1059 9.62434 16.6227 9.62434C16.1395 9.62434 15.7478 10.0161 15.7478 10.4993C15.7478 10.9825 16.1395 11.3742 16.6227 11.3742Z" stroke="white" stroke-width="1.71537" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M4.37361 11.3742C4.85682 11.3742 5.24854 10.9825 5.24854 10.4993C5.24854 10.0161 4.85682 9.62434 4.37361 9.62434C3.89039 9.62434 3.49867 10.0161 3.49867 10.4993C3.49867 10.9825 3.89039 11.3742 4.37361 11.3742Z" stroke="white" stroke-width="1.71537" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</file>

<file path="public/assets/icons/process-step-icon.svg">
<svg width="21" height="21" viewBox="0 0 21 21" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8.74883 6.99954V6.1246M8.74883 10.9368V10.0618M8.74883 14.874V13.999M4.54913 3.49979H16.4483C17.4283 3.49979 17.9183 3.49979 18.2926 3.69052C18.6219 3.85828 18.8896 4.12598 19.0573 4.45524C19.2481 4.82956 19.2481 5.31957 19.2481 6.29959V7.43701C17.5568 7.43701 16.1858 8.80803 16.1858 10.4993C16.1858 12.1905 17.5568 13.5616 19.2481 13.5616V14.699C19.2481 15.679 19.2481 16.169 19.0573 16.5433C18.8896 16.8726 18.6219 17.1403 18.2926 17.3081C17.9183 17.4988 17.4283 17.4988 16.4483 17.4988H4.54913C3.56911 17.4988 3.0791 17.4988 2.70478 17.3081C2.37552 17.1403 2.10783 16.8726 1.94006 16.5433C1.74934 16.169 1.74934 15.679 1.74934 14.699V13.5616C3.44059 13.5616 4.81161 12.1905 4.81161 10.4993C4.81161 8.80803 3.44059 7.43701 1.74934 7.43701V6.29959C1.74934 5.31957 1.74934 4.82956 1.94006 4.45524C2.10783 4.12598 2.37552 3.85828 2.70478 3.69052C3.0791 3.49979 3.56911 3.49979 4.54913 3.49979Z" stroke="#4761C4" stroke-width="1.71537" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</file>

<file path="public/assets/icons/x-close.svg">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M22.2846 1.71393L1.71543 22.2831M1.71543 1.71393L22.2846 22.2831" stroke="#85888E" stroke-width="1.66667" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</file>

<file path="public/assets/x-close.svg">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M22.2856 1.71436L1.71436 22.2856M1.71436 1.71436L22.2856 22.2856" stroke="#98A2B3" stroke-width="1.66667" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</file>

<file path="public/ai-thinking-orb.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <radialGradient id="orbGradient" cx="50%" cy="50%" r="50%" fx="25%" fy="25%">
      <stop offset="0%" stop-color="#4a8cff" />
      <stop offset="85%" stop-color="#0037da" />
      <stop offset="100%" stop-color="#0028d9" />
    </radialGradient>
    
    <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="3" result="blur" />
      <feComposite in="SourceGraphic" in2="blur" operator="over" />
    </filter>
    
    <filter id="innerGlow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="2" result="blur" />
      <feComposite in="SourceGraphic" in2="blur" operator="over" />
    </filter>
  </defs>
  
  <!-- Main orb -->
  <circle cx="50" cy="50" r="40" fill="url(#orbGradient)" filter="url(#glow)">
    <animate attributeName="opacity" values="0.9;1;0.9" dur="3s" repeatCount="indefinite" />
  </circle>
  
  <!-- Inner glow that pulses -->
  <circle id="innerGlow" cx="50" cy="50" r="30" fill="rgba(100, 180, 255, 0.4)" filter="url(#innerGlow)">
    <animate attributeName="r" values="28;32;28" dur="2s" repeatCount="indefinite" />
    <animate attributeName="opacity" values="0.6;0.9;0.6" dur="2s" repeatCount="indefinite" />
  </circle>
  
  <!-- Highlight -->
  <ellipse cx="35" cy="35" rx="15" ry="15" fill="rgba(255, 255, 255, 0.2)" />
  
  <!-- Particles -->
  <g id="particles">
    <circle cx="60" cy="25" r="1.5" fill="rgba(255, 255, 255, 0.8)">
      <animate attributeName="opacity" values="0.5;1;0.5" dur="3s" repeatCount="indefinite" />
    </circle>
    <circle cx="75" cy="45" r="1" fill="rgba(255, 255, 255, 0.6)">
      <animate attributeName="opacity" values="0.3;0.8;0.3" dur="2.5s" repeatCount="indefinite" />
    </circle>
    <circle cx="65" cy="70" r="1.2" fill="rgba(255, 255, 255, 0.7)">
      <animate attributeName="opacity" values="0.4;0.9;0.4" dur="2.7s" repeatCount="indefinite" />
    </circle>
    <circle cx="35" cy="75" r="0.8" fill="rgba(255, 255, 255, 0.5)">
      <animate attributeName="opacity" values="0.2;0.7;0.2" dur="3.2s" repeatCount="indefinite" />
    </circle>
    <circle cx="25" cy="45" r="1" fill="rgba(255, 255, 255, 0.6)">
      <animate attributeName="opacity" values="0.3;0.8;0.3" dur="2.8s" repeatCount="indefinite" />
    </circle>
    
    <!-- Rotate the particles group -->
    <animateTransform 
      attributeName="transform" 
      type="rotate" 
      from="0 50 50" 
      to="360 50 50" 
      dur="8s" 
      repeatCount="indefinite" />
  </g>
</svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>
</file>

<file path="supabase/functions/hello-world/.npmrc">
# Configuration for private npm package dependencies
# For more information on using private registries with Edge Functions, see:
# https://supabase.com/docs/guides/functions/import-maps#importing-from-private-registries
</file>

<file path="supabase/functions/hello-world/deno.json">
{
  "imports": {}
}
</file>

<file path="supabase/functions/hello-world/index.ts">
/// <reference lib="deno.ns" />

// Follow this setup guide to integrate the Deno language server with your editor:
// https://deno.land/manual/getting_started/setup_your_environment
// This enables autocomplete, go to definition, etc.

// Setup type definitions for built-in Supabase Runtime APIs
import "jsr:@supabase/functions-js/edge-runtime.d.ts"



Deno.serve(async (req) => {
  const { name } = await req.json()
  const data = {
    message: `Hello ${name}!`,
  }

  return new Response(
    JSON.stringify(data),
    { headers: { "Content-Type": "application/json" } },
  )
})

/* To invoke locally:

  1. Run `supabase start` (see: https://supabase.com/docs/reference/cli/supabase-start)
  2. Make an HTTP request:

  curl -i --location --request POST 'http://127.0.0.1:54321/functions/v1/hello-world' \
    --header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6ImFub24iLCJleHAiOjE5ODM4MTI5OTZ9.CRXP1A7WOeoJeXxjNni43kdQwgnWNReilDMblYTn_I0' \
    --header 'Content-Type: application/json' \
    --data '{"name":"Functions"}'

*/
</file>

<file path="supabase/functions/onboarding_filter/index.ts">
import { serve } from 'https://deno.land/std@0.131.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

serve(async (req: Request) => {
  try {
    console.log('Fonction dclenche');
    const body = await req.json();
    console.log('Body reu:', JSON.stringify(body));

    const { type, record, old_record } = body;

    // Vrification plus stricte des donnes reues
    if (!record?.id || !record?.onboarding_step) {
      console.log('Donnes invalides:', { record });
      return new Response(
        JSON.stringify({ error: 'Donnes invalides' }), 
        { status: 400 }
      );
    }

    console.log('Vrification du type et du statut:', {
      type,
      newStep: record.onboarding_step,
      oldStep: old_record?.onboarding_step
    });

    // Vrifie si c'est bien une mise  jour vers COMPLETED
    if (
      type === 'UPDATE' &&
      record.onboarding_step === 'COMPLETED' &&
      old_record?.onboarding_step !== 'COMPLETED'
    ) {
      // Mise  jour de onboarding_completed_at
      const supabase = createClient(
        Deno.env.get('PROJECT_URL') ?? '',
        Deno.env.get('SERVICE_ROLE_KEY') ?? ''
      );

      // Met  jour la date de completion
      await supabase
        .from('user')
        .update({ onboarding_completed_at: new Date().toISOString() })
        .eq('id', record.id);

      // Appel webhook n8n
      const response = await fetch(
        'https://n8n-6pil.onrender.com/webhook/5e8d04c8-52eb-4802-91f9-66b4c03bba65',
        {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            user_id: record.id,
            onboarding_step: record.onboarding_step,
            completed_at: new Date().toISOString()
          }),
        }
      );

      if (!response.ok) {
        console.error('Erreur n8n:', await response.text());
        return new Response(
          JSON.stringify({ error: 'Erreur lors de l\'appel n8n' }), 
          { status: 500 }
        );
      }

      return new Response(
        JSON.stringify({ success: true, user_id: record.id }), 
        { status: 200 }
      );
    }

    return new Response(
      JSON.stringify({ ignored: true }), 
      { status: 200 }
    );
  } catch (error) {
    console.error('Erreur:', error);
    return new Response(
      JSON.stringify({ error: error.message }), 
      { status: 500 }
    );
  }
});
</file>

<file path="supabase/functions/deno.json">
{
  "imports": {
    "std/": "https://deno.land/std@0.168.0/"
  }
}
</file>

<file path="supabase/functions/tsconfig.json">
{
  "compilerOptions": {
    "allowJs": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "moduleResolution": "node",
    "lib": ["deno.ns"]
  }
}
</file>

<file path="supabase/migrations/20240320000000_add_users_rls.sql">
-- Enable Row Level Security
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- Create policies
-- Allow users to read their own data
CREATE POLICY "Users can read own data" ON public.users
    FOR SELECT
    USING (auth.uid() = auth_id);

-- Allow users to update their own data
CREATE POLICY "Users can update own data" ON public.users
    FOR UPDATE
    USING (auth.uid() = auth_id);

-- Allow authenticated users to read has_completed_tutorial
CREATE POLICY "Users can read tutorial status" ON public.users
    FOR SELECT
    USING (true)
    WITH CHECK (true);

-- Allow authenticated users to update has_completed_tutorial
CREATE POLICY "Users can update tutorial status" ON public.users
    FOR UPDATE
    USING (auth.uid() = auth_id)
    WITH CHECK (auth.uid() = auth_id);
</file>

<file path="supabase/.gitignore">
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local
</file>

<file path="supabase/config.toml">
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "ProcessFlow"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083

# Use these configurations to customize your Edge Function.
# [functions.MY_FUNCTION_NAME]
# enabled = true
# verify_jwt = true
# import_map = "./functions/MY_FUNCTION_NAME/deno.json"
# Uncomment to specify a custom file path to the entrypoint.
# Supported file extensions are: .ts, .js, .mjs, .jsx, .tsx
# entrypoint = "./functions/MY_FUNCTION_NAME/index.ts"
# Specifies static files to be bundled with the function. Supports glob patterns.
# For example, if you want to serve static HTML pages in your function:
# static_files = [ "./functions/MY_FUNCTION_NAME/*.html" ]

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"
</file>

<file path="test-results/.last-run.json">
{
  "status": "passed",
  "failedTests": []
}
</file>

<file path="tests/api/hello.test.ts">
// tests/api/hello.integration.test.ts
import request from 'supertest'
import { requestWithBypass } from '../utils/requestWithBypass'

const BASE_URL = process.env.TEST_BASE_URL || 'http://localhost:3000'
const VERCEL_AUTH_COOKIE = process.env.VERCEL_AUTH_COOKIE
console.log('Using BASE_URL:', BASE_URL)

describe('/api/hello (integration)', () => {
  it('returns hello message', async () => {
    await requestWithBypass(BASE_URL, 'get', '/api/hello')
      .set('Cookie', `authorization=${VERCEL_AUTH_COOKIE}`)
      .expect(200)
      .expect('Content-Type', /json/)
      .expect({ message: 'Hello from API' })
  })
})
</file>

<file path="tests/e2e/signup-navigation.spec.ts">
import { test, expect } from '@playwright/test';

const BASE_URL = process.env.TEST_BASE_URL || 'http://localhost:3000';
const BYPASS = process.env.VERCEL_AUTOMATION_BYPASS_SECRET;

test.use({
  ...(BYPASS && {
    extraHTTPHeaders: {
      'x-vercel-protection-bypass': BYPASS,
    },
  }),
});

test('should navigate to signup page when clicking Sign up link', async ({ page }) => {
  const loginUrl = `${BASE_URL}/login`;
  console.log('Navigating to:', loginUrl);
  await page.goto(loginUrl);

  await page.getByRole('textbox', { name: '' }).click();
  await page.getByRole('textbox', { name: '' }).fill('');
  await page.getByRole('textbox', { name: '' }).click();

  await page.getByRole('link', { name: 'Sign up' }).click();

  // Wait for navigation and assert the URL contains '/signup'
  await expect(page).toHaveURL(/\/signup$/);
});
</file>

<file path="tests/utils/requestWithBypass.ts">
import request, { Test } from 'supertest';

/**
 * Returns a supertest Test with the Vercel protection bypass header set (if available).
 * Usage: requestWithBypass(BASE_URL, 'get', '/api/hello')...
 */
export function requestWithBypass(
  baseUrl: string,
  method: 'get' | 'post' | 'put' | 'patch' | 'delete' | 'head' | 'options',
  url: string | URL
): Test {
  const test = request(baseUrl)[method](typeof url === 'string' ? url : url.toString());
  const bypass = process.env.VERCEL_AUTOMATION_BYPASS_SECRET;
  return bypass
    ? test.set('x-vercel-protection-bypass', bypass)
    : test;
}
</file>

<file path="tests/checkNames.test.ts">
import { checkWorkflowName, checkFolderName, checkWorkspaceName } from '../app/utils/checkNames';

describe('checkWorkflowName', () => {
  it('returns null for valid name', () => {
    expect(checkWorkflowName('Valid Name')).toBeNull();
  });

  it('returns error for name longer than 50 chars', () => {
    const longName = 'a'.repeat(51);
    expect(checkWorkflowName(longName)).toEqual({
      title: 'Invalid Name Length',
      description: 'Workflow name cannot be longer than 50 characters'
    });
  });
});

describe('checkFolderName', () => {
  it('returns null for valid name', () => {
    expect(checkFolderName('Valid Folder')).toBeNull();
  });

  it('returns error for name longer than 100 chars', () => {
    const longName = 'a'.repeat(101);
    expect(checkFolderName(longName)).toEqual({
      title: 'Invalid Name Length',
      description: 'Folder name cannot be longer than 100 characters'
    });
  });
});

describe('checkWorkspaceName', () => {
  it('returns null for valid name', () => {
    expect(checkWorkspaceName('Valid Workspace')).toBeNull();
  });

  it('returns error for name longer than 50 chars', () => {
    const longName = 'a'.repeat(51);
    expect(checkWorkspaceName(longName)).toEqual({
      title: 'Invalid Name Length',
      description: 'Workspace name cannot be longer than 50 characters'
    });
  });

  it('returns error for invalid characters', () => {
    expect(checkWorkspaceName('Invalid!Name')).toEqual({
      title: 'Invalid Characters',
      description: 'Workspace name must contain only letters, numbers, spaces, and hyphens.'
    });
  });
});
</file>

<file path="tests/sanitize.test.ts">
import { sanitizeInput } from '../app/utils/sanitize';

describe('sanitizeInput', () => {
  it('trims whitespace', () => {
    expect(sanitizeInput('  test  ')).toBe('test');
  });

  it('removes control characters', () => {
    expect(sanitizeInput('test\u0000\u0001')).toBe('test');
  });

  it('removes script tags and angle brackets', () => {
    expect(sanitizeInput('<script>alert(1)</script>')).toBe('alert(1)');
    expect(sanitizeInput('a<b>c')).toBe('ac');
    expect(sanitizeInput('a>c')).toBe('ac');
  });
});
</file>

<file path="types/action.ts">
import { User } from './user';
import { Block } from './block';
import { Workflow } from './workflow';

export interface Action {
  id: number;
  userId: number;
  user: User;
  type: string;
  targetId: number;
  target: Block;
  workflow_id: number;
  workflow: Workflow;
  value: number;
}
</file>

<file path="types/block.ts">
// types/block.ts
import { Workflow } from './workflow'; // Import Workflow type if needed
import { Action } from './action'; // Import Action type if needed
import { Path } from './path';

// Represents a Block, which might include different types of blocks
// Represents a Block, which might include different types of blocks
export interface Block {
  id: number;
  type: BlockType; // Use BlockType enum
  position: number;
  title: string;
  icon?: string; // Optional field
  description?: string; // Optional field
  image?: string; // Optional, URL for an image
  imageDescription?: string; // Optional, description for the image
  averageTime?: string; // Optional, average time for the block
  taskType?: 'MANUAL' | 'AUTOMATIC'; // Optional, enum values as string literals
  workflow_id: number;
  workflow?: Workflow; // Optional, representing the workflow this block belongs to
  step_block?: step_block; // Optional, if the block has a step_block
  path_block?: path_block; // Optional, if the block has a path_block
  delay_block?: delay_block;
  path_id: number; // Required field for the path relationship
  path?: Path; // Optional, the path this block belongs to
  coordinates?: { x: number; y: number } | null; // Optional, block coordinates
  children?: Block[]; // Add this line
  is_endpoint?: boolean; // Optional, if the block is an endpoint
}

// Enum for Block types
export enum BlockType {
  BEGIN = 'BEGIN',
  DELAY = 'DELAY',
  STEP = 'STEP',
  PATH = 'PATH',
  END = 'END',
  LAST = 'LAST',
  MERGE = 'MERGE',
}

export enum BlockEndType {
  END = 'END',
  LAST = 'LAST',
  PATH = 'PATH',
  MERGE = 'MERGE',
}

export enum FormType {
  ADD = 'ADD',
  UPDATE = 'UPDATE',
}

// Represents a step_block, specific for STEP type blocks
export interface step_block {
  id: number;
  blockId: number;
  stepDetails: string; // Details specific to the step
  block?: Block; // Optional reference back to the block
}

// Represents a delay_block, specific for DELAY type blocks
export interface delay_block {
  id: number;
  blockId: number;
  seconds: number; // Duration of the delay
  block?: Block; // Optional reference back to the block
}

// Represents a path_block, which can contain multiple Paths
export interface path_block {
  id: number;
  blockId: number;
  block: Block; // Reference to the block associated with this path_block
  paths: Path[]; // Array of Paths associated with this path_block
}
</file>

<file path="types/canvasevent.ts">
import { Block } from './block';
import { PathObject } from './sidebar';

export enum CanvasEventType {
  PATH_CREATION,
  SUBPATH_CREATION,
  BLOCK_ADD,
  BLOCK_DEL,
  BLOCK_REORDER,
  BLOCK_UPDATE,
  BLOCK_POSITION,
}

export interface CanvasEvent {
  type: CanvasEventType;
  path_id: number;
  blockId?: number;
  pathName?: string;
  blocks?: Block[];
  subpaths?: PathObject[];
  coordinates?: { x: number; y: number };
  handleBlocksReorder?: (reorderedBlocks: Block[]) => Promise<void>;
}
</file>

<file path="types/path.ts">
// types/path.ts

import { Block } from './block'; // Adjust the import path based on your project structure

export interface Path {
  id: number; // Unique identifier for the path
  name: string; // Name of the path
  workflow_id: number; // ID of the workflow the path belongs to
  path_blockId?: number; // Optional ID for a related path block (can be null)
  blocks: Block[]; // Array of blocks contained within this path
}
</file>

<file path="types/role.ts">
export enum Role {
    ADMIN,
    EDITOR,
    READER,
  }
</file>

<file path="types/sidebar.ts">
import { Block, BlockType } from './block';

export interface SidebarBlock {
  id: number;
  type: BlockType;
  position: number;
  icon?: string;
  title?: string;
  description?: string;
  subpaths?: PathObject[];
}

export interface PathObject {
  id: number;
  name: string;
  blocks?: SidebarBlock[];
  handleBlocksReorder?: (reorderedBlocks: Block[]) => Promise<void>;
}
</file>

<file path="types/sidebarevent.ts">
import { Block } from './block';

export enum SidebarEventType {
  FOCUS,
  REORDER,
}

export interface SidebarEvent {
  type: SidebarEventType;
  path_id?: number;
  blocks?: Block[];
  focusId?: string;
}
</file>

<file path="types/team.ts">
import { UserTeam } from './userTeam';
import { Workspace } from './workspace';

export interface Team {
  id: number;
  name: string;
  userTeams: UserTeam[];
  workspaces: Workspace[];
}
</file>

<file path="types/todo.ts">
export interface Todo {
    id: number;
    title: string;
  }
</file>

<file path="types/transformstate.ts">
export interface TransformState {
  scale: number;
  positionX: number;
  positionY: number;
}
</file>

<file path="types/user.ts">
import { Action } from './action';
import { UserTeam } from './userTeam';

export interface User {
  id: number;
  auth_id: string;
  first_name: string;
  last_name: string;
  full_name: string;
  email: string;
  avatar_url?: string;
  avatar_signed_url?: string;
  active_workspace_id?: number;
  hubspot_contact_id?: string;
  sentry_id?: string;
  post_hog_id?: string;
  phone?: string;
  archived_at?: string;
  created_at: string;
  updated_at: string;
  last_login_at?: string;
}
</file>

<file path="types/userTeam.ts">
import { Role } from './role';
import { User } from './user';
import { Team } from './team';

export interface UserTeam {
  id: number;
  userId: number;
  teamId: number;
  role: Role;
  poles: string[];
  user: User;
  team: Team;
}
</file>

<file path="types/workflow.ts">
import { Workspace } from './workspace';
import { Block } from './block';
import { Action } from './action';
import { User } from './user';

export type WorkflowStatus = 'ACTIVE' | 'DRAFT' | 'IN_REVIEW' | 'NEEDS_UPDATE' | 'ARCHIVED';

export interface Workflow {
  id: number;
  name: string;
  icon: string;
  signedIconUrl?: string;
  description: string;
  process_owner?: string;
  review_date?: string;
  additional_notes?: string;
  workspaceId: number;
  workspace: Workspace;
  blocks: Block[];
  public_access_id: string;
  history: Action[];
  folder_id?: number;
  last_opened?: Date;
  team_tags: string[];
  author: User;
  status: WorkflowStatus;
  updated_at: string;
  created_at: string;
  is_public: boolean;
}
</file>

<file path="utils/supabase/admin.ts">
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.SUPABASE_URL!;
const supabaseAdminKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

export const supabaseAdmin = createClient(supabaseUrl, supabaseAdminKey, {
  global: {
    headers: {
      apikey: supabaseAdminKey,
    },
  },
});
</file>

<file path="utils/supabase/client.ts">
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
</file>

<file path="utils/supabase/fetch_url.ts">
export const fetchSignedUrl = async (path: string): Promise<string | null> => {
  try {
    const response = await fetch(`/api/get-signed-url?path=${path}`);
    const data = await response.json();
    if (response.ok && data.signedUrl) {
      return data.signedUrl;
    } else {
      console.error('Error fetching signed URL:', data.error);
      return null;
    }
  } catch (error) {
    console.error('Error fetching signed URL:', error);
    return null;
  }
};
</file>

<file path="utils/supabase/middleware.ts">
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) =>
            request.cookies.set(name, value)
          );
          supabaseResponse = NextResponse.next({
            request,
          });
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          );
        },
      },
    }
  );

  // Do not run code between createServerClient and
  // supabase.auth.getUser(). A simple mistake could make it very hard to debug
  // issues with users being randomly logged out.

  // IMPORTANT: DO NOT REMOVE auth.getUser()

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Check if the user is logged in
  if (
    !user &&
    !request.nextUrl.pathname.startsWith('/login') &&
    !request.nextUrl.pathname.startsWith('/auth')
  ) {
    // no user, potentially respond by redirecting the user to the login page
    const url = request.nextUrl.clone();
    url.pathname = '/login';
    return NextResponse.redirect(url);
  }

  // Check if the password-reset-required cookie is set to 'true'
  const passwordResetRequired =
    request.cookies.get('password-reset-required')?.value === 'true';

  if (passwordResetRequired) {
    // If the password reset is required, redirect to the reset-password page
    const url = request.nextUrl.clone();
    url.pathname = '/reset-password';
    return NextResponse.redirect(url);
  }

  // IMPORTANT: You *must* return the supabaseResponse object as it is.
  // If you're creating a new response object with NextResponse.next() make sure to:
  // 1. Pass the request in it, like so:
  //    const myNewResponse = NextResponse.next({ request })
  // 2. Copy over the cookies, like so:
  //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())
  // 3. Change the myNewResponse object to fit your needs, but avoid changing
  //    the cookies!
  // 4. Finally:
  //    return myNewResponse
  // If this is not done, you may be causing the browser and server to go out
  // of sync and terminate the user's session prematurely!

  return supabaseResponse;
}
</file>

<file path="utils/supabase/server.ts">
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createClient() {
  const cookieStore = await cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  );
}
</file>

<file path="utils/createSignedUrls.ts">
import { generatePublicUrl } from '@/app/api/utils/generatePublicUrl';

const BUCKET_NAME = process.env.NEXT_PUBLIC_SUPABASE_PRIVATE_BUCKET;

export async function createSignedUrls(path: any) {
    if (!BUCKET_NAME) {
      throw new Error('Bucket name is not defined in the environment variables');
    }
    if (!path?.blocks || !Array.isArray(path.blocks)) return path;

  // Map blocks to promises for public URLs
  const updatedBlocks = await Promise.all(
    path.blocks.map(async (block: any) => {
      return await createSignedUrlForBlock(block);
    })
  );

  return {
    ...path,
    blocks: updatedBlocks,
  };
}

/**
 * Creates public URLs for the image and icon of a single block.
 * - Skips icon if it's a Brandfetch CDN URL.
 * @param block The block object to process.
 * @returns The block object with signedImageUrl and/or signedIconUrl if applicable.
 */
export async function createSignedUrlForBlock(block: any) {
  if (!BUCKET_NAME) {
    throw new Error('Bucket name is not defined in the environment variables');
  }
  const updatedBlock = { ...block };

  // For block.image
  if (block.image) {
    try {
      updatedBlock.signedImageUrl = generatePublicUrl(block.image);
    } catch (error) {
      console.error('Error generating public URL for block image:', error);
    }
  }

  // For block.icon, skip if it's a Brandfetch CDN URL
  if (
    block.icon &&
    !block.icon.startsWith('https://cdn.brandfetch.io/')
  ) {
    try {
      updatedBlock.signedIconUrl = generatePublicUrl(block.icon);
    } catch (error) {
      console.error('Error generating public URL for block icon:', error);
    }
  }

  return updatedBlock;
}

/**
 * For each workspace, go through each workflow and each folder and create a signedIconUrl for each of their icon_url.
 * - Skips icon_url if it's a Brandfetch CDN URL.
 * @param workspaces Array of workspace objects (as returned by the API)
 * @returns Updated array of workspaces with signedIconUrl fields
 */
export async function createSignedIconUrlsForWorkspaces(workspaces: any[]) {
  if (!BUCKET_NAME) {
    throw new Error('Bucket name is not defined in the environment variables');
  }
  if (!Array.isArray(workspaces)) return workspaces;

  // Helper to sign a single icon_url
  const signIconUrl = async (icon_url: string | null | undefined) => {
    if (
      !icon_url ||
      icon_url.startsWith('https://cdn.brandfetch.io/')
    ) {
      return icon_url; // Return as is (or null/undefined)
    }
    try {
      return generatePublicUrl(icon_url);
    } catch (error) {
      console.error('Error generating public URL for icon:', error);
      return icon_url;
    }
  };

  // Deep copy and process
  const updatedWorkspaces = await Promise.all(
    workspaces.map(async (workspace) => {
      // Clone workspace to avoid mutating input
      const updatedWorkspace = { ...workspace };

      // Process folders
      if (Array.isArray(updatedWorkspace.folders)) {
        updatedWorkspace.folders = await Promise.all(
          updatedWorkspace.folders.map(async (folder: any) => {
            if (folder.icon_url) {
              const signed = await signIconUrl(folder.icon_url);
              return { ...folder, signedIconUrl: signed };
            }
            return folder;
          })
        );
      }

      // Process workflows
      if (Array.isArray(updatedWorkspace.workflows)) {
        updatedWorkspace.workflows = await Promise.all(
          updatedWorkspace.workflows.map(async (workflow: any) => {
            if (workflow.icon) {
              const signed = await signIconUrl(workflow.icon);
              return { ...workflow, signedIconUrl: signed };
            }
            return workflow;
          })
        );
      }

      return updatedWorkspace;
    })
  );

  return updatedWorkspaces;
}
</file>

<file path="utils/DynamicIcon.tsx">
import React, { useEffect } from "react";
import { useIconToken, useTheme } from "@/app/theme/hooks";

const svgCache = new Map<string, string>();

const fetchSvg = async (url: string): Promise<string> => {
  if (svgCache.has(url)) {
    return svgCache.get(url) || '';
  }

  const response = await fetch(url);
  if (!response.ok) {
    throw new Error('Failed to fetch SVG');
  }

  const svgText = await response.text();
  
  // Don't add transition here, we'll control it via a wrapper
  svgCache.set(url, svgText);
  return svgText;
};

type IconVariant = 'default' | 'primary' | 'secondary' | 'tertiary' | 'tertiary-color' | 'success' | 'warning' | 'error' | 'info';

interface DynamicIconProps {
  url: string;
  color?: string;
  size?: number;
  variant?: IconVariant;
  className?: string;
  isHovered?: boolean; // Accept hover state from parent
  referrerPolicy?: React.HTMLAttributeReferrerPolicy;
}

// Icon component that fetches and caches SVGs dynamically
const DynamicIcon: React.FC<DynamicIconProps> = ({
  url,
  color,
  size = 24,
  variant = 'default',
  className = '',
  isHovered = false,
  referrerPolicy,
}) => {
  const [svgContent, setSvgContent] = React.useState<string | null>(null);
  const { getCssVariable } = useTheme();
  
  // If BrandFetch or PNG, render <img> directly
  if (url.startsWith('https://cdn.brandfetch.io/') || url.toLowerCase().endsWith('.png')) {
    return (
      <img
        src={url}
        alt="Icon"
        className={className}
        width={size}
        height={size}
        referrerPolicy={referrerPolicy || "strict-origin-when-cross-origin"}
      />
    );
  }
  
  // Get color based on variant type - for button-related variants, use button tokens
  const getColorForVariant = (variant: IconVariant, isHover: boolean): string => {
    // If custom color is provided, use it
    if (color) return color;
    
    // For tertiary and tertiary-color variants, use button tokens
    if (variant === 'tertiary') {
      return getCssVariable(isHover ? 'button-tertiary-fg-hover' : 'button-tertiary-fg');
    }
    
    if (variant === 'tertiary-color') {
      return getCssVariable(isHover ? 'button-tertiary-color-fg-hover' : 'button-tertiary-color-fg');
    }
    
    // Otherwise use icon tokens
    return getCssVariable(`icon-${variant}${isHover ? '-hover' : ''}` as any);
  };
  
  // Determine colors based on hover state
  const normalColor = getColorForVariant(variant, false);
  const hoverColor = getColorForVariant(variant, true);
  
  // Use the hover state directly from props without internal state management
  // This ensures closer timing with the parent button's hover state

  // Get processed SVG with colors applied
  const coloredSvg = React.useMemo(() => {
    if (!svgContent) return null;
    
    // If color is 'inherit', preserve original SVG colors
    if (color === 'inherit') return svgContent;
    
    return svgContent
      .replace(/stroke="([^"]+)"/g, (match, value) => {
        // Preserve special values
        if (value === 'none' || value.includes('url(') || value.includes('gradient')) {
          return match;
        }
        return `stroke="currentColor"`;
      })
      .replace(/fill="([^"]+)"/g, (match, value) => {
        // Preserve special values
        if (value === 'none' || value.includes('url(') || value.includes('gradient')) {
          return match;
        }
        return `fill="currentColor"`;
      });
  }, [svgContent, color]);

  useEffect(() => {
    fetchSvg(url)
      .then((svg) => setSvgContent(svg))
      .catch(console.error);
  }, [url]);

  if (!coloredSvg) {
    return <span style={{ width: size, height: size }} />; // Placeholder
  }

  return (
    <span
      className={`inline-svg ${className}`}
      style={{
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        width: size,
        height: size,
        color: isHovered ? hoverColor : normalColor,
        transition: 'none !important',
        pointerEvents: 'none',
      } as React.CSSProperties}
      dangerouslySetInnerHTML={{ __html: coloredSvg
        .replace('<svg', `<svg width="${size}" height="${size}" preserveAspectRatio="xMidYMid meet"`)
      }}
    />
  );
};

export default DynamicIcon;
</file>

<file path="utils/iconCache.ts">
// utils/iconCache.ts

interface CachedIcon {
  signedUrl: string;
  expiresAt: number;
}

interface BatchSignedUrlResponse {
  signedUrls: Array<{
    path: string;
    signedUrl: string | null;
    error: string | null;
  }>;
}

class IconCache {
  private cache = new Map<string, CachedIcon>();
  private readonly DEFAULT_EXPIRY_HOURS = 23; // Slightly less than 24h to be safe

  /**
   * Set a signed URL in the cache with expiry time
   */
  set(path: string, signedUrl: string, expiryHours = this.DEFAULT_EXPIRY_HOURS): void {
    this.cache.set(path, {
      signedUrl,
      expiresAt: Date.now() + (expiryHours * 60 * 60 * 1000)
    });
  }

  /**
   * Get a signed URL from cache if it exists and hasn't expired
   */
  get(path: string): string | null {
    const cached = this.cache.get(path);
    if (!cached) return null;

    if (Date.now() > cached.expiresAt) {
      this.cache.delete(path);
      return null;
    }

    return cached.signedUrl;
  }

  /**
   * Check if a path exists in cache and is not expired
   */
  has(path: string): boolean {
    return this.get(path) !== null;
  }

  /**
   * Clear all cached entries
   */
  clear(): void {
    this.cache.clear();
  }

  /**
   * Remove expired entries from cache
   */
  cleanup(): void {
    const now = Date.now();
    for (const [path, cached] of this.cache.entries()) {
      if (now > cached.expiresAt) {
        this.cache.delete(path);
      }
    }
  }

  /**
   * Get cache statistics for debugging
   */
  getStats(): { total: number; expired: number } {
    const now = Date.now();
    let expired = 0;
    
    for (const cached of this.cache.values()) {
      if (now > cached.expiresAt) {
        expired++;
      }
    }

    return {
      total: this.cache.size,
      expired
    };
  }
}

// Create a singleton instance
export const iconCache = new IconCache();

// Cleanup expired entries every 30 minutes
if (typeof window !== 'undefined') {
  setInterval(() => {
    iconCache.cleanup();
  }, 30 * 60 * 1000);
}
</file>

<file path="utils/optimizedIconFetch.ts">
import { iconCache } from './iconCache';
import { fetchSignedUrl } from './supabase/fetch_url';

interface IconData {
  basicUrl: string;
  signedUrl: string;
}

interface BatchSignedUrlResult {
  path: string;
  signedUrl: string | null;
  error: string | null;
}

/**
 * Fetch signed URLs for multiple icons using batch API with caching and fallback
 */
export const fetchIconsBatch = async (
  applist: string[],
  iconlist: string[]
): Promise<{ applistResult: IconData[]; iconlistResult: IconData[] }> => {
  try {
    // Prepare all paths
    const appPaths = applist.map((app: string) => `step-icons/apps/${app}`);
    const iconPaths = iconlist.map((icon: string) => `step-icons/default-icons/${icon}`);
    const allPaths = [...appPaths, ...iconPaths];

    // Check cache first and separate cached vs uncached
    const cachedResults = new Map<string, string>();
    const uncachedPaths: string[] = [];

    for (const path of allPaths) {
      const cached = iconCache.get(path);
      if (cached) {
        cachedResults.set(path, cached);
      } else {
        uncachedPaths.push(path);
      }
    }

    console.log(`Icon fetch: ${cachedResults.size} cached, ${uncachedPaths.length} to fetch`);

    // Fetch uncached URLs using batch API
    const newSignedUrls = new Map<string, string>();
    
    if (uncachedPaths.length > 0) {
      try {
        const batchResponse = await fetch('/api/batch-signed-urls', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ paths: uncachedPaths })
        });

        if (batchResponse.ok) {
          const batchData = await batchResponse.json();
          
          // Process batch results
          batchData.signedUrls.forEach((result: BatchSignedUrlResult) => {
            if (result.signedUrl && !result.error) {
              newSignedUrls.set(result.path, result.signedUrl);
              iconCache.set(result.path, result.signedUrl);
            } else {
              console.warn(`Failed to get signed URL for ${result.path}:`, result.error);
            }
          });
        } else {
          throw new Error(`Batch API failed with status: ${batchResponse.status}`);
        }
      } catch (batchError) {
        console.warn('Batch fetch failed, falling back to individual requests:', batchError);
        
        // Fallback: fetch individually using existing method
        const individualPromises = uncachedPaths.map(async (path) => {
          try {
            const signedUrl = await fetchSignedUrl(path);
            if (signedUrl) {
              newSignedUrls.set(path, signedUrl);
              iconCache.set(path, signedUrl);
            }
          } catch (error) {
            console.warn(`Failed to fetch individual signed URL for ${path}:`, error);
          }
        });

        await Promise.allSettled(individualPromises);
      }
    }

    // Combine cached and new results
    const getSignedUrl = (path: string): string => {
      return cachedResults.get(path) || newSignedUrls.get(path) || '';
    };

    // Build final results
    const applistResult: IconData[] = applist.map((app: string, idx: number) => ({
      basicUrl: appPaths[idx],
      signedUrl: getSignedUrl(appPaths[idx])
    }));

    const iconlistResult: IconData[] = iconlist.map((icon: string, idx: number) => ({
      basicUrl: iconPaths[idx],
      signedUrl: getSignedUrl(iconPaths[idx])
    }));

    return { applistResult, iconlistResult };

  } catch (error) {
    console.error('Error in fetchIconsBatch:', error);
    
    // Ultimate fallback: return empty signed URLs, let individual components handle loading
    const applistResult: IconData[] = applist.map((app: string) => ({
      basicUrl: `step-icons/apps/${app}`,
      signedUrl: ''
    }));

    const iconlistResult: IconData[] = iconlist.map((icon: string) => ({
      basicUrl: `step-icons/default-icons/${icon}`,
      signedUrl: ''
    }));

    return { applistResult, iconlistResult };
  }
};

/**
 * Preload critical icons (first N icons) for better perceived performance
 */
export const preloadCriticalIcons = async (iconUrls: string[], maxPreload = 20): Promise<void> => {
  if (typeof window === 'undefined') return; // Skip on server side

  const urlsToPreload = iconUrls.filter(url => url).slice(0, maxPreload);
  
  const preloadPromises = urlsToPreload.map(url => {
    return new Promise<void>((resolve) => {
      const img = new Image();
      img.onload = () => resolve();
      img.onerror = () => resolve(); // Don't fail the whole batch if one image fails
      img.src = url;
      
      // Timeout after 5 seconds to avoid hanging
      setTimeout(() => resolve(), 5000);
    });
  });

  try {
    await Promise.allSettled(preloadPromises);
    console.log(`Preloaded ${urlsToPreload.length} critical icons`);
  } catch (error) {
    console.warn('Icon preloading failed:', error);
  }
};
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env
.env.staging

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

nftl.txt    
# Sentry Config File
.env.sentry-build-plugin

# Claude documentation
.qodo

# Ignore database backups
backup.sql
</file>

<file path=".prettierrc">
{
    "semi": true,
    "trailingComma": "es5",
    "singleQuote": true,
    "printWidth": 80,
    "tabWidth": 2,
    "useTabs": false
}
</file>

<file path="business-logic.md">
# Business Logic ProcessFlow

# 0. Glossary

- **Flow**: A flow corresponds to a process.
- **Block**: A block is an element in which the user can describe what action to take in their process. It can include an image, title, or description. There is a hierarchical logic with parent blocks and child blocks.
- **Path**: A path is the route where the block is located. Paths can have names.
- **SOP (Standard Operating Procedure)**: A document within a company that compiles the standard procedures used within the company.
- **Step**: A step corresponds to a stage; each stage contains a block.
- **PF**: ProcessFlow.

# 1. Introduction

This document aims to catalog all the business logic of Flows.

ProcessFlow include and edit mode and a read mode :

- **Edit mode** : The user can create a full process using paths we saw on 2. Blocks and Paths Types. The user is restricted by rules detailed below.
- **Read mode** : The user can switch to this mode to visualize his process in a one way document which mean user will select which path he would like to use in order to follow the processus. The user can share the link of this view or share an embed link in order to set this up to a documentation.

There are no technical limitations on workflow complexity, including number of condition paths or total workflow size.

# 2. Blocks and Paths Types

- **Step :** Create a unique path with a block at the end. This block can contain:
    - A title
    - A description
    - An image
        
- **Conditional Path :** The user can choose how many paths they wish to create, and they can also choose whether to name them or not. Paths are created with the desired number, with a block at the end of each path.

- **Stroke Line** : You can create a stroke line to clearly identify a connection to an upper or same level block.


- **Merge Functionality** : The user can choose to merge two paths or more in one path.

- **Delay :** The user can choose a predetermined duration or a custom duration. Then create a line that connects to a block with a slightly different design from other blocks.
    - Delay block has 2 modes:
        - Fixed Duration  Just select a duration. Its a rigid duration obligated to respect.
                        
        - Wait For Event  Must also precise an event, it can be more flexible and have this utility : Wait for the client respond in max 7 days. So if the even happen before you can proceed.

- **Start Block** : The start block is the block that is added by default to each new Flow. It cannot be deleted or modified, and there can only be one per Flow.

- **End Block:** The user can create this end block. It is purely visual and serves to close a path.

# 3. Business Logic

# Start Block:

1. Definition: A Start Block marks the beginning of a workflow process and serves as the entry point.
2. Uniqueness: Each workflow must have exactly one Start Block, created automatically when the workflow is initiated.
3. Deletion Protection: Start Blocks cannot be deleted through the user interface. This is enforced through application logic.
4. Modification Restrictions: Users cant changes the label of the Start Block and the label is always This is where your process starts
5. Connection Direction: Start Blocks can only have outgoing connections in normal workflows.
6. Read Mode : The Start Block does not appear on the Read Mode

# End Block:

- Purpose: Represent a true process terminus with no further actions
- Visual: Displayed with no possibilities to create anything after to indicate finality
- Connections: Can only have incoming connections
- Quantity: Multiple End blocks can exist in a single workflow
- Read Mode: End block are not rendered in the Read Mode
- Deletion: End Blocks can be deleted

# Last Block:

### Definition and Purpose

- A LAST block represents the termination point of a workflow path that can be extended.
- Unlike END blocks which represent true process termini, LAST blocks serve as interactive endpoints where users can continue building the workflow.
- LAST blocks are automatically positioned at the end of every path that doesn't already terminate in another end-type block (END or MERGE).
- They provide a visual indication that the path can be extended, offering users an intuitive way to add new blocks.

### Interaction Behavior

- Clicking on the "+" button associated with a LAST block opens the block creation interface.
- Users can select the type of block they wish to add (STEP, DELAY, PATH) to continue building the workflow.
- When a new block is added through the LAST block interface, the LAST block automatically repositions itself after the newly added block.
- This creates a continuous building experience where the LAST block is always available for further workflow extension.

### System Rules

- LAST blocks cannot be manually deleted - they are system-managed elements.
- When a path is merged with another path, its LAST block is automatically removed.
- If all blocks in a path are deleted except the BEGIN block, a LAST block is automatically regenerated.
- LAST blocks do not appear in Read Mode, as they are strictly editing interface elements.
- Like other end-type blocks, LAST blocks can only have incoming connections in the workflow hierarchy.

# Path Direction Rules:

1. Vertical Layout:
    - Workflows automatically follow a hierarchical progression from top to bottom for improved readability
    - The layout engine automatically positions blocks to maintain this vertical flow using Elksjs Tree in ReactFlow
    - Users cannot arbitrarily position blocks outside this hierarchical structure
2. Connection Constraints:
    - Regular blocks can only connect to blocks further down in the workflow hierarchy
    - Blocks cannot connect directly to themselves through regular connections
    - Self-connections are only possible using stroke lines

# Conditional Paths Rules:

1. Definition and Purpose:
    - Conditional paths create branching workflows where users can follow different paths based on specific conditions
    - Each conditional path represents a decision point in the process
2. Path Requirements:
    - Each conditional path must have at least two outgoing paths (branches)
    - The minimum of two paths is enforced by the UI and cannot be reduced
    - Path names are displayed to users to help them understand the branching options
3. User Navigation:
    - In read mode, users select which path to follow based on their specific scenario. The label of the path will be displayed in the condition, if the user select a path, the next display will be the first block on this path.
    - The system presents path options as clickable choices
    - Users can navigate back to the decision point to explore alternative paths

# Merge Functionality:

1. Definition and Purpose:
    - Merge functionality allows combining multiple workflow paths into a single path
    - Merges create a visual indication of path convergence in the workflow
    - After merging, the workflow continues as a single path
    - Merge paths dont have any label
2. Merge Requirements:
    - Only paths of the same hierarchical level and same parent branch can be merged
    - "Same hierarchical level" means paths that branched from the same parent conditional path
    - At least two paths must be merged together (minimum of two incoming connections)
3. Post-Merge Behavior:
    - After merging, the workflow continues as a single path
    - This merged path can contain additional blocks of any type
4. Technical Implementation:
    - Merge operations create path_parent_block relationships between the parent paths' end blocks and the new merged path
    - These relationships enable the visual representation of convergence
    - The parent paths remain in the workflow but visually connect to the merged path

# Stroke Line Rules:

1. Definition and Purpose:
    - Stroke lines are special connections that allow linking blocks outside the normal workflow hierarchy
    - They appear as pink dashed lines with directional arrows
2. Connection Constraints:
    - Stroke lines cannot connect to Start Blocks, as this would create invalid workflow entry points
    - There is no limit to the number of stroke lines in a workflow
3. Loop and Cycle Creation:
    - Stroke lines can create cycles or loops in the workflow
    - Self-loops (connecting a block to itself) are supported with special curved rendering
    - Multi-block loops (connecting through several blocks back to an earlier point) are also supported
    - Loops should be used judiciously to avoid confusing workflows
4. Visual Representation:
    - Stroke lines appear as pink dashed lines with arrow indicators showing direction
    - They follow orthogonal routing (right-angled paths) rather than diagonal lines
    - When selected, stroke lines show control points that can be manipulated
    - Stroke lines MUST have text labels to describe their purpose or condition
5. Path Customization:
    - Users can customize stroke line paths using control points
    - Control points can be dragged to adjust the exact routing of the line
    - The system maintains orthogonal paths (right angles) even when customized
    - Paths automatically adjust when blocks are moved
6. Labeling:
    - Each stroke line MUST have a text label explaining its purpose
    - Labels appear when hovering over the stroke line
    - Labels should be concise and descriptive (e.g., "Return to review", "Skip if urgent")
7. Read Mode:
    - In the Read Mode, the Stroke line looks like a condition and on the choice, the label of the stroke line can be selected

# Delay Block Rules:

1. Delay Types:
    - Delays come in two distinct types:
    a) Fixed Duration: Simulate a pause in the workflow for a specified time period
    b) Wait for Event: Simulate a pause in the workflow until a specific event occurs, with optional timeout
    - Fixed Duration delays always require a time specification (minutes, hours, days)
    - Wait for Event delays require an event name and optionally include an expiration time
2. Delay Configuration:
    - Time can be specified in minutes, hours, and days in any combination
    - Wait for Event delays require a descriptive event name (e.g., "Customer approves quote")
    - Expiration times for Wait for Event delays are optional but recommended
3. Placement Rules:
    - Delays can be placed at any point in a workflow path
    - Delays can serve as final elements in a path (e.g., for waiting periods after task completion)

# 6. Documentation in app

Heres the current documentation in app to help users with the features of ProcessFlow.

### **Delay Block :**

The **Delay Block** allows you to introduce waiting periods into your Flow. This is essential for modeling real-world scenarios where tasks may require waiting for specific durations or external events before proceeding. There is 2 type of delay block :
**Fixed Duration Delay**

A strict waiting period that must be fully completed before the process can continue.

When to use:

- Mandatory waiting periods (e.g., "Wait 24 hours for the solution to set")
- Regulatory holding periods (e.g., "Wait 7 days before processing the refund")

**Wait For Event**

A flexible waiting period that concludes when either an external event occurs or a maximum time limit is reached.

When to use:

- Client responses (e.g., "Wait for client feedback for up to 3 days")
- Approval workflows (e.g., "Wait for manager approval within 48 hours")
- Conditional actions (e.g., "Wait for payment confirmation for up to 7 days")

How to add :

1. Click on the + to add a new step to your flow
2. Select the delay block
3. Setup your delay block

### **End Block :**

The **End Block** represents the final point of a process path. Unlike the Start block (which is automatically added to every workflow and cannot be deleted), End blocks are optional visual elements that help users clearly identify where specific paths terminate.

When to use:

- At the conclusion of every meaningful path in your workflow
- To mark different possible outcomes of a process (e.g., "Application Approved," "Application Rejected")
- When documenting process termination points for compliance or training purposes
- To make complex workflows with multiple branches easier to understand

How to add :

1. Click on the + to add a new step to your flow
2. Select the End block, which will only be visible if there are no steps below the current one.

### **Link :**

The Link allows you to create connections between blocks that don't follow the standard top-to-bottom flow. This is essential for representing complex processes that include cycles, loops, decision points with returns to previous steps, or any non-linear flow.

When to use :

- To create loops (e.g., "If document needs revision, return to Step 2")
- To represent conditional returns to earlier steps (e.g., "If application is incomplete, return to data collection")
- When a process requires jumping between different sections based on specific conditions
- To simplify complex workflows by avoiding redundant steps

How to add :

- Click on the three dot on a step block, it will open a menu.
- Select connect blocks
- Click on the source block (where the link starts)
- Click on the target block (where the link ends)
- Add an optional label to describe the purpose of the connection

### **Merge Paths :**

The Merge Paths allows you to unify multiple paths back into a single path, making it essential for workflows where different conditions or parallel processes eventually converge to a common next step. This creates cleaner, more maintainable processes by avoiding redundant blocks after decision points.

When to use:

- After conditional paths that eventually lead to the same next steps
- When multiple approval or review paths converge to a common outcome
- To simplify workflow visualization by reducing redundant blocks

How to add :

- Click on the three dot on a step block, it will open a menu.
- Select Merge paths
- Choose the paths you want to merge (it can only be the paths on the same path and at the same level).
- Click on Merge Paths once youve choose your block to merge.

### Step Block :

The Step Block is the fundamental building block of any Flow. It represents a single action, task, or stage in your process and provides detailed information to help users understand exactly what needs to be done.

When to use:

- To break down complex processes into understandable segments
- When users need clear guidance with visual support
- As the primary building blocks of straightforward, linear processes

How to add :

- Click on the + to add a new step to your flow
- Select the Step

### **Conditional Paths :**

The Conditional Path functionality enables you to create multiple alternative paths in your workflow based on different scenarios, decisions, or conditions. This powerful feature allows your processes to adapt to varying circumstances, making them more flexible and realistic.

When to use :

- When a process can take different routes based on specific criteria
- For approval workflows with "approved" and "rejected" outcomes
- When representing decision trees with multiple possible answers
- When documenting exception handling in standard procedures
- For compliance documentation that covers multiple scenarios

How to add :

- Click on the + to add a new step to your flow
- Select the Condition

### Path Labels :

Path Labels are descriptive text elements that identify the different options at decision points in your workflow. They appear on Conditional Paths and Link Lines, providing clear guidance to users when they need to make selections in Read Mode.

When to use :

- On all conditional paths to clearly distinguish between options
- When creating interactive processes where users select their own path
- When documenting decision trees with multiple options
- For any workflow where users need to make choices based on specific criteria

How to add :

- Label are automatically added on path when needed
- You can always modify the text on it
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Commands

**Development:**
- `npm run dev` - Start development server (http://localhost:3000)
- `npm run build` - Build for production
- `npm run lint` - Run ESLint
- `npm test` - Run Jest tests
- `npm run test:watch` - Run tests in watch mode
- `npm run test:coverage` - Run tests with coverage

**Testing workflows:**
- Access workflows at: `http://localhost:3000/workspace/2`

## Architecture

**Tech Stack:**
- Next.js 15 with App Router
- React 18 with TypeScript
- Prisma ORM with PostgreSQL
- Supabase for auth
- ReactFlow for workflow visualization
- Tailwind CSS with custom theming
- Stripe for billing

**Core Models:**
- **Workspace** - Contains workflows, folders, users with role-based access
- **Workflow** - Contains blocks organized in paths, supports public sharing
- **Path** - Collection of connected blocks forming workflow sequences
- **Block** - Individual workflow steps (STEP, DELAY, BEGIN, END, LAST, MERGE, PATH)
- **StrokeLine** - Custom connections between blocks with control points

**Key Architectural Patterns:**
- Server Components by default, `"use client"` only when necessary
- Zustand stores for client state management (modal, paths, edit modes)
- API routes follow `/app/api/*` structure
- Server Actions preferred over API routes for mutations
- Theme-aware components using `useColors()` hook from `/app/theme/hooks.ts`

**Frontend Structure:**
- `/[slug]/[flow]/edit/` - Workflow editor with ReactFlow canvas
- `/[slug]/[flow]/read/` - Read-only workflow viewer  
- `/dashboard/` - Workspace management
- Custom ReactFlow blocks in `/edit/components/blocks/`
- Custom ReactFlow edges in `/edit/components/edges/`

**State Management:**
- Edit mode: Multiple Zustand stores for different concerns
- Modal state, path selection, stroke lines, clipboard operations
- SWR for server state synchronization

## Code Standards

**TypeScript:**
- Functions max 50 lines, ideally 20-30
- Single responsibility principle
- Use object parameters for functions with many parameters
- Handle errors gracefully, never expose sensitive errors

**React/Frontend:**
- Functional components only
- Use `useColors()` hook for theme colors
- All pages must be theme-aware
- Self-close components without children
- Use parentheses for multi-line JSX

**Backend:**
- Validate API inputs before processing
- Use async/await consistently
- Sanitize user input before database operations
- Use React Query (TanStack) or SWR for client-side fetching
- Use Server Actions or `getServerSideProps` for server-side fetching
- Use Next.js Middleware for request handling
- Use `useFormState` instead of `useState` for form handling in Server Components
</file>

<file path="exportFeaturesToMarkdown.js">
const fs = require('fs');
const path = require('path');

// Paths
const FEATURE_DIR = './e2e/features';
const OUTPUT_DIR = './docs/test-cases';

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// Format Gherkin lines to Markdown
function formatLine(line) {
  const trimmed = line.trim();
  if (trimmed.startsWith('Feature:')) {
    return `# ${trimmed.replace('Feature:', '').trim()}\n`;
  } else if (trimmed.startsWith('Scenario:')) {
    return `## ${trimmed}\n`;
  } else if (
    trimmed.startsWith('Given') ||
    trimmed.startsWith('When') ||
    trimmed.startsWith('Then') ||
    trimmed.startsWith('And') ||
    trimmed.startsWith('But')
  ) {
    return `**${trimmed.split(' ')[0]}** ${trimmed.slice(trimmed.indexOf(' ') + 1)}`;
  } else {
    return trimmed;
  }
}

function convertFeatureToMarkdown(featurePath) {
  const fileName = path.basename(featurePath, '.feature');
  const markdownPath = path.join(OUTPUT_DIR, `${fileName}.md`);

  const autoBlockStart = '<!-- AUTO-GENERATED START -->';
  const autoBlockEnd = '<!-- AUTO-GENERATED END -->';

  const lines = fs.readFileSync(featurePath, 'utf-8').split('\n');
  const formatted = lines.map(formatLine).join('\n\n');

  const autoContent = `${autoBlockStart}\n\n${formatted}\n\n${autoBlockEnd}`;

  let existingContent = '';
  if (fs.existsSync(markdownPath)) {
    existingContent = fs.readFileSync(markdownPath, 'utf-8');
  }

  let preservedContent = existingContent.split(autoBlockEnd)[1] || '';
  fs.writeFileSync(markdownPath, `${autoContent}${preservedContent}`, 'utf-8');

  console.log(
    ` Converted ${fileName}.feature  ${fileName}.md (preserving manual edits)`
  );
}

// Run on all .feature files
fs.readdirSync(FEATURE_DIR)
  .filter((file) => file.endsWith('.feature'))
  .forEach((file) => convertFeatureToMarkdown(path.join(FEATURE_DIR, file)));
</file>

<file path="global.d.ts">
// global.d.ts
import { PrismaClient } from '@prisma/client';

declare global {
  var prisma: PrismaClient | undefined;
}
</file>

<file path="instrumentation.ts">
import * as Sentry from '@sentry/nextjs';

export async function register() {
  if (process.env.NEXT_RUNTIME === 'nodejs') {
    await import('./sentry.server.config');
  }

  if (process.env.NEXT_RUNTIME === 'edge') {
    await import('./sentry.edge.config');
  }
}

export const onRequestError = Sentry.captureRequestError;
</file>

<file path="jest.config.js">
const nextJest = require('next/jest');

const createJestConfig = nextJest({
  // Chemin vers votre app Next.js
  dir: './',
});

const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testEnvironment: 'jest-environment-jsdom',
  moduleNameMapper: {
    // Gestion des alias de chemins de votre tsconfig.json
    '^@/(.*)$': '<rootDir>/$1',
  },
  // Configuration spcifique pour TypeScript
  // transform: {
  //   '^.+\\.(ts|tsx)$': ['ts-jest', {
  //     tsconfig: 'tsconfig.json',
  //   }],
  // },
  // Patterns des fichiers de test
  testMatch: ['**/__tests__/**/*.ts?(x)', '**/?(*.)+(spec|test).ts?(x)'],
  // Ignore e2e tests for Jest
  testPathIgnorePatterns: ['/node_modules/', '/tests/e2e/'],
  // Couverture de code
  collectCoverageFrom: [
    'app/**/*.{js,jsx,ts,tsx}',
    '!app/**/*.d.ts',
    '!app/**/_*.{js,jsx,ts,tsx}',
    '!app/**/*.stories.{js,jsx,ts,tsx}',
  ],
};

module.exports = createJestConfig(customJestConfig);
</file>

<file path="jest.setup.js">
import '@testing-library/jest-dom';

const { TextDecoder, TextEncoder } = require('util');
global.TextDecoder = TextDecoder;
global.TextEncoder = TextEncoder;

// Polyfill fetch API globals if your API handlers use fetch, Request, Response, Headers
const fetch = require('node-fetch');

global.fetch = fetch;
global.Request = fetch.Request;
global.Response = fetch.Response;
global.Headers = fetch.Headers;
</file>

<file path="jest.setup.ts">
import '@testing-library/jest-dom';
</file>

<file path="next.config.mjs">
import { withSentryConfig } from '@sentry/nextjs';

/** @type {import('next').NextConfig} */
const nextConfig = {
  env: {
    APP_ENV: process.env.NODE_ENV === 'production' ? 'production' : 'staging',
    // Explicitly include Stripe environment variables
    STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY,
    NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY:
      process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY,
    NEXT_PUBLIC_STRIPE_EARLY_ADOPTER_MONTHLY_PRICE_ID:
      process.env.NEXT_PUBLIC_STRIPE_EARLY_ADOPTER_MONTHLY_PRICE_ID,
    NEXT_PUBLIC_STRIPE_EARLY_ADOPTER_ANNUAL_PRICE_ID:
      process.env.NEXT_PUBLIC_STRIPE_EARLY_ADOPTER_ANNUAL_PRICE_ID,
  },
  // Add visual indicator for staging environment
  publicRuntimeConfig: {
    isStaging: process.env.NODE_ENV !== 'production',
  },
  // Image optimization for better icon loading performance
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: '*.supabase.co',
        port: '',
        pathname: '/storage/v1/object/**',
      },
      {
        protocol: 'https',
        hostname: 'cdn.brandfetch.io',
        port: '',
        pathname: '/**',
      },
    ],
    formats: ['image/webp', 'image/avif'],
    minimumCacheTTL: 86400, // Cache images for 24 hours
  },
  compiler: {
    styledComponents: true,
  },
  webpack: (config, { isServer }) => {
    // Ignore the swagger-jsdoc warning
    config.ignoreWarnings = [{ module: /swagger-jsdoc/ }];
    return config;
  },
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'X-Frame-Options',
            value: 'DENY', // Prevent embedding
          },
          {
            key: 'Content-Security-Policy',
            value: [
              "default-src 'self';",
              "script-src 'self' 'unsafe-inline' 'unsafe-eval' cdn.jsdelivr.net unpkg.com https://js.stripe.com https://media-editor.cloudinary.com https://js.hs-scripts.com http://js.hs-scripts.com https://eu-assets.i.posthog.com https://js.usemessages.com https://js.hs-analytics.net https://js.hs-banner.com https://js.hscollectedforms.net https://www.youtube.com https://va.vercel-scripts.com https://vercel.live;",
              "worker-src 'self' blob: data:;",
              "style-src 'self' 'unsafe-inline' data: fonts.googleapis.com;", // Tailwind JIT & Google Fonts & data: for TUI
              "img-src 'self' data: blob: https: http://i.ytimg.com https://i.ytimg.com;", // allow images from any HTTPS source and YouTube thumbnails
              "font-src 'self' fonts.gstatic.com;",
              "connect-src 'self' https://*.supabase.co https://js.stripe.com https://api.stripe.com https://eu.i.posthog.com https://eu-assets.i.posthog.com https://api.hubspot.com https://forms.hscollectedforms.net;",
              "frame-src 'self' https://js.stripe.com https://app.hubspot.com https://www.youtube.com https://www.youtube-nocookie.com https://vercel.live;", // allow Stripe, HubSpot, YouTube, and Vercel Live iframes
              "object-src 'none';",
              "base-uri 'self';",
              "frame-ancestors 'none';", // CSP way to prevent embedding
              "media-src 'self' https://www.youtube.com https://www.youtube-nocookie.com;",
            ].join(' '),
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff', // Prevent MIME type sniffing
          },
          {
            key: 'Referrer-Policy',
            value: 'strict-origin-when-cross-origin', // Privacy-safe referrer
          },
          {
            key: 'Strict-Transport-Security',
            value: 'max-age=63072000; includeSubDomains; preload', // HSTS
          },
          {
            key: 'Permissions-Policy',
            value: 'camera=(), microphone=(), geolocation=()', // Disable unused browser features
          },
          {
            key: 'Cross-Origin-Opener-Policy',
            value: 'same-origin',
          },
        ],
      },
    ];
  },
};

export default withSentryConfig(nextConfig, {
  // Sentry organization and project
  org: 'pf-5j',
  project: 'processflow',

  // Only print logs for uploading source maps in CI
  silent: !process.env.CI,

  // Upload a larger set of source maps for prettier stack traces (increases build time)
  widenClientFileUpload: true,

  // Automatically annotate React components to show their full name in breadcrumbs and session replay
  reactComponentAnnotation: {
    enabled: true,
  },

  // Route browser requests to Sentry through a Next.js rewrite to circumvent ad-blockers.
  // This can increase your server load as well as your hosting bill.
  // Note: Check that the configured route will not match with your Next.js middleware, otherwise reporting of client-side errors will fail.
  tunnelRoute: '/monitoring',

  // Hides source maps from generated client bundles
  hideSourceMaps: true,

  // Automatically tree-shake Sentry logger statements to reduce bundle size
  disableLogger: true,

  // Enables automatic instrumentation of Vercel Cron Monitors. (Does not yet work with App Router route handlers.)
  // See the following for more information:
  // https://docs.sentry.io/product/crons/
  // https://vercel.com/docs/cron-jobs
  automaticVercelMonitors: true,
});
</file>

<file path="playwright.config.ts">
// playwright.config.ts
import { defineConfig } from '@playwright/test';

export default defineConfig({
  testDir: './tests/e2e', // only run tests in this folder
  timeout: 30 * 1000,
  retries: 0,
  use: {
    headless: true,
    baseURL: 'http://localhost:3000', // adjust to your app
    viewport: { width: 1280, height: 720 },
  },
});
</file>

<file path="postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.

## Accder aux workflows

http://localhost:3000/workspace/2

Bug  noter : la sidebar ne s'affiche pas lorsqu'il n'y a aucun bloc dans le workflow
</file>

<file path="sentry.client.config.ts">
// This file configures the initialization of Sentry on the client.
// The config you add here will be used whenever a users loads a page in their browser.
// https://docs.sentry.io/platforms/javascript/guides/nextjs/

import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: "https://44626799eb3705f48c15304ea7915494@o4508738869788672.ingest.de.sentry.io/4508738871623760",

  // Dsactive la collecte des spans en mode dveloppement (client)
  tracesSampler: (samplingContext) => {
    if (process.env.NODE_ENV === "development") {
      return 0;
    }
    return 1;
  },

  //

  debug: false,
});
</file>

<file path="sentry.edge.config.ts">
// This file configures the initialization of Sentry for edge features (middleware, edge routes, and so on).
// The config you add here will be used whenever one of the edge features is loaded.
// Note that this config is unrelated to the Vercel Edge Runtime and is also required when running locally.
// https://docs.sentry.io/platforms/javascript/guides/nextjs/

import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: "https://44626799eb3705f48c15304ea7915494@o4508738869788672.ingest.de.sentry.io/4508738871623760",

  // Dsactive la collecte des spans en mode dveloppement (edge)
  tracesSampler: (samplingContext) => {
    if (process.env.NODE_ENV === "development") {
      return 0;
    }
    return 1;
  },

  debug: false,
});
</file>

<file path="sentry.server.config.ts">
// This file configures the initialization of Sentry on the server.
// The config you add here will be used whenever the server handles a request.
// https://docs.sentry.io/platforms/javascript/guides/nextjs/

import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: "https://44626799eb3705f48c15304ea7915494@o4508738869788672.ingest.de.sentry.io/4508738871623760",

  // Define how likely traces are sampled. Adjust this value in production, or use tracesSampler for greater control.
  tracesSampleRate: 1,

  // Setting this option to true will print useful information to the console while you're setting up Sentry.
  debug: false,
});
</file>

<file path="tailwind.config.ts">
import type { Config } from 'tailwindcss';
import { PluginAPI } from 'tailwindcss/types/config';

const myTheme = require('./theme');

const config: Config = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './src/**/*.{js,jsx,ts,tsx}',
    // Add the regex to scan dynamic class strings
    {
      raw: `
        cn('font-medium', 'text-sm'); // Example usage
        cn('text-gray-600', 'bg-red-500');
      `,
      extension: 'js',
    },
  ],
  darkMode: 'class',
  theme: {
    extend: {
      colors: myTheme.colors,
      fontSize: myTheme.colors.fontSize,
      boxShadow: myTheme.colors.boxShadow,
      borderRadius: myTheme.colors.borderRadius,
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic':
          'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
      fontFamily: {
        sans: ['Inter', 'sans-serif'], // Default 'sans' is now Inter
      },
      spacing: myTheme.spacing,
      backgroundColor: {
        'primary-button': 'var(--button-primary-bg)',
        'primary-button-hover': 'var(--button-primary-bg-hover)',
        'secondary-button': 'var(--button-secondary-bg)',
        'secondary-button-hover': 'var(--button-secondary-bg-hover)',
        // ... add other button backgrounds
      },
      textColor: {
        'primary-button-text': 'var(--button-primary-fg)',
        'secondary-button-text': 'var(--button-secondary-fg)',
        'secondary-button-text-hover': 'var(--button-secondary-fg-hover)',
        // ... add other text colors
      },
      borderColor: {
        'primary-button': 'var(--button-primary-border)',
        'secondary-button': 'var(--button-secondary-border)',
        // ... add other border colors
      },
    },
  },
  variants: {
    extend: {
      borderColor: ['focus'],
    },
  },
  plugins: [
    function (api: PluginAPI) {
      const { addUtilities } = api;
      addUtilities({
        '.hide-scrollbar': {
          'scrollbar-width': 'none', /* For Firefox */
          '-ms-overflow-style': 'none', /* For Internet Explorer and Edge */
        },
        '.hide-scrollbar::-webkit-scrollbar': {
          display: 'none', /* For Chrome, Safari, and Edge */
        },
        '.resize-x': {
          resize: 'horizontal',
          overflow: 'auto', // Ensure the content can overflow
        },
        '.custom-border-left-top': {
          position: 'relative',
        },
        '.custom-border-left-top::before': {
          content: '""',
          position: 'absolute',
          top: '-80px',
          left: '50%',
          width: '3px',
          height: 'calc(10% + 80px)',
          backgroundColor: '#98A2B3',
          borderTopLeftRadius: '100px',
          borderBottomLeftRadius: '100px',
          zIndex: '-1',
        },
        '.custom-border-left-top::after': {
          content: '""',
          position: 'absolute',
          top: '-80px',
          left: '50%',
          width: 'calc(50% + 240px)',
          height: '2px',
          backgroundColor: '#98A2B3',
          borderTopLeftRadius: '100px',
          borderTopRightRadius: '100px',
          zIndex: '-1',
        },
        '.custom-border-right-top': {
          position: 'relative',
        },
        '.custom-border-right-top::before': {
          content: '""',
          position: 'absolute',
          top: '-80px',
          right: '50%',
          width: '2px',
          height: 'calc(10% + 80px)',
          backgroundColor: '#98A2B3',
          borderTopRightRadius: '100px',
          borderBottomRightRadius: '100px',
          zIndex: '-1',
        },
        '.custom-border-right-top::after': {
          content: '""',
          position: 'absolute',
          top: '-80px',
          right: '50%',
          width: 'calc(50% + 240px)',
          height: '2px',
          backgroundColor: '#98A2B3',
          borderTopLeftRadius: '100px',
          borderTopRightRadius: '100px',
          zIndex: '-1',
        },
        '.custom-border-middle-top': {
          position: 'relative',
        },
        '.custom-border-middle-top::after': {
          content: '""',
          position: 'absolute',
          top: '-80px',
          left: '0',
          width: 'calc(100% + 240px)' /* Full width */,
          height: '2px',
          backgroundColor: '#98A2B3',
          borderTopLeftRadius: '100px',
          borderTopRightRadius: '100px',
          zIndex: '-1',
        },
        '.custom-border-middle-side': {
          position: 'relative',
        },
        '.custom-border-middle-side::before': {
          content: '""',
          position: 'absolute',
          top: '0px',
          left: '50%',
          transform: 'translateY(-50%)',
          width: '2px',
          height: 'calc(160px)',
          backgroundColor: '#98A2B3',
          borderTopLeftRadius: '100px',
          borderTopRightRadius: '100px',
          zIndex: '-1',
        },
      });
    },
  ],
};

export default config;
</file>

<file path="theme.js">
const theme = { colors: 
  { 'Base/White': '#ffffff',
     'Base/Black': '#000000',
     'Gray (light mode)/25': '#fcfcfd',
     'Gray (light mode)/50': '#f9fafb',
     'Gray (light mode)/100': '#f2f4f7',
     'Gray (light mode)/200': '#e4e7ec',
     'Gray (light mode)/300': '#d0d5dd',
     'Gray (light mode)/400': '#98a2b3',
     'Gray (light mode)/500': '#667085',
     'Gray (light mode)/600': '#475467',
     'Gray (light mode)/700': '#344054',
     'Gray (light mode)/800': '#182230',
     'Gray (light mode)/900': '#101828',
     'Gray (light mode)/950': '#0c111d',
     'Gray (dark mode)/25': '#fafafa',
     'Gray (dark mode)/50': '#f5f5f6',
     'Gray (dark mode)/100': '#f0f1f1',
     'Gray (dark mode)/200': '#ececed',
     'Gray (dark mode)/300': '#cecfd2',
     'Gray (dark mode)/400': '#94969c',
     'Gray (dark mode)/500': '#85888e',
     'Gray (dark mode)/600': '#61646c',
     'Gray (dark mode)/700': '#333741',
     'Gray (dark mode)/800': '#1f242f',
     'Gray (dark mode)/900': '#161b26',
     'Gray (dark mode)/950': '#0c111d',
     'Brand/25': '#f4f6fe',
     'Brand/50': '#edf0fb',
     'Brand/100': '#c8d1f3',
     'Brand/200': '#aebbed',
     'Brand/300': '#889ce4',
     'Brand/400': '#7189df',
     'Brand/500': '#4e6bd7',
     'Brand/600': '#4761c4',
     'Brand/700': '#374c99',
     'Brand/800': '#2b3b76',
     'Brand/900': '#202e62',
     'Brand/950': '#132154',
     'Error/25': '#fffbfa',
     'Error/50': '#fef3f2',
     'Error/100': '#fee4e2',
     'Error/200': '#fecdca',
     'Error/300': '#fda29b',
     'Error/400': '#f97066',
     'Error/500': '#f04438',
     'Error/600': '#d92d20',
     'Error/700': '#b42318',
     'Error/800': '#912018',
     'Error/900': '#7a271a',
     'Error/950': '#55160c',
     'Warning/25': '#fffcf5',
     'Warning/50': '#fffaeb',
     'Warning/100': '#fef0c7',
     'Warning/200': '#fedf89',
     'Warning/300': '#fec84b',
     'Warning/400': '#fdb022',
     'Warning/500': '#f79009',
     'Warning/600': '#dc6803',
     'Warning/700': '#b54708',
     'Warning/800': '#93370d',
     'Warning/900': '#7a2e0e',
     'Warning/950': '#4e1d09',
     'Success/25': '#f6fef9',
     'Success/50': '#ecfdf3',
     'Success/100': '#dcfae6',
     'Success/200': '#abefc6',
     'Success/300': '#75e0a7',
     'Success/400': '#47cd89',
     'Success/500': '#17b26a',
     'Success/600': '#079455',
     'Success/700': '#067647',
     'Success/800': '#085d3a',
     'Success/900': '#074d31',
     'Success/950': '#053321',
     'Gray blue/25': '#fcfcfd',
     'Gray blue/50': '#f8f9fc',
     'Gray blue/100': '#eaecf5',
     'Gray blue/200': '#d5d9eb',
     'Gray blue/300': '#b3b8db',
     'Gray blue/400': '#717bbc',
     'Gray blue/500': '#4e5ba6',
     'Gray blue/600': '#3e4784',
     'Gray blue/700': '#363f72',
     'Gray blue/800': '#293056',
     'Gray blue/900': '#101323',
     'Gray blue/950': '#0d0f1c',
     'Gray cool/25': '#fcfcfd',
     'Gray cool/50': '#f9f9fb',
     'Gray cool/100': '#eff1f5',
     'Gray cool/200': '#dcdfea',
     'Gray cool/300': '#b9c0d4',
     'Gray cool/400': '#7d89b0',
     'Gray cool/500': '#5d6b98',
     'Gray cool/600': '#4a5578',
     'Gray cool/700': '#404968',
     'Gray cool/800': '#30374f',
     'Gray cool/900': '#111322',
     'Gray cool/950': '#0e101b',
     'Gray modern/25': '#fcfcfd',
     'Gray modern/50': '#f8fafc',
     'Gray modern/100': '#eef2f6',
     'Gray modern/200': '#e3e8ef',
     'Gray modern/300': '#cdd5df',
     'Gray modern/400': '#9aa4b2',
     'Gray modern/500': '#697586',
     'Gray modern/600': '#4b5565',
     'Gray modern/700': '#364152',
     'Gray modern/800': '#202939',
     'Gray modern/900': '#121926',
     'Gray modern/950': '#0d121c',
     'Gray neutral/25': '#fcfcfd',
     'Gray neutral/50': '#f9fafb',
     'Gray neutral/100': '#f3f4f6',
     'Gray neutral/200': '#e5e7eb',
     'Gray neutral/300': '#d2d6db',
     'Gray neutral/400': '#9da4ae',
     'Gray neutral/500': '#6c737f',
     'Gray neutral/600': '#4d5761',
     'Gray neutral/700': '#384250',
     'Gray neutral/800': '#1f2a37',
     'Gray neutral/900': '#111927',
     'Gray neutral/950': '#0d121c',
     'Gray iron/25': '#fcfcfc',
     'Gray iron/50': '#fafafa',
     'Gray iron/100': '#f4f4f5',
     'Gray iron/200': '#e4e4e7',
     'Gray iron/300': '#d1d1d6',
     'Gray iron/400': '#a0a0ab',
     'Gray iron/500': '#70707b',
     'Gray iron/600': '#51525c',
     'Gray iron/700': '#3f3f46',
     'Gray iron/800': '#26272b',
     'Gray iron/900': '#1a1a1e',
     'Gray iron/950': '#131316',
     'Gray true/25': '#fcfcfc',
     'Gray true/50': '#f7f7f7',
     'Gray true/100': '#f5f5f5',
     'Gray true/200': '#e5e5e5',
     'Gray true/300': '#d6d6d6',
     'Gray true/400': '#a3a3a3',
     'Gray true/500': '#737373',
     'Gray true/600': '#525252',
     'Gray true/700': '#424242',
     'Gray true/800': '#292929',
     'Gray true/900': '#141414',
     'Gray true/950': '#0f0f0f',
     'Gray warm/25': '#fdfdfc',
     'Gray warm/50': '#fafaf9',
     'Gray warm/100': '#f5f5f4',
     'Gray warm/200': '#e7e5e4',
     'Gray warm/300': '#d7d3d0',
     'Gray warm/400': '#a9a29d',
     'Gray warm/500': '#79716b',
     'Gray warm/600': '#57534e',
     'Gray warm/700': '#44403c',
     'Gray warm/800': '#292524',
     'Gray warm/900': '#1c1917',
     'Gray warm/950': '#171412',
     'Moss/25': '#fafdf7',
     'Moss/50': '#f5fbee',
     'Moss/100': '#e6f4d7',
     'Moss/200': '#ceeab0',
     'Moss/300': '#acdc79',
     'Moss/400': '#86cb3c',
     'Moss/500': '#669f2a',
     'Moss/600': '#4f7a21',
     'Moss/700': '#3f621a',
     'Moss/800': '#335015',
     'Moss/900': '#2b4212',
     'Moss/950': '#1a280b',
     'Green light/25': '#fafef5',
     'Green light/50': '#f3fee7',
     'Green light/100': '#e3fbcc',
     'Green light/200': '#d0f8ab',
     'Green light/300': '#a6ef67',
     'Green light/400': '#85e13a',
     'Green light/500': '#66c61c',
     'Green light/600': '#4ca30d',
     'Green light/700': '#3b7c0f',
     'Green light/800': '#326212',
     'Green light/900': '#2b5314',
     'Green light/950': '#15290a',
     'Green/25': '#f6fef9',
     'Green/50': '#edfcf2',
     'Green/100': '#d3f8df',
     'Green/200': '#aaf0c4',
     'Green/300': '#73e2a3',
     'Green/400': '#3ccb7f',
     'Green/500': '#16b364',
     'Green/600': '#099250',
     'Green/700': '#087443',
     'Green/800': '#095c37',
     'Green/900': '#084c2e',
     'Green/950': '#052e1c',
     'Teal/25': '#f6fefc',
     'Teal/50': '#f0fdf9',
     'Teal/100': '#ccfbef',
     'Teal/200': '#99f6e0',
     'Teal/300': '#5fe9d0',
     'Teal/400': '#2ed3b7',
     'Teal/500': '#15b79e',
     'Teal/600': '#0e9384',
     'Teal/700': '#107569',
     'Teal/800': '#125d56',
     'Teal/900': '#134e48',
     'Teal/950': '#0a2926',
     'Cyan/25': '#f5feff',
     'Cyan/50': '#ecfdff',
     'Cyan/100': '#cff9fe',
     'Cyan/200': '#a5f0fc',
     'Cyan/300': '#67e3f9',
     'Cyan/400': '#22ccee',
     'Cyan/500': '#06aed4',
     'Cyan/600': '#088ab2',
     'Cyan/700': '#0e7090',
     'Cyan/800': '#155b75',
     'Cyan/900': '#164c63',
     'Cyan/950': '#0d2d3a',
     'Blue light/25': '#f5fbff',
     'Blue light/50': '#f0f9ff',
     'Blue light/100': '#e0f2fe',
     'Blue light/200': '#b9e6fe',
     'Blue light/300': '#7cd4fd',
     'Blue light/400': '#36bffa',
     'Blue light/500': '#0ba5ec',
     'Blue light/600': '#0086c9',
     'Blue light/700': '#026aa2',
     'Blue light/800': '#065986',
     'Blue light/900': '#0b4a6f',
     'Blue light/950': '#062c41',
     'Blue/25': '#f5faff',
     'Blue/50': '#eff8ff',
     'Blue/100': '#d1e9ff',
     'Blue/200': '#b2ddff',
     'Blue/300': '#84caff',
     'Blue/400': '#53b1fd',
     'Blue/500': '#2e90fa',
     'Blue/600': '#1570ef',
     'Blue/700': '#175cd3',
     'Blue/800': '#1849a9',
     'Blue/900': '#194185',
     'Blue/950': '#102a56',
     'Blue dark/25': '#f5f8ff',
     'Blue dark/50': '#eff4ff',
     'Blue dark/100': '#d1e0ff',
     'Blue dark/200': '#b2ccff',
     'Blue dark/300': '#84adff',
     'Blue dark/400': '#528bff',
     'Blue dark/500': '#2970ff',
     'Blue dark/600': '#155eef',
     'Blue dark/700': '#004eeb',
     'Blue dark/800': '#0040c1',
     'Blue dark/900': '#00359e',
     'Blue dark/950': '#002266',
     'Indigo/25': '#f5f8ff',
     'Indigo/50': '#eef4ff',
     'Indigo/100': '#e0eaff',
     'Indigo/200': '#c7d7fe',
     'Indigo/300': '#a4bcfd',
     'Indigo/400': '#8098f9',
     'Indigo/500': '#6172f3',
     'Indigo/600': '#444ce7',
     'Indigo/700': '#3538cd',
     'Indigo/800': '#2d31a6',
     'Indigo/900': '#2d3282',
     'Indigo/950': '#1f235b',
     'Violet/25': '#fbfaff',
     'Violet/50': '#f5f3ff',
     'Violet/100': '#ece9fe',
     'Violet/200': '#ddd6fe',
     'Violet/300': '#c3b5fd',
     'Violet/400': '#a48afb',
     'Violet/500': '#875bf7',
     'Violet/600': '#7839ee',
     'Violet/700': '#6927da',
     'Violet/800': '#5720b7',
     'Violet/900': '#491c96',
     'Violet/950': '#2e125e',
     'Purple/25': '#fafaff',
     'Purple/50': '#f4f3ff',
     'Purple/100': '#ebe9fe',
     'Purple/200': '#d9d6fe',
     'Purple/300': '#bdb4fe',
     'Purple/400': '#9b8afb',
     'Purple/500': '#7a5af8',
     'Purple/600': '#6938ef',
     'Purple/700': '#5925dc',
     'Purple/800': '#4a1fb8',
     'Purple/900': '#3e1c96',
     'Purple/950': '#27115f',
     'Fuchsia/25': '#fefaff',
     'Fuchsia/50': '#fdf4ff',
     'Fuchsia/100': '#fbe8ff',
     'Fuchsia/200': '#f6d0fe',
     'Fuchsia/300': '#eeaafd',
     'Fuchsia/400': '#e478fa',
     'Fuchsia/500': '#d444f1',
     'Fuchsia/600': '#ba24d5',
     'Fuchsia/700': '#9f1ab1',
     'Fuchsia/800': '#821890',
     'Fuchsia/900': '#6f1877',
     'Fuchsia/950': '#47104c',
     'Pink/25': '#fef6fb',
     'Pink/50': '#fdf2fa',
     'Pink/100': '#fce7f6',
     'Pink/200': '#fcceee',
     'Pink/300': '#faa7e0',
     'Pink/400': '#f670c7',
     'Pink/500': '#ee46bc',
     'Pink/600': '#dd2590',
     'Pink/700': '#c11574',
     'Pink/800': '#9e165f',
     'Pink/900': '#851651',
     'Pink/950': '#4e0d30',
     'Ros/25': '#fff5f6',
     'Ros/50': '#fff1f3',
     'Ros/100': '#ffe4e8',
     'Ros/200': '#fecdd6',
     'Ros/300': '#fea3b4',
     'Ros/400': '#fd6f8e',
     'Ros/500': '#f63d68',
     'Ros/600': '#e31b54',
     'Ros/700': '#c01048',
     'Ros/800': '#a11043',
     'Ros/900': '#89123e',
     'Ros/950': '#510b24',
     'Orange dark/25': '#fff9f5',
     'Orange dark/50': '#fff4ed',
     'Orange dark/100': '#ffe6d5',
     'Orange dark/200': '#ffd6ae',
     'Orange dark/300': '#ff9c66',
     'Orange dark/400': '#ff692e',
     'Orange dark/500': '#ff4405',
     'Orange dark/600': '#e62e05',
     'Orange dark/700': '#bc1b06',
     'Orange dark/800': '#97180c',
     'Orange dark/900': '#771a0d',
     'Orange dark/950': '#57130a',
     'Orange/25': '#fefaf5',
     'Orange/50': '#fef6ee',
     'Orange/100': '#fdead7',
     'Orange/200': '#f9dbaf',
     'Orange/300': '#f7b27a',
     'Orange/400': '#f38744',
     'Orange/500': '#ef6820',
     'Orange/600': '#e04f16',
     'Orange/700': '#b93815',
     'Orange/800': '#932f19',
     'Orange/900': '#772917',
     'Orange/950': '#511c10',
     'Yellow/25': '#fefdf0',
     'Yellow/50': '#fefbe8',
     'Yellow/100': '#fef7c3',
     'Yellow/200': '#feee95',
     'Yellow/300': '#fde272',
     'Yellow/400': '#fac515',
     'Yellow/500': '#eaaa08',
     'Yellow/600': '#ca8504',
     'Yellow/700': '#a15c07',
     'Yellow/800': '#854a0e',
     'Yellow/900': '#713b12',
     'Yellow/950': '#542c0d' },
  fontSize: 
   { xs: '0.75rem',
     sm: '0.875rem',
     base: '1rem',
     lg: '1.125rem',
     xl: '1.25rem',
     '2xl': '1.5rem',
     '3xl': '1.875rem',
     '4xl': '2.25rem',
     '5xl': '3rem',
     '6xl': '3.75rem',
     '7xl': '4.5rem' },
  fontFamily: { inter: 'Inter' },
  boxShadow: 
   { 'Shadows/shadow-xs': '0px 1px 2px 0px rgba(16,24,40,0.05)',
     'Shadows/shadow-xs-skeuomorphic': '0px 1px 2px 0px rgba(16,24,40,0.05), inset 0px -2px 0px 0px rgba(16,24,40,0.05), inset 0px 0px 0px 1px rgba(16,24,40,0.18)',
     'Shadows/shadow-sm': '0px 1px 2px 0px rgba(16,24,40,0.06), 0px 1px 3px 0px rgba(16,24,40,0.1)',
     'Shadows/shadow-md': '0px 2px 4px -2px rgba(16,24,40,0.06), 0px 4px 8px -2px rgba(16,24,40,0.1)',
     'Shadows/shadow-lg': '0px 4px 6px -2px rgba(16,24,40,0.03), 0px 12px 16px -4px rgba(16,24,40,0.08)',
     'Shadows/shadow-xl': '0px 8px 8px -4px rgba(16,24,40,0.03), 0px 20px 24px -4px rgba(16,24,40,0.08)',
     'Shadows/shadow-2xl': '0px 24px 48px -12px rgba(16,24,40,0.18)',
     'Shadows/shadow-3xl': '0px 32px 64px -12px rgba(16,24,40,0.14)',
     'Shadows/Portfolio mockups/shadow-main-centre-md': '0px 75px 150px 0px rgba(16,24,40,0.14)',
     'Shadows/Portfolio mockups/shadow-main-centre-lg': '0px 100px 200px 0px rgba(16,24,40,0.18)',
     'Shadows/Portfolio mockups/shadow-overlay-right-lg': '-40px 40px 72px 0px rgba(16,24,40,0.12)',
     'Shadows/Portfolio mockups/shadow-overlay-left-lg': '100px 100px 150px 0px rgba(16,24,40,0.12)',
     'Shadows/Portfolio mockups/shadow-grid-md': '32px 32px 64px 0px rgba(16,24,40,0.08)',
     'Focus rings/focus-ring': '0px 0px 0px 4px rgba(78,107,215,1), 0px 0px 0px 2px rgba(255,255,255,1)',
     'Focus rings/focus-ring-shadow-xs': '0px 0px 0px 4px rgba(78,107,215,1), 0px 0px 0px 2px rgba(255,255,255,1), 0px 1px 2px 0px rgba(16,24,40,0.05)',
     'Focus rings/focus-ring-shadow-xs-skeuomorphic': '0px 0px 0px 4px rgba(78,107,215,1), 0px 0px 0px 2px rgba(255,255,255,1), 0px 1px 2px 0px rgba(16,24,40,0.05), inset 0px -2px 0px 0px rgba(16,24,40,0.05), inset 0px 0px 0px 1px rgba(16,24,40,0.18)',
     'Focus rings/focus-ring-shadow-sm': '0px 0px 0px 4px rgba(78,107,215,1), 0px 0px 0px 2px rgba(255,255,255,1), 0px 1px 2px 0px rgba(16,24,40,0.06), 0px 1px 3px 0px rgba(16,24,40,0.1)',
     'Focus rings/focus-ring-error': '0px 0px 0px 4px rgba(240,68,56,1), 0px 0px 0px 2px rgba(255,255,255,1)',
     'Focus rings/focus-ring-error-shadow-xs': '0px 0px 0px 4px rgba(240,68,56,1), 0px 0px 0px 2px rgba(255,255,255,1), 0px 1px 2px 0px rgba(16,24,40,0.05)',
     'Focus rings/focus-ring-error-shadow-xs-skeuomorphic': '0px 0px 0px 4px rgba(240,68,56,1), 0px 0px 0px 2px rgba(255,255,255,1), 0px 1px 2px 0px rgba(16,24,40,0.05), inset 0px -2px 0px 0px rgba(16,24,40,0.05), inset 0px 0px 0px 1px rgba(16,24,40,0.18)',
     'Backdrop blurs/backdrop-blur-sm': '',
     'Backdrop blurs/backdrop-blur-md': '',
     'Backdrop blurs/backdrop-blur-lg': '',
     'Backdrop blurs/backdrop-blur-xl': '' },
  borderRadius: 
   { 'rounded-0': '0rem',
     'rounded-1': '0.020000001415610313rem',
     'rounded-2': '0.02500000223517418rem',
     'rounded-3': '0.03125rem',
     'rounded-4': '0.0369623638689518rem',
     'rounded-5': '0.04864433407783508rem',
     'rounded-6': '0.05342902988195419rem',
     'rounded-7': '0.056618817150592804rem',
     'rounded-8': '0.0625rem',
     'rounded-9': '0.06259781122207642rem',
     'rounded-10': '0.078125rem',
     'rounded-11': '0.0833333358168602rem',
     'rounded-12': '0.0842423364520073rem',
     'rounded-13': '0.09728866815567017rem',
     'rounded-14': '0.1041666716337204rem',
     'rounded-15': '0.10685805976390839rem',
     'rounded-16': '0.11323763430118561rem',
     'rounded-17': '0.11660447716712952rem',
     'rounded-18': '0.125rem',
     'rounded-19': '0.12519562244415283rem',
     'rounded-20': '0.13129015266895294rem',
     'rounded-21': '0.1384785771369934rem',
     'rounded-22': '0.140625rem',
     'rounded-23': '0.146484375rem',
     'rounded-24': '0.151162788271904rem',
     'rounded-25': '0.1645437479019165rem',
     'rounded-26': '0.16483516991138458rem',
     'rounded-27': '0.1666666716337204rem',
     'rounded-28': '0.1748834252357483rem',
     'rounded-29': '0.1875rem',
     'rounded-30': '0.1973150074481964rem',
     'rounded-31': '0.19911029934883118rem',
     'rounded-32': '0.20469914376735687rem',
     'rounded-33': '0.20999209582805634rem',
     'rounded-34': '0.210608571767807rem',
     'rounded-35': '0.2130310982465744rem',
     'rounded-36': '0.2151898741722107rem',
     'rounded-37': '0.24690908193588257rem',
     'rounded-38': '0.25rem',
     'rounded-39': '0.2769571542739868rem',
     'rounded-40': '0.277777761220932rem',
     'rounded-41': '0.29695022106170654rem',
     'rounded-42': '0.3125rem',
     'rounded-43': '0.3195466697216034rem',
     'rounded-44': '0.329087495803833rem',
     'rounded-45': '0.32967033982276917rem',
     'rounded-46': '0.36441442370414734rem',
     'rounded-47': '0.3654019832611084rem',
     'rounded-48': '0.375rem',
     'rounded-49': '0.3792523443698883rem',
     'rounded-50': '0.39040514826774597rem',
     'rounded-51': '0.3925553858280182rem',
     'rounded-52': '0.3931660056114197rem',
     'rounded-53': '0.41604965925216675rem',
     'rounded-54': '0.4175247251987457rem',
     'rounded-55': '0.421875rem',
     'rounded-56': '0.42520320415496826rem',
     'rounded-57': '0.4365234375rem',
     'rounded-58': '0.4375rem',
     'rounded-59': '0.4375000298023224rem',
     'rounded-60': '0.4430379867553711rem',
     'rounded-61': '0.44929245114326477rem',
     'rounded-62': '0.453125rem',
     'rounded-63': '0.4534883499145508rem',
     'rounded-64': '0.4666574001312256rem',
     'rounded-65': '0.46687498688697815rem',
     'rounded-66': '0.48711341619491577rem',
     'rounded-67': '0.491318017244339rem',
     'rounded-68': '0.4933195412158966rem',
     'rounded-69': '0.5rem',
     'rounded-70': '0.5056250095367432rem',
     'rounded-71': '0.5512499809265137rem',
     'rounded-72': '0.5553351640701294rem',
     'rounded-73': '0.5563187599182129rem',
     'rounded-74': '0.5625rem',
     'rounded-75': '0.6249999403953552rem',
     'rounded-76': '0.625rem',
     'rounded-77': '0.6394736766815186rem',
     'rounded-78': '0.6494845747947693rem',
     'rounded-79': '0.658174991607666rem',
     'rounded-80': '0.6593406796455383rem',
     'rounded-81': '0.6666666865348816rem',
     'rounded-82': '0.6875rem',
     'rounded-83': '0.6923076510429382rem',
     'rounded-84': '0.7288288474082947rem',
     'rounded-85': '0.75rem',
     'rounded-86': '0.7500000596046448rem',
     'rounded-87': '0.7762096524238586rem',
     'rounded-88': '0.8320993185043335rem',
     'rounded-89': '0.8333332538604736rem',
     'rounded-90': '0.84375rem',
     'rounded-91': '0.8437500596046448rem',
     'rounded-92': '0.8616728186607361rem',
     'rounded-93': '0.873046875rem',
     'rounded-94': '0.8744171261787415rem',
     'rounded-95': '0.890625rem',
     'rounded-96': '0.9530981183052063rem',
     'rounded-97': '0.9599999785423279rem',
     'rounded-98': '0.9865750074386597rem',
     'rounded-99': '0.9955514669418335rem',
     'rounded-100': '1rem',
     'rounded-101': '1.0234956741333008rem',
     'rounded-102': '1.0416666269302368rem',
     'rounded-103': '1.0499604940414429rem',
     'rounded-104': '1.0530428886413574rem',
     'rounded-105': '1.0546875rem',
     'rounded-106': '1.0759494304656982rem',
     'rounded-107': '1.125rem',
     'rounded-108': '1.1875rem',
     'rounded-109': '1.2147146463394165rem',
     'rounded-110': '1.2345454692840576rem',
     'rounded-111': '1.25rem',
     'rounded-112': '1.4296472072601318rem',
     'rounded-113': '1.4847511053085327rem',
     'rounded-114': '1.5rem',
     'rounded-115': '1.6666665077209473rem',
     'rounded-116': '1.75rem',
     'rounded-117': '1.797169804573059rem',
     'rounded-118': '1.875rem',
     'rounded-119': '1.8962616920471191rem',
     'rounded-120': '1.9375rem',
     'rounded-121': '1.9520257711410522rem',
     'rounded-122': '1.9627768993377686rem',
     'rounded-123': '1.9658300876617432rem',
     'rounded-124': '2rem',
     'rounded-125': '2.2151899337768555rem',
     'rounded-126': '2.25rem',
     'rounded-127': '2.4375rem',
     'rounded-128': '2.480860948562622rem',
     'rounded-129': '2.5rem',
     'rounded-130': '2.7248804569244385rem',
     'rounded-131': '2.78125rem',
     'rounded-132': '2.815732955932617rem',
     'rounded-133': '2.887559652328491rem',
     'rounded-134': '3rem',
     'rounded-135': '3.0579874515533447rem',
     'rounded-136': '3.125rem',
     'rounded-137': '3.15625rem',
     'rounded-138': '3.192488193511963rem',
     'rounded-139': '3.375rem',
     'rounded-140': '3.5rem',
     'rounded-141': '3.648324966430664rem',
     'rounded-142': '4rem',
     'rounded-143': '4.007176876068115rem',
     'rounded-144': '4.246411323547363rem',
     'rounded-145': '4.25rem',
     'rounded-146': '4.5625rem',
     'rounded-147': '4.694835662841797rem',
     'rounded-148': '4.757740497589111rem',
     'rounded-149': '4.839731216430664rem',
     'rounded-150': '5.104671955108643rem',
     'rounded-151': '5.315770626068115rem',
     'rounded-152': '5.633129596710205rem',
     'rounded-153': '5.9471755027771rem',
     'rounded-154': '6rem',
     'rounded-155': '6.082630634307861rem',
     'rounded-156': '62.4375rem' },
     
     spacing: {
      "container-padding-mobile": "16px",
      "container-padding-desktop": "32px",
      "container-max-width-desktop": "1280px",
      "spacing-none": "0px",
      "spacing-xxs": "2px",
      "spacing-xs": "4px",
      "spacing-sm": "6px",
      "spacing-md": "8px",
      "spacing-lg": "12px",
      "spacing-xl": "16px",
      "spacing-2xl": "20px",
      "spacing-3xl": "24px",
      "spacing-4xl": "32px",
      "spacing-5xl": "40px",
      "spacing-6xl": "48px",
      "spacing-7xl": "64px",
      "spacing-8xl": "80px",
      "spacing-9xl": "96px",
      "spacing-10xl": "128px",
      "spacing-11xl": "160px",
    },
    sizes: {
      "width-xxs": "320px",
      "width-xs": "384px",
      "width-sm": "480px",
      "width-md": "560px",
      "width-lg": "640px",
      "width-xl": "768px",
      "width-2xl": "1024px",
      "width-3xl": "1280px",
      "width-4xl": "1440px",
      "width-5xl": "1600px",
      "width-6xl": "1920px",
      "paragraph-max-width": "720px",
    },
    radius: {
      "radius-none": "0px",
      "radius-xxs": "2px",
      "radius-xs": "4px",
      "radius-sm": "6px",
      "radius-md": "8px",
      "radius-lg": "10px",
      "radius-xl": "12px",
      "radius-2xl": "16px",
      "radius-3xl": "20px",
      "radius-4xl": "24px",
      "radius-full": "9999px",
    },
    typography: {
      "font-family-display": "Inter",
      "font-family-body": "Inter",
      "font-weight-regular": "Regular",
      "font-weight-regular-italic": "Regular italic",
      "font-weight-medium": "Medium",
      "font-weight-medium-italic": "Medium italic",
      "font-weight-semibold": "Semibold",
      "font-weight-semibold-italic": "Semibold italic",
      "font-weight-bold": "Bold",
      "font-weight-bold-italic": "Bold italic",
      "text-xs": "12px",
      "text-sm": "14px",
      "text-md": "16px",
      "text-lg": "18px",
      "text-xl": "20px",
      "display-xs": "24px",
      "display-sm": "30px",
      "display-md": "36px",
      "display-lg": "48px",
      "display-xl": "60px",
      "display-2xl": "72px",
      "line-height-text-xs": "18px",
      "line-height-text-sm": "20px",
      "line-height-text-md": "24px",
      "line-height-text-lg": "28px",
      "line-height-text-xl": "30px",
      "line-height-display-xs": "32px",
      "line-height-display-sm": "38px",
      "line-height-display-md": "44px",
      "line-height-display-lg": "60px",
      "line-height-display-xl": "72px",
      "line-height-display-2xl": "90px",
    },
    
    };
     
        // LightMode Assignment
    theme.colors.lightMode = {
      "text-primary": theme.colors["Gray (light mode)/900"],
      "text-primary_on-brand": theme.colors["Base/White"],
      "text-secondary": theme.colors["Gray (light mode)/700"],
      "text-secondary_hover": theme.colors["Gray (light mode)/800"],
      "text-secondary_on-brand": theme.colors["Brand/200"],
      "text-tertiary": theme.colors["Gray (light mode)/600"],
      "text-tertiary_hover": theme.colors["Gray (light mode)/700"],
      "text-tertiary_on-brand": theme.colors["Brand/200"],
      "text-quaternary": theme.colors["Gray (light mode)/500"],
      "text-quaternary_on-brand": theme.colors["Brand/300"],
      "text-white": theme.colors["Base/White"],
      "text-disabled": theme.colors["Gray (light mode)/500"],
      "text-placeholder": theme.colors["Gray (light mode)/500"],
      "text-placeholder_subtle": theme.colors["Gray (light mode)/300"],
      "text-brand-primary": theme.colors["Brand/900"],
      "text-brand-secondary": theme.colors["Brand/700"],
      "text-brand-tertiary": theme.colors["Brand/600"],
      "text-brand-tertiary_alt": theme.colors["Brand/600"],
      "text-error-primary": theme.colors["Error/600"],
      "text-warning-primary": theme.colors["Warning/600"],
      "text-success-primary": theme.colors["Success/600"],
      
      // Borders
      "border-primary": theme.colors["Gray (light mode)/300"],
      "border-secondary": theme.colors["Gray (light mode)/200"],
      "border-tertiary": theme.colors["Gray (light mode)/100"],
      "border-disabled": theme.colors["Gray (light mode)/300"],
      "border-disabled_subtle": theme.colors["Gray (light mode)/200"],
      "border-brand": theme.colors["Brand/500"],
      "border-brand_alt": theme.colors["Brand/600"],
      "border-error": theme.colors["Error/500"],
      "border-error_subtle": theme.colors["Error/300"],

      // Foreground assignments
      "fg-primary": theme.colors["Gray (light mode)/900"],
      "fg-secondary": theme.colors["Gray (light mode)/700"],
      "fg-secondary_hover": theme.colors["Gray (light mode)/800"],
      "fg-tertiary": theme.colors["Gray (light mode)/600"],
      "fg-tertiary_hover": theme.colors["Gray (light mode)/700"],
      "fg-quaternary": theme.colors["Gray (light mode)/500"],
      "fg-quaternary_hover": theme.colors["Gray (light mode)/600"],
      "fg-quinary": theme.colors["Gray (light mode)/400"],
      "fg-quinary_hover": theme.colors["Gray (light mode)/500"],
      "fg-senary": theme.colors["Gray (light mode)/300"],
      "fg-white": theme.colors["Base/White"],
      "fg-disabled": theme.colors["Gray (light mode)/400"],
      "fg-disabled_subtle": theme.colors["Gray (light mode)/300"],
      "fg-brand-primary": theme.colors["Brand/600"],
      "fg-brand-primary_alt": theme.colors["Brand/600"],
      "fg-brand-secondary": theme.colors["Brand/500"],
      "fg-error-primary": theme.colors["Error/600"],
      "fg-error-secondary": theme.colors["Error/500"],
      "fg-warning-primary": theme.colors["Warning/600"],
      "fg-warning-secondary": theme.colors["Warning/500"],
      "fg-success-primary": theme.colors["Success/600"],
      "fg-success-secondary": theme.colors["Success/500"],

      // Background assignments
      "bg-primary": theme.colors["Base/White"],
      "bg-primary_alt": theme.colors["Base/White"],
      "bg-primary_hover": theme.colors["Gray (light mode)/100"],
      "bg-primary-solid": theme.colors["Gray (light mode)/950"],
      "bg-secondary": theme.colors["Gray (light mode)/50"],
      "bg-secondary_alt": theme.colors["Gray (light mode)/50"],
      "bg-secondary_hover": theme.colors["Gray (light mode)/100"],
      "bg-secondary_subtle": theme.colors["Gray (light mode)/25"],
      "bg-secondary-solid": theme.colors["Gray (light mode)/600"],
      "bg-tertiary": theme.colors["Gray (light mode)/100"],
      "bg-quaternary": theme.colors["Gray (light mode)/200"],
      "bg-active": theme.colors["Gray (light mode)/100"],
      "bg-disabled": theme.colors["Gray (light mode)/100"],
      "bg-disabled_subtle": theme.colors["Gray (light mode)/50"],
      "bg-overlay": theme.colors["Gray (light mode)/950"],
      "bg-brand-primary": theme.colors["Brand/50"],
      "bg-brand-primary_alt": theme.colors["Brand/50"],
      "bg-brand-secondary": theme.colors["Brand/100"],
      "bg-brand-solid": theme.colors["Brand/600"],
      "bg-brand-solid_hover": theme.colors["Brand/700"],
      "bg-brand-section": theme.colors["Brand/800"],
      "bg-brand-section_subtle": theme.colors["Brand/700"],
      "bg-error-primary": theme.colors["Error/50"],
      "bg-error-secondary": theme.colors["Error/100"],
      "bg-error-solid": theme.colors["Error/600"],
      "bg-warning-primary": theme.colors["Warning/50"],
      "bg-warning-secondary": theme.colors["Warning/100"],
      "bg-warning-solid": theme.colors["Warning/600"],
      "bg-success-primary": theme.colors["Success/50"],
      "bg-success-secondary": theme.colors["Success/100"],
      "bg-success-solid": theme.colors["Success/600"],

          // Focus-ring assignments
      "focus-ring": theme.colors["Brand/500"],
      "focus-ring-error": theme.colors["Error/500"],

          // Shadow assignments
      "shadow-xs": "rgba(16, 24, 40, 0.05)",
      "shadow-sm_01": "rgba(16, 24, 40, 0.10)",
      "shadow-sm_02": "rgba(16, 24, 40, 0.06)",
      "shadow-md_01": "rgba(16, 24, 40, 0.10)",
      "shadow-md_02": "rgba(16, 24, 40, 0.06)",
      "shadow-lg_01": "rgba(16, 24, 40, 0.08)",
      "shadow-lg_02": "rgba(16, 24, 40, 0.03)",
      "shadow-xl_01": "rgba(16, 24, 40, 0.08)",
      "shadow-xl_02": "rgba(16, 24, 40, 0.03)",
      "shadow-2xl": "rgba(16, 24, 40, 0.18)",
      "shadow-3xl": "rgba(16, 24, 40, 0.14)",
      "shadow-skeumorphic-inner": "rgba(16, 24, 40, 0.05)",
      "shadow-skeumorphic-inner-border": "rgba(16, 24, 40, 0.18)",

      // Additional shadow assignments
      "shadow-main-centre-md": "rgba(16, 24, 40, 0.14)",
      "shadow-main-centre-lg": "rgba(16, 24, 40, 0.18)",
      "shadow-overlay-lg": "rgba(16, 24, 40, 0.12)",
      "shadow-grid-md": "rgba(16, 24, 40, 0.08)",

          // Alpha white and black assignments
      "alpha-white-10": "rgba(255, 255, 255, 0.10)",
      "alpha-white-20": "rgba(255, 255, 255, 0.20)",
      "alpha-white-30": "rgba(255, 255, 255, 0.30)",
      "alpha-white-40": "rgba(255, 255, 255, 0.40)",
      "alpha-white-50": "rgba(255, 255, 255, 0.50)",
      "alpha-white-60": "rgba(255, 255, 255, 0.60)",
      "alpha-white-70": "rgba(255, 255, 255, 0.70)",
      "alpha-white-80": "rgba(255, 255, 255, 0.80)",
      "alpha-white-90": "rgba(255, 255, 255, 0.90)",
      "alpha-white-100": "#ffffff",
      "alpha-black-10": "rgba(0, 0, 0, 0.10)",
      "alpha-black-20": "rgba(0, 0, 0, 0.20)",
      "alpha-black-30": "rgba(0, 0, 0, 0.30)",
      "alpha-black-40": "rgba(0, 0, 0, 0.40)",
      "alpha-black-50": "rgba(0, 0, 0, 0.50)",
      "alpha-black-60": "rgba(0, 0, 0, 0.60)",
      "alpha-black-70": "rgba(0, 0, 0, 0.70)",
      "alpha-black-80": "rgba(0, 0, 0, 0.80)",
      "alpha-black-90": "rgba(0, 0, 0, 0.90)",
      "alpha-black-100": "#000000",

          // Utility gray assignments
      "utility-gray-50": theme.colors["Gray (light mode)/50"],
      "utility-gray-100": theme.colors["Gray (light mode)/100"],
      "utility-gray-200": theme.colors["Gray (light mode)/200"],
      "utility-gray-300": theme.colors["Gray (light mode)/300"],
      "utility-gray-400": theme.colors["Gray (light mode)/400"],
      "utility-gray-500": theme.colors["Gray (light mode)/500"],
      "utility-gray-600": theme.colors["Gray (light mode)/600"],
      "utility-gray-700": theme.colors["Gray (light mode)/700"],
      "utility-gray-800": theme.colors["Gray (light mode)/800"],
      "utility-gray-900": theme.colors["Gray (light mode)/900"],
  
          // Utility brand assignments
      "utility-brand-50": theme.colors["Brand/50"],
      "utility-brand-50_alt": theme.colors["Brand/50"],
      "utility-brand-100": theme.colors["Brand/100"],
      "utility-brand-100_alt": theme.colors["Brand/100"],
      "utility-brand-200": theme.colors["Brand/200"],
      "utility-brand-200_alt": theme.colors["Brand/200"],
      "utility-brand-300": theme.colors["Brand/300"],
      "utility-brand-300_alt": theme.colors["Brand/300"],
      "utility-brand-400": theme.colors["Brand/400"],
      "utility-brand-400_alt": theme.colors["Brand/400"],
      "utility-brand-500": theme.colors["Brand/500"],
      "utility-brand-500_alt": theme.colors["Brand/500"],
      "utility-brand-600": theme.colors["Brand/600"],
      "utility-brand-600_alt": theme.colors["Brand/600"],
      "utility-brand-700": theme.colors["Brand/700"],
      "utility-brand-700_alt": theme.colors["Brand/700"],
      "utility-brand-800": theme.colors["Brand/800"],
      "utility-brand-800_alt": theme.colors["Brand/800"],
      "utility-brand-900": theme.colors["Brand/900"],
      "utility-brand-900_alt": theme.colors["Brand/900"],

         // Utility error assignments
      "utility-error-50": theme.colors["Error/50"],
      "utility-error-100": theme.colors["Error/100"],
      "utility-error-200": theme.colors["Error/200"],
      "utility-error-300": theme.colors["Error/300"],
      "utility-error-400": theme.colors["Error/400"],
      "utility-error-500": theme.colors["Error/500"],
      "utility-error-600": theme.colors["Error/600"],
      "utility-error-700": theme.colors["Error/700"],

          // Utility warning assignments
      "utility-warning-50": theme.colors["Warning/50"],
      "utility-warning-100": theme.colors["Warning/100"],
      "utility-warning-200": theme.colors["Warning/200"],
      "utility-warning-300": theme.colors["Warning/300"],
      "utility-warning-400": theme.colors["Warning/400"],
      "utility-warning-500": theme.colors["Warning/500"],
      "utility-warning-600": theme.colors["Warning/600"],
      "utility-warning-700": theme.colors["Warning/700"],

         // Utility success assignments
      "utility-success-50": theme.colors["Success/50"],
      "utility-success-100": theme.colors["Success/100"],
      "utility-success-200": theme.colors["Success/200"],
      "utility-success-300": theme.colors["Success/300"],
      "utility-success-400": theme.colors["Success/400"],
      "utility-success-500": theme.colors["Success/500"],
      "utility-success-600": theme.colors["Success/600"],
      "utility-success-700": theme.colors["Success/700"],

          // Utility gray-blue assignments
      "utility-gray-blue-50": theme.colors["Gray blue/50"],
      "utility-gray-blue-100": theme.colors["Gray blue/100"],
      "utility-gray-blue-200": theme.colors["Gray blue/200"],
      "utility-gray-blue-300": theme.colors["Gray blue/300"],
      "utility-gray-blue-400": theme.colors["Gray blue/400"],
      "utility-gray-blue-500": theme.colors["Gray blue/500"],
      "utility-gray-blue-600": theme.colors["Gray blue/600"],
      "utility-gray-blue-700": theme.colors["Gray blue/700"],

          // Utility blue-light assignments
      "utility-blue-light-50": theme.colors["Blue light/50"],
      "utility-blue-light-100": theme.colors["Blue light/100"],
      "utility-blue-light-200": theme.colors["Blue light/200"],
      "utility-blue-light-300": theme.colors["Blue light/300"],
      "utility-blue-light-400": theme.colors["Blue light/400"],
      "utility-blue-light-500": theme.colors["Blue light/500"],
      "utility-blue-light-600": theme.colors["Blue light/600"],
      "utility-blue-light-700": theme.colors["Blue light/700"],
    
          // Utility blue assignments
      "utility-blue-50": theme.colors["Blue/50"],
      "utility-blue-100": theme.colors["Blue/100"],
      "utility-blue-200": theme.colors["Blue/200"],
      "utility-blue-300": theme.colors["Blue/300"],
      "utility-blue-400": theme.colors["Blue/400"],
      "utility-blue-500": theme.colors["Blue/500"],
      "utility-blue-600": theme.colors["Blue/600"],
      "utility-blue-700": theme.colors["Blue/700"],

          // Utility blue-dark assignments
      "utility-blue-dark-50": theme.colors["Blue dark/50"],
      "utility-blue-dark-100": theme.colors["Blue dark/100"],
      "utility-blue-dark-200": theme.colors["Blue dark/200"],
      "utility-blue-dark-300": theme.colors["Blue dark/300"],
      "utility-blue-dark-400": theme.colors["Blue dark/400"],
      "utility-blue-dark-500": theme.colors["Blue dark/500"],
      "utility-blue-dark-600": theme.colors["Blue dark/600"],
      "utility-blue-dark-700": theme.colors["Blue dark/700"],

          // Utility indigo assignments
      "utility-indigo-50": theme.colors["Indigo/50"],
      "utility-indigo-100": theme.colors["Indigo/100"],
      "utility-indigo-200": theme.colors["Indigo/200"],
      "utility-indigo-300": theme.colors["Indigo/300"],
      "utility-indigo-400": theme.colors["Indigo/400"],
      "utility-indigo-500": theme.colors["Indigo/500"],
      "utility-indigo-600": theme.colors["Indigo/600"],
      "utility-indigo-700": theme.colors["Indigo/700"],
    
          // Utility purple assignments
      "utility-purple-50": theme.colors["Purple/50"],
      "utility-purple-100": theme.colors["Purple/100"],
      "utility-purple-200": theme.colors["Purple/200"],
      "utility-purple-300": theme.colors["Purple/300"],
      "utility-purple-400": theme.colors["Purple/400"],
      "utility-purple-500": theme.colors["Purple/500"],
      "utility-purple-600": theme.colors["Purple/600"],
      "utility-purple-700": theme.colors["Purple/700"],
      
          // Utility fuchsia assignments
      "utility-fuchsia-50": theme.colors["Fuchsia/50"],
      "utility-fuchsia-100": theme.colors["Fuchsia/100"],
      "utility-fuchsia-200": theme.colors["Fuchsia/200"],
      "utility-fuchsia-300": theme.colors["Fuchsia/300"],
      "utility-fuchsia-400": theme.colors["Fuchsia/400"],
      "utility-fuchsia-500": theme.colors["Fuchsia/500"],
      "utility-fuchsia-600": theme.colors["Fuchsia/600"],
      "utility-fuchsia-700": theme.colors["Fuchsia/700"],


           // Utility pink assignments
      "utility-pink-50": theme.colors["Pink/50"],
      "utility-pink-100": theme.colors["Pink/100"],
      "utility-pink-200": theme.colors["Pink/200"],
      "utility-pink-300": theme.colors["Pink/300"],
      "utility-pink-400": theme.colors["Pink/400"],
      "utility-pink-500": theme.colors["Pink/500"],
      "utility-pink-600": theme.colors["Pink/600"],
      "utility-pink-700": theme.colors["Pink/700"],
    
          // Utility orange-dark assignments
      "utility-orange-dark-50": theme.colors["Orange dark/50"],
      "utility-orange-dark-100": theme.colors["Orange dark/100"],
      "utility-orange-dark-200": theme.colors["Orange dark/200"],
      "utility-orange-dark-300": theme.colors["Orange dark/300"],
      "utility-orange-dark-400": theme.colors["Orange dark/400"],
      "utility-orange-dark-500": theme.colors["Orange dark/500"],
      "utility-orange-dark-600": theme.colors["Orange dark/600"],
      "utility-orange-dark-700": theme.colors["Orange dark/700"],


          // Utility orange assignments
      "utility-orange-50": theme.colors["Orange/50"],
      "utility-orange-100": theme.colors["Orange/100"],
      "utility-orange-200": theme.colors["Orange/200"],
      "utility-orange-300": theme.colors["Orange/300"],
      "utility-orange-400": theme.colors["Orange/400"],
      "utility-orange-500": theme.colors["Orange/500"],
      "utility-orange-600": theme.colors["Orange/600"],
      "utility-orange-700": theme.colors["Orange/700"],
  
          // App store badges
      "app-store-badge-border": "#a6a6a6",


          // Application navigation
      "nav-item-button-icon-fg": theme.colors["Gray (light mode)/500"],
      "nav-item-button-icon-fg_active": theme.colors["Gray (light mode)/700"],
      "nav-item-icon-fg": theme.colors["Gray (light mode)/500"],
      "nav-item-icon-fg_active": theme.colors["Gray (light mode)/500"],


          // Avatars
      "avatar-bg": theme.colors["Gray (light mode)/100"],
      "avatar-profile-photo-border": theme.colors["Base/white"],
      "avatar-contrast-border": "rgba(0, 0, 0, 0.08)",
      "avatar-styles-bg-neutral": "#e0e0e0",


          // Breadcrumbs
      "breadcrumb-fg": theme.colors["Gray (light mode)/600"],
      "breadcrumb-fg_hover": theme.colors["Gray (light mode)/700"],
      "breadcrumb-bg_hover": theme.colors["Gray (light mode)/50"],
      "breadcrumb-brand-fg_hover": theme.colors["Brand/700"],
      "breadcrumb-brand-bg_hover": theme.colors["Brand/50"],
      "breadcrumb-icon-fg": theme.colors["Gray (light mode)/500"],
      "breadcrumb-icon-fg_hover": theme.colors["Gray (light mode)/700"],
      "breadcrumb-brand-icon-fg_hover": theme.colors["Brand/700"],

    // Primary button assignments
      "button-primary-fg": theme.colors["Base/white"],
      "button-primary-fg_hover": theme.colors["Base/white"],
      "button-primary-bg": theme.colors["Brand/500"],
      "button-primary-bg_hover": theme.colors["Brand/700"],
  

    // Secondary button assignments
      "button-secondary-fg": theme.colors["Gray (light mode)/700"],
      "button-secondary-fg_hover": theme.colors["Gray (light mode)/800"],
      "button-secondary-bg": theme.colors["Base/white"],
      "button-secondary-bg_hover": theme.colors["Gray (light mode)/50"],
      "button-secondary-border": theme.colors["Gray (light mode)/300"],
      "button-secondary-border_hover": theme.colors["Gray (light mode)/300"],


    // Secondary color button assignments
      "button-secondary-color-fg": theme.colors["Brand/700"],
      "button-secondary-color-fg_hover": theme.colors["Brand/800"],
      "button-secondary-color-bg": theme.colors["Base/white"],
      "button-secondary-color-bg_hover": theme.colors["Brand/50"],
      "button-secondary-color-border": theme.colors["Brand/300"],
      "button-secondary-color-border_hover": theme.colors["Brand/300"],
  
    // Tertiary button assignments
      "button-tertiary-fg": theme.colors["Gray (light mode)/600"],
      "button-tertiary-fg_hover": theme.colors["Gray (light mode)/700"],
      "button-tertiary-bg_hover": theme.colors["Gray (light mode)/50"],

    // Tertiary color button assignments
      "button-tertiary-color-fg": theme.colors["Brand/700"],
      "button-tertiary-color-fg_hover": theme.colors["Brand/800"],
      "button-tertiary-color-bg_hover": theme.colors["Brand/50"],


    // Primary error button assignments
      "button-primary-error-fg": theme.colors["Base/white"],
      "button-primary-error-fg_hover": theme.colors["Base/white"],
      "button-primary-error-bg": theme.colors["Error/600"],
      "button-primary-error-bg_hover": theme.colors["Error/700"],


    // Secondary error button assignments
      "button-secondary-error-fg": theme.colors["Error/700"],
      "button-secondary-error-fg_hover": theme.colors["Error/800"],
      "button-secondary-error-bg": theme.colors["Base/white"],
      "button-secondary-error-bg_hover": theme.colors["Error/50"],
      "button-secondary-error-border": theme.colors["Error/300"],
      "button-secondary-error-border_hover": theme.colors["Error/300"],


    // Tertiary error button assignments
      "button-tertiary-error-fg": theme.colors["Error/700"],
      "button-tertiary-error-fg_hover": theme.colors["Error/800"],
      "button-tertiary-error-bg_hover": theme.colors["Error/50"],
  
    // Footer assignments
      "footer-button-fg": theme.colors["Brand/200"],
      "footer-button-fg_hover": theme.colors["Base/white"],
      "footer-badge-fg": theme.colors["Success/700"],
      "footer-badge-bg": theme.colors["Success/50"],
      "footer-badge-border": theme.colors["Success/200"],


    // Header sections assignments
      "header-abstract-50-bg": theme.colors["Brand/50"],
      "header-abstract-100-bg": theme.colors["Brand/100"],
      "header-abstract-200-bg": theme.colors["Brand/200"],
      "header-abstract-300-bg": theme.colors["Brand/300"],

    // Icon assignments
      "icon-fg-brand": theme.colors["Brand/600"],
      "icon-fg-brand_on-brand": theme.colors["Brand/200"],

      // Featured icons assignments

      // Light
      "featured-icon-light-fg-brand": theme.colors["Brand/600"],
      "featured-icon-light-fg-gray": theme.colors["Gray (light mode)/500"],
      "featured-icon-light-fg-error": theme.colors["Error/600"],
      "featured-icon-light-fg-warning": theme.colors["Warning/600"],
      "featured-icon-light-fg-success": theme.colors["Success/600"],
      
      // Dark
      "featured-icon-dark-fg-brand": theme.colors["Base/white"],
      "featured-icon-dark-fg-gray": theme.colors["Base/white"],
      "featured-icon-dark-fg-error": theme.colors["Base/white"],
      "featured-icon-dark-fg-warning": theme.colors["Base/white"],
      "featured-icon-dark-fg-success": theme.colors["Base/white"],

      // Modern
      "featured-icon-modern-border": theme.colors["Gray (light mode)/200"],


    // Social icons assignments
      "social-icon-fg-x": "#242e36",
      "social-icon-fg-instagram": "#000100",
      "social-icon-fg-apple": theme.colors["Base/black"],
      "social-icon-fg-github": theme.colors["Base/black"],
      "social-icon-fg-angellist": theme.colors["Base/black"],
      "social-icon-fg-tumblr": "#001935",

          // Mockups assignments
      "screen-mockup-border": theme.colors["Gray (light mode)/900"],

    // Sliders assignments
      "slider-handle-bg": theme.colors["Base/white"],
      "slider-handle-border": theme.colors["Brand/600"],

    // Thumbnail assignments
      "thumbnail-badge-brand-fg": theme.colors["Brand/700"],
      "thumbnail-badge-success-fg": theme.colors["Success/700"],

    // Toggles assignments
      "toggle-button-fg_disabled": theme.colors["Gray (light mode)/50"],
 
    // Tooltips assignments
      "tooltip-supporting-text": theme.colors["Gray (light mode)/300"],

    // WYSIWYG editor assignments
      "wysiwyg-editor-icon-fg": theme.colors["Gray (light mode)/400"],
      "wysiwyg-editor-icon-fg_active": theme.colors["Gray (light mode)/500"],


    };

     
       // darkMode Assignment
       theme.colors.darkMode = {
      // Text color assignments for Dark mode

    "text-primary (900)": theme.colors["Gray (dark mode)/50"],
    "text-primary_on-brand": theme.colors["Gray (dark mode)/50"],
    "text-secondary (700)": theme.colors["Gray (dark mode)/300"],
    "text-secondary_hover": theme.colors["Gray (dark mode)/200"],
    "text-secondary_on-brand": theme.colors["Gray (dark mode)/300"],
    "text-tertiary (600)": theme.colors["Gray (dark mode)/400"],
    "text-tertiary_hover": theme.colors["Gray (dark mode)/300"],
    "text-tertiary_on-brand": theme.colors["Gray (dark mode)/400"],
    "text-quaternary (500)": theme.colors["Gray (dark mode)/400"],
    "text-quaternary_on-brand": theme.colors["Gray (dark mode)/400"],
    "text-white": theme.colors["Base/white"],
    "text-disabled": theme.colors["Gray (dark mode)/500"],
    "text-placeholder": theme.colors["Gray (dark mode)/500"],
    "text-placeholder_subtle": theme.colors["Gray (dark mode)/700"],
    "text-brand-primary (900)": theme.colors["Gray (dark mode)/50"],
    "text-brand-secondary (700)": theme.colors["Gray (dark mode)/300"],
    "text-brand-tertiary (600)": theme.colors["Gray (dark mode)/400"],
    "text-brand-tertiary_alt": theme.colors["Gray (dark mode)/50"],
    "text-error-primary (600)": theme.colors["Error/400"],
    "text-warning-primary (600)": theme.colors["Warning/400"],
    "text-success-primary (600)": theme.colors["Success/400"],

  // Border color assignments for Dark mode
    "border-primary": theme.colors["Gray (dark mode)/700"],
    "border-secondary": theme.colors["Gray (dark mode)/800"],
    "border-tertiary": theme.colors["Gray (dark mode)/800"],
    "border-disabled": theme.colors["Gray (dark mode)/700"],
    "border-disabled_subtle": theme.colors["Gray (dark mode)/800"],
    "border-brand": theme.colors["Brand/400"],
    "border-brand_alt": theme.colors["Gray (dark mode)/700"],
    "border-error": theme.colors["Error/400"],
    "border-error_subtle": theme.colors["Error/400"],

// Foreground color assignments for Dark mode
    "fg-primary (900)": theme.colors["Base/white"],
    "fg-secondary (700)": theme.colors["Gray (dark mode)/300"],
    "fg-secondary_hover": theme.colors["Gray (dark mode)/200"],
    "fg-tertiary (600)": theme.colors["Gray (dark mode)/400"],
    "fg-tertiary_hover": theme.colors["Gray (dark mode)/300"],
    "fg-quaternary (500)": theme.colors["Gray (dark mode)/400"],
    "fg-quaternary_hover": theme.colors["Gray (dark mode)/300"],
    "fg-quinary (400)": theme.colors["Gray (dark mode)/500"],
    "fg-quinary_hover": theme.colors["Gray (dark mode)/400"],
    "fg-senary (300)": theme.colors["Gray (dark mode)/600"],
    "fg-white": theme.colors["Base/white"],
    "fg-disabled": theme.colors["Gray (dark mode)/500"],
    "fg-disabled_subtle": theme.colors["Gray (dark mode)/600"],
    "fg-brand-primary (600)": theme.colors["Brand/500"],
    "fg-brand-primary_alt": theme.colors["Gray (dark mode)/300"],
    "fg-brand-secondary (500)": theme.colors["Brand/500"],
    "fg-error-primary": theme.colors["Error/500"],
    "fg-error-secondary": theme.colors["Error/400"],
    "fg-warning-primary": theme.colors["Warning/500"],
    "fg-warning-secondary": theme.colors["Warning/400"],
    "fg-success-primary": theme.colors["Success/500"],
    "fg-success-secondary": theme.colors["Success/400"],
  
    // Background color assignments for Dark mode

    "bg-primary": theme.colors["Gray (dark mode)/950"],
    "bg-primary_alt": theme.colors["Background/bg-secondary"],
    "bg-primary_hover": theme.colors["Gray (dark mode)/800"],
    "bg-primary-solid": theme.colors["Background/bg-secondary"],
    "bg-secondary": theme.colors["Gray (dark mode)/900"],
    "bg-secondary_alt": theme.colors["Background/bg-primary"],
    "bg-secondary_hover": theme.colors["Gray (dark mode)/800"],
    "bg-secondary_subtle": theme.colors["Gray (dark mode)/900"],
    "bg-secondary-solid": theme.colors["Gray (dark mode)/600"],
    "bg-tertiary": theme.colors["Gray (dark mode)/800"],
    "bg-quaternary": theme.colors["Gray (dark mode)/700"],
    "bg-active": theme.colors["Gray (dark mode)/800"],
    "bg-disabled": theme.colors["Gray (dark mode)/800"],
    "bg-disabled_subtle": theme.colors["Gray (dark mode)/900"],
    "bg-overlay": theme.colors["Gray (dark mode)/800"],
    "bg-brand-primary": theme.colors["Brand/500"],
    "bg-brand-primary_alt": theme.colors["Background/bg-secondary"],
    "bg-brand-secondary": theme.colors["Brand/600"],
    "bg-brand-solid": theme.colors["Brand/600"],
    "bg-brand-solid_hover": theme.colors["Brand/500"],
    "bg-brand-section": theme.colors["Background/bg-secondary"],
    "bg-brand-section_subtle": theme.colors["Background/bg-primary"],
    "bg-error-primary": theme.colors["Error/500"],
    "bg-error-secondary": theme.colors["Error/600"],
    "bg-error-solid": theme.colors["Error/600"],
    "bg-warning-primary": theme.colors["Warning/500"],
    "bg-warning-secondary": theme.colors["Warning/600"],
    "bg-warning-solid": theme.colors["Warning/600"],
    "bg-success-primary": theme.colors["Success/500"],
    "bg-success-secondary": theme.colors["Success/600"],
    "bg-success-solid": theme.colors["Success/600"],
  
    // Focus Rings
    "focus-ring": theme.colors["Brand/500"],
    "focus-ring-error": theme.colors["Error/500"],
  
    // Shadows
    "shadow-xs": theme.colors["Base/transparent"],
    "shadow-sm_01": theme.colors["Base/transparent"],
    "shadow-sm_02": theme.colors["Base/transparent"],
    "shadow-md_01": theme.colors["Base/transparent"],
    "shadow-md_02": theme.colors["Base/transparent"],
    "shadow-lg_01": theme.colors["Base/transparent"],
    "shadow-lg_02": theme.colors["Base/transparent"],
    "shadow-xl_01": theme.colors["Base/transparent"],
    "shadow-xl_02": theme.colors["Base/transparent"],
    "shadow-2xl": theme.colors["Base/transparent"],
    "shadow-3xl": theme.colors["Base/transparent"],
    "shadow-skeumorphic-inner": "rgba(12, 17, 29, 5)",
    "shadow-skeumorphic-inner-border": "rgba(12, 17, 29, 18)",
  
    // Portfolio mockups
    "shadow-main-centre-md": theme.colors["Base/transparent"],
    "shadow-main-centre-lg": theme.colors["Base/transparent"],
    "shadow-overlay-lg": theme.colors["Base/transparent"],
    "shadow-grid-md": theme.colors["Base/transparent"],
  
    // Alpha Colors
    "alpha-white-10": "rgba(12, 17, 29, 10)",
    "alpha-white-20": "rgba(12, 17, 29, 20)",
    "alpha-white-30": "rgba(12, 17, 29, 30)",
    "alpha-white-40": "rgba(12, 17, 29, 40)",
    "alpha-white-50": "rgba(12, 17, 29, 50)",
    "alpha-white-60": "rgba(12, 17, 29, 60)",
    "alpha-white-70": "rgba(12, 17, 29, 70)",
    "alpha-white-80": "rgba(12, 17, 29, 80)",
    "alpha-white-90": "rgba(12, 17, 29, 90)",
    "alpha-white-100": theme.colors["Gray (dark mode)/950"],
    "alpha-black-10": "rgba(255, 255, 255, 10)",
    "alpha-black-20": "rgba(255, 255, 255, 20)",
    "alpha-black-30": "rgba(255, 255, 255, 30)",
    "alpha-black-40": "rgba(255, 255, 255, 40)",
    "alpha-black-50": "rgba(255, 255, 255, 50)",
    "alpha-black-60": "rgba(255, 255, 255, 60)",
    "alpha-black-70": "rgba(255, 255, 255, 70)",
    "alpha-black-80": "rgba(255, 255, 255, 80)",
    "alpha-black-90": "rgba(255, 255, 255, 90)",
    "alpha-black-100": "#ffffff",
  
    // Utility - Gray Colors
    "utility-gray-50": theme.colors["Gray (dark mode)/900"],
    "utility-gray-100": theme.colors["Gray (dark mode)/800"],
    "utility-gray-200": theme.colors["Gray (dark mode)/700"],
    "utility-gray-300": theme.colors["Gray (dark mode)/700"],
    "utility-gray-400": theme.colors["Gray (dark mode)/600"],
    "utility-gray-500": theme.colors["Gray (dark mode)/500"],
    "utility-gray-600": theme.colors["Gray (dark mode)/400"],
    "utility-gray-700": theme.colors["Gray (dark mode)/300"],
    "utility-gray-800": theme.colors["Gray (dark mode)/200"],
    "utility-gray-900": theme.colors["Gray (dark mode)/100"],
  
    // Utility - Brand Colors
    "utility-brand-50": theme.colors["Brand/950"],
    "utility-brand-50_alt": theme.colors["Utility.Gray.utility-gray-50"],
    "utility-brand-100": theme.colors["Brand/900"],
    "utility-brand-100_alt": theme.colors["Utility.Gray.utility-gray-100"],
    "utility-brand-200": theme.colors["Brand/800"],
    "utility-brand-200_alt": theme.colors["Utility.Gray.utility-gray-200"],
    "utility-brand-300": theme.colors["Brand/700"],
    "utility-brand-300_alt": theme.colors["Utility.Gray.utility-gray-300"],
    "utility-brand-400": theme.colors["Brand/600"],
    "utility-brand-400_alt": theme.colors["Utility.Gray.utility-gray-400"],
    "utility-brand-500": theme.colors["Brand/500"],
    "utility-brand-500_alt": theme.colors["Utility.Gray.utility-gray-500"],
    "utility-brand-600": theme.colors["Brand/400"],
    "utility-brand-600_alt": theme.colors["Utility.Gray.utility-gray-600"],
    "utility-brand-700": theme.colors["Brand/300"],
    "utility-brand-700_alt": theme.colors["Utility.Gray.utility-gray-700"],
    "utility-brand-800": theme.colors["Brand/200"],
    "utility-brand-800_alt": theme.colors["Utility.Gray.utility-gray-800"],
    "utility-brand-900": theme.colors["Brand/100"],
    "utility-brand-900_alt": theme.colors["Utility.Gray.utility-gray-900"],
 
    // Error Colors
    "utility-error-50": theme.colors["Error/950"],
    "utility-error-100": theme.colors["Error/900"],
    "utility-error-200": theme.colors["Error/800"],
    "utility-error-300": theme.colors["Error/700"],
    "utility-error-400": theme.colors["Error/600"],
    "utility-error-500": theme.colors["Error/500"],
    "utility-error-600": theme.colors["Error/400"],
    "utility-error-700": theme.colors["Error/300"],
  
    // Warning Colors
    "utility-warning-50": theme.colors["Warning/950"],
    "utility-warning-100": theme.colors["Warning/900"],
    "utility-warning-200": theme.colors["Warning/800"],
    "utility-warning-300": theme.colors["Warning/700"],
    "utility-warning-400": theme.colors["Warning/600"],
    "utility-warning-500": theme.colors["Warning/500"],
    "utility-warning-600": theme.colors["Warning/400"],
    "utility-warning-700": theme.colors["Warning/300"],
  
    // Success Colors
    "utility-success-50": theme.colors["Success/950"],
    "utility-success-100": theme.colors["Success/900"],
    "utility-success-200": theme.colors["Success/800"],
    "utility-success-300": theme.colors["Success/700"],
    "utility-success-400": theme.colors["Success/600"],
    "utility-success-500": theme.colors["Success/500"],
    "utility-success-600": theme.colors["Success/400"],
    "utility-success-700": theme.colors["Success/300"],
  
    // Gray Blue Colors
    "utility-gray-blue-50": theme.colors["Gray blue/900"],
    "utility-gray-blue-100": theme.colors["Gray blue/900"],
    "utility-gray-blue-200": theme.colors["Gray blue/800"],
    "utility-gray-blue-300": theme.colors["Gray blue/700"],
    "utility-gray-blue-400": theme.colors["Gray blue/600"],
    "utility-gray-blue-500": theme.colors["Gray blue/500"],
    "utility-gray-blue-600": theme.colors["Gray blue/400"],
    "utility-gray-blue-700": theme.colors["Gray blue/300"],
  
    // Blue Light Colors
    "utility-blue-light-50": theme.colors["Blue light/950"],
    "utility-blue-light-100": theme.colors["Blue light/900"],
    "utility-blue-light-200": theme.colors["Blue light/800"],
    "utility-blue-light-300": theme.colors["Blue light/700"],
    "utility-blue-light-400": theme.colors["Blue light/600"],
    "utility-blue-light-500": theme.colors["Blue light/500"],
    "utility-blue-light-600": theme.colors["Blue light/400"],
    "utility-blue-light-700": theme.colors["Blue light/300"],
  
    // Blue Colors
    "utility-blue-50": theme.colors["Blue/950"],
    "utility-blue-100": theme.colors["Blue/900"],
    "utility-blue-200": theme.colors["Blue/800"],
    "utility-blue-300": theme.colors["Blue/700"],
    "utility-blue-400": theme.colors["Blue/600"],
    "utility-blue-500": theme.colors["Blue/500"],
    "utility-blue-600": theme.colors["Blue/400"],
    "utility-blue-700": theme.colors["Blue/300"],
  
    // Blue Dark Colors
    "utility-blue-dark-50": theme.colors["Blue dark/950"],
    "utility-blue-dark-100": theme.colors["Blue dark/900"],
    "utility-blue-dark-200": theme.colors["Blue dark/800"],
    "utility-blue-dark-300": theme.colors["Blue dark/700"],
    "utility-blue-dark-400": theme.colors["Blue dark/600"],
    "utility-blue-dark-500": theme.colors["Blue dark/500"],
    "utility-blue-dark-600": theme.colors["Blue dark/400"],
    "utility-blue-dark-700": theme.colors["Blue dark/300"],
  
    // Indigo Colors
    "utility-indigo-50": theme.colors["Indigo/950"],
    "utility-indigo-100": theme.colors["Indigo/900"],
    "utility-indigo-200": theme.colors["Indigo/800"],
    "utility-indigo-300": theme.colors["Indigo/700"],
    "utility-indigo-400": theme.colors["Indigo/600"],
    "utility-indigo-500": theme.colors["Indigo/500"],
    "utility-indigo-600": theme.colors["Indigo/400"],
    "utility-indigo-700": theme.colors["Indigo/300"],
  
    // Purple Colors
    "utility-purple-50": theme.colors["Purple/950"],
    "utility-purple-100": theme.colors["Purple/900"],
    "utility-purple-200": theme.colors["Purple/800"],
    "utility-purple-300": theme.colors["Purple/700"],
    "utility-purple-400": theme.colors["Purple/600"],
    "utility-purple-500": theme.colors["Purple/500"],
    "utility-purple-600": theme.colors["Purple/400"],
    "utility-purple-700": theme.colors["Purple/300"],
  
    // Fuchsia Colors
    "utility-fuchsia-50": theme.colors["Fuchsia/950"],
    "utility-fuchsia-100": theme.colors["Fuchsia/900"],
    "utility-fuchsia-200": theme.colors["Fuchsia/800"],
    "utility-fuchsia-300": theme.colors["Fuchsia/700"],
    "utility-fuchsia-400": theme.colors["Fuchsia/600"],
    "utility-fuchsia-500": theme.colors["Fuchsia/500"],
    "utility-fuchsia-600": theme.colors["Fuchsia/400"],
    "utility-fuchsia-700": theme.colors["Fuchsia/300"],
  
    // Pink Colors
    "utility-pink-50": theme.colors["Pink/950"],
    "utility-pink-100": theme.colors["Pink/900"],
    "utility-pink-200": theme.colors["Pink/800"],
    "utility-pink-300": theme.colors["Pink/700"],
    "utility-pink-400": theme.colors["Pink/600"],
    "utility-pink-500": theme.colors["Pink/500"],
    "utility-pink-600": theme.colors["Pink/400"],
    "utility-pink-700": theme.colors["Pink/300"],
  
    // Orange Dark Colors
    "utility-orange-dark-50": theme.colors["Orange dark/950"],
    "utility-orange-dark-100": theme.colors["Orange dark/900"],
    "utility-orange-dark-200": theme.colors["Orange dark/800"],
    "utility-orange-dark-300": theme.colors["Orange dark/700"],
    "utility-orange-dark-400": theme.colors["Orange dark/600"],
    "utility-orange-dark-500": theme.colors["Orange dark/500"],
    "utility-orange-dark-600": theme.colors["Orange dark/400"],
    "utility-orange-dark-700": theme.colors["Orange dark/300"],
  
    // Orange Colors
    "utility-orange-50": theme.colors["Orange/950"],
    "utility-orange-100": theme.colors["Orange/900"],
    "utility-orange-200": theme.colors["Orange/800"],
    "utility-orange-300": theme.colors["Orange/700"],
    "utility-orange-400": theme.colors["Orange/600"],
    "utility-orange-500": theme.colors["Orange/500"],
    "utility-orange-600": theme.colors["Orange/400"],
    "utility-orange-700": theme.colors["Orange/300"],
  
    // App Store Badges
    "app-store-badge-border": theme.colors["Base/white"],
  
    // Application Navigation
    "nav-item-button-icon-fg": theme.colors["Gray (dark mode)/400"],
    "nav-item-button-icon-fg_active": theme.colors["Gray (dark mode)/200"],
    "nav-item-icon-fg": theme.colors["Gray (dark mode)/400"],
    "nav-item-icon-fg_active": theme.colors["Gray (dark mode)/200"],
  
    // Avatars
    "avatar-bg": theme.colors["Gray (dark mode)/800"],
    "avatar-profile-photo-border": theme.colors["Gray (dark mode)/950"],
    "avatar-contrast-border": "rgba(255, 255, 255, 12)",
    "avatar-styles-bg-neutral": "#e0e0e0",
  
    // Breadcrumbs
    "breadcrumb-fg": theme.colors["Gray (dark mode)/300"],
    "breadcrumb-fg_hover": theme.colors["Base/white"],
    "breadcrumb-bg_hover": theme.colors["Gray (dark mode)/800"],
    "breadcrumb-brand-fg_hover": theme.colors["Base/white"],
    "breadcrumb-brand-bg_hover": theme.colors["Gray (dark mode)/800"],
    "breadcrumb-icon-fg": theme.colors["Gray (dark mode)/400"],
    "breadcrumb-icon-fg_hover": theme.colors["Base/white"],
    "breadcrumb-brand-icon-fg_hover": theme.colors["Base/white"],
  
    // Primary Buttons
    "button-primary-fg": theme.colors["Base/white"],
    "button-primary-fg-hover": theme.colors["Base/white"],
    "button-primary-bg": theme.colors["Brand/500"],
    "button-primary-bg-hover": theme.colors["Brand/700"],
  
    // Secondary Buttons
    "button-secondary-fg": theme.colors["Gray (dark mode)/300"],
    "button-secondary-fg_hover": theme.colors["Gray (dark mode)/100"],
    "button-secondary-bg": theme.colors["Gray (dark mode)/900"],
    "button-secondary-bg_hover": theme.colors["Gray (dark mode)/800"],
    "button-secondary-border": theme.colors["Gray (dark mode)/700"],
    "button-secondary-border_hover": theme.colors["Gray (dark mode)/700"],
  
    // Secondary Color Buttons
    "button-secondary-color-fg": theme.colors["Gray (dark mode)/300"],
    "button-secondary-color-fg_hover": theme.colors["Gray (dark mode)/100"],
    "button-secondary-color-bg": theme.colors["Gray (dark mode)/900"],
    "button-secondary-color-bg_hover": theme.colors["Gray (dark mode)/800"],
    "button-secondary-color-border": theme.colors["Gray (dark mode)/700"],
    "button-secondary-color-border_hover": theme.colors["Gray (dark mode)/700"],
  
    // Tertiary Buttons
    "button-tertiary-fg": theme.colors["Gray (dark mode)/400"],
    "button-tertiary-fg_hover": theme.colors["Gray (dark mode)/200"],
    "button-tertiary-bg_hover": theme.colors["Gray (dark mode)/800"],
  
    // Tertiary Color Buttons
    "button-tertiary-color-fg": theme.colors["Gray (dark mode)/300"],
    "button-tertiary-color-fg_hover": theme.colors["Gray (dark mode)/100"],
    "button-tertiary-color-bg_hover": theme.colors["Gray (dark mode)/800"],
  
    // Primary Error Buttons
    "button-primary-error-fg": theme.colors["Base/white"],
    "button-primary-error-fg_hover": theme.colors["Base/white"],
    "button-primary-error-bg": theme.colors["Error/600"],
    "button-primary-error-bg_hover": theme.colors["Error/700"],
  
    // Secondary Error Buttons
    "button-secondary-error-fg": theme.colors["Error/200"],
    "button-secondary-error-fg_hover": theme.colors["Error/100"],
    "button-secondary-error-bg": theme.colors["Error/950"],
    "button-secondary-error-bg_hover": theme.colors["Error/900"],
    "button-secondary-error-border": theme.colors["Error/800"],
    "button-secondary-error-border_hover": theme.colors["Error/700"],
  
    // Tertiary Error Buttons
    "button-tertiary-error-fg": theme.colors["Error/300"],
    "button-tertiary-error-fg_hover": theme.colors["Error/200"],
    "button-tertiary-error-bg_hover": theme.colors["Error/900"],
  
    // Footers
    "footer-button-fg": theme.colors["Gray (dark mode)/300"],
    "footer-button-fg_hover": theme.colors["Gray (dark mode)/100"],
    "footer-badge-fg": theme.colors["Base/white"],
    "footer-badge-bg": "rgba(255, 255, 255, 10)",
    "footer-badge-border": "rgba(255, 255, 255, 30)",
  
    // Header Sections
    "header-abstract-50-bg": theme.colors["Gray (dark mode)/900"],
    "header-abstract-100-bg": theme.colors["Gray (dark mode)/800"],
    "header-abstract-200-bg": theme.colors["Gray (dark mode)/700"],
    "header-abstract-300-bg": theme.colors["Gray (dark mode)/600"],
  
    // Icons
    "icon-fg-brand": theme.colors["Gray (dark mode)/400"],
    "icon-fg-brand_on-brand": theme.colors["Gray (dark mode)/400"],
  
    // Featured Icons - Light
    "featured-icon-light-fg-brand": theme.colors["Brand/200"],
    "featured-icon-light-fg-gray": theme.colors["Gray (dark mode)/200"],
    "featured-icon-light-fg-error": theme.colors["Error/200"],
    "featured-icon-light-fg-warning": theme.colors["Warning/200"],
    "featured-icon-light-fg-success": theme.colors["Success/200"],
  
    // Featured Icons - Dark
    "featured-icon-dark-fg-brand": theme.colors["Brand/200"],
    "featured-icon-dark-fg-gray": theme.colors["Gray (dark mode)/200"],
    "featured-icon-dark-fg-error": theme.colors["Error/200"],
    "featured-icon-dark-fg-warning": theme.colors["Warning/200"],
    "featured-icon-dark-fg-success": theme.colors["Success/200"],
  
    // Featured Icons - Modern
    "featured-icon-modern-border": theme.colors["Gray (dark mode)/700"],
  
    // Social Icons
    "social-icon-fg-x": theme.colors["Base/white"],
    "social-icon-fg-instagram": theme.colors["Base/white"],
    "social-icon-fg-apple": theme.colors["Base/white"],
    "social-icon-fg-github": theme.colors["Base/white"],
    "social-icon-fg-angellist": theme.colors["Base/white"],
    "social-icon-fg-tumblr": theme.colors["Base/white"],
  
    // Mockups
    "screen-mockup-border": theme.colors["Gray (dark mode)/700"],
  
    // Sliders
    "slider-handle-bg": theme.colors["Foreground/fg-brand-primary (600)"],
    "slider-handle-border": theme.colors["Background/bg-primary"],
  
    // Thumbnail
    "thumbnail-badge-brand-fg": theme.colors["Gray (dark mode)/300"],
    "thumbnail-badge-success-fg": theme.colors["Gray (dark mode)/300"],
  
    // Toggles
    "toggle-button-fg_disabled": theme.colors["Gray (dark mode)/600"],
  
    // Tooltips
    "tooltip-supporting-text": theme.colors["Gray (dark mode)/300"],
  
    // WYSIWYG Editor
    "wysiwyg-editor-icon-fg": theme.colors["Gray (dark mode)/400"],
    "wysiwyg-editor-icon-fg_active": theme.colors["Base/white"],
        
    };
      

        
      

     export default theme;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "ESNext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    },
    "target": "ES2017"
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "global.d.ts",
    "theme.js",
    "app/docs/page.jsx",
    "app/swagger-ui/page.jsx",
    "app/reactflow/page.tsx"
  ],
  "exclude": [
    "node_modules",
    "supabase/functions/**/*"
  ]
}
</file>

<file path="app/[slug]/[flow]/edit/components/modals/EditLinksModal.tsx">
'use client';
import React, { useState, useEffect, useRef } from 'react';
import { useColors } from '@/app/theme/hooks';
import Modal from '@/app/components/Modal';
import { Node as FlowNodeType, Edge, useReactFlow } from '@xyflow/react';
import { useModalStore } from '../../store/modalStore';
import ButtonNormal from '@/app/components/ButtonNormal';
import { Node as FlowNode } from '@xyflow/react';
import { NodeData, Block } from '../../../types';
import { deleteStrokeLine } from '../../utils/stroke-lines';
import ConnectNodeModal from './ConnectNodeModal';
import { handleToggleEndpoint } from '../../utils/toggleEndpoint';
import { usePathsStore } from '../../store/pathsStore';

interface EditLinksModalProps {
  isVisible?: boolean;
  onEditLink?: (
    sourceNode: FlowNodeType<NodeData>,
    targetNode: FlowNodeType<NodeData>,
    label: string,
    strokeLineId?: string
  ) => void;
}

const EditLinksModal: React.FC<EditLinksModalProps> = ({
  isVisible = true,
  onEditLink,
}) => {
  const colors = useColors();
  const {
    showEditLinksModal,
    editLinksData,
    setShowEditLinksModal,
    setConnectData,
    setShowConnectModal,
    setEditLinksData,
  } = useModalStore((state) => ({
    showEditLinksModal: state.showEditLinksModal,
    editLinksData: state.editLinksData,
    setShowEditLinksModal: state.setShowEditLinksModal,
    setConnectData: state.setConnectData,
    setShowConnectModal: state.setShowConnectModal,
    setEditLinksData: state.setEditLinksData,
  }));

  const { getEdges, getNode, setEdges } = useReactFlow();
  const [isDirectionToggled, setIsDirectionToggled] = useState(false);
  const [links, setLinks] = useState<Edge[]>([]);
  const [sourceBlock, setSourceBlock] = useState<FlowNodeType<NodeData> | null>(
    null
  );
  const [hoveredLinkId, setHoveredLinkId] = useState<string | null>(null);
  const [openMenuId, setOpenMenuId] = useState<string | null>(null);
  const menuRefs = useRef<{ [key: string]: HTMLDivElement | null }>({});
  const dotsRefs = useRef<{ [key: string]: HTMLButtonElement | null }>({});
  const [menuPosition, setMenuPosition] = useState<{
    [key: string]: 'bottom' | 'top';
  }>({});
  const menuOptionRefs = useRef<{
    [key: string]: (HTMLButtonElement | null)[];
  }>({});
  const [hoveredDotsId, setHoveredDotsId] = useState<string | null>(null);
  const [showConnectNodeModal, setShowConnectNodeModal] = useState(false);
  const [connectModalSourceNode, setConnectModalSourceNode] =
    useState<FlowNodeType<NodeData> | null>(null);
  const [connectModalTargetNode, setConnectModalTargetNode] =
    useState<FlowNodeType<NodeData> | null>(null);
  const [connectModalLabel, setConnectModalLabel] = useState<string>('');

  const allPaths = usePathsStore((state) => state.paths);
  const setAllPaths = usePathsStore((state) => state.setPaths);

  // Load data when modal opens
  useEffect(() => {
    if (showEditLinksModal && editLinksData?.sourceNode) {
      // Get the source node
      setSourceBlock(editLinksData.sourceNode as FlowNodeType<NodeData>);

      // Get all stroke edges where this node is the source
      const strokeEdges = getEdges().filter(
        (edge) =>
          edge.source === editLinksData.sourceNode.id &&
          edge.type === 'strokeEdge'
      );

      setLinks(strokeEdges);

      // Set toggle state based on is_endpoint
      const isEndpoint =
        editLinksData.sourceNode.data?.block?.is_endpoint === true;
      setIsDirectionToggled(isEndpoint);
    }
  }, [showEditLinksModal, editLinksData, getEdges]);

  // Keep toggle in sync with sourceBlock.is_endpoint if sourceBlock changes
  useEffect(() => {
    if (sourceBlock?.data?.block) {
      setIsDirectionToggled(!!sourceBlock.data.block.is_endpoint);
    }
  }, [sourceBlock]);

  // Close menu on outside click or Escape
  useEffect(() => {
    function handleClick(e: MouseEvent | TouchEvent) {
      if (openMenuId && menuRefs.current[openMenuId]) {
        const targetNode = e.target;
        const menuRef = menuRefs.current[openMenuId];
        const dotsRef = dotsRefs.current[openMenuId];
        if (
          targetNode instanceof Node &&
          (!menuRef || !menuRef.contains(targetNode)) &&
          (!dotsRef || !dotsRef.contains(targetNode))
        ) {
          setOpenMenuId(null);
        }
      }
    }
    function handleEscape(e: KeyboardEvent) {
      if (e.key === 'Escape') setOpenMenuId(null);
    }
    
    if (showEditLinksModal) { // Only add listeners when modal is open
      document.addEventListener('mousedown', handleClick as EventListener);
      document.addEventListener('touchstart', handleClick as EventListener);
      document.addEventListener('keydown', handleEscape);
    }
    
    return () => {
      document.removeEventListener('mousedown', handleClick as EventListener);
      document.removeEventListener('touchstart', handleClick as EventListener);
      document.removeEventListener('keydown', handleEscape);
    };
  }, [openMenuId, showEditLinksModal]); // Add showEditLinksModal dependency

  // Menu positioning (above or below)
  const handleMenuOpen = (linkId: string, idx: number) => {
    setOpenMenuId(linkId);
    setTimeout(() => {
      if (idx === 0) {
        setMenuPosition((prev) => ({ ...prev, [linkId]: 'bottom' }));
      } else {
        setMenuPosition((prev) => ({ ...prev, [linkId]: 'top' }));
      }
    }, 0);
  };

  // Keyboard navigation for menu
  const handleMenuKeyDown = (
    e: React.KeyboardEvent,
    linkId: string,
    optionIdx: number
  ) => {
    const options = menuOptionRefs.current[linkId];
    if (!options) return;
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      const next = (optionIdx + 1) % options.length;
      options[next]?.focus();
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      const prev = (optionIdx - 1 + options.length) % options.length;
      options[prev]?.focus();
    } else if (e.key === 'Tab') {
      setOpenMenuId(null);
    }
  };

  // Edit and delete handlers
  const handleEditLink = (link: Edge) => {
    const sourceNode = getNode(link.source) as FlowNodeType<NodeData> | null;
    const targetNode = getNode(link.target) as FlowNodeType<NodeData> | null;
    if (sourceNode && targetNode && onEditLink) {
      onEditLink(
        sourceNode,
        targetNode,
        typeof link.data?.label === 'string' ? link.data.label : '',
        link.id
      );
    }
    setOpenMenuId(null);
  };
  const handleDeleteLink = async (link: Edge) => {
    // Extract stroke line ID from edge ID
    const strokeLineId = link.id.replace('stroke-edge-', '');
    const deleted = await deleteStrokeLine(Number(strokeLineId));
    if (!deleted) return; // If backend deletion fails, do not update UI

    // Remove the link from local state
    const { onStrokeLinesUpdate } = useModalStore.getState();
    if (onStrokeLinesUpdate) {
      onStrokeLinesUpdate((prev) =>
        prev.filter((l) => l.id !== Number(strokeLineId))
      );
    }
    setEdges((prev) => prev.filter((l) => l.id !== link.id));
    setLinks((prev) => prev.filter((l) => l.id !== link.id));
    setOpenMenuId(null);

    // --- NEW LOGIC: Check if the source block has any other outgoing stroke lines ---
    if (sourceBlock?.id) {
      // Get all remaining stroke edges for this source
      const remainingEdges = getEdges().filter(
        (edge) =>
          edge.source === sourceBlock.id &&
          edge.type === 'strokeEdge' &&
          edge.id !== link.id // Exclude the just-deleted one
      );
      if (remainingEdges.length === 0) {
        // No more outgoing stroke lines, update is_endpoint in allPaths
        const blockId = sourceBlock.data.block.id;
        const updatedPaths = allPaths.map((path) => ({
          ...path,
          blocks: path.blocks.map((block) =>
            block.id === blockId ? { ...block, is_endpoint: false } : block
          ),
        }));
        setAllPaths(updatedPaths);
        if (sourceBlock.data.onPathsUpdate) {
          sourceBlock.data.onPathsUpdate(updatedPaths);
        }

        // Also update local UI state
        setSourceBlock((prev) =>
          prev
            ? {
                ...prev,
                data: {
                  ...prev.data,
                  block: {
                    ...prev.data.block,
                    is_endpoint: false,
                  },
                },
              }
            : prev
        );
        setIsDirectionToggled(false);
      }
    }
    // --- END NEW LOGIC ---
  };

  const handleClose = () => {
    setShowEditLinksModal(false);
  };

  const handleToggleDirection = async () => {
    if (!sourceBlock?.data?.block?.id) return;
    const newValue = !isDirectionToggled;

    // Call the util and only update UI if fetch succeeded
    try {
      await handleToggleEndpoint(
        sourceBlock.data.block.id,
        newValue,
        allPaths,
        setAllPaths,
        sourceBlock.data.onPathsUpdate
      );
      setIsDirectionToggled(newValue);
      // Optionally update sourceBlock's is_endpoint in local state
      setSourceBlock((prev) =>
        prev
          ? {
              ...prev,
              data: {
                ...prev.data,
                block: {
                  ...prev.data.block,
                  is_endpoint: newValue,
                },
              },
            }
          : prev
      );
    } catch (err) {
      // Optionally show an error to the user
      // e.g. toast.error('Failed to update endpoint status');
    }
  };

  const handleCreateNewLink = () => {
    if (editLinksData?.sourceNode) {
      setShowEditLinksModal(false);
      setConnectData({ sourceNode: editLinksData.sourceNode });
      setShowConnectModal(true);
    }
  };

  if (!showEditLinksModal || !editLinksData) {
    return null;
  }

  return (
    <>
      <Modal
        title="Edit links"
        icon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/connect-node.svg`}
        onClose={handleClose}
        width="w-[600px]"
        showHeaderSeparator={true}
        actions={
          <div className="flex justify-end gap-2 w-full">
            <ButtonNormal variant="primary" size="small" onClick={handleClose}>
              Close
            </ButtonNormal>
          </div>
        }
      >
        <div className="flex flex-col gap-6">
          {/* Original block section */}
          <div className="flex flex-col gap-2">
            <div className="flex flex-col gap-1">
              <label
                className="text-sm font-semibold"
                style={{ color: colors['text-secondary'] }}
              >
                Original block
              </label>
              <div
                className="flex items-center gap-2 p-2"
                style={{
                  color: colors['text-primary'],
                  backgroundColor: colors['bg-primary'],
                  borderRadius: '4px',
                }}
              >
                <div className="w-5 h-5">
                  {sourceBlock?.data?.block?.signedIconUrl ? (
                    <img
                      src={sourceBlock.data.block.signedIconUrl}
                      alt="Block Icon"
                      className="w-5 h-5"
                    />
                  ) : sourceBlock?.data?.block?.icon && sourceBlock.data.block.icon.startsWith('https://cdn.brandfetch.io/') ? (
                    <img
                      src={sourceBlock.data.block.icon}
                      alt="Block Icon"
                      className="w-5 h-5"
                    />
                  ) : (
                    <img
                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/git-commit.svg`}
                      alt="Block"
                      className="w-5 h-5"
                    />
                  )}
                </div>
                <span className="text-sm">
                  {sourceBlock?.data?.block?.title || 'Untitled Block'}
                </span>
              </div>
            </div>
          </div>

          {/* Direction toggle section */}
          {links.length > 0 && (
            <div className="flex flex-col gap-2">
              <div className="flex flex-col gap-1">
                <label
                  className="text-sm font-semibold"
                  style={{ color: colors['text-secondary'] }}
                >
                  Direction
                </label>
                <div className="flex items-center gap-2">
                  <div
                    className="flex items-center gap-2"
                    style={{ minHeight: 20 }}
                  >
                    <div
                      className="relative flex items-center cursor-pointer"
                      style={{ width: 36, height: 20 }}
                      onClick={handleToggleDirection}
                      tabIndex={0}
                      role="switch"
                      aria-checked={isDirectionToggled}
                      onKeyDown={(e) => {
                        if (e.key === 'Enter' || e.key === ' ')
                          handleToggleDirection();
                      }}
                    >
                      <div
                        className="transition-colors duration-200"
                        style={{
                          width: 36,
                          height: 20,
                          borderRadius: 9999,
                          backgroundColor: isDirectionToggled
                            ? colors['bg-brand-solid'] || '#4761c4'
                            : colors['bg-quaternary'] || '#E4E7EC',
                          boxShadow:
                            '0px 1px 2px 0px rgba(16, 24, 40, 0.06), 0px 1px 3px 0px rgba(16, 24, 40, 0.1)',
                        }}
                      />
                      <div
                        className="absolute transition-transform duration-200"
                        style={{
                          left: 2,
                          top: 2,
                          width: 16,
                          height: 16,
                          borderRadius: '50%',
                          backgroundColor: '#fff',
                          transform: isDirectionToggled
                            ? 'translateX(16px)'
                            : 'translateX(0px)',
                          boxShadow:
                            '0px 1px 2px 0px rgba(16, 24, 40, 0.06), 0px 1px 3px 0px rgba(16, 24, 40, 0.1)',
                        }}
                      />
                    </div>
                  </div>
                  <span
                    className="text-sm"
                    style={{
                      color: '#667085',
                      fontFamily: 'Inter',
                      fontWeight: 400,
                    }}
                  >
                    {isDirectionToggled
                      ? 'The user will only be able to follow one of the links below.'
                      : 'The user will be able to follow a link or complete the process.'}
                  </span>
                </div>
              </div>
            </div>
          )}

          {/* Links section */}
          <div className="flex flex-col gap-3">
            <label
              className="text-sm font-semibold"
              style={{ color: colors['text-secondary'] }}
            >
              Links
            </label>
            <div className="flex flex-col gap-3">
              {links.length > 0 ? (
                links.map((link, idx) => {
                  const targetNode = getNode(
                    link.target
                  ) as FlowNodeType<NodeData> | null;
                  const isHovered = hoveredLinkId === link.id;
                  const isMenuOpen = openMenuId === link.id;
                  return (
                    <div
                      key={link.id}
                      className={`flex items-center justify-between rounded-md transition-colors duration-150 cursor-pointer`}
                      style={{
                        padding: '8px 8px',
                        backgroundColor:
                          isHovered || isMenuOpen
                            ? colors['bg-primary_hover']
                            : colors['bg-primary'],
                      }}
                      tabIndex={0}
                      onMouseEnter={() => setHoveredLinkId(link.id)}
                      onMouseLeave={() => setHoveredLinkId(null)}
                      onFocus={() => setHoveredLinkId(link.id)}
                      onBlur={() => setHoveredLinkId(null)}
                    >
                      <div className="flex items-center gap-2">
                        <span
                          className="text-sm font-medium"
                          style={{ color: colors['text-secondary'] }}
                        >
                          {typeof link.data?.label === 'string'
                            ? link.data.label
                            : 'Unlabeled link'}
                        </span>
                        <div className="w-5 h-5">
                          <img
                            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-narrow-right.svg`}
                            alt="Arrow"
                            className="w-5 h-5"
                          />
                        </div>
                        <div className="flex items-center gap-1">
                          {
                          targetNode?.data?.block?.signedIconUrl ? (
                            <img
                              src={targetNode.data.block.signedIconUrl}
                              alt="Block Icon"
                              className="w-4 h-4"
                            />
                          ) : targetNode?.data?.block?.icon && targetNode.data.block.icon.startsWith('https://cdn.brandfetch.io/') ? (
                            <img
                              src={targetNode.data.block.icon}
                              alt="Block Icon"
                              className="w-4 h-4"
                            />
                          ) : (
                            <img
                              src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/container.svg`}
                              alt="Block"
                              className="w-4 h-4"
                            />
                          )}
                          <span
                            className="text-sm font-medium"
                            style={{ color: colors['text-secondary'] }}
                          >
                            {targetNode?.data?.block?.title || 'Untitled Block'}
                          </span>
                        </div>
                      </div>
                      <div className="relative">
                        <button
                          ref={(el) => {
                            dotsRefs.current[link.id] = el;
                          }}
                          className="w-6 h-6 flex items-center justify-center rounded-md"
                          style={{
                            backgroundColor:
                              hoveredDotsId === link.id
                                ? colors['bg-secondary_subtle']
                                : 'transparent',
                            transition: 'background-color 0.2s',
                            cursor: 'pointer',
                          }}
                          aria-haspopup="menu"
                          aria-expanded={isMenuOpen}
                          aria-controls={`link-menu-${link.id}`}
                          tabIndex={0}
                          onMouseEnter={() => setHoveredDotsId(link.id)}
                          onMouseLeave={() => setHoveredDotsId(null)}
                          onFocus={() => setHoveredDotsId(link.id)}
                          onBlur={() => setHoveredDotsId(null)}
                          onClick={(e) => {
                            e.stopPropagation();
                            if (isMenuOpen) setOpenMenuId(null);
                            else handleMenuOpen(link.id, idx);
                          }}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                              e.preventDefault();
                              if (isMenuOpen) setOpenMenuId(null);
                              else handleMenuOpen(link.id, idx);
                            }
                          }}
                        >
                          <img
                            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dots-horizontal.svg`}
                            alt="Menu"
                            className="w-5 h-5"
                          />
                        </button>
                        {/* Dropdown menu */}
                        {isMenuOpen && (
                          <div
                            ref={(el) => {
                              menuRefs.current[link.id] = el;
                            }}
                            id={`link-menu-${link.id}`}
                            role="menu"
                            tabIndex={-1}
                            style={{
                              outline: 'none',
                              borderColor: colors['border-secondary'],
                              backgroundColor: colors['bg-secondary'],
                              minWidth: 200,
                              maxWidth: 260,
                              wordBreak: 'break-word',
                            }}
                            className={`absolute right-0 z-50 flex flex-col py-1 overflow-hidden cursor-pointer rounded-lg shadow-[0px_4px_6px_-2px_rgba(16,24,40,0.03),0px_12px_16px_-4px_rgba(16,24,40,0.08)] border transition-all duration-150 origin-top-right bg-white dark:bg-gray-900 ${menuPosition[link.id] === 'top' || links.length === 1 ? 'bottom-7' : 'top-7'} ${isMenuOpen ? 'opacity-100 scale-100' : 'opacity-0 scale-95'}`}
                          >
                            <div
                              onClick={() => handleEditLink(link)}
                              className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
                              role="menuitem"
                              tabIndex={0}
                              onKeyDown={(e) =>
                                handleMenuKeyDown(e, link.id, 0)
                              }
                            >
                              <div
                                style={
                                  {
                                    '--hover-bg': colors['bg-quaternary'],
                                  } as React.CSSProperties
                                }
                                className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] focus:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
                              >
                                <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
                                  <div className="w-4 h-4 relative overflow-hidden">
                                    <img
                                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                                      alt="Edit"
                                      className="w-4 h-4"
                                    />
                                  </div>
                                  <div
                                    style={{ color: colors['text-primary'] }}
                                    className="grow shrink basis-0 text-xs font-medium font-['Inter'] leading-tight overflow-hidden text-ellipsis whitespace-nowrap"
                                  >
                                    Edit link
                                  </div>
                                </div>
                              </div>
                            </div>
                            <div
                              style={{
                                borderColor: colors['border-secondary'],
                              }}
                              className="self-stretch h-px border-b my-1"
                            />
                            <div
                              onClick={() => handleDeleteLink(link)}
                              className="self-stretch px-1.5 py-px flex items-center gap-3"
                              role="menuitem"
                              tabIndex={0}
                              onKeyDown={(e) =>
                                handleMenuKeyDown(e, link.id, 1)
                              }
                            >
                              <div
                                style={
                                  {
                                    '--hover-bg': colors['bg-quaternary'],
                                  } as React.CSSProperties
                                }
                                className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] focus:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
                              >
                                <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
                                  <div className="w-4 h-4 relative overflow-hidden">
                                    <img
                                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`}
                                      alt="Delete"
                                      className="w-4 h-4"
                                    />
                                  </div>
                                  <div
                                    style={{ color: colors['text-primary'] }}
                                    className="grow shrink basis-0 text-xs font-medium font-['Inter'] leading-tight overflow-hidden text-ellipsis whitespace-nowrap"
                                  >
                                    Delete link
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                  );
                })
              ) : (
                <div
                  className="p-4 text-center"
                  style={{ color: colors['text-tertiary'] }}
                >
                  No links found
                </div>
              )}
            </div>
            <ButtonNormal
              variant="secondary"
              size="small"
              className="mt-2 w-full"
              onClick={handleCreateNewLink}
            >
              Create a new link
            </ButtonNormal>
          </div>
        </div>
      </Modal>
    </>
  );
};

export default EditLinksModal;
</file>

<file path="app/[slug]/[flow]/edit/components/AddBlockDropdownMenu.tsx">
import React, { useCallback, useState, useMemo, useRef, useEffect } from 'react';
import { DropdownDatas, Path, DelayType, Block } from '../../types';
import { BlockEndType } from '@/types/block';
import { useClipboardStore } from '../store/clipboardStore';
import { useModalStore } from '../store/modalStore';
import { useColors } from '@/app/theme/hooks';
import DelayTypeModal from './modals/DelayTypeModal';
import { motion } from 'framer-motion';

interface AddBlockDropdownMenuProps {
  dropdownDatas: DropdownDatas;
  onSelect: (
    blockType: 'STEP' | 'PATH' | 'DELAY',
    dropdownDatas: DropdownDatas,
    delayOptions?: {
      delayType?: DelayType;
      eventName?: string;
      seconds?: number;
    }
  ) => void;
  onClose: () => void;
  workspaceId: string;
  workflowId: string;
  onPathsUpdate: (paths: Path[] | ((currentPaths: Path[]) => Path[])) => void;
}

const AddBlockDropdownMenu: React.FC<AddBlockDropdownMenuProps> = ({
  dropdownDatas,
  onSelect,
  onClose,
  workspaceId,
  workflowId,
  onPathsUpdate,
}) => {
  const colors = useColors();
  const copiedBlock = useClipboardStore((state) => state.copiedBlock);
  const { setShowModal, setModalData } = useModalStore();
  const [showDelayTypeModal, setShowDelayTypeModal] = useState(false);
  const popupRef = useRef<HTMLDivElement>(null);
  const [actualPopupDimensions, setActualPopupDimensions] = useState<{width: number; height: number} | null>(null);

  // Measure popup dimensions after render
  useEffect(() => {
    if (popupRef.current) {
      const rect = popupRef.current.getBoundingClientRect();
      setActualPopupDimensions({
        width: rect.width,
        height: rect.height
      });
    }
  }, []);

  const menuItems = [
    {
      type: 'STEP' as const,
      label: 'Step',
      icon: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/git-commit.svg`,
    },
    {
      type: 'PATH' as const,
      label: 'Condition',
      icon: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dataflow-04.svg`,
    },
    {
      type: 'DELAY' as const,
      label: 'Delay',
      icon: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/clock-stopwatch-1.svg`,
    },
  ];

  // Find the last block in the current path
  const lastBlock = dropdownDatas.path.blocks.length
    ? dropdownDatas.path.blocks[dropdownDatas.path.blocks.length - 1]
    : undefined;

  // Check if last block has exactly one child_path
  const lastBlockHasExactlyOneChildPath =
    lastBlock &&
    Array.isArray(lastBlock.child_paths) &&
    lastBlock.child_paths.length === 1;

  // Filter menu items: remove "Condition" if last block has exactly one child_path
  const filteredMenuItems = lastBlockHasExactlyOneChildPath
    ? menuItems.filter((item) => item.type !== 'PATH')
    : menuItems;
  const handleSelect = useCallback(
    async (type: string) => {
      if (type === 'PATH') {
        setModalData({
          path: dropdownDatas.path,
          position: dropdownDatas.position,
          existingPaths: [],
        });
        setShowModal(true);
        onClose();
      } else if (type === 'DELAY') {
        setShowDelayTypeModal(true);
      } else {
        onSelect(type as 'STEP' | 'PATH' | 'DELAY', dropdownDatas);
        onClose();
      }
    },
    [onSelect, onClose, setShowModal, setModalData, dropdownDatas]
  );

  const handlePasteBlock = async () => {
    if (!copiedBlock) return;

    onClose();
    // 1. Create a fake block for optimistic UI
    const fakeId = -Date.now();
    const fakeBlock: Block = {
      ...copiedBlock,
      id: fakeId,
      position: dropdownDatas.position,
      path_id: dropdownDatas.path.id,
      child_paths: [],
      title: (copiedBlock.title || '') + ' (copy)',
    };

    // Optimistically add the fake block
    onPathsUpdate((currentPaths) => {
      return currentPaths.map((path) => {
        if (path.id === dropdownDatas.path.id) {
          const blocks = [...path.blocks];
          blocks.splice(dropdownDatas.position, 0, fakeBlock);
          const reindexedBlocks = blocks.map((block, idx) => ({
            ...block,
            position: idx,
          }));
          return { ...path, blocks: reindexedBlocks };
        }
        return path;
      });
    });

    try {
      const response = await fetch(`/api/blocks/${copiedBlock.id}/duplicate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          position: dropdownDatas.position,
          path_id: dropdownDatas.path.id,
        }),
      });

      if (!response.ok) throw new Error('Failed to paste block');

      const result = await response.json();
      const newBlock = { ...result.block, child_paths: [] };

      // Replace the fake block with the real one and reindex
      onPathsUpdate((currentPaths) => {
        return currentPaths.map((path) => {
          if (path.id === dropdownDatas.path.id) {
            // Remove the fake block
            let blocks = path.blocks.filter((block) => block.id !== fakeId);
            // Insert the real block at the correct position
            blocks.splice(dropdownDatas.position, 0, newBlock);
            // Reindex positions
            const reindexedBlocks = blocks.map((block, idx) => ({
              ...block,
              position: idx,
            }));
            return { ...path, blocks: reindexedBlocks };
          }
          return path;
        });
      });
    } catch (error) {
      // Rollback: remove the fake block
      onPathsUpdate((currentPaths) =>
        currentPaths.map((path) =>
          path.id === dropdownDatas.path.id
            ? {
                ...path,
                blocks: path.blocks.filter((block) => block.id !== fakeId),
              }
            : path
        )
      );
      console.error('Error pasting block:', error);
    }
  };

  const block = dropdownDatas.path.blocks.find(
    (b) => b.position === dropdownDatas.position
  );
  const isLastBlock = block?.type === BlockEndType.LAST;

  // Get existing child paths for the current path
  const existingPaths = block?.child_paths.map((cp) => cp.path.name) || [];

  // Check if the source path is a LastNode
  const isLastNode =
    dropdownDatas.path.blocks.find(
      (block) => block.position === dropdownDatas.position
    )?.type === 'LAST';

  const handleDelayTypeSelect = (
    delayType: DelayType,
    data: { seconds?: number; eventName?: string }
  ) => {
    // Send the delay data to the parent component
    onSelect('DELAY', dropdownDatas, {
      delayType,
      seconds: data.seconds,
      eventName: data.eventName,
    });
    onClose();
  };

  const handleDelayTypeClose = () => {
    setShowDelayTypeModal(false);
    onClose();
  };

  // Calculate optimal popup position using exact coordinates
  const popupPosition = useMemo(() => {
    const height = actualPopupDimensions?.height || 180;
    const width = actualPopupDimensions?.width || 240;
    const padding = 16;
    
    const viewportHeight = window.innerHeight;
    const viewportWidth = window.innerWidth;
    
    // Vertical positioning: above, below, or bottom edge
    let top: number;
    const aboveY = dropdownDatas.y - height;
    const belowY = dropdownDatas.y;
    
    if (aboveY >= padding) {
      top = aboveY;
    } else if (belowY + height <= viewportHeight - padding) {
      top = belowY;
    } else {
      top = viewportHeight - height - padding;
    }
    
    // Horizontal positioning: centered, left edge, or right edge
    let left: number;
    const centeredX = dropdownDatas.x - width / 2;
    
    if (centeredX >= padding && centeredX + width <= viewportWidth - padding) {
      left = centeredX;
    } else if (centeredX < padding) {
      left = padding;
    } else {
      left = viewportWidth - width - padding;
    }
    
    return { top, left, transform: 'none' };
  }, [dropdownDatas.x, dropdownDatas.y, actualPopupDimensions]);

  return (
    <>
      {/* Always render the DelayTypeModal but control visibility with isVisible prop */}
      <DelayTypeModal
        onClose={handleDelayTypeClose}
        onSelect={handleDelayTypeSelect}
        isVisible={showDelayTypeModal}
      />

      {/* Render dropdown menu only if delay type modal is not shown */}
      {!showDelayTypeModal && (
        <>
          <div className="fixed inset-0" onClick={onClose} />
          <motion.div
            ref={popupRef}
            initial={{ opacity: 0, scale: 0.95, y: -10 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            exit={{ opacity: 0, scale: 0.95, y: -10 }}
            transition={{ 
              duration: 0.15, 
              ease: [0.16, 1, 0.3, 1] // Custom easing for smooth feel
            }}
            className="absolute shadow-[0px_4px_6px_-2px_rgba(16,24,40,0.03),0px_12px_16px_-4px_rgba(16,24,40,0.08)] rounded-lg border z-[9999] py-1 flex flex-col overflow-hidden cursor-pointer"
            style={{
              top: popupPosition.top,
              left: popupPosition.left,
              transform: popupPosition.transform,
              backgroundColor: colors['bg-secondary'],
              borderColor: colors['border-primary'],
            }}
          >
            <div className="py-1">
              <div
                className="w-[240px] px-2.5 py-[9px] text-sm font-normal"
                style={{ color: colors['text-secondary'] }}
              >
                Add under this a:
              </div>

              <div
                className="h-px my-1"
                style={{ backgroundColor: colors['border-secondary'] }}
              />

              {filteredMenuItems.map((item) => (
                <div
                  key={item.type}
                  className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
                  onClick={() => handleSelect(item.type)}
                >
                  <div
                    style={
                      {
                        '--hover-bg': colors['bg-quaternary'],
                      } as React.CSSProperties
                    }
                    className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-200 overflow-hidden"
                  >
                    <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
                      <div className="w-4 h-4 relative overflow-hidden">
                        <img
                          src={item.icon}
                          alt={item.label}
                          className="w-4 h-4"
                        />
                      </div>
                      <div
                        style={{ color: colors['text-primary'] }}
                        className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
                      >
                        {item.label}
                      </div>
                    </div>
                  </div>
                </div>
              ))}

              {isLastBlock && (
                <div
                  className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
                  onClick={async () => {
                    // Optimistically update to END
                    onClose();
                    let previousType: BlockEndType;
                    onPathsUpdate((currentPaths) => {
                      const updatedPaths = currentPaths.map((path) => {
                        if (path.id === dropdownDatas.path.id) {
                          return {
                            ...path,
                            blocks: path.blocks.map((b) => {
                              if (b.id === block.id) {
                                previousType = b.type as BlockEndType;
                                return { ...b, type: BlockEndType.END };
                              }
                              return b;
                            }),
                          };
                        }
                        return path;
                      });
                      return updatedPaths;
                    });
                    try {
                      await fetch(`/api/blocks/${block.id}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                          type: BlockEndType.END,
                        }),
                      });
                    } catch (error) {
                      // Rollback to previous type if error
                      onPathsUpdate((currentPaths) => {
                        const rolledBackPaths = currentPaths.map((path) => {
                          if (path.id === dropdownDatas.path.id) {
                            return {
                              ...path,
                              blocks: path.blocks.map((b) =>
                                b.id === block.id
                                  ? { ...b, type: previousType }
                                  : b
                              ),
                            };
                          }
                          return path;
                        });
                        return rolledBackPaths;
                      });
                      console.error('Error converting block to END:', error);
                    }
                  }}
                >
                  <div
                    style={
                      {
                        '--hover-bg': colors['bg-quaternary'],
                      } as React.CSSProperties
                    }
                    className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-200 overflow-hidden"
                  >
                    <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
                      <div className="w-4 h-4 relative overflow-hidden">
                        <img
                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/stop-circle.svg`}
                          alt="End Block"
                          className="w-4 h-4"
                        />
                      </div>
                      <div
                        style={{ color: colors['text-primary'] }}
                        className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
                      >
                        End Block
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {copiedBlock && (
                <div
                  className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
                  onClick={handlePasteBlock}
                >
                  <div
                    style={
                      {
                        '--hover-bg': colors['bg-quaternary'],
                      } as React.CSSProperties
                    }
                    className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex hover:bg-[var(--hover-bg)] transition-all duration-200 overflow-hidden"
                  >
                    <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
                      <div className="w-4 h-4 relative overflow-hidden">
                        <img
                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/copy-icon.svg`}
                          alt="Paste"
                          className="w-4 h-4"
                        />
                      </div>
                      <div
                        style={{ color: colors['text-primary'] }}
                        className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
                      >
                        Paste Block
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </motion.div>
        </>
      )}
    </>
  );
};

export default AddBlockDropdownMenu;
</file>

<file path="app/[slug]/[flow]/edit/components/WorkflowHeader.tsx">
'use client';

import React, { useEffect, useState, useRef } from 'react';
import { useRouter, usePathname } from 'next/navigation';
import AvatarGroup from '@/app/components/AvatarGroup';
import ButtonNormal from '@/app/components/ButtonNormal';
import { useColors } from '@/app/theme/hooks';
import ShareModal from '@/app/components/ShareModal';
import EditFlowModal from '@/app/dashboard/components/EditFlowModal';
import { createReadLink } from '../../utils/createLinks';
import { Workflow } from '@/types/workflow';
import { motion, AnimatePresence } from 'framer-motion';
import { Workspace } from '@/types/workspace';

interface WorkflowHeaderProps {
  workflowId: string;
  parentFolder?: string;
  grandParentFolder?: string;
  slug?: string;
}

const WorkflowHeader: React.FC<WorkflowHeaderProps> = React.memo(
  ({ workflowId, parentFolder, grandParentFolder, slug }) => {
    const router = useRouter();
    const pathname = usePathname();
    const colors = useColors();
    const [avatarUrls, setAvatarUrls] = useState<string[]>([]);
    const [workflowTitle, setWorkflowTitle] = useState('');
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const [isShareModalOpen, setIsShareModalOpen] = useState(false);
    const [isEditFlowModalOpen, setIsEditFlowModalOpen] = useState(false);
    const [editableTitle, setEditableTitle] = useState('');
    const [createdDate, setCreatedDate] = useState('');
    const [workflowData, setWorkflowData] = useState<Workflow | null>(null);
    const [workspace, setWorkspace] = useState<Workspace | null>(null);

    useEffect(() => {
      const files = [
        'images/placeholder-avatar1.png',
        'images/placeholder-avatar2.png',
        'images/placeholder-avatar3.png',
      ];
      const baseUrl = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}`;
      const urls = files.map((file) => `${baseUrl}/${file}`);
      setAvatarUrls(urls);
    }, []);

    useEffect(() => {
      const fetchWorkflowData = async () => {
        try {
          const response = await fetch(`/api/workflow/${workflowId}`);
          if (response.ok) {
            const data = await response.json();
            setWorkflowTitle(data.title || data.name);
            setEditableTitle(data.title || data.name);
            setWorkflowData(data);

            if (data.workspace_id) {
              const workspaceResponse = await fetch(
                `/api/workspace/${data.workspace_id}`
              );
              if (workspaceResponse.ok) {
                const workspaceData = await workspaceResponse.json();
                setWorkspace(workspaceData);
              }
            }

            // Format the created date
            if (data.created_at) {
              const date = new Date(data.created_at);
              const formattedDate = date.toLocaleDateString('en-GB', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
              });
              setCreatedDate(formattedDate);
            }
          }
        } catch (error) {
          console.error('Error fetching workflow data:', error);
        }
      };

      fetchWorkflowData();
    }, [workflowId]);

    const navigateToFirstSegment = () => {
      router.push('/');
    };

    const navigateToRead = () => {
      if (slug) {
        const readPath = createReadLink(workflowTitle, workflowId, slug);
        router.push(readPath);
      }
    };

    const openShareModal = () => {
      setIsShareModalOpen(true);
      setIsDropdownOpen(false);
    };

    const closeShareModal = () => {
      setIsShareModalOpen(false);
    };

    const handleDropdownToggle = () => {
      setIsDropdownOpen(!isDropdownOpen);
    };

    const handleEditProcessInfo = () => {
      setIsEditFlowModalOpen(true);
      setIsDropdownOpen(false);
    };

    const handleDeleteProcess = () => {
      // TODO: Implement delete process functionality
      setIsDropdownOpen(false);
    };

    const dropdownMenuItems = [
      {
        label: 'Edit Flow info',
        icon: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`,
        onClick: handleEditProcessInfo,
      },
      {
        label: 'Delete Flow',
        icon: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-01.svg`,
        onClick: handleDeleteProcess,
      },
    ];

    return (
      <>
        <div
          className="fixed top-0 left-0 w-full h-[56px] p-4 flex justify-between items-center z-30"
          style={{
            backgroundColor: colors['bg-primary'],
            borderBottom: `1px solid ${colors['border-primary']}`,
          }}
        >
          <ButtonNormal
            variant="tertiary"
            size="small"
            leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-left.svg`}
            onClick={navigateToFirstSegment}
          >
            Back to Dashboard
          </ButtonNormal>

          <div className="pl-24 flex items-center gap-3">
            {grandParentFolder && (
              <>
                <span
                  className="text-sm font-['Inter'] px-2 py-1 rounded-md"
                  style={{
                    color: colors['breadcrumb-inactive-fg'],
                    fontWeight: 500,
                  }}
                >
                  {grandParentFolder}
                </span>
                <div
                  className="w-5 h-5 flex items-center justify-center"
                  style={{ color: colors['breadcrumb-separator'] }}
                >
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/slash-divider.svg`}
                    alt="/"
                    width="16"
                    height="16"
                  />
                </div>
              </>
            )}
            {parentFolder && (
              <>
                <span
                  className="text-sm font-['Inter'] px-2 py-1 rounded-md"
                  style={{
                    color: colors['breadcrumb-inactive-fg'],
                    fontWeight: 500,
                  }}
                >
                  {parentFolder}
                </span>
                <div
                  className="w-5 h-5 flex items-center justify-center"
                  style={{ color: colors['breadcrumb-separator'] }}
                >
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/slash-divider.svg`}
                    alt="/"
                    width="16"
                    height="16"
                  />
                </div>
              </>
            )}

            {/* Workflow title with dropdown */}
            <div className="relative">
              <span
                className="text-sm font-['Inter'] px-2 py-1 rounded-md cursor-pointer flex items-center gap-1"
                style={{
                  color: colors['breadcrumb-active-fg'],
                  backgroundColor: colors['breadcrumb-active-bg'],
                  fontWeight: 600,
                }}
                onClick={handleDropdownToggle}
                onMouseOver={(e) => {
                  e.currentTarget.style.opacity = '0.75';
                }}
                onMouseOut={(e) => {
                  e.currentTarget.style.opacity = '1';
                }}
              >
                {workflowTitle || 'Untitled Workflow'}
                <svg
                  width="16"
                  height="16"
                  viewBox="0 0 16 16"
                  fill="none"
                  style={{
                    transform: isDropdownOpen
                      ? 'rotate(180deg)'
                      : 'rotate(0deg)',
                    transition: 'transform 0.2s ease',
                  }}
                >
                  <path
                    d="M4 6L8 10L12 6"
                    stroke="currentColor"
                    strokeWidth="1.5"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                  />
                </svg>
              </span>

              {/* Dropdown Menu */}
              <AnimatePresence>
                {isDropdownOpen && (
                  <motion.div
                    initial={{ opacity: 0, scale: 0.95, y: -10 }}
                    animate={{ opacity: 1, scale: 1, y: 0 }}
                    exit={{ opacity: 0, scale: 0.95, y: -10 }}
                    transition={{
                      duration: 0.15,
                      ease: [0.16, 1, 0.3, 1], // Custom easing for smooth feel
                    }}
                    className="absolute top-full left-0 mt-1 w-48 rounded-lg shadow-[0px_4px_6px_-2px_rgba(16,24,40,0.03)] border z-50 overflow-hidden py-1 flex flex-col"
                    style={{
                      backgroundColor: colors['bg-secondary'],
                      borderColor: colors['border-primary'],
                    }}
                  >
                    {dropdownMenuItems.map((item, index) => (
                      <div key={index}>
                        <div
                          onClick={item.onClick}
                          className="self-stretch px-1.5 py-px flex items-center gap-3 transition duration-300"
                        >
                          <div
                            style={
                              {
                                '--hover-bg': colors['bg-quaternary'],
                              } as React.CSSProperties
                            }
                            className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-between items-center flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden cursor-pointer"
                          >
                            <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
                              <div className="w-4 h-4 relative overflow-hidden">
                                <img
                                  src={item.icon}
                                  alt={item.label}
                                  className="w-4 h-4"
                                />
                              </div>
                              <div
                                style={{
                                  color: colors['text-primary'],
                                }}
                                className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
                              >
                                {item.label}
                              </div>
                            </div>
                          </div>
                        </div>

                        {/* Add separator after "Edit Flow info" (index 0) */}
                        {index === 0 && (
                          <div
                            style={{ borderColor: colors['border-secondary'] }}
                            className="self-stretch h-px border-b my-1"
                          />
                        )}
                      </div>
                    ))}

                    {/* Separator before "Created on" information */}
                    {createdDate && (
                      <div
                        style={{ borderColor: colors['border-secondary'] }}
                        className="self-stretch h-px border-b my-1"
                      />
                    )}

                    {/* Created on information */}
                    {createdDate && (
                      <div className="self-stretch px-1.5 py-px">
                        <div className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-2 flex">
                          <div
                            style={{ color: colors['text-tertiary'] }}
                            className="text-sm font-normal font-['Inter'] leading-tight"
                          >
                            Created on: {createdDate}
                          </div>
                        </div>
                      </div>
                    )}
                  </motion.div>
                )}
              </AnimatePresence>
            </div>
          </div>

          <div className="flex items-center gap-4 ">
            {/*<AvatarGroup urls={avatarUrls} />*/}

            <div
              className="pl-4 justify-start items-center gap-2 flex"
              style={{ borderLeft: `1px solid ${colors['border-primary']}` }}
            >
              {slug && (
                <ButtonNormal
                  variant="tertiary"
                  iconOnly={true}
                  leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/play-icon.svg`}
                  onClick={navigateToRead}
                />
              )}
            </div>
          </div>
        </div>

        {/* Edit Process Info Modal */}
        {isEditFlowModalOpen && workflowData && (
          <EditFlowModal
            selectedWorkflow={workflowData}
            onClose={() => setIsEditFlowModalOpen(false)}
            onConfirm={async (
              id: number,
              name: string,
              description: string,
              process_owner: string,
              review_date: string,
              additional_notes: string,
              folder: any,
              icon: string | null,
              signedIcon: string | null
            ) => {
              try {
                // Convert review_date to ISO-8601 if present and not empty
                let reviewDateISO: string | null = null;
                if (review_date && review_date.trim() !== '') {
                  // If review_date is already ISO, this is safe; if it's "YYYY-MM-DD", this will work too
                  reviewDateISO = new Date(review_date).toISOString();
                }

                const response = await fetch(`/api/workflow/${workflowId}`, {
                  method: 'PATCH',
                  headers: {
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    name,
                    description,
                    process_owner,
                    review_date: reviewDateISO,
                    additional_notes,
                    icon,
                  }),
                });

                if (!response.ok) {
                  throw new Error('Failed to update workflow');
                }

                const updatedWorkflow = await response.json();

                // Update local state
                setWorkflowTitle(name);
                setEditableTitle(name);
                setWorkflowData(updatedWorkflow);

                return { workflow: updatedWorkflow };
              } catch (error) {
                console.error('Error updating workflow:', error);
                return {
                  workflow: null,
                  error: {
                    title: 'Update Failed',
                    description:
                      'Failed to update the workflow. Please try again.',
                  },
                };
              }
            }}
          />
        )}

        {/* Share Modal */}
        <ShareModal
          isOpen={isShareModalOpen}
          onClose={closeShareModal}
          itemName={workflowTitle || 'Untitled Workflow'}
          workspace={workspace || undefined}
        />
      </>
    );
  }
);

export default WorkflowHeader;
</file>

<file path="app/[slug]/[flow]/read/components/Header.tsx">
'use client';

import { useState, createContext } from 'react';
import { useTheme, useColors } from '@/app/theme/hooks';
import { cn } from '@/lib/utils/cn';
import BreadCrumbs from './BreadCrumbs';
import ButtonNormal from '@/app/components/ButtonNormal';
import Image from 'next/image';
import Link from 'next/link';
import UserInfo from '@/app/dashboard/components/UserInfo';
import UserDropdown from '@/app/dashboard/components/UserDropdown';
import { User } from '@/types/user';
import ShareModal from '@/app/components/ShareModal';
import { AnimatePresence } from 'framer-motion';
import { Workspace } from '@/types/workspace';

import { usePathname, useRouter } from 'next/navigation';
import { createEditLink } from '../../utils/createLinks';

export const HeaderHeightContext = createContext<number>(0);

interface HeaderProps {
  breadcrumbItems: Array<{
    label: string;
    href?: string;
  }>;
  user: User;
  className?: string;
  onOpenUserSettings: () => void;
  onOpenHelpCenter: () => void;
  params?: {
    id: string;
    workflowId: string;
    slug: string;
  };
  is_public?: boolean;
  onToggleAccess: () => void;
  shareUrl: string;
  workflowTitle?: string;
  workspace?: Workspace;
}

const Header: React.FC<HeaderProps> = ({
  breadcrumbItems,
  user,
  className,
  workflowTitle,
  onOpenUserSettings,
  onOpenHelpCenter,
  params,
  is_public = false,
  onToggleAccess,
  shareUrl,
  workspace,
}) => {
  const router = useRouter();
  const pathname = usePathname();
  const { getCssVariable } = useTheme();
  const colors = useColors();
  const [dropdownVisible, setDropdownVisible] = useState<boolean>(false);
  const [isFeedbackOpen, setIsFeedbackOpen] = useState(false);
  const [isShareModalOpen, setIsShareModalOpen] = useState(false);
  const headerHeight = 57; // Define the height here

  const handleUserInfoClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    setDropdownVisible(!dropdownVisible);
  };

  // Example messages - in a real app, these would come from your backend
  const exampleMessages = [
    {
      id: '1',
      user: {
        name: 'Lana Steiner',
        avatar: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/default-avatar.svg`,
        isOnline: true,
      },
      message:
        'Hey! I think the 1st step should be more direct. Here is an example',
      timestamp: 'Thursday 11:40am',
    },
    {
      id: '2',
      user: {
        name: 'Lana Steiner',
        avatar: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/default-avatar.svg`,
        isOnline: true,
      },
      attachment: {
        name: 'Onboarding.pdf',
        type: 'pdf',
        size: '1.2 MB',
      },
      timestamp: 'Thursday 11:40am',
    },
    {
      id: '3',
      isYou: true,
      user: {
        name: 'You',
        avatar:
          user.avatar_url ||
          `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/default-avatar.svg`,
      },
      message: 'Awesome! Thanks.',
      timestamp: 'Thursday 11:41am',
    },
    {
      id: '4',
      user: {
        name: 'Demi Wilkinson',
        avatar: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/default-avatar.svg`,
        isOnline: true,
      },
      message: 'Good timing  was just looking at this.',
      timestamp: 'Thursday 11:44am',
    },
    {
      id: '5',
      user: {
        name: 'Phoenix Baker',
        avatar: `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/default-avatar.svg`,
        isOnline: true,
      },
      message: 'Hey Olivia, can you please review the process date?',
      timestamp: 'Friday 2:20pm',
    },
    {
      id: '6',
      isYou: true,
      user: {
        name: 'You',
        avatar:
          user.avatar_url ||
          `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/default-avatar.svg`,
      },
      message: "Sure thing, I'll have a look today.",
      timestamp: 'Friday 2:20pm',
    },
  ];

  const navigateToEdit = () => {
    if (!params?.workflowId || !params?.slug || !workflowTitle) {
      console.error('Missing required parameters', params, workflowTitle);
      return;
    }
    const editPath = createEditLink(
      workflowTitle,
      params?.workflowId,
      params?.slug
    );
    router.push(editPath);
  };

  const handleSendMessage = (message: string) => {
    // In a real app, this would send the message to your backend
  };

  const openShareModal = () => {
    setIsShareModalOpen(true);
  };

  const closeShareModal = () => {
    setIsShareModalOpen(false);
  };

  return (
    <HeaderHeightContext.Provider value={headerHeight}>
      <header
        className={cn('w-full flex items-center justify-between', 'border-b')}
        style={{
          borderColor: colors['border-secondary'],
          backgroundColor: colors['bg-primary'],
          height: `${headerHeight}px`,
          padding: '0 16px',
        }}
      >
        <div className="flex items-center gap-2">
          <ButtonNormal
            variant="tertiary"
            size="small"
            iconOnly
            className="!p-2"
            onClick={() => window.history.back()}
            leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-left.svg`}
          />
          <BreadCrumbs items={breadcrumbItems} />
        </div>

        <div className="flex items-center gap-3">
          {/* Edit Button */}
          <ButtonNormal
            variant="secondary"
            size="small"
            leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-06.svg`}
            onClick={navigateToEdit}
          >
            Edit
          </ButtonNormal>

          {/* Share Button */}
          <ButtonNormal
            variant="primary"
            size="small"
            leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/share-06.svg`}
            onClick={openShareModal}
          >
            Share
          </ButtonNormal>

          {/* User Avatar with Dropdown */}
          <div className="relative">
            <div
              className="relative cursor-pointer"
              onClick={handleUserInfoClick}
            >
              <UserInfo user={user} isActive={dropdownVisible} />
              <AnimatePresence>
                {dropdownVisible && (
                  <div
                    className="fixed inset-0 z-10"
                    onClick={() => setDropdownVisible(false)}
                  >
                    <div
                      className="absolute top-[68px] right-3.5"
                      onClick={(e) => e.stopPropagation()}
                    >
                      <UserDropdown
                        user={user}
                        onOpenUserSettings={onOpenUserSettings}
                        onOpenHelpCenter={onOpenHelpCenter}
                        onClose={() => setDropdownVisible(false)}
                      />
                    </div>
                  </div>
                )}
              </AnimatePresence>
            </div>
          </div>
        </div>
      </header>

      {/* Share Modal */}
      <ShareModal
        isOpen={isShareModalOpen}
        onClose={closeShareModal}
        itemName={
          breadcrumbItems[breadcrumbItems.length - 1]?.label ||
          'Untitled Workflow'
        }
        params={params}
        is_public={is_public}
        onToggleAccess={onToggleAccess}
        shareUrl={shareUrl}
        workspace={workspace}
      />
    </HeaderHeightContext.Provider>
  );
};

export default Header;
</file>

<file path="app/api/blocks/[id]/image/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { supabase } from '@/lib/supabaseClient';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function DELETE(req: NextRequest) {
  // Choose the correct Prisma client
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Extract ID from the URL path
    const id = req.nextUrl.pathname.split('/').slice(-2)[0];
    if (!id) {
      return NextResponse.json(
        { error: 'Block ID is required' },
        { status: 400 }
      );
    }

    const blockId = parseInt(id);

    // Get both current image and original image paths
    const block = await prisma_client.block.findUnique({
      where: { id: blockId },
      select: { 
        image: true,
        original_image: true 
      },
    });

    if (!block?.image && !block?.original_image) {
      return NextResponse.json({ message: 'No images to delete' });
    }

    // Delete both images from Supabase storage
    const bucketName = process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_BUCKET;
    if (bucketName) {
      const filesToDelete = [
        block.image,
        block.original_image
      ].filter(Boolean) as string[];

      if (filesToDelete.length > 0) {
        const { error: storageError } = await supabase.storage
          .from(bucketName)
          .remove(filesToDelete);

        if (storageError) {
          console.error('Error deleting from storage:', storageError);
        }
      }
    }

    // Update the block to remove both image references
    const updatedBlock = await prisma_client.block.update({
      where: { id: blockId },
      data: { 
        image: null,
        original_image: null 
      },
    });

    return NextResponse.json(updatedBlock);
  } catch (error) {
    console.error('Error deleting images:', error);
    return NextResponse.json(
      { error: 'Failed to delete images' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/check-email/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { supabaseAdmin } from '@/utils/supabase/admin';
import { isVercel } from '../utils/isVercel';
import { PrismaClient } from '@prisma/client';

export async function GET(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) throw new Error('Prisma client not initialized');

  try {
    const email = req.nextUrl.searchParams.get('email');
    if (!email) {
      return NextResponse.json({ error: 'Email is required' }, { status: 400 });
    }

    // 1. Check Prisma
    const existingUser = await prisma_client.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      console.log('User exists in Prisma:', existingUser);
      return NextResponse.json({ exists: true });
    }

    // 2. Check Supabase using admin client
    try {
      const { data, error } = await supabaseAdmin.auth.admin.listUsers();
      if (!error && data?.users) {
        const userExists = data.users.some(user => user.email === email);
        if (userExists) {
          console.log('User exists in Supabase:', userExists);
          return NextResponse.json({ exists: true });
        }
      }
    } catch (e) {
      // If we can't check Supabase, assume user doesn't exist
      console.error('Error checking Supabase:', e);
    }

    console.log('User does not exist in Prisma or Supabase');
    return NextResponse.json({ exists: false });
  } catch (error) {
    console.error('Check email error:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/deleteUser/route.ts">
// app/api/deleteUser/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { supabaseAdmin } from '@/utils/supabase/admin'; // Use the new admin client
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { supabase } from '@/lib/supabaseClient';

/**
 * @swagger
 * /api/deleteUser:
 *   post:
 *     summary: Delete a user from the database and Supabase Auth
 *     description: Removes a user from the PostgreSQL database and Supabase authentication system.
 *     tags:
 *       - User 
*     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               userId:
 *                 type: string
 *                 description: The authentication ID of the user to be deleted.
 *                 example: "user-12345"
 *     responses:
 *       200:
 *         description: User successfully deleted
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *       400:
 *         description: Missing user ID in the request
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "User ID is required"
 *       404:
 *         description: User not found in the database
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "User not found in database"
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error: Error message"
 */
export async function POST(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { userId } = await req.json();

    console.log('deleting user', userId);
    if (!userId) {
      return NextResponse.json(
        { error: 'User ID is required' },
        { status: 400 }
      );
    }

    // Find user in PostgreSQL using auth_id
    const user = await prisma_client.user.findUnique({
      where: { auth_id: userId },
      select: { id: true },
    });

    if (!user) {
      return NextResponse.json(
        { error: 'User not found in database' },
        { status: 404 }
      );
    }

    // Delete related user_workspace
    await prisma_client.user_workspace.deleteMany({ where: { user_id: user.id } });

    // Delete the user from PostgreSQL
    await prisma_client.user.delete({ where: { id: user.id } });

    // Delete the user from Supabase Auth using the admin client
  
    const { error } = await supabaseAdmin.auth.admin.deleteUser(userId);

    if (error) {
      return NextResponse.json(
        { error: `Failed to delete user in Supabase: ${error.message}` },
        { status: 500 }
      );
    }

    // Delete all files in the user's storage folder (named after their UID)
    const bucketName = process.env.NEXT_PUBLIC_SUPABASE_PRIVATE_BUCKET;
    if (bucketName) {
      try {
        // List all files in the user's root folder (UID)
        const { data: files, error: listError } = await supabase.storage.from(bucketName).list(`${userId}/avatars`);
        console.log('files', files);
        if (listError) {
          console.error(`Error listing files for user ${userId}:`, listError);
        } else if (files && files.length > 0) {
          // Collect all file paths (including subfolders)
          const filePaths = files.map((file: any) => `${userId}/avatars/${file.name}`);
          const { error: removeError } = await supabase.storage.from(bucketName).remove(filePaths);
          if (removeError) {
            console.error(`Error deleting files for user ${userId}:`, removeError);
          }
        }
      } catch (storageError) {
        console.error(`Unexpected error deleting user files for ${userId}:`, storageError);
      }
    }

    return NextResponse.json({ success: true }, { status: 200 });
  } catch (error: any) {
    console.error('Error deleting user:', error);
    return NextResponse.json(
      { error: `Internal Server Error: ${error.message}` },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/onboarding/email/route.ts">
import { createClient } from '@/utils/supabase/server';
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
// Import the email components and utility
import { sendReactEmail } from '@/lib/email';
import { WelcomeEmail } from '@/emails/templates/WelcomeEmail';
import { scheduleFollowUpEmail, scheduleTestEmail } from '@/lib/scheduledEmails';
import { scheduleFeedbackRequestEmail } from '@/lib/emails/scheduleFeedbackRequestEmail';
import { checkWorkspaceName } from '@/app/utils/checkNames';
import * as Sentry from '@sentry/nextjs';
import { createDefaultWorkflow, createDefaultWorkflows } from '@/app/api/utils/create-default-workflow';
import { performance } from 'perf_hooks';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

// Define the EmailScheduleResponse interface and necessary functions inline
interface EmailScheduleResponse {
  success: boolean;
  error?: any;
  warnings?: {
    welcomeEmail?: any;
    followUpEmail?: any;
    feedbackEmail?: any;
    emailError?: any;
  } | null;
}

// Implementation of scheduleOnboardingFollowUpEmail (renamed to avoid conflict)
async function scheduleOnboardingFollowUpEmail(userId: number): Promise<EmailScheduleResponse> {
  try {
    // Get the user from the database to get their email and name
    // This is a placeholder - in a real implementation, you would fetch the user
    // const user = await prisma.user.findUnique({ where: { id: userId } });
    
    // For now, we'll just simulate scheduling the email
    const scheduledDate = new Date();
    scheduledDate.setDate(scheduledDate.getDate() + 4); // 4 days from now
    
    // Schedule the follow-up email
    const result = await scheduleEmail(userId, EmailType.FOLLOW_UP, scheduledDate);
    
    if (!result.success) {
      console.error('Failed to schedule follow-up email:', result.error);
      Sentry.captureException(result.error);
      return { success: false, error: result.error };
    }
    
   
    return { success: true };
  } catch (error) {
    console.error('Error scheduling follow-up email:', error);
    Sentry.captureException(error);
    return { success: false, error };
  }
}

// Enum for email types
enum EmailType {
  WELCOME = 'WELCOME',
  FOLLOW_UP = 'FOLLOW_UP',
}

// Implementation of scheduleEmail
async function scheduleEmail(
  userId: number,
  emailType: EmailType,
  scheduledDate: Date
): Promise<EmailScheduleResponse> {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Here you would implement the actual email scheduling logic
    // This could involve creating a record in a database table for scheduled emails
    // that a cron job would pick up and process
    
    // Use upsert to handle duplicates gracefully
    await prisma_client.scheduled_email.upsert({
      where: {
        unique_pending_email_per_user_type: {
          user_id: userId,
          email_type: emailType.toString()
        }
      },
      update: {
        scheduled_for: scheduledDate,
        updated_at: new Date()
      },
      create: {
        user_id: userId,
        email_type: emailType.toString(),
        scheduled_for: scheduledDate
      }
    });
    
    return { success: true };
  } catch (error) {
    console.error(`Failed to schedule ${emailType} email:`, error);
    Sentry.captureException(error);
    return { success: false, error };
  }
}

/**
 * Helper function to send welcome email with proper error handling
 */
async function sendWelcomeEmailToUser(email: string, firstName: string): Promise<{ success: boolean; error?: any }> {
  try {
    // Get safe public URLs for email templates
    const safePublicUrls = {
      supabasePublicUrl: process.env.NEXT_PUBLIC_SUPABASE_URL || '',
      supabaseStoragePath: process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH || '',
      producthuntUrl: process.env.NEXT_PUBLIC_PRODUCTHUNT_URL || 'https://www.producthunt.com',
      linkedinUrl: process.env.NEXT_PUBLIC_LINKEDIN_URL || 'https://www.linkedin.com/company/processflow1/',
      xUrl: process.env.NEXT_PUBLIC_X_URL || 'https://x.com',
    };

    const result = await sendReactEmail({
      to: email,
      subject: 'Welcome to ProcessFlow - Here\'s how to start decently',
      Component: WelcomeEmail,
      props: {
        firstName: firstName,
        jeanRdvLink: process.env.JEAN_RDV_LINK || 'https://cal.com/jean-willame-v2aevm/15min',
        sender: 'jean',
        publicUrls: safePublicUrls,
      },
      sender: 'jean',
    });

    if (!result.success) {
      console.error('Failed to send welcome email:', result.error);
      Sentry.captureException(result.error);
      return { success: false, error: result.error };
    }

  
    return { success: true };
  } catch (error) {
    console.error('Error sending welcome email:', error);
    Sentry.captureException(error);
    return { success: false, error };
  }
}

/**
 * Helper function to schedule onboarding emails with proper error handling
 */
async function scheduleOnboardingEmails(userId: number, firstName: string, email: string): Promise<EmailScheduleResponse> {
  try {
    // Send welcome email right away
    const welcomeResult = await sendWelcomeEmailToUser(email, firstName);
    
    if (!welcomeResult.success) {
      // Log the error but continue with onboarding
      console.error('Failed to send welcome email, but continuing with onboarding:', welcomeResult.error);
      Sentry.captureException(welcomeResult.error);
    }
    
    // Schedule follow-up email for 4 days later
    const followUpResult = await scheduleOnboardingFollowUpEmail(userId);
    
    if (!followUpResult.success) {
      // Log the error but continue with onboarding
      console.error('Failed to schedule follow-up email, but continuing with onboarding:', followUpResult.error);
      Sentry.captureException(followUpResult.error);
    }
    
    // Schedule feedback request email for 7 days later
    // NOTE: This is the ONLY place where feedback request emails should be scheduled
    // The scheduleFeedbackRequestEmail function has duplicate prevention built-in
    const feedbackResult = await scheduleFeedbackRequestEmail(userId);
    
    if (!feedbackResult.success) {
      // Log the error but continue with onboarding
      console.error('Failed to schedule feedback request email, but continuing with onboarding:', feedbackResult.error);
      Sentry.captureException(feedbackResult.error);
    }
    
    return { 
      success: true,
      // Include warnings if any email operations failed
      warnings: !welcomeResult.success || !followUpResult.success || !feedbackResult.success ? {
        welcomeEmail: welcomeResult.success ? null : welcomeResult.error,
        followUpEmail: followUpResult.success ? null : followUpResult.error,
        feedbackEmail: feedbackResult.success ? null : feedbackResult.error,
      } : null
    };
  } catch (error) {
    console.error('Error scheduling onboarding emails:', error);
    Sentry.captureException(error);
    // Return success true because we want onboarding to continue even if emails fail
    return { 
      success: true, 
      warnings: { emailError: error }
    };
  }
}

// Add a helper function at the top level to update an existing workspace
async function updateExistingWorkspace(
  workspaceId: number, 
  formData: any, 
  userId: number,
  tempIndustry: string | null, 
  tempCompanySize: string | null,
  prisma_client: typeof prisma
) {
  try {
    if (!prisma_client) {
      throw new Error('Prisma client not initialized');
    }
    const workspace = await prisma_client.workspace.update({
      where: { id: workspaceId },
      data: {
        name: formData.workspace_name,
        slug: formData.workspace_url,
        icon_url: formData.workspace_icon_url,
        industry: tempIndustry || null,
        company_size: tempCompanySize || null,
      }
    });
    
    return workspace;
  } catch (error) {
    console.error(`Error updating existing workspace (ID: ${workspaceId}):`, error);
    Sentry.captureException(error);
    throw error;
  }
}

export async function POST(request: Request) {
  // Choose the correct Prisma client
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.error('Auth error:', authError);
      Sentry.captureException(authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Check if the request is multipart/form-data or JSON
    const contentType = request.headers.get('content-type');
    let step: string;
    let formData: any;

    if (contentType?.includes('multipart/form-data')) {
      // Handle multipart/form-data (with file)
      const requestFormData = await request.formData();
      step = requestFormData.get('step') as string;
      
      // Get JSON data
      const dataString = requestFormData.get('data') as string;
      formData = JSON.parse(dataString);
      
      // Handle logo file if present
      const logoFile = requestFormData.get('logo') as File;
      if (logoFile) {
        const fileName = `workspace-logo-${user.id}-${Date.now()}`;
        const { data: uploadData, error: uploadError } = await supabase.storage
          .from('user-assets')
          .upload(`workspaces_logo/${fileName}`, logoFile, {
            cacheControl: '3600',
            upsert: false
          });
        
        if (uploadError) {
          console.error('Error uploading logo:', uploadError);
          Sentry.captureException(uploadError);
          throw new Error('Failed to upload logo');
        }
        
        // Get public URL for the logo
        const { data: { publicUrl } } = supabase.storage
          .from('user-assets')
          .getPublicUrl(`workspaces_logo/${fileName}`);
        
        formData.workspace_icon_url = publicUrl;
      }
    } else {
      // Handle JSON request (without file)
      const json = await request.json();
      step = json.step;
      formData = json.data;
    }

    if (!step || !formData) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    // Get user from database
    const dbUser = await prisma_client.user.findUnique({
      where: { auth_id: user.id },
    });

    if (!dbUser) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Handle each onboarding step
    switch (step) {
      case 'PERSONAL_INFO':
      //   // Create a temporary workspace WITHOUT creating a workflow
      //   const { workspaceId: tempWorkspaceId } = await createTempWorkspace(
      //     dbUser.id, 
      //     formData.first_name, 
      //     formData.last_name
      //   );

        // Update user with personal info and temporary workspace ID
        await prisma_client.user.update({
          where: { id: dbUser.id },
          data: {
            ...formData,
            onboarding_step: 'PROFESSIONAL_INFO',
          }
        });

        // Store the temp workspace ID in Supabase user metadata
        await supabase.auth.updateUser({
          data: {
            onboarding_status: {
              current_step: 'professional-info',
              completed_at: null
            },
          }
        });
        break;

      case 'PROFESSIONAL_INFO':
        // Extract user-specific and workspace-specific data
        const { industry, company_size, is_navigating_back, forceComplete, ...userData } = formData;
        
        await prisma_client.user.update({
          where: { id: dbUser.id },
          data: {
            ...userData,
            temp_industry: industry,
            temp_company_size: company_size,
            onboarding_step: is_navigating_back ? 'PERSONAL_INFO' : (forceComplete ? 'COMPLETED' : 'WORKSPACE_SETUP'),
            onboarding_completed_at: forceComplete ? new Date() : undefined,
          }
        });

        // Update Supabase user metadata
        await supabase.auth.updateUser({
          data: {
            onboarding_status: {
              current_step: is_navigating_back
                ? 'personal-info'
                : (forceComplete ? 'completed' : 'workspace-setup'),
              completed_at: forceComplete ? new Date().toISOString() : null,
            }
          }
        });
        
        // We don't need to create a workflow here either
        // The workflow will be created during the WORKSPACE_SETUP step, regardless of auth method
        break;

      case 'WORKSPACE_SETUP':
        // Skip workspace validation if we're just navigating back
        if (formData.is_navigating_back) {
          await prisma_client.user.update({
            where: { id: dbUser.id },
            data: {
              onboarding_step: 'PROFESSIONAL_INFO'
            }
          });

          // Update Supabase user metadata
          await supabase.auth.updateUser({
            data: {
              onboarding_status: {
                current_step: 'professional-info',
                completed_at: null
              }
            }
          });

          return NextResponse.json({ success: true });
        }

        // Only validate workspace name if we're not navigating back
        const nameError = checkWorkspaceName(formData.workspace_name);
        if (nameError) {
          return NextResponse.json({ 
            error: 'Invalid workspace name',
            ...nameError 
          }, { status: 400 });
        }

        let workspace;
        let workflowCreationWarning = null;
        
        // Reset user workspaces
        await prisma_client.user_workspace.deleteMany({
          where: { user_id: dbUser.id }
        });
        
          // Create a new workspace if no temp workspace exists
          console.log(`Creating new workspace for user ${dbUser.id} as no existing workspace was found`);
          
          // Double-check slug availability before attempting to create
          const existingWorkspaceWithSlug = await prisma_client.workspace.findFirst({
            where: { slug: formData.workspace_url }
          });
          
          if (existingWorkspaceWithSlug) {
            console.error(`Slug "${formData.workspace_url}" already exists in database before creation attempt`);
            return NextResponse.json({ 
              error: `Slug constraint failed: The workspace URL "${formData.workspace_url}" is already taken. Please try a different URL.` 
            }, { status: 400 });
          }
          
          try {
            workspace = await prisma_client.workspace.create({
              data: {
                name: formData.workspace_name,
                slug: formData.workspace_url,
                icon_url: formData.workspace_icon_url,
                industry: dbUser.temp_industry || null,
                company_size: dbUser.temp_company_size || null,
                user_workspaces: {
                  create: {
                    user_id: dbUser.id,
                    role: 'ADMIN'
                  }
                }
              }
            });
            
            console.log(`Successfully created workspace with slug: ${formData.workspace_url}`);
          } catch (workspaceError) {
            // Check if this is a slug constraint error
            const errorMsg = workspaceError instanceof Error ? workspaceError.message : 'Unknown error';
            console.error(`Error creating workspace for user ${dbUser.id}:`, errorMsg);
            Sentry.captureException(workspaceError);
            
            // Provide a more detailed error message for slug constraint violations
            if (
              errorMsg.includes('Unique constraint failed') ||
              errorMsg.includes('unique constraint') ||
              errorMsg.includes('duplicate key') ||
              errorMsg.includes('workspace_slug_key')
            ) {
              return NextResponse.json({ 
                error: `Slug constraint failed: The workspace URL "${formData.workspace_url}" is already taken. Please try a different URL.` 
              }, { status: 400 });
            }
            
            // For other errors, rethrow to be handled by the outer catch block
            throw workspaceError;
          }
          
          // If no temp workspace was created, we need to create the workflow now
          let workflowErrorFinal = null;
          let workflowCreationDurationMs = null; // Add this to store the duration

          const workflowStart = performance.now(); // Start timing

          for (let attempt = 1; attempt <= 3; attempt++) {
            try {
              const results = await createDefaultWorkflows({
                workspaceId: workspace.id,
                userId: dbUser.id
              });
              const allWarnings = results.flatMap(r => 'warnings' in r && r.warnings ? r.warnings : []);
              if (allWarnings.length > 0) {
                workflowCreationWarning = {
                  message: 'Default workflows created with warnings',
                  details: allWarnings
                };
              }
              workflowErrorFinal = null;
              break; // Success, exit retry loop
            } catch (workflowError) {
              console.error(`Error creating default workflows (attempt ${attempt}):`, workflowError);
              Sentry.captureException(workflowError);
              workflowErrorFinal = workflowError;
              if (attempt < 3) await new Promise(res => setTimeout(res, 500));
            }
          }

          workflowCreationDurationMs = performance.now() - workflowStart; // End timing
          console.log(`Default workflows created in ${workflowCreationDurationMs} milliseconds`);

          if (workflowErrorFinal) {
            workflowCreationWarning = {
              message: 'Failed to create default workflows after 3 attempts',
              details: workflowErrorFinal
            };
            Sentry.captureException(workflowErrorFinal);
          }

        // Update user with active workspace and complete onboarding
        await prisma_client.user.update({
          where: { id: dbUser.id },
          data: {
            active_workspace_id: workspace?.id || null,
            onboarding_step: 'COMPLETED',
            onboarding_completed_at: new Date(),
            temp_industry: null,
            temp_company_size: null,
          }
        });

        // Update Supabase user metadata and clear the temporary workspace ID
        await supabase.auth.updateUser({
          data: {
            onboarding_status: {
              current_step: 'completed',
              completed_at: new Date().toISOString()
            },
            temp_workspace_id: null // Clear temp workspace ID
          }
        });

        // Schedule welcome and follow-up emails
        const emailResult = await scheduleOnboardingEmails(dbUser.id, dbUser.first_name, dbUser.email);
        
        // Include warnings in the response if there were email issues
        const response: any = { success: true };
        if (emailResult.warnings) {
          response.warnings = {
            emails: emailResult.warnings,
            message: "Onboarding completed successfully, but there were issues with email notifications."
          };
        }
        
        // Add workflow creation warnings if any
        if (workflowCreationWarning) {
          if (!response.warnings) {
            response.warnings = {};
          }
          response.warnings.workflowCreation = workflowCreationWarning;
          response.warnings.message = response.warnings.message || 
            "Onboarding completed successfully, but there were some issues.";
        }

        try {
          // Use the imported scheduleFollowUpEmail function
          await scheduleFollowUpEmail({
            userId: dbUser.id,
            emailType: 'FEATURE_UPDATE',
            daysAfter: 4,
            metadata: {
              firstName: dbUser.first_name,
              // The roadmapLink will be generated by the scheduleFollowUpEmail function
            },
          }).catch(err => {
            console.warn('Error scheduling feature update email, but continuing:', err);
            Sentry.captureException(err);
            if (response.warnings) {
              response.warnings.emails.featureUpdateEmail = err;
            }
          });

          // For testing: Schedule the same email to be sent in 5 minutes
          // Comment this out in production
          if (process.env.NODE_ENV !== 'production') {
            await scheduleTestEmail({
              userId: dbUser.id,
              emailType: 'FEATURE_UPDATE',
              minutesAfter: 5,
              metadata: {
                firstName: dbUser.first_name,
                // The roadmapLink will be generated by the scheduleTestEmail function
              },
            }).catch(err => {
              console.warn('Error scheduling test email, but continuing:', err);
              Sentry.captureException(err);
              if (response.warnings) {
                response.warnings.emails.testEmail = err;
              }
            });
          }
        } catch (error) {
          console.warn('Error in additional email scheduling, but continuing with onboarding completion:', error);
          Sentry.captureException(error);
          if (response.warnings) {
            response.warnings.additionalEmails = error;
          }
        }

        return NextResponse.json(response);

      case 'INVITED_USER':
        await prisma_client.user.update({
          where: { id: dbUser.id },
          data: {
            ...formData,
            onboarding_step: 'COMPLETED',
            onboarding_completed_at: new Date()
          }
        });

        // Update Supabase user metadata
        await supabase.auth.updateUser({
          data: {
            onboarding_status: {
              current_step: 'completed',
              completed_at: new Date().toISOString()
            }
          }
        });
        
        // Create default workflows for invited users as well
        let invitedWorkflowCreationWarning = null;
        if (dbUser.active_workspace_id) {
          let invitedWorkflowErrorFinal = null;
          for (let attempt = 1; attempt <= 3; attempt++) {
            try {
              const start = performance.now();
              const results = await createDefaultWorkflows({
                workspaceId: dbUser.active_workspace_id,
                userId: dbUser.id
              });
              const end = performance.now();
              const elapsedTime = end - start;
              console.log(`Default workflows created in ${elapsedTime} milliseconds`);
              const allWarnings = results.flatMap(r => 'warnings' in r && r.warnings ? r.warnings : []);
              if (allWarnings.length > 0) {
                invitedWorkflowCreationWarning = {
                  message: 'Default workflows created with warnings',
                  details: allWarnings
                };
              }
              invitedWorkflowErrorFinal = null;
              break; // Success, exit retry loop
            } catch (workflowError) {
              console.error(`Error creating default workflows for invited user (attempt ${attempt}):`, workflowError);
              Sentry.captureException(workflowError);
              invitedWorkflowErrorFinal = workflowError;
              if (attempt < 3) await new Promise(res => setTimeout(res, 500));
            }
          }
          if (invitedWorkflowErrorFinal) {
            invitedWorkflowCreationWarning = {
              message: 'Failed to create default workflows after 3 attempts',
              details: invitedWorkflowErrorFinal
            };
            Sentry.captureException(invitedWorkflowErrorFinal);
          }
        }

        // Schedule welcome and follow-up emails for invited users too
        const invitedEmailResult = await scheduleOnboardingEmails(dbUser.id, dbUser.first_name, dbUser.email);
        
        // Include warnings in the response if there were email issues
        const invitedResponse: any = { success: true };
        if (invitedEmailResult.warnings) {
          invitedResponse.warnings = {
            emails: invitedEmailResult.warnings,
            message: "Onboarding completed successfully, but there were issues with email notifications."
          };
        }
        
        // Add workflow creation warnings for invited users if any
        if (invitedWorkflowCreationWarning) {
          if (!invitedResponse.warnings) {
            invitedResponse.warnings = {};
          }
          invitedResponse.warnings.workflowCreation = invitedWorkflowCreationWarning;
          invitedResponse.warnings.message = invitedResponse.warnings.message || 
            "Onboarding completed successfully, but there were some issues.";
        }
        
        return NextResponse.json(invitedResponse);

      default:
        return NextResponse.json({ error: 'Invalid step' }, { status: 400 });
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error processing onboarding:', error);
    Sentry.captureException(error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to update onboarding information' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/test/cleanup-user/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { createClient } from '@supabase/supabase-js';

export async function POST(req: NextRequest) {
  const prisma = isVercel() ? new PrismaClient() : require('@/lib/prisma').default;
  const { email } = await req.json();
  if (!email) {
    return NextResponse.json({ error: 'Email is required' }, { status: 400 });
  }
  try {
    // Get userId by email
    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }
    const auth_id = user.auth_id;
    // Delete user from Prisma
    await prisma.user.delete({ where: { auth_id } });
    // Delete user from Supabase
    const supabaseUrl = process.env.SUPABASE_URL;
    const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
    if (!supabaseUrl || !supabaseKey) {
      throw new Error('Missing Supabase environment variables');
    }
    const supabase = createClient(supabaseUrl, supabaseKey);
    const { error: supabaseError } = await supabase.auth.admin.deleteUser(auth_id);
    if (supabaseError) {
      return NextResponse.json({ error: supabaseError.message }, { status: 500 });
    }
    return NextResponse.json({ success: true });
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return NextResponse.json({ error: message || 'Internal server error' }, { status: 500 });
  } finally {
    if (isVercel()) await prisma.$disconnect();
  }
}
</file>

<file path="app/api/test/cleanup-workspace/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function POST(req: NextRequest) {
  const prisma = isVercel() ? new PrismaClient() : require('@/lib/prisma').default;
  const { name, user_id } = await req.json();
  if (!name || !user_id) {
    return NextResponse.json({ error: 'Workspace name and user_id are required' }, { status: 400 });
  }
  try {
    const workspace = await prisma.workspace.findFirst({
      where: {
        name,
        user_workspaces: { some: { user_id, role: 'ADMIN' } }
      }
    });
    if (workspace) {
      await prisma.user_workspace.deleteMany({ where: { workspace_id: workspace.id } });
      await prisma.workspace.delete({ where: { id: workspace.id } });
    }
    return NextResponse.json({ success: true });
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return NextResponse.json({ error: message || 'Internal server error' }, { status: 500 });
  } finally {
    if (isVercel()) await prisma.$disconnect();
  }
}
</file>

<file path="app/api/test/get-user-by-email/route.ts">
import { isVercel } from '@/app/api/utils/isVercel';
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';

export async function POST(req: NextRequest) {
    const prisma_client = isVercel() ? new PrismaClient() : prisma;
    if (!prisma_client) {
        throw new Error('Prisma client not initialized');
    }
    const { email } = await req.json();
    if (!email) {
        return NextResponse.json({ error: 'Email is required' }, { status: 400 });
    }
    try {
        const user = await prisma_client.user.findUnique({ where: { email } });
        if (!user) {
            return NextResponse.json({ error: 'User not found' }, { status: 404 });
        }
        return NextResponse.json({ auth_id: user.auth_id });
    } catch (error) {
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    } finally {
        if (isVercel()) {
            await prisma_client.$disconnect();
        }
    }
}
</file>

<file path="app/api/test/seed-user/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { createClient } from '@supabase/supabase-js';

export async function POST(req: NextRequest) {
  const prisma = isVercel() ? new PrismaClient() : require('@/lib/prisma').default;
  const { email, password, email_confirmed, onboarding_step, first_name, last_name, full_name, provider } = await req.json();
  if (!email || !password) {
    return NextResponse.json({ error: 'Email and password are required' }, { status: 400 });
  }
  const supabaseUrl = process.env.SUPABASE_URL;
  const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!supabaseUrl || !supabaseKey) {
    throw new Error('Missing Supabase environment variables');
  }
  const supabase = createClient(supabaseUrl, supabaseKey);
  let step = onboarding_step || 'PERSONAL_INFO';
  const isCompleted = step === 'COMPLETED';
  try {
    // Try to create user in Supabase Auth
    let { data: authUser, error: authError } = await supabase.auth.admin.createUser({
      email,
      password,
      email_confirm: email_confirmed,
      user_metadata: {
        onboarding_step: step,
        onboarding_status: {
          current_step: step,
          completed_at: isCompleted ? new Date().toISOString() : null
        }
      }
    });
    let resultUser = authUser;
    if (authError && authError.message.includes('already been registered')) {
      // Update user if already exists
      const { data: userList, error: listError } = await supabase.auth.admin.listUsers();
      if (listError) return NextResponse.json({ error: listError.message }, { status: 500 });
      const user = userList?.users?.find((u) => u.email === email);
      if (!user) return NextResponse.json({ error: 'User not found for update.' }, { status: 404 });
      const { data: updatedUser, error: updateError } = await supabase.auth.admin.updateUserById(user.id, {
        email_confirm: email_confirmed,
        user_metadata: {
          onboarding_step: step,
          onboarding_status: {
            current_step: step,
            completed_at: isCompleted ? new Date().toISOString() : null
          }
        }
      });
      if (updateError) return NextResponse.json({ error: updateError.message }, { status: 500 });
      resultUser = updatedUser;
    } else if (authError) {
      return NextResponse.json({ error: authError.message }, { status: 500 });
    }
    // Create or update user in Prisma
    const auth_id = resultUser.user?.id;
    const userEmail = resultUser.user?.email;
    if (!auth_id || !userEmail) {
      return NextResponse.json({ error: 'Supabase user missing id or email' }, { status: 500 });
    }
    let user = await prisma.user.findUnique({ where: { auth_id } });
    if (!user) {
      user = await prisma.user.create({
        data: {
          auth_id,
          email: userEmail,
          first_name: first_name || '',
          last_name: last_name || '',
          full_name: full_name || '',
          onboarding_step: step,
          onboarding_completed_at: isCompleted ? new Date().toISOString() : null,
        }
      });
    } else {
      user = await prisma.user.update({
        where: { auth_id },
        data: {
          onboarding_step: step,
          onboarding_completed_at: isCompleted ? new Date().toISOString() : null,
        }
      });
    }
    return NextResponse.json({ user });
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return NextResponse.json({ error: message || 'Internal server error' }, { status: 500 });
  } finally {
    if (isVercel()) await prisma.$disconnect();
  }
}
</file>

<file path="app/api/test/seed-workspace/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function POST(req: NextRequest) {
  const prisma = isVercel() ? new PrismaClient() : require('@/lib/prisma').default;
  const { name, user_id } = await req.json();
  if (!name || !user_id) {
    return NextResponse.json({ error: 'Workspace name and user_id are required' }, { status: 400 });
  }
  try {
    let workspace = await prisma.workspace.findFirst({
      where: {
        name,
        user_workspaces: { some: { user_id, role: 'ADMIN' } }
      }
    });
    if (!workspace) {
      // Generate a random slug
      let slug;
      let isUnique = false;
      while (!isUnique) {
        slug = Math.floor(Math.random() * 1e9).toString();
        const existing = await prisma.workspace.findUnique({ where: { slug } });
        if (!existing) isUnique = true;
      }
      const background_colours = ['#4299E1', '#F56565', '#48BB78'];
      const randomColour = background_colours[Math.floor(Math.random() * background_colours.length)];
      workspace = await prisma.workspace.create({
        data: {
          name,
          slug,
          background_colour: randomColour,
          user_workspaces: {
            create: {
              user_id,
              role: 'ADMIN',
            },
          },
        },
        include: {
          user_workspaces: true,
        },
      });
    }
    return NextResponse.json({ workspace });
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return NextResponse.json({ error: message || 'Internal server error' }, { status: 500 });
  } finally {
    if (isVercel()) await prisma.$disconnect();
  }
}
</file>

<file path="app/api/upload/route.ts">
// app/api/upload/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/lib/supabaseClient'; // Shared Supabase client
import { createClient } from '@/utils/supabase/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { v4 as uuidv4 } from 'uuid';

/**
 * @swagger
 * /api/upload:
 *   post:
 *     summary: Upload a file to Supabase storage
 *     description: Allows users to upload images or videos to a designated Supabase storage bucket.
 *     tags:
 *       - Upload 
*     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               file:
 *                 type: string
 *                 format: binary
 *                 description: The file to be uploaded.
 *     responses:
 *       200:
 *         description: File uploaded successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "File uploaded successfully: uploads/unique-file-name.png"
 *                 filePath:
 *                   type: string
 *                   example: "uploads/unique-file-name.png"
 *       400:
 *         description: Invalid file type or no file provided.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "No file uploaded"
 *       500:
 *         description: Internal server error, possibly due to Supabase upload failure.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "File upload failed"
 */
export async function POST(req: NextRequest) {
  // Get authenticated user
  const supabaseServer = await createClient();
  const { data: userData, error: userError } = await supabaseServer.auth.getUser();

  if (userError || !userData || !userData.user) {
    return NextResponse.json(
      { error: 'User not authenticated' },
      { status: 401 }
    );
  }

  const userUID = userData.user.id;

  // Get user's active workspace
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }

  try {
    const user = await prisma_client.user.findUnique({
      where: { auth_id: userUID },
      include: {
        active_workspace: true
      }
    });

    if (!user || !user.active_workspace) {
      return NextResponse.json(
        { error: 'No active workspace found' },
        { status: 400 }
      );
    }

    const workspaceSlug = user.active_workspace.slug;

    const formData = await req.formData();
    const file = formData.get('file') as File | null;

    if (!file) {
      return NextResponse.json({ error: 'No file uploaded' }, { status: 400 });
    }

    // Validate file type
    const allowedMimeTypes = [
      'image/svg+xml',
      'image/png',
      'image/jpeg',
      'image/gif',
      'video/mp4',
    ];
    if (!allowedMimeTypes.includes(file.type)) {
      return NextResponse.json({ error: 'Invalid file type' }, { status: 400 });
    }

    const buffer = await file.arrayBuffer();
    const fileData = new Uint8Array(buffer); // Convert to Uint8Array

    // Generate a unique file name and specify the folder using workspace slug
    const sanitizedFileName = file.name.replace(/\s+/g, '_'); // Replace spaces with underscores
    const fileName = `${uuidv4()}-${sanitizedFileName}`;
    const filePath = `uploads/${workspaceSlug}/${fileName}`; // Upload inside workspace folder

    // Retrieve bucket name from environment variable
    const bucketName = process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_BUCKET;

    if (!bucketName) {
      return NextResponse.json(
        { error: 'Bucket name is not defined in environment variables' },
        { status: 500 }
      );
    }
    
    // Upload the file to the workspace folder in the specified bucket
    const { error } = await supabase.storage
      .from(bucketName)
      .upload(filePath, fileData, {
        contentType: file.type,
        upsert: false, // Avoid overwriting existing files
      });

    if (error) {
      console.error('Supabase upload error:', error);
      return NextResponse.json(
        { error: 'File upload failed' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      message: `File uploaded successfully: ${filePath}`,
      filePath,
    });
  } catch (error) {
    console.error('File upload error:', error);
    return NextResponse.json({ error: 'File upload failed' }, { status: 500 });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/user/onboarding-complete/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { isVercel } from '../../utils/isVercel';
import { PrismaClient } from '@prisma/client';
import { supabaseAdmin } from '@/utils/supabase/admin';

export async function POST(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  const { userId } = await req.json();
  if (!userId) {
    return NextResponse.json({ error: 'Missing userId' }, { status: 400 });
  }
  try {
    const { data, error } = await supabaseAdmin.auth.updateUser({
      data: {
        onboarding_status: {
          current_step: 'completed',
          completed_at: new Date().toISOString(),
        },
        user_metadata: {
          onboarding_status: {
            current_step: 'completed',
            completed_at: new Date().toISOString(),
          },
        },
      },
    });
    if (error) throw error;
    await prisma_client.user.update({
      where: { auth_id: userId },
      data: {
        onboarding_step: 'COMPLETED',
        onboarding_completed_at: new Date().toISOString(),
      },
    });
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error updating onboarding status:', error);
    return NextResponse.json({ error: 'Failed to update onboarding status' }, { status: 500 });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/user/switch-workspace/route.ts">
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { createClient } from '@/utils/supabase/server';
import { isVercel } from '../../utils/isVercel';
import { PrismaClient } from '@prisma/client';

export async function POST(req: Request) {
    const prisma_client = isVercel() ? new PrismaClient() : prisma;
    if (!prisma_client) {
        throw new Error('Prisma client not initialized');
    }
  try {
    const { workspaceId } = await req.json();
    if (!workspaceId || typeof workspaceId !== 'number') {
      return NextResponse.json({ error: 'Invalid workspaceId' }, { status: 400 });
    }

    // Get the authenticated user from Supabase
    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (!user || authError) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Find the user in the database
    const dbUser = await prisma_client.user.findUnique({
      where: { email: user.email },
      include: { workspaces: true },
    });
    if (!dbUser) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Check if the user is a member of the workspace
    const isMember = dbUser.workspaces.some(
      (uw) => uw.workspace_id === workspaceId
    );
    if (!isMember) {
      return NextResponse.json({ error: 'Forbidden: Not a member of this workspace' }, { status: 403 });
    }

    // Update the user's active_workspace_id
    await prisma_client.user.update({
      where: { id: dbUser.id },
      data: { active_workspace_id: workspaceId },
    });

    return NextResponse.json({ success: true });
  } catch (error: any) {
    console.error('Error switching workspace:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/user/tutorial-status/[userId]/route.ts">
import { createClient } from '@/utils/supabase/server';
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

interface TutorialStatusRequest {
  hasCompletedTutorial: boolean;
}

export async function GET(
  request: Request,
  context: { params: Promise<{ userId: string }> }
) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { userId } = await context.params;
    if (!userId) {
      return NextResponse.json({ error: 'User ID is required' }, { status: 400 });
    }

    const supabase = await createClient();
    
    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      console.error('Authentication error:', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const dbUser = await prisma_client.user.findFirst({
      where: {
        auth_id: user.id
      },
      select: {
        id: true,
        tutorial_completed: true
      }
    });

    if (!dbUser) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    if (dbUser.id.toString() !== userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });
    }

    return NextResponse.json({ hasCompletedTutorial: dbUser.tutorial_completed });
  } catch (error) {
    console.error('Error fetching tutorial status:', error);
    return NextResponse.json({ error: 'Failed to fetch tutorial status' }, { status: 500 });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}

export async function POST(
  request: Request,
  context: { params: Promise<{ userId: string }> }
) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { userId } = await context.params;
    if (!userId) {
      return NextResponse.json({ error: 'User ID is required' }, { status: 400 });
    }

    const supabase = await createClient();
    
    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      console.error('Authentication error:', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Basic request validation
    const body = await request.json();
    if (typeof body.hasCompletedTutorial !== 'boolean') {
      return NextResponse.json({ 
        error: 'Invalid request body: hasCompletedTutorial must be a boolean'
      }, { status: 400 });
    }

    const { hasCompletedTutorial } = body as TutorialStatusRequest;

    // Use transaction to ensure both updates succeed or fail together
    const result = await prisma_client.$transaction(async (tx) => {
      const dbUser = await tx.user.findFirst({
        where: {
          auth_id: user.id
        },
        select: {
          id: true
        }
      });

      if (!dbUser) {
        throw new Error('User not found');
      }

      if (dbUser.id.toString() !== userId) {
        throw new Error('Unauthorized');
      }

      await tx.user.update({
        where: {
          id: dbUser.id
        },
        data: {
          tutorial_completed: hasCompletedTutorial
        }
      });

      return dbUser;
    });

    // Update Supabase user metadata
    await supabase.auth.updateUser({
      data: {
        tutorial_status: {
          completed: hasCompletedTutorial,
          completed_at: hasCompletedTutorial ? new Date().toISOString() : null
        }
      }
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error updating tutorial status:', error);
    
    if (error instanceof Error) {
      if (error.message === 'User not found') {
        return NextResponse.json({ error: 'User not found' }, { status: 404 });
      }
      if (error.message === 'Unauthorized') {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });
      }
    }
    
    return NextResponse.json({ error: 'Failed to update tutorial status' }, { status: 500 });
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/user_workspace/route.ts">
// app/api/workspace/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

/**
 * @swagger
 * /api/user_workspace:
 *   get:
 *     summary: Get all workspaces
 *     description: Fetches all workspaces along with their associated users.
 *     tags:
 *       - Workspace
 *     responses:
 *       200:
 *         description: A list of workspaces with user details
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   name:
 *                     type: string
 *                     example: "Workspace A"
 *                   background_colour:
 *                     type: string
 *                     example: "#4299E1"
 *                   user_workspaces:
 *                     type: array
 *                     items:
 *                       type: object
 *                       properties:
 *                         user_id:
 *                           type: integer
 *                           example: 1
 *                         role:
 *                           type: string
 *                           example: "ADMIN"
 *                         user:
 *                           type: object
 *                           properties:
 *                             id:
 *                               type: integer
 *                               example: 1
 *                             username:
 *                               type: string
 *                               example: "john_doe"
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Failed to fetch workspaces"
 *
 *   post:
 *     summary: Create a new workspace
 *     description: Creates a new workspace and assigns a user as the admin, with a randomly selected background color.
 *     tags:
 *       - Workspace
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 example: "New Workspace"
 *               user_id:
 *                 type: integer
 *                 example: 1
 *     responses:
 *       201:
 *         description: Workspace created successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 name:
 *                   type: string
 *                   example: "New Workspace"
 *                 background_colour:
 *                   type: string
 *                   example: "#F56565"
 *                 user_workspaces:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       user_id:
 *                         type: integer
 *                         example: 1
 *                       role:
 *                         type: string
 *                         example: "ADMIN"
 *                       user:
 *                         type: object
 *                         properties:
 *                           id:
 *                             type: integer
 *                             example: 1
 *                           username:
 *                             type: string
 *                             example: "john_doe"
 *       404:
 *         description: User not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "User not found"
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Failed to create workspace"
 */
export async function GET(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const workspaces = await prisma_client.workspace.findMany({
      include: {
        user_workspaces: {
          include: {
            user: true, // Fetch user details for each workspace
          },
        },
      },
    });
    return NextResponse.json(workspaces);
  } catch (error) {
    console.error('Error fetching workspaces:', error);
    return NextResponse.json(
      { error: 'Failed to fetch workspaces' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

export async function POST(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { name, user_id } = await req.json();

    // Vrifier si l'utilisateur existe
    const user = await prisma_client.user.findUnique({
      where: { id: Number(user_id) },
    });

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Dfinir trois couleurs de fond dans les tons bleu, rouge et vert
    const background_colours = ['#4299E1', '#F56565', '#48BB78'];
    // Slectionner alatoirement une couleur parmi les trois
    const randomIndex = Math.floor(Math.random() * background_colours.length);
    const randomColour = background_colours[randomIndex];

    // Crer le workspace et lier le crateur en tant qu'ADMIN, en assignant la couleur de fond alatoire
    const newWorkspace = await prisma_client.workspace.create({
      data: {
        name,
        background_colour: randomColour,
        user_workspaces: {
          create: {
            user_id: Number(user_id),
            role: 'ADMIN',
          },
        },
      },
      include: {
        user_workspaces: {
          include: {
            user: true,
          },
        },
      },
    });

    return NextResponse.json(newWorkspace, { status: 201 });
  } catch (error) {
    console.error('Error creating workspace:', error);
    return NextResponse.json(
      { error: 'Failed to create workspace' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/utils/blocks/deleteOne.ts">
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { IsFirstPath } from '../paths/Pathutils';
import { deleteFile } from '../deleteFile';

export async function deleteOneBlock(id: number | string) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Find the block and its path
    const block = await prisma_client.block.findUnique({
      where: { id: typeof id === 'string' ? parseInt(id, 10) : id },
      include: {
        child_paths: true
      }
    });

    if (!block) {
      return { error: 'Block not found', status: 404 };
    }

    // If block is BEGIN and its path is the first path, do not delete
    if (block.type === 'BEGIN' && block.path_id) {
      const isFirst = await IsFirstPath(block.path_id);
      if (isFirst) {
        return { error: 'Cannot delete BEGIN block of the first path', status: 400 };
      }
    }

    const imageUrl = block.image;
    const originalImageUrl = block.original_image;
    const iconUrl = block.icon;

    // Save workflow_id and position before deleting
    const workflowId = block.workflow_id;
    const pathId = block.path_id;
    const deletedPosition = block.position;

    // Delete only the image, original image, and icon files from Supabase storage
    await deleteFile(imageUrl);
    await deleteFile(originalImageUrl);
    if (iconUrl && (iconUrl.includes('uploads/') && iconUrl.includes('icons/') || iconUrl.includes('step-icons/custom'))) {
      await deleteFile(iconUrl);
    }

    // Delete the block (cascade will handle related records)
    await prisma_client.block.delete({
      where: { id: typeof id === 'string' ? parseInt(id, 10) : id },
    });

    // Decrement positions of blocks with position > deletedPosition
    await prisma_client.block.updateMany({
      where: {
        workflow_id: workflowId,
        path_id: pathId,
        position: { gt: deletedPosition }
      },
      data: {
        position: { decrement: 1 }
      }
    });

    return { status: 204 };
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/utils/deleteFile.ts">
import { supabase } from '@/lib/supabaseClient';

/**
 * Deletes a file from Supabase storage given its public URL.
 * @param fileUrl The public URL of the file to delete.
 */
export async function deleteFile(fileUrl: string | null) {
  if (!fileUrl) return;

  const filePath = fileUrl.replace(
    'https://your-project.supabase.co/storage/v1/object/public/',
    ''
  );

  const bucketName = process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_BUCKET;
  if (!bucketName) {
    console.error('Bucket name is not defined in the environment variables.');
    return;
  }

  const { error } = await supabase.storage.from(bucketName).remove([filePath]);

  if (error) {
    console.error(`Failed to delete file: ${fileUrl}`, error);
  }
}

/**
 * Deletes a user avatar from the Supabase private bucket given its storage path.
 * @param avatarPath The storage path of the avatar to delete (e.g., userUID/avatars/filename.png)
 */
export async function deleteAvatarFromPrivateBucket(avatarPath: string | null) {
  if (!avatarPath) return;

  const bucketName = process.env.NEXT_PUBLIC_SUPABASE_PRIVATE_BUCKET;
  if (!bucketName) {
    console.error('Private bucket name is not defined in the environment variables.');
    return;
  }

  const { error } = await supabase.storage.from(bucketName).remove([avatarPath]);

  if (error) {
    console.error(`Failed to delete avatar from private bucket: ${avatarPath}`, error);
  }
}
</file>

<file path="app/auth/callback/route.ts">
import { createClient } from '@/lib/supabaseServerClient';
import { NextResponse, type NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { PostHog } from 'posthog-node';
import * as Sentry from '@sentry/nextjs';
import { createDefaultWorkflow } from '@/app/api/utils/create-default-workflow';
import { isVercel } from '@/app/api/utils/isVercel';
import { PrismaClient } from '@prisma/client';

const posthog = new PostHog(
  process.env.NEXT_PUBLIC_POSTHOG_KEY as string,
  {
    host: process.env.NEXT_PUBLIC_POSTHOG_HOST,
  }
);

export async function GET(request: NextRequest) {
  try {
    const requestUrl = new URL(request.url);
    const code = requestUrl.searchParams.get('code');
    const token_hash = requestUrl.searchParams.get('token_hash');
    const type = requestUrl.searchParams.get('type');
    const inviteToken = requestUrl.searchParams.get('invite_token');
    const workspaceId = requestUrl.searchParams.get('workspace_id');

    if (!code && !token_hash) {
      console.error('No code or token_hash found in URL');
      return NextResponse.redirect(new URL('/login?error=no-code', request.url));
    }

    const supabase = createClient();

    // Handle email confirmation (using either token_hash or code)
    const verifyData = token_hash ? 
      await supabase.auth.verifyOtp({
        token_hash,
        type: 'email'
      }) :
      await supabase.auth.exchangeCodeForSession(code as string);

    if (verifyData.error) {
      console.error('Error verifying email:', verifyData.error);
      return NextResponse.redirect(new URL('/login?error=confirmation-failed', request.url));
    }

    const { data: { user, session } } = verifyData;

    if (user && session) {
      const prisma_client = isVercel() ? new PrismaClient() : prisma;
      if (!prisma_client) {
        throw new Error('Prisma client not initialized');
      }
      try {
        const existingUser = await prisma_client.user.findUnique({
          where: { auth_id: user.id }
        });

        let redirectUrl = '/onboarding';

        if (!existingUser) {
          // Check if it's a Google sign-in
          const isGoogleAuth = user.app_metadata?.provider === 'google';
          const googleAvatarUrl = isGoogleAuth ? user.user_metadata?.avatar_url : null;
          const firstName = user.user_metadata?.full_name?.split(' ')[0] || '';
          const lastName = user.user_metadata?.full_name?.split(' ').slice(1).join(' ') || '';

          // Create new user with Google avatar if available
          const newUser = await prisma_client.user.create({
            data: {
              auth_id: user.id,
              email: user.email || '',
              first_name: firstName,
              last_name: lastName,
              full_name: user.user_metadata?.full_name || '',
              avatar_url: googleAvatarUrl, // Store Google avatar URL
              onboarding_step: isGoogleAuth ? 'PROFESSIONAL_INFO' : 'PERSONAL_INFO'
            }
          });
        }

        // Handle workspace invitation if parameters exist
        if (workspaceId && inviteToken) {
          redirectUrl = `/join?workspace=${encodeURIComponent(workspaceId)}&token=${encodeURIComponent(inviteToken)}`;
        } else if (existingUser && existingUser?.onboarding_step !== 'COMPLETED') {
          redirectUrl = '/onboarding';
        } else {
          redirectUrl = '/';
        }

        const response = NextResponse.redirect(new URL(redirectUrl, request.url));
        
        response.cookies.set('sb-access-token', session.access_token, {
          path: '/',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 7, // 7 days
        });
        
        response.cookies.set('sb-refresh-token', session.refresh_token!, {
          path: '/',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 7, // 7 days
        });

        return response;
      } catch (error) {
        console.error('Database error:', error);
        return NextResponse.redirect(new URL('/login?error=database', request.url));
      } finally {
        if (isVercel()) await prisma_client.$disconnect();
      }
    }

    return NextResponse.redirect(new URL('/login?error=invalid-confirmation-type', request.url));
  } catch (error) {
    console.error('Unexpected error during confirmation:', error);
    return NextResponse.redirect(new URL('/login?error=confirmation-failed', request.url));
  }
}
</file>

<file path="app/auth/confirm/route.ts">
import { createClient } from '@/utils/supabase/server';
import { NextResponse, type NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { isVercel } from '@/app/api/utils/isVercel';
import { PrismaClient } from '@prisma/client';

export async function GET(request: NextRequest) {
  const requestUrl = new URL(request.url);
  const token_hash = requestUrl.searchParams.get('token_hash');
  const code = requestUrl.searchParams.get('code');
  const type = requestUrl.searchParams.get('type') || 'email'; // Default to email if not specified
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }

  // Check for either token_hash (password recovery) or code (email confirmation)
  if (!token_hash && !code) {
    return NextResponse.redirect(new URL('/login?error=invalid_token', request.url));
  }

  const supabase = await createClient();

  try {
    // Handle password recovery
    if (type === 'recovery' && token_hash) {
      // const { data, error } = await supabase.auth.verifyOtp({
      //   token_hash,
      //   type: 'recovery'
      // });
      
      // if (error) {
      //   console.error('Error verifying recovery token:', error);
      //   return NextResponse.redirect(new URL('/login?error=recovery-failed', request.url));
      // }

      // After verifying OTP, immediately sign out to prevent automatic login
      // await supabase.auth.signOut();

      // Set a cookie to indicate that password reset is required and store the user ID
      const response = NextResponse.redirect(new URL('/reset-password', request.url));
      response.cookies.set('password-reset-token', token_hash, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 60 * 30 // 30 minutes
      });
      
      // Store the user ID in a separate cookie for the reset password page
      // if (data.user) {
      //   response.cookies.set('reset-user-id', data.user.id, {
      //     httpOnly: true,
      //     secure: process.env.NODE_ENV === 'production',
      //     sameSite: 'lax',
      //     maxAge: 60 * 30 // 30 minutes
      //   });
      // }
      
      return response;
    }

    // Handle email confirmation (using either token_hash or code)
    const verifyData = token_hash ? 
      await supabase.auth.verifyOtp({
        token_hash,
        type: 'email'
      }) :
      await supabase.auth.exchangeCodeForSession(code as string);

    if (verifyData.error) {
      console.error('Error verifying email:', verifyData.error);
      return NextResponse.redirect(new URL('/login?error=confirmation-failed', request.url));
    }

    const { data: { user, session } } = verifyData;

    if (user && session) {
      try {
        const existingUser = await prisma_client.user.findUnique({
          where: { auth_id: user.id }
        });

        if (!existingUser) {
          await prisma_client.user.create({
            data: {
              auth_id: user.id,
              email: user.email || '',
              first_name: '',
              last_name: '',
              full_name: '',
              onboarding_step: 'PERSONAL_INFO'
            }
          });
        }

        const response = NextResponse.redirect(new URL('/onboarding', request.url));
        
        response.cookies.set('sb-access-token', session.access_token, {
          path: '/',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 7, // 7 days
        });
        
        response.cookies.set('sb-refresh-token', session.refresh_token!, {
          path: '/',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 7, // 7 days
        });

        return response;
      } catch (error) {
        console.error('Database error:', error);
        return NextResponse.redirect(new URL('/login?error=database', request.url));
      } finally {
        if (isVercel()) await prisma_client.$disconnect();
      }
    }

    return NextResponse.redirect(new URL('/login?error=invalid-confirmation-type', request.url));
  } catch (error) {
    console.error('Unexpected error during confirmation:', error);
    return NextResponse.redirect(new URL('/login?error=confirmation-failed', request.url));
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/checkout/success/page.tsx">
import { redirect } from 'next/navigation';
import { headers } from 'next/headers';
import { stripe, mapStripeStatusToDbStatus } from '@/lib/stripe';
import prisma from '@/lib/prisma';
import Stripe from 'stripe';
import { isVercel } from '@/app/api/utils/isVercel';
import { PrismaClient } from '@prisma/client';

// Mark as dynamic to ensure it's not cached
export const dynamic = 'force-dynamic';

// Utility function to wait for a specified time
const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

// New function to retry getting subscription
async function getSubscriptionWithRetry(
  workspaceId: number,
  maxRetries = 3,
  delayMs = 2000
) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }

  for (let i = 0; i < maxRetries; i++) {
    const workspace = await prisma_client.workspace.findUnique({
      where: { id: workspaceId },
      select: {
        id: true,
        subscription_id: true,
        stripe_customer_id: true,
        subscription: {
          select: {
            id: true,
            status: true,
            stripe_subscription_id: true,
            canceled_at: true,
          },
        },
      },
    });
    if (isVercel()) await prisma_client.$disconnect();
    if (workspace?.subscription && workspace.subscription.status === 'ACTIVE') {
      return workspace;
    }

    await sleep(delayMs);
  }
  return null;
}

// Safe server-side tracking function that doesn't use client-side PostHog
async function trackCheckoutServerSide(
  workspaceId: number,
  sessionId: string,
  status: string
) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Only attempt if we have a POSTHOG_KEY
    const posthogApiKey = process.env.NEXT_PUBLIC_POSTHOG_KEY;
    const posthogHost = process.env.NEXT_PUBLIC_POSTHOG_HOST;

    if (!posthogApiKey || !posthogHost) return;

    // Import PostHog Node library dynamically to avoid client-side loading
    const { PostHog } = await import('posthog-node');

    // Initialize server-side PostHog client
    const posthog = new PostHog(posthogApiKey, {
      host: posthogHost,
    });

    // Get workspace info for better tracking data
    const workspace = await prisma_client.workspace.findUnique({
      where: { id: workspaceId },
      select: {
        id: true,
        name: true,
        created_at: true,
      },
    });

    if (workspace) {
      // Capture the checkout event server-side
      await posthog.capture({
        distinctId: `workspace-${workspaceId}`,
        event: 'checkout_completed',
        properties: {
          workspace_id: workspaceId,
          session_id: sessionId,
          status: status,
          workspace_name: workspace.name,
          created_at: workspace.created_at,
        },
      });
    }
  } catch (error) {
    if (isVercel()) await prisma_client.$disconnect();
    // Just log the error - don't let tracking issues affect the main flow
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}

interface SearchParams {
  session_id?: string;
  workspace?: string;
}

interface PageProps {
  searchParams: Promise<SearchParams>;
}

async function handleSubscriptionActivated(
  sessionId: string,
  workspaceId: string
) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }

  try {
    // Get the session details from Stripe
    const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || '', {
      apiVersion: '2025-02-24.acacia',
    });

    const session = await stripe.checkout.sessions.retrieve(sessionId);

    if (session.subscription) {
      // Get the subscription details
      const subscription = await stripe.subscriptions.retrieve(
        session.subscription as string
      );

      if (subscription.status === 'active') {
        // Find the user who made the purchase
        const user = await prisma_client.user.findFirst({
          where: {
            workspaces: {
              some: {
                workspace_id: parseInt(workspaceId),
              },
            },
          },
        });

        if (isVercel()) await prisma_client.$disconnect();

        if (user) {
          // Send the subscription activated email
          const response = await fetch(
            `${process.env.NEXT_PUBLIC_APP_URL}/api/email/subscription-activated`,
            {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                userId: user.id,
                workspaceId: parseInt(workspaceId),
              }),
            }
          );

          if (!response.ok) {
            console.error(
              'Failed to send subscription activated email:',
              await response.text()
            );
          } else {
            if (process.env.NODE_ENV !== 'production') {
              console.log('Successfully sent subscription activated email');
            }
          }
        }
      }
    }
  } catch (error) {
    console.error('Error handling subscription activation:', error);
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}

export default async function CheckoutSuccessPage(props: PageProps) {
  const searchParams = await props.searchParams;
  const sessionId = String(searchParams?.session_id || '');
  const workspaceId = String(searchParams?.workspace || '');

  if (!sessionId || !workspaceId) {
    return redirect('/');
  }

  const workspaceIdNumber = parseInt(workspaceId);
  if (isNaN(workspaceIdNumber)) {
    return redirect('/');
  }

  let session;
  try {
    session = await stripe.checkout.sessions.retrieve(sessionId);
  } catch (error) {
    return redirect(
      `/?workspace=${workspaceId}&checkout=failed&error=invalid_session`
    );
  }

  if (session.payment_status !== 'paid') {
    return redirect(`/?workspace=${workspaceId}&checkout=failed`);
  }

  await sleep(2000);

  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    return redirect('/');
  }

  try {
    const existingWorkspace = await getSubscriptionWithRetry(workspaceIdNumber);

    if (existingWorkspace?.subscription?.status === 'ACTIVE') {
      return redirect(`/?workspace=${workspaceId}&checkout=success`);
    }

    let workspace = await prisma_client.workspace.findUnique({
      where: { id: workspaceIdNumber },
      select: {
        id: true,
        subscription_id: true,
        stripe_customer_id: true,
        subscription: {
          select: {
            id: true,
            status: true,
            stripe_subscription_id: true,
            canceled_at: true,
          },
        },
      },
    });

    if (isVercel()) await prisma_client.$disconnect();

    if (!workspace) {
      return redirect(
        `/?workspace=${workspaceId}&checkout=failed&error=workspace_not_found`
      );
    }

    if (
      !workspace.subscription ||
      workspace.subscription.status === 'CANCELED'
    ) {
      const stripeSubscription = await stripe.subscriptions.retrieve(
        session.subscription as string
      );

      if (!stripeSubscription) {
        return redirect(
          `/?workspace=${workspaceId}&checkout=failed&error=stripe_subscription_not_found`
        );
      }

      const mappedStatus = mapStripeStatusToDbStatus(stripeSubscription.status);

      if (
        workspace.subscription &&
        workspace.subscription.status === 'CANCELED'
      ) {
        await prisma_client.subscription.update({
          where: { id: workspace.subscription.id },
          data: {
            stripe_subscription_id: stripeSubscription.id,
            plan_type: 'EARLY_ADOPTER',
            quantity_seats: stripeSubscription.items.data[0].quantity || 1,
            current_period_start: new Date(
              stripeSubscription.current_period_start * 1000
            ),
            current_period_end: new Date(
              stripeSubscription.current_period_end * 1000
            ),
            trial_end_date: stripeSubscription.trial_end
              ? new Date(stripeSubscription.trial_end * 1000)
              : null,
            status: mappedStatus,
            canceled_at: null,
          },
        });

        const customer = (await stripe.customers.retrieve(
          session.customer as string,
          {
            expand: ['tax_ids'],
          }
        )) as Stripe.Customer;

        const defaultTaxRate = 20.0;
        await prisma_client.workspace_billing_infos.upsert({
          where: {
            workspace_id: workspaceIdNumber,
          },
          update: {
            billing_email: customer.email || '',
            billing_address: [
              customer.address?.line1,
              customer.address?.line2,
              customer.address?.city,
              customer.address?.state,
              customer.address?.postal_code,
              customer.address?.country,
            ]
              .filter(Boolean)
              .join('\n'),
            tax_rate: defaultTaxRate,
            vat_number: customer.tax_ids?.data[0]?.value || null,
          },
          create: {
            workspace_id: workspaceIdNumber,
            billing_email: customer.email || '',
            billing_address: [
              customer.address?.line1,
              customer.address?.line2,
              customer.address?.city,
              customer.address?.state,
              customer.address?.postal_code,
              customer.address?.country,
            ]
              .filter(Boolean)
              .join('\n'),
            tax_rate: defaultTaxRate,
            vat_number: customer.tax_ids?.data[0]?.value || null,
          },
        });

        await prisma_client.workspace.update({
          where: { id: workspaceIdNumber },
          data: { subscription_id: workspace.subscription.id },
        });
      } else {
        const newSubscription = await prisma_client.subscription.create({
          data: {
            workspace_id: workspaceIdNumber,
            stripe_subscription_id: stripeSubscription.id,
            plan_type: 'EARLY_ADOPTER',
            quantity_seats: stripeSubscription.items.data[0].quantity || 1,
            current_period_start: new Date(
              stripeSubscription.current_period_start * 1000
            ),
            current_period_end: new Date(
              stripeSubscription.current_period_end * 1000
            ),
            trial_end_date: stripeSubscription.trial_end
              ? new Date(stripeSubscription.trial_end * 1000)
              : null,
            status: mappedStatus,
          },
        });

        const customer = (await stripe.customers.retrieve(
          session.customer as string,
          {
            expand: ['tax_ids'],
          }
        )) as Stripe.Customer;

        const defaultTaxRate = 20.0;
        await prisma_client.workspace_billing_infos.upsert({
          where: {
            workspace_id: workspaceIdNumber,
          },
          update: {
            billing_email: customer.email || '',
            billing_address: [
              customer.address?.line1,
              customer.address?.line2,
              customer.address?.city,
              customer.address?.state,
              customer.address?.postal_code,
              customer.address?.country,
            ]
              .filter(Boolean)
              .join('\n'),
            tax_rate: defaultTaxRate,
            vat_number: customer.tax_ids?.data[0]?.value || null,
          },
          create: {
            workspace_id: workspaceIdNumber,
            billing_email: customer.email || '',
            billing_address: [
              customer.address?.line1,
              customer.address?.line2,
              customer.address?.city,
              customer.address?.state,
              customer.address?.postal_code,
              customer.address?.country,
            ]
              .filter(Boolean)
              .join('\n'),
            tax_rate: defaultTaxRate,
            vat_number: customer.tax_ids?.data[0]?.value || null,
          },
        });

        await prisma_client.workspace.update({
          where: { id: workspaceIdNumber },
          data: { subscription_id: newSubscription.id },
        });
      }
      if (isVercel()) await prisma_client.$disconnect();
    } else {
      if (isVercel()) await prisma_client.$disconnect();
    }

    await trackCheckoutServerSide(workspaceIdNumber, '[REDACTED]', 'success');

    const wasUpgrade =
      workspace.subscription && workspace.subscription.status === 'CANCELED';
    const actionParam = wasUpgrade ? '&action=upgrade' : '';

    await handleSubscriptionActivated(sessionId, workspaceId);

    return redirect(
      `/?workspace=${workspaceId}&checkout=success${actionParam}`
    );
  } catch (error) {
    if (error instanceof Error && error.message !== 'NEXT_REDIRECT') {
      await trackCheckoutServerSide(workspaceIdNumber, '[REDACTED]', 'failed');
      return redirect(
        `/?workspace=${workspaceId}&checkout=failed&error=checkout_error`
      );
    }
    throw error;
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/components/AuthCheck.tsx">
'use client';

import { createBrowserClient } from '@supabase/ssr';
import { useEffect, useState } from 'react';
import { usePathname, useRouter } from 'next/navigation';
import { onboarding_step } from '@prisma/client';
import LoadingSpinner from './LoadingSpinner';
import posthog from 'posthog-js';
import * as Sentry from '@sentry/nextjs';

type OnboardingResponse = {
  onboardingStep: onboarding_step;
  completed: boolean;
};

const PUBLIC_PATHS = [
  '/login',
  '/signup',
  '/auth/callback',
  '/auth/confirm',
  '/reset-password-request',
  '/reset-password',
] as const;

export default function AuthCheck({ children }: { children: React.ReactNode }) {
  const router = useRouter();
  const pathname = usePathname();
  const [isLoading, setIsLoading] = useState(true);
  const supabase = createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  useEffect(() => {
    const checkAuth = async () => {
      try {
        const {
          data: { user },
          error,
        } = await supabase.auth.getUser();

        const sharePaths = [
          '/shared',
          '/step-icons',
          '/apps',
          '/assets',
          '.png',
          '.svg',
          '/unauthorized',
          '/monitoring',
        ];

        const isPublicPath = pathname
          ? PUBLIC_PATHS.some((path) => pathname.startsWith(path))
          : false;

        const isSharePath = pathname
          ? sharePaths.some((path) => pathname.includes(path))
          : false;

        // Redirect to login if not authenticated and not on public/share path
        if ((!user || error) && !isPublicPath && !isSharePath) {
          router.push('/login');
          return;
        }

        // Identify user in PostHog if authenticated
        if (user) {
          // Set up PostHog identification
          posthog.identify(user.id);

          // Set user email as a property
          if (user.email) {
            posthog.people.set({ email: user.email });
          }

          // Capture login event for Google auth users coming from callback
          if (pathname?.includes('/auth/callback')) {
            const isGoogleAuth = user.app_metadata?.provider === 'google';
            if (isGoogleAuth) {
              posthog.capture('login', {
                email: user.email,
                provider: 'google',
              });
            }
          }

          // Also set up Sentry user identification
          Sentry.setUser({
            id: user.id,
            email: user.email || undefined,
          });

          // Check onboarding status
          const response = await fetch('/api/auth/check-onboarding');

          if (!response.ok) {
            console.error('Error checking onboarding status');
            if (isPublicPath) {
              router.push('/');
            }
            return;
          }

          const data = (await response.json()) as OnboardingResponse;

          if (data.onboardingStep && !data.completed) {
            const onboardingSteps: Record<onboarding_step, string> = {
              PERSONAL_INFO: '/onboarding',
              PROFESSIONAL_INFO: '/onboarding',
              WORKSPACE_SETUP: '/onboarding',
              COMPLETED: '/onboarding',
              INVITED_USER: '/onboarding',
            };

            const currentStep = onboardingSteps[data.onboardingStep];

            // Redirect to appropriate onboarding step if on public path or wrong step
            if (isPublicPath || (pathname && pathname !== '/onboarding')) {
              router.push(currentStep);
            }
          } else if (isPublicPath) {
            // Redirect completed users away from public paths
            router.push('/');
          }
        }
      } catch (error) {
        console.error('Error in auth check:', error);
      } finally {
        setIsLoading(false);
      }
    };

    checkAuth();
  }, [pathname, router, supabase.auth]);

  if (
    isLoading &&
    pathname !== '/login' &&
    pathname &&
    !pathname.startsWith('/auth/')
  ) {
    return <LoadingSpinner fullScreen size="large" />;
  }

  return <>{children}</>;
}
</file>

<file path="app/components/InputFields.tsx">
'use client';

import React, { useState } from 'react';
import { useTheme } from '@/app/theme/hooks';
import { InputTokens } from '@/app/theme/types';
import { cn } from '@/lib/utils';
import DynamicIcon from '../../utils/DynamicIcon';

// =======================================================
// Constant Styles
// =======================================================
const BASE_STYLES = {
  width: '100%',
  flex: 1,
  fontSize: 16,
  lineHeight: '24px',
  outline: 'none',
  border: 'none',
  background: 'transparent',
  padding: 0,
  margin: 0,
  boxSizing: 'border-box' as 'border-box',
  fontFamily: 'Inter, sans-serif',
  minWidth: 0, // Prevent input from overflowing its container
};

const SELECT_STYLE = {
  border: 'none',
  outline: 'none',
  background: 'transparent',
  fontSize: 14,
};

const DEFAULT_CONTAINER_STYLE: React.CSSProperties = {
  width: '100%',
  display: 'inline-flex',
  flexDirection: 'column',
  gap: 6,
};

// Leading-text variant styles
const LEADING_TEXT_OUTER = {
  width: 320,
  height: 92,
  flexDirection: 'column',
  justifyContent: 'flex-start',
  alignItems: 'flex-start',
  gap: 6,
  display: 'inline-flex',
};

const LEADING_TEXT_INNER = {
  alignSelf: 'stretch',
  height: 66,
  flexDirection: 'column',
  justifyContent: 'flex-start',
  alignItems: 'flex-start',
  gap: 6,
  display: 'flex',
};

const LEADING_TEXT_LABEL_CONTAINER = {
  justifyContent: 'flex-start',
  alignItems: 'flex-start',
  gap: 2,
  display: 'inline-flex',
};

const LEADING_TEXT_LABEL = {
  color: '#344054',
  fontSize: 14,
  fontFamily: 'Inter',
  fontWeight: 500,
  lineHeight: 20,
  wordWrap: 'break-word',
};

const LEADING_TEXT_ASTERISK = {
  color: '#4761C4',
  fontSize: 14,
  fontFamily: 'Inter',
  fontWeight: 500,
  lineHeight: 20,
  wordWrap: 'break-word',
};

const LEADING_TEXT_INPUT_CONTAINER = {
  alignSelf: 'stretch',
  background: 'white',
  boxShadow: '0px 1px 2px rgba(16, 24, 40, 0.05)',
  borderRadius: 6,
  border: '1px #D0D5DD solid',
  justifyContent: 'flex-start',
  alignItems: 'flex-start',
  display: 'inline-flex',
};

const LEADING_TEXT_PREFIX_CONTAINER = {
  paddingLeft: 12,
  paddingRight: 12,
  paddingTop: 8,
  paddingBottom: 8,
  borderTopLeftRadius: 6,
  borderTopRightRadius: 6,
  justifyContent: 'flex-start',
  alignItems: 'center',
  display: 'flex',
  background: 'white',
  border: `1px solid #D0D5DD`,
};

const LEADING_TEXT_PREFIX_TEXT = {
  color: '#475467',
  fontSize: 16,
  fontFamily: 'Inter',
  fontWeight: 400,
  lineHeight: 24,
  wordWrap: 'break-word',
};

const LEADING_TEXT_MAIN_INPUT_CONTAINER = {
  flex: '1 1 0',
  alignSelf: 'stretch',
  paddingLeft: 12,
  paddingRight: 12,
  paddingTop: 8,
  paddingBottom: 8,
  background: 'white',
  borderTopLeftRadius: 6,
  borderTopRightRadius: 6,
  overflow: 'hidden',
  border: `1px solid #D0D5DD`,
  justifyContent: 'flex-start',
  alignItems: 'center',
  gap: 8,
  display: 'flex',
};

const LEADING_TEXT_MAIN_INPUT_TEXT = {
  flex: '1 1 0',
  color: '#667085',
  fontSize: 16,
  fontFamily: 'Inter',
  fontWeight: 400,
  lineHeight: 24,
  wordWrap: 'break-word',
};

const LEADING_TEXT_HINT = {
  alignSelf: 'stretch',
  color: '#475467',
  fontSize: 14,
  fontFamily: 'Inter',
  fontWeight: 400,
  lineHeight: 20,
  wordWrap: 'break-word',
};

// =======================================================
// Types and Helper Components
// =======================================================
interface InputFieldProps {
  size?: 'small' | 'medium';
  type?:
    | 'default'
    | 'password'
    | 'icon-leading'
    | 'leading-dropdown'
    | 'trailing-dropdown'
    | 'leading-text'
    | 'payment-input'
    | 'tags'
    | 'trailing-button';
  destructive?: boolean;
  placeholder?: string;
  value?: string;
  label?: string;
  required?: boolean;
  hintText?: string;

  helpIcon?: boolean;
  onChange?: (value: string) => void;
  onBlur?: () => void;
  onKeyDown?: (e: React.KeyboardEvent<HTMLInputElement>) => void;
  disabled?: boolean;
  errorMessage?: string;
  setError?: (message: string) => void;
  iconUrl?: string; // URL for the leading icon
  iconColor?: string; // Tailwind color class for the icon
  dropdownOptions?: string[];
  tooltipText?: string;
  mode?: 'light' | 'dark';
  dataTestId?: string;
}

const Tooltip: React.FC<{ text: string }> = ({ text }) => {
  const { getCssVariable } = useTheme();

  return (
    <div
      className="absolute z-10 invisible group-hover:visible bg-white dark:bg-gray-800 text-sm text-gray-500 px-2 py-1 rounded-md shadow-sm max-w-xs"
      style={{
        backgroundColor: getCssVariable('input-bg'),
        color: getCssVariable('input-hint'),
        borderColor: getCssVariable('input-border'),
        borderWidth: '1px',
      }}
    >
      {text}
    </div>
  );
};

const HelpIcon: React.FC<{ destructive?: boolean; tooltipText?: string }> = ({
  destructive,
  tooltipText,
}) => {
  const { getCssVariable } = useTheme();

  return (
    <div className="group relative inline-block ml-1">
      <svg
        width="16"
        height="16"
        viewBox="0 0 16 16"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M8.00004 14.6666C11.6819 14.6666 14.6667 11.6819 14.6667 7.99998C14.6667 4.31808 11.6819 1.33331 8.00004 1.33331C4.31814 1.33331 1.33337 4.31808 1.33337 7.99998C1.33337 11.6819 4.31814 14.6666 8.00004 14.6666Z"
          stroke={
            destructive
              ? getCssVariable('input-destructive-icon')
              : getCssVariable('input-icon')
          }
          strokeWidth="1.33333"
          strokeLinecap="round"
          strokeLinejoin="round"
        />
        <path
          d="M8 10.6667V8"
          stroke={
            destructive
              ? getCssVariable('input-destructive-icon')
              : getCssVariable('input-icon')
          }
          strokeWidth="1.33333"
          strokeLinecap="round"
          strokeLinejoin="round"
        />
        <path
          d="M8 5.33331H8.00667"
          stroke={
            destructive
              ? getCssVariable('input-destructive-icon')
              : getCssVariable('input-icon')
          }
          strokeWidth="1.33333"
          strokeLinecap="round"
          strokeLinejoin="round"
        />
      </svg>
      {tooltipText && <Tooltip text={tooltipText} />}
    </div>
  );
};

const ErrorIcon: React.FC<{ tooltipText?: string }> = ({ tooltipText }) => {
  const { getCssVariable } = useTheme();

  return (
    <div className="group relative inline-block ml-1">
      <svg
        width="16"
        height="16"
        viewBox="0 0 16 16"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M8.00004 14.6666C11.6819 14.6666 14.6667 11.6819 14.6667 7.99998C14.6667 4.31808 11.6819 1.33331 8.00004 1.33331C4.31814 1.33331 1.33337 4.31808 1.33337 7.99998C1.33337 11.6819 4.31814 14.6666 8.00004 14.6666Z"
          stroke={getCssVariable('input-destructive-icon')}
          strokeWidth="1.33333"
          strokeLinecap="round"
          strokeLinejoin="round"
        />
        <path
          d="M8 5.33331V7.99998"
          stroke={getCssVariable('input-destructive-icon')}
          strokeWidth="1.33333"
          strokeLinecap="round"
          strokeLinejoin="round"
        />
        <path
          d="M8 10.6667H8.00667"
          stroke={getCssVariable('input-destructive-icon')}
          strokeWidth="1.33333"
          strokeLinecap="round"
          strokeLinejoin="round"
        />
      </svg>
      {tooltipText && <Tooltip text={tooltipText} />}
    </div>
  );
};

const getInputToken = (
  state: 'normal' | 'hover' | 'focus',
  type: 'bg' | 'fg' | 'border',
  destructive: boolean = false,
  disabled: boolean = false
): keyof InputTokens => {
  if (disabled) {
    return `input-disabled-${type}` as keyof InputTokens;
  }

  const prefix = destructive ? 'input-destructive-' : 'input-';
  const suffix = state === 'normal' ? '' : `-${state}`;
  return `${prefix}${type}${suffix}` as keyof InputTokens;
};

// =======================================================
// Main Component
// =======================================================
const InputField: React.FC<InputFieldProps> = ({
  size = 'medium',
  type = 'default',
  destructive = false,
  placeholder = '',
  value = '',
  label = '',
  required = false,
  hintText = '',
  helpIcon = false,
  onChange,
  onBlur,
  onKeyDown,
  disabled = false,
  errorMessage = '',
  setError,
  iconUrl = '',
  iconColor = 'currentColor',
  dropdownOptions,
  tooltipText = 'Tooltips are used to describe or identify an element. In most scenarios, tooltips help the user understand meaning, function or alt-text.',
  mode = 'light',
  dataTestId = 'input-field',
}) => {
  const [isFocused, setIsFocused] = useState(false);
  const [showPassword, setShowPassword] = useState(false);
  const { getCssVariable } = useTheme();

  const handleFocus = () => setIsFocused(true);
  const handleBlur = () => setIsFocused(false);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    // Clear any existing error when user starts typing
    if (setError && errorMessage) {
      setError('');
    }
    if (onChange) {
      onChange(e.target.value);
    }
  };

  const baseStyles = {
    backgroundColor: getCssVariable(
      getInputToken('normal', 'bg', destructive, disabled)
    ),
    color: getCssVariable(getInputToken('normal', 'fg', destructive, disabled)),
    borderColor: getCssVariable(
      getInputToken('normal', 'border', destructive, disabled)
    ),
  };

  const hoverStyles = {
    backgroundColor: getCssVariable(
      getInputToken('hover', 'bg', destructive, disabled)
    ),
    color: getCssVariable(getInputToken('hover', 'fg', destructive, disabled)),
    borderColor: getCssVariable(
      getInputToken('hover', 'border', destructive, disabled)
    ),
  };

  const focusStyles = {
    backgroundColor: getCssVariable(
      getInputToken('focus', 'bg', destructive, disabled)
    ),
    color: getCssVariable(getInputToken('focus', 'fg', destructive, disabled)),
    borderColor: getCssVariable(
      getInputToken('focus', 'border', destructive, disabled)
    ),
  };

  const labelStyles = {
    color: destructive
      ? getCssVariable('input-destructive-label')
      : disabled
        ? getCssVariable('input-disabled-label')
        : getCssVariable('input-label'),
  };

  const hintStyles = {
    color: destructive
      ? getCssVariable('input-destructive-hint')
      : getCssVariable('input-hint'),
  };

  const iconStyles = {
    color: destructive
      ? getCssVariable('input-destructive-icon')
      : disabled
        ? getCssVariable('input-disabled-fg')
        : getCssVariable('input-icon'),
  };

  const prefixStyles = {
    color: getCssVariable('input-prefix'),
  };

  const inputStyle = {
    ...BASE_STYLES,
    '::placeholder': {
      color: getCssVariable(
        disabled ? 'input-disabled-placeholder' : 'input-placeholder'
      ),
    },
  };

  const inputContainerStyle: React.CSSProperties = {
    flex: 1,
    display: 'flex',
    alignItems: 'center',
    padding: '8px 12px',
    background: getCssVariable(
      getInputToken('normal', 'bg', destructive, disabled)
    ),
    borderLeft: `1px solid ${getCssVariable(getInputToken('normal', 'border', destructive, disabled))}`,
    borderTopLeftRadius: 0,
    borderBottomLeftRadius: 0,
    zIndex: 1,
  };

  const renderInputContent = () => {
    switch (type) {
      case 'icon-leading':
      case 'default':
        return (
          <>
            {iconUrl && (
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                }}
              >
                <DynamicIcon url={iconUrl} color={iconStyles.color} size={16} />
              </div>
            )}
            <input
              data-testid={dataTestId}
              type="text"
              placeholder={placeholder}
              value={value}
              onChange={handleChange}
              onBlur={(e) => {
                handleBlur();
                onBlur?.();
              }}
              onKeyDown={(e) => onKeyDown?.(e)}
              disabled={disabled}
              onFocus={handleFocus}
              style={{
                ...inputStyle,
                width: '100%',
                flex: 1,
                fontSize: 16,
                lineHeight: '24px',
                outline: 'none',
                border: 'none',
                background: 'transparent',
                color: getCssVariable(
                  getInputToken('normal', 'fg', destructive, disabled)
                ),
              }}
            />
            {destructive && <ErrorIcon tooltipText={errorMessage} />}
            {helpIcon && !destructive && (
              <HelpIcon destructive={destructive} tooltipText={tooltipText} />
            )}
          </>
        );

      case 'leading-dropdown':
      case 'leading-text':
        return (
          <div style={DEFAULT_CONTAINER_STYLE}>
            <div
              style={{
                display: 'flex',
                width: '100%',
                height: 40,
                borderRadius: 6,
                overflow: 'visible',
              }}
            >
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  padding: '8px 12px',
                  background: getCssVariable(
                    getInputToken('normal', 'bg', destructive, disabled)
                  ),
                  border: `1px solid ${getCssVariable(getInputToken('normal', 'border', destructive, disabled))}`,
                  borderRight: 'none',
                  borderTopLeftRadius: 6,
                  borderBottomLeftRadius: 6,
                  position: 'relative',
                  minWidth: 80,
                  zIndex: 0,
                }}
              >
                {type === 'leading-dropdown' ? (
                  <>
                    <select
                      style={{
                        background: 'transparent',
                        border: 'none',
                        outline: 'none',
                        fontSize: 16,
                        color: getCssVariable(
                          getInputToken('normal', 'fg', destructive, disabled)
                        ),
                        cursor: 'pointer',
                        appearance: 'none',
                        fontFamily: 'Inter',
                        lineHeight: '24px',
                        paddingRight: 20,
                      }}
                      disabled={disabled}
                    >
                      {dropdownOptions?.map((option) => (
                        <option key={option} value={option}>
                          {option}
                        </option>
                      )) || <option value="US">US</option>}
                    </select>
                    <div
                      style={{
                        position: 'absolute',
                        right: 12,
                        pointerEvents: 'none',
                      }}
                    >
                      <svg
                        width="20"
                        height="20"
                        viewBox="0 0 20 20"
                        fill="none"
                      >
                        <path
                          d="M5 7.5L10 12.5L15 7.5"
                          stroke={getCssVariable(
                            getInputToken('normal', 'fg', destructive, disabled)
                          )}
                          strokeWidth="1.66667"
                          strokeLinecap="round"
                          strokeLinejoin="round"
                        />
                      </svg>
                    </div>
                  </>
                ) : (
                  <div
                    style={{
                      color: getCssVariable(
                        getInputToken('normal', 'fg', destructive, disabled)
                      ),
                      fontSize: 16,
                      fontFamily: 'Inter',
                      lineHeight: '24px',
                    }}
                  >
                    app.process-flow.io/
                  </div>
                )}
              </div>
              <div
                style={{
                  ...focusStyles,
                  border: `1px solid ${
                    destructive
                      ? getCssVariable('input-destructive-border')
                      : isFocused
                        ? getCssVariable(
                            getInputToken(
                              'focus',
                              'border',
                              destructive,
                              disabled
                            )
                          )
                        : getCssVariable(
                            getInputToken(
                              'normal',
                              'border',
                              destructive,
                              disabled
                            )
                          )
                  }`,
                  borderTopLeftRadius: 0,
                  borderBottomLeftRadius: 0,
                  zIndex: 1,
                  flex: 1,
                }}
              >
                <input
                  data-testid={dataTestId}
                  type="text"
                  placeholder={
                    type === 'leading-text' ? 'www.example.com' : placeholder
                  }
                  value={value}
                  onChange={handleChange}
                  onBlur={(e) => {
                    handleBlur();
                    onBlur?.();
                  }}
                  onKeyDown={(e) => onKeyDown?.(e)}
                  disabled={disabled}
                  onFocus={handleFocus}
                  style={{
                    ...inputStyle,
                    width: '100%',
                    flex: 1,
                    fontSize: 16,
                    lineHeight: '24px',
                    outline: 'none',
                    border: 'none',
                    background: 'transparent',
                  }}
                />
                {destructive && <ErrorIcon tooltipText={errorMessage} />}
                {helpIcon && !destructive && (
                  <HelpIcon
                    destructive={destructive}
                    tooltipText={tooltipText}
                  />
                )}
              </div>
            </div>
          </div>
        );

      case 'trailing-dropdown':
        return (
          <div
            style={{
              display: 'flex',
              width: '100%',
              alignItems: 'center',
            }}
          >
            <input
              data-testid={dataTestId}
              type="text"
              placeholder={placeholder}
              value={value}
              onChange={handleChange}
              onBlur={(e) => {
                handleBlur();
                onBlur?.();
              }}
              onKeyDown={(e) => onKeyDown?.(e)}
              disabled={disabled}
              onFocus={handleFocus}
              style={{
                ...inputStyle,
                flex: 1,
                fontSize: 16,
                lineHeight: '24px',
                outline: 'none',
                border: 'none',
                background: 'transparent',
                color: getCssVariable(
                  getInputToken('normal', 'fg', destructive, disabled)
                ),
              }}
            />
            {destructive && <ErrorIcon tooltipText={errorMessage} />}
            {helpIcon && !destructive && (
              <HelpIcon destructive={destructive} tooltipText={tooltipText} />
            )}

            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                marginLeft: 8,
              }}
            >
              <span
                style={{
                  color: getCssVariable(
                    getInputToken('normal', 'fg', destructive, disabled)
                  ),
                  fontSize: 16,
                  fontFamily: 'Inter',
                  fontWeight: 600,
                  lineHeight: '24px',
                  marginRight: 8,
                }}
              >
                {dropdownOptions && dropdownOptions.length > 0
                  ? dropdownOptions[0]
                  : 'can view'}
              </span>
              <div>
                <svg
                  width="20"
                  height="20"
                  viewBox="0 0 20 20"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M5 7.5L10 12.5L15 7.5"
                    stroke={getCssVariable(
                      getInputToken('normal', 'fg', destructive, disabled)
                    )}
                    strokeWidth="1.6667"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                  />
                </svg>
              </div>
            </div>
          </div>
        );

      case 'tags':
        return (
          <div
            style={{
              ...focusStyles,
              minHeight: size === 'small' ? 32 : 40,
              padding: '4px 8px',
              overflow: 'hidden',
              width: '100%',
            }}
          >
            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                gap: 4,
                overflow: 'auto',
                overflowX: 'auto',
                overflowY: 'hidden',
                flex: '1 1 0',
                minWidth: 0,
              }}
            >
              {value
                .split(',')
                .filter((tag) => tag.trim() !== '')
                .map((tag, index) => (
                  <div
                    key={index}
                    style={{
                      background: getCssVariable(
                        getInputToken('normal', 'bg', destructive, disabled)
                      ),
                      borderRadius: 6,
                      padding: '2px 6px',
                      display: 'flex',
                      alignItems: 'center',
                      gap: 4,
                      flexShrink: 0,
                      height: 24,
                      border: `1px solid ${getCssVariable(
                        getInputToken('normal', 'border', destructive, disabled)
                      )}`,
                    }}
                  >
                    <div
                      style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: 2,
                      }}
                    >
                      <img
                        src="https://grzxiilmiwwwepaymqnu.supabase.co/storage/v1/object/public/public-assets/assets/shared_components/avatar-01.png"
                        style={{
                          width: 16,
                          height: 16,
                          borderRadius: '50%',
                        }}
                        alt=""
                      />
                      <span
                        style={{
                          color: getCssVariable(
                            getInputToken('normal', 'fg', destructive, disabled)
                          ),
                          fontSize: 14,
                          fontFamily: 'Inter',
                          fontWeight: '500',
                        }}
                      >
                        {tag}
                      </span>
                    </div>
                    <button
                      type="button"
                      onClick={(e) => {
                        e.stopPropagation(); // Prevent event from bubbling up
                        const tags = value
                          .split(',')
                          .filter((t) => t.trim() !== '');
                        tags.splice(index, 1);
                        onChange?.(tags.join(','));
                      }}
                      style={{
                        background: 'none',
                        border: 'none',
                        padding: 0,
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                      }}
                    >
                      <svg
                        width="12"
                        height="12"
                        viewBox="0 0 12 12"
                        fill="none"
                      >
                        <path
                          d="M9 3L3 9M3 3L9 9"
                          stroke={getCssVariable(
                            getInputToken('normal', 'fg', destructive, disabled)
                          )}
                          strokeWidth="1.5"
                          strokeLinecap="round"
                          strokeLinejoin="round"
                        />
                      </svg>
                    </button>
                  </div>
                ))}
              <input
                data-testid={dataTestId}
                type="text"
                placeholder={value ? '' : placeholder}
                onKeyDown={(e) => {
                  onKeyDown?.(e);
                  if (e.key === 'Enter' || e.key === ',') {
                    e.preventDefault();
                    const tagValue = e.currentTarget.value.trim();
                    if (tagValue) {
                      const newValue = value
                        ? `${value},${tagValue}`
                        : tagValue;
                      onChange?.(newValue);
                    }
                    e.currentTarget.value = '';
                  } else if (
                    e.key === 'Backspace' &&
                    e.currentTarget.value === ''
                  ) {
                    // Delete the last tag when pressing Backspace on empty input
                    e.preventDefault();
                    const tags = value
                      .split(',')
                      .filter((t) => t.trim() !== '');
                    if (tags.length > 0) {
                      tags.pop();
                      onChange?.(tags.join(','));
                    }
                  }
                }}
                disabled={disabled}
                onFocus={handleFocus}
                onBlur={(e) => {
                  handleBlur();
                  onBlur?.();
                }}
                style={{
                  ...inputStyle,
                  width: '100%',
                  flex: 1,
                  fontSize: 16,
                  lineHeight: '24px',
                  outline: 'none',
                  border: 'none',
                  background: 'transparent',
                  color: getCssVariable(
                    getInputToken('normal', 'fg', destructive, disabled)
                  ),
                  minWidth: '20px', // Ensure there's always space to type
                }}
              />
            </div>
          </div>
        );

      case 'trailing-button':
        return (
          <div style={DEFAULT_CONTAINER_STYLE}>
            <div
              style={{
                display: 'flex',
                width: '100%',
                height: 40,
                borderRadius: 6,
                overflow: 'visible',
                position: 'relative',
              }}
            >
              <div
                style={{
                  ...focusStyles,
                  borderRight: 'none',
                  borderTopRightRadius: 0,
                  borderBottomRightRadius: 0,
                  flex: 1,
                  position: 'relative',
                  zIndex: 2,
                }}
              >
                <input
                  data-testid={dataTestId}
                  type="text"
                  placeholder={placeholder}
                  value={value}
                  onChange={handleChange}
                  onBlur={(e) => {
                    handleBlur();
                    onBlur?.();
                  }}
                  onKeyDown={(e) => onKeyDown?.(e)}
                  disabled={disabled}
                  onFocus={handleFocus}
                  style={{
                    ...inputStyle,
                    width: '100%',
                    flex: 1,
                    fontSize: 16,
                    lineHeight: '24px',
                    outline: 'none',
                    border: 'none',
                    background: 'transparent',
                  }}
                />
                {destructive && <ErrorIcon tooltipText={errorMessage} />}
                {helpIcon && !destructive && (
                  <HelpIcon
                    destructive={destructive}
                    tooltipText={tooltipText}
                  />
                )}
              </div>
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  padding: '8px 14px',
                  background: getCssVariable(
                    getInputToken('normal', 'bg', destructive, disabled)
                  ),
                  borderTop: `1px solid ${getCssVariable(getInputToken('normal', 'border', destructive, disabled))}`,
                  borderBottom: `1px solid ${getCssVariable(getInputToken('normal', 'border', destructive, disabled))}`,
                  borderRight: `1px solid ${getCssVariable(getInputToken('normal', 'border', destructive, disabled))}`,
                  borderTopRightRadius: 6,
                  borderBottomRightRadius: 6,
                  position: 'relative',
                  minWidth: 'fit-content',
                  cursor: value ? 'pointer' : 'not-allowed',
                  userSelect: 'none',
                  color: getCssVariable(
                    getInputToken('normal', 'fg', destructive, disabled)
                  ),
                  fontSize: 14,
                  fontFamily: 'Inter',
                  fontWeight: 500,
                  zIndex: 1,
                  opacity: value ? 1 : 0.5,
                }}
                onClick={() => {
                  if (value) {
                    navigator.clipboard.writeText(value);
                  }
                }}
              >
                <div
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: 8,
                  }}
                >
                  {value && (
                    <svg
                      width="16"
                      height="16"
                      viewBox="0 0 16 16"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg"
                    >
                      <path
                        d="M13.3333 4L6 11.3333L2.66667 8"
                        stroke={getCssVariable(
                          getInputToken('normal', 'fg', destructive, disabled)
                        )}
                        strokeWidth="1.33333"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      />
                    </svg>
                  )}
                  {value ? 'Copied!' : 'Copy'}
                </div>
              </div>
            </div>
          </div>
        );

      case 'password':
        return (
          <>
            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
              }}
            >
              <DynamicIcon
                url={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/lock-01.svg`}
                color={iconStyles.color}
                size={16}
              />
            </div>
            <input
              data-testid={dataTestId}
              type={showPassword ? 'text' : 'password'}
              placeholder={placeholder}
              value={value}
              onChange={handleChange}
              onBlur={(e) => {
                handleBlur();
                onBlur?.();
              }}
              onKeyDown={(e) => onKeyDown?.(e)}
              disabled={disabled}
              onFocus={handleFocus}
              style={{
                ...inputStyle,
                width: '100%',
                flex: 1,
                fontSize: 16,
                lineHeight: '24px',
                outline: 'none',
                border: 'none',
                background: 'transparent',
                color: getCssVariable(
                  getInputToken('normal', 'fg', destructive, disabled)
                ),
              }}
            />
            <button
              type="button"
              onClick={() => setShowPassword(!showPassword)}
              style={{
                background: 'none',
                border: 'none',
                padding: 0,
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
              }}
            >
              <DynamicIcon
                url={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${showPassword ? 'eye-off' : 'eye'}.svg`}
                color={iconStyles.color}
                size={16}
              />
            </button>
            {destructive && <ErrorIcon tooltipText={errorMessage} />}
            {helpIcon && !destructive && (
              <HelpIcon destructive={destructive} tooltipText={tooltipText} />
            )}
          </>
        );

      default:
        return (
          <>
            {iconUrl && (
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                }}
              >
                <DynamicIcon url={iconUrl} color={iconStyles.color} size={20} />
              </div>
            )}
            <input
              data-testid={dataTestId}
              type="text"
              placeholder={placeholder}
              value={value}
              onChange={handleChange}
              onBlur={(e) => {
                handleBlur();
                onBlur?.();
              }}
              onKeyDown={(e) => onKeyDown?.(e)}
              disabled={disabled}
              onFocus={handleFocus}
              style={{
                ...inputStyle,
                width: '100%',
                flex: 1,
                fontSize: 16,
                lineHeight: '24px',
                outline: 'none',
                border: 'none',
                background: 'transparent',
                color: getCssVariable(
                  getInputToken('normal', 'fg', destructive, disabled)
                ),
              }}
            />
            {destructive && <ErrorIcon tooltipText={errorMessage} />}
            {helpIcon && !destructive && (
              <HelpIcon destructive={destructive} tooltipText={tooltipText} />
            )}
          </>
        );
    }
  };

  return (
    <div className="flex flex-col gap-1.5 w-full">
      {label && (
        <div style={{ display: 'inline-flex', flexDirection: 'row', gap: 2 }}>
          <div className={cn('font-medium text-sm')} style={labelStyles}>
            {label}
          </div>
          {required && (
            <div
              className={cn('text-sm font-medium')}
              style={{
                color: getCssVariable(
                  getInputToken('normal', 'fg', destructive, disabled)
                ),
              }}
            >
              *
            </div>
          )}
        </div>
      )}
      <div
        style={
          {
            display: 'flex',
            alignItems: 'center',
            gap: 8,
            padding: '8px 12px',
            width: '100%',
            background: getCssVariable(
              getInputToken('normal', 'bg', destructive, disabled)
            ),
            borderRadius: 6,
            border: `1px solid ${
              destructive
                ? getCssVariable('input-destructive-border')
                : isFocused
                  ? getCssVariable(
                      getInputToken('focus', 'border', destructive, disabled)
                    )
                  : getCssVariable(
                      getInputToken('normal', 'border', destructive, disabled)
                    )
            }`,
            boxShadow: isFocused
              ? destructive
                ? '0px 0px 0px 4px rgba(253, 139, 139, 0.12)'
                : '0px 0px 0px 4px rgba(78,107,215,0.12)'
              : '0px 1px 2px rgba(16, 24, 40, 0.05)',
            transition: 'border-color 0.2s, box-shadow 0.2s',
          } as React.CSSProperties
        }
      >
        <div
          style={{
            display: 'flex',
            alignItems: 'center',
            gap: 8,
            width: '100%',
            position: 'relative',
          }}
        >
          {renderInputContent()}
        </div>
      </div>
      {hintText && (
        <div
          className={cn(
            'text-sm leading-5',
            destructive ? 'text-red-500' : 'text-gray-600'
          )}
          style={hintStyles}
        >
          {hintText}
        </div>
      )}
      {errorMessage && (
        <div
          style={{
            color: getCssVariable('input-destructive-fg'),
            fontSize: 14,
            fontFamily: 'Inter',
            fontWeight: 400,
            lineHeight: '20px',
            marginTop: 6,
          }}
        >
          {errorMessage}
        </div>
      )}
    </div>
  );
};

export default InputField;
</file>

<file path="app/components/ShareModal.tsx">
'use client';

import { useState, useRef, useEffect } from 'react';
import Modal from './Modal';
import ButtonNormal from './ButtonNormal';
import InputField from './InputFields';
import { useColors, useTheme } from '../theme/hooks';
import { toast } from 'sonner';
import { Workspace } from '@/types/workspace';

interface ShareModalProps {
  isOpen: boolean;
  onClose: () => void;
  itemName?: string;
  shareableLink?: string;
  params?: {
    id?: string;
    workflowId?: string;
  };
  is_public?: boolean;
  onToggleAccess?: () => void;
  shareUrl?: string;
  workspaceLogo?: string;
  workspace?: Workspace;
}

export default function ShareModal({
  isOpen,
  onClose,
  itemName = 'item',
  shareableLink = window.location.href,
  params,
  is_public = false,
  onToggleAccess,
  shareUrl,
  workspaceLogo,
  workspace,
}: ShareModalProps) {
  const colors = useColors();
  const { currentTheme, setTheme } = useTheme();
  const [previewTheme, setPreviewTheme] = useState<'light' | 'dark'>('light');
  const [activeTab, setActiveTab] = useState('share');
  const [inputValue, setInputValue] = useState('');
  const [selectedPermission, setSelectedPermission] = useState('can view');
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const [openPersonDropdownIndex, setOpenPersonDropdownIndex] = useState<
    number | null
  >(null);
  const [openTeamDropdownIndex, setOpenTeamDropdownIndex] = useState<
    number | null
  >(null);
  const [showToast, setShowToast] = useState(false);
  const [visibilityOption, setVisibilityOption] = useState(
    'Anyone with the link can view'
  );
  const [isVisibilityDropdownOpen, setIsVisibilityDropdownOpen] =
    useState(false);
  const [peopleWithAccess, setPeopleWithAccess] = useState([
    { name: 'JordanDesprs', permission: 'Full access' },
    { name: 'John Doe', permission: 'Editor' },
    { name: 'Marc Aston', permission: 'Reader' },
  ]);
  const [teamsWithAccess, setTeamsWithAccess] = useState([
    { name: 'Design', permission: 'Editor', color: 'blue' },
    { name: 'Human resources', permission: 'Reader', color: 'indigo' },
    { name: 'Marketing', permission: 'Editor', color: 'pink' },
  ]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const isFreePlan = workspace?.subscription?.plan_type === 'FREE';

  const showCustomBranding =
    workspace?.branding_enabled &&
    !isFreePlan &&
    (workspace.brand_logo_url || workspace.brand_name_img_url);

  const brandLogoUrl = workspace?.brand_logo_url
    ? `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_STORAGE_PATH}/${workspace.brand_logo_url}`
    : null;

  const brandNameUrl = workspace?.brand_name_img_url
    ? `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_STORAGE_PATH}/${workspace.brand_name_img_url}`
    : null;

  const dropdownRef = useRef<HTMLDivElement>(null);
  const peopleDropdownRefs = useRef<(HTMLDivElement | null)[]>([]);
  const teamDropdownRefs = useRef<(HTMLDivElement | null)[]>([]);
  const visibilityDropdownRef = useRef<HTMLDivElement>(null);

  const permissionOptions = ['can view', 'can edit', 'can comment'];
  const personPermissionOptions = ['Full access', 'Editor', 'Reader'];
  const visibilityOptions = [
    'Anyone with the link can view',
    'Anyone with the link can edit',
    'Only invited people can view',
    'Only invited people can edit',
  ];

  // Define permission type for TypeScript
  type Permission = 'Full access' | 'Editor' | 'Reader';

  const permissionDescriptions: Record<Permission, string> = {
    'Full access': 'Can edit & share',
    Editor: 'Can edit but not share',
    Reader: 'Cannot edit or share',
  };

  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target as Node)
      ) {
        setIsDropdownOpen(false);
      }

      if (
        visibilityDropdownRef.current &&
        !visibilityDropdownRef.current.contains(event.target as Node)
      ) {
        setIsVisibilityDropdownOpen(false);
      }

      if (openPersonDropdownIndex !== null) {
        const ref = peopleDropdownRefs.current[openPersonDropdownIndex];
        if (ref && !ref.contains(event.target as Node)) {
          setOpenPersonDropdownIndex(null);
        }
      }

      if (openTeamDropdownIndex !== null) {
        const ref = teamDropdownRefs.current[openTeamDropdownIndex];
        if (ref && !ref.contains(event.target as Node)) {
          setOpenTeamDropdownIndex(null);
        }
      }
    }

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [openPersonDropdownIndex, openTeamDropdownIndex]);

  // Hide toast after 3 seconds
  useEffect(() => {
    if (showToast) {
      const timer = setTimeout(() => {
        setShowToast(false);
      }, 3000);

      return () => clearTimeout(timer);
    }
  }, [showToast]);

  const handleCopyLink = async () => {
    try {
      if (!shareUrl) {
        await navigator.clipboard.writeText(shareableLink);
      } else {
        await navigator.clipboard.writeText(shareUrl);
      }
      toast.success('Link Copied!', {
        description: 'Share link has been copied to your clipboard.',
        duration: 3000,
      });
    } catch (err) {
      console.error('Failed to copy link: ', err);
      toast.error('Failed to Copy', {
        description: 'Could not copy the link to your clipboard.',
        duration: 3000,
      });
    }
  };

  const togglePreviewTheme = () => {
    setTheme(currentTheme === 'light' ? 'dark' : 'light');
  };

  const handleCopyEmbedSnippet = async () => {
    if (!shareUrl) return;

    try {
      const url = new URL(shareUrl + '/embed');
      url.searchParams.set('theme', currentTheme);
      await navigator.clipboard.writeText(url.toString());
      toast.success('Embed Link Copied!', {
        description: 'Embed link has been copied to your clipboard.',
        duration: 3000,
      });
    } catch (err) {
      console.error('Failed to copy embed link: ', err);
      toast.error('Failed to Copy', {
        description: 'Could not copy the embed link to your clipboard.',
        duration: 3000,
      });
    }
  };

  const validateEmail = (email: string) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  };

  const handleShare = async () => {
    // Reset error state
    setError(null);

    // Validate email
    if (!inputValue) {
      toast.error('Missing Email', {
        description: 'Please enter an email address.',
        duration: 3000,
      });
      return;
    }

    if (!validateEmail(inputValue)) {
      toast.error('Invalid Email', {
        description: 'Please enter a valid email address.',
        duration: 3000,
      });
      return;
    }

    setIsLoading(true);
    try {
      const response = await fetch('/api/share/invite', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: inputValue,
          itemName,
          permission: selectedPermission,
          shareableLink,
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to send invitation');
      }

      // Add the invited person to the list
      setPeopleWithAccess([
        ...peopleWithAccess,
        {
          name: inputValue,
          permission: selectedPermission === 'can edit' ? 'Editor' : 'Reader',
        },
      ]);

      // Clear input
      setInputValue('');

      // Show success toast
      toast.success('Invitation Sent', {
        description: 'The invitation has been sent successfully.',
        duration: 3000,
      });
    } catch (err) {
      toast.error('Failed to Send Invitation', {
        description:
          'An error occurred while sending the invitation. Please try again.',
        duration: 3000,
      });
      console.error('Error sending invitation:', err);
    } finally {
      setIsLoading(false);
    }
  };

  if (!isOpen) return null;

  return (
    <>
      <Modal
        onClose={onClose}
        title="Share with people and teams"
        width="w-[600px]"
        actions={
          <div className="flex justify-between items-center w-full">
            {activeTab === 'share' && (
              <>
                <div className="flex justify-between w-full gap-4">
                  {onToggleAccess && (
                    <div
                      className="flex items-center gap-2 cursor-pointer"
                      onClick={() => onToggleAccess()}
                    >
                      <div
                        className={`w-8 h-4 rounded-full transition-colors duration-200 ${
                          is_public ? 'bg-brand-solid' : 'bg-tertiary'
                        }`}
                        style={{
                          backgroundColor: is_public
                            ? colors['bg-brand-solid']
                            : colors['bg-tertiary'],
                        }}
                      >
                        <div
                          className={`w-3 h-3 rounded-full bg-white transform transition-transform duration-200 mt-0.5 ${
                            is_public ? 'translate-x-4' : 'translate-x-1'
                          }`}
                        />
                      </div>
                      <span
                        className="text-sm font-medium"
                        style={{ color: colors['text-primary'] }}
                      >
                        {is_public ? 'Public' : 'Private'}
                      </span>
                    </div>
                  )}
                  <ButtonNormal
                    variant="primary"
                    size="small"
                    leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/link-02-white.svg`}
                    onClick={handleCopyLink}
                  >
                    Copy Link
                  </ButtonNormal>
                </div>
              </>
            )}
            {activeTab === 'embed' && (
              <ButtonNormal
                variant="primary"
                size="small"
                leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/link-02-white.svg`}
                onClick={handleCopyEmbedSnippet}
                className="w-full"
              >
                Copy Embed Link
              </ButtonNormal>
            )}
          </div>
        }
      >
        {/* Tabs */}
        <div
          style={{
            backgroundColor: colors['bg-secondary'],
            borderColor: colors['border-secondary'],
          }}
          className="w-full flex items-center gap-1 border rounded-lg p-1 mb-5"
        >
          <ButtonNormal
            onClick={() => setActiveTab('share')}
            variant={activeTab === 'share' ? 'secondary' : 'tertiary'}
            size="small"
            className="flex-1"
          >
            Share
          </ButtonNormal>
          <ButtonNormal
            onClick={() => setActiveTab('embed')}
            variant={activeTab === 'embed' ? 'secondary' : 'tertiary'}
            size="small"
            className="flex-1"
          >
            Embed
          </ButtonNormal>
        </div>

        {/* Tab content */}
        {activeTab === 'share' && (
          <>
            {/* Input field with custom dropdown */}
            <div className="w-full flex items-center gap-3 mb-6">
              <div className="flex-1 relative">
                <style jsx>{`
                  /* Ensure input text doesn't overlap with the dropdown */
                  :global(input) {
                    padding-right: 140px !important;
                  }
                `}</style>
                {/* <InputField
                  type="default"
                  value={inputValue}
                  onChange={setInputValue}
                  placeholder="Enter teams, people or email address"
                /> */}

                {/* Custom permission dropdown button */}
                {/* <div
                  ref={dropdownRef}
                  className="absolute right-3 top-1/2 transform -translate-y-1/2 flex items-center z-20"
                >
                  <button
                    onClick={(e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      setIsDropdownOpen(!isDropdownOpen);
                    }}
                    className="flex items-center gap-2"
                    style={{ backgroundColor: 'transparent' }}
                  >
                    <span
                      className="font-medium"
                      style={{ color: colors['text-tertiary'] }}
                    >
                      {selectedPermission}
                    </span>
                    <svg
                      width="20"
                      height="20"
                      viewBox="0 0 20 20"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg"
                      style={{ color: colors['text-tertiary'] }}
                    >
                      <path
                        d="M5 7.5L10 12.5L15 7.5"
                        stroke="currentColor"
                        strokeWidth="1.6667"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      />
                    </svg>
                  </button>

                  {isDropdownOpen && (
                    <div
                      className="absolute right-0 mt-1 top-full w-[180px] rounded-lg shadow-[0px_4px_6px_-2px_rgba(16,24,40,0.03),0px_12px_16px_-4px_rgba(16,24,40,0.08)] py-1 flex flex-col overflow-hidden"
                      style={{
                        backgroundColor: colors['bg-secondary'],
                        border: `1px solid ${colors['border-secondary']}`,
                        zIndex: 50,
                      }}
                    >
                      {permissionOptions.map((option) => (
                        <div
                          key={option}
                          className="self-stretch px-1.5 py-px flex items-center gap-3"
                          onClick={() => {
                            setSelectedPermission(option);
                            setIsDropdownOpen(false);
                          }}
                        >
                          <div
                            className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-between items-center flex cursor-pointer transition-all duration-150"
                            style={{
                              backgroundColor: 'transparent',
                            }}
                            onMouseEnter={(e) => {
                              e.currentTarget.style.backgroundColor =
                                colors['bg-tertiary'];
                            }}
                            onMouseLeave={(e) => {
                              e.currentTarget.style.backgroundColor =
                                'transparent';
                            }}
                          >
                            <div
                              className="text-sm font-medium"
                              style={{ color: colors['text-primary'] }}
                            >
                              {option}
                            </div>
                            {selectedPermission === option && (
                              <img
                                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-icon3.svg`}
                                alt="Selected"
                                className="w-4 h-4"
                              />
                            )}
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                </div> */}
              </div>
              {/* <ButtonNormal
                variant="primary"
                size="small"
                leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/share-06.svg`}
                onClick={handleShare}
                disabled={isLoading}
              >
                {isLoading ? 'Sending...' : 'Share'}
              </ButtonNormal> */}
            </div>

            {/* Error message */}
            {error && (
              <div
                className="mb-4 px-3 py-2 rounded-md text-sm"
                style={{
                  backgroundColor: '#FEF3F2',
                  color: '#B42318',
                  border: '1px solid #FEE4E2',
                }}
              >
                {error}
              </div>
            )}

            {/* People with access
            <div className="w-full mb-4">
              <h3
                style={{ color: colors['text-quaternary'] }}
                className="text-sm font-medium mb-3"
              >
                People with access
              </h3>
              <div className="space-y-3">
                {peopleWithAccess.map((person, index) => {
                  return (
                    <div
                      key={index}
                      className="flex items-center justify-between"
                    >
                      <div className="flex items-center gap-3">
                        <div
                          style={{
                            backgroundColor: colors['bg-accent-muted'],
                            color: colors['text-primary'],
                          }}
                          className="w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium"
                        >
                          {person.name.charAt(0)}
                        </div>
                        <span
                          style={{ color: colors['text-secondary'] }}
                          className="text-sm font-medium"
                        >
                          {person.name}
                        </span>
                      </div>
                      <div
                        ref={(el) => {
                          peopleDropdownRefs.current[index] = el;
                        }}
                        className="relative"
                      >
                        <button
                          onClick={() =>
                            setOpenPersonDropdownIndex(
                              index === openPersonDropdownIndex ? null : index
                            )
                          }
                          style={{
                            color: colors['text-primary'],
                          }}
                          className="flex items-center gap-1 px-3 py-1.5 text-sm rounded transition-colors duration-150"
                          onMouseEnter={(e) => {
                            e.currentTarget.style.backgroundColor =
                              colors['bg-tertiary'];
                          }}
                          onMouseLeave={(e) => {
                            e.currentTarget.style.backgroundColor =
                              'transparent';
                          }}
                        >
                          {person.permission}
                          <svg
                            width="16"
                            height="16"
                            viewBox="0 0 16 16"
                            fill="none"
                            xmlns="http://www.w3.org/2000/svg"
                          >
                            <path
                              d="M4 6L8 10L12 6"
                              stroke="currentColor"
                              strokeWidth="1.5"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                            />
                          </svg>
                        </button>

                        {index === openPersonDropdownIndex && (
                          <div
                            className="absolute right-0 mt-1 z-50 w-[180px] rounded-lg shadow-[0px_4px_6px_-2px_rgba(16,24,40,0.03),0px_12px_16px_-4px_rgba(16,24,40,0.08)] py-1 flex flex-col overflow-hidden"
                            style={{
                              backgroundColor: colors['bg-secondary'],
                              border: `1px solid ${colors['border-secondary']}`,
                              zIndex: 50,
                            }}
                          >
                            {personPermissionOptions.map((option) => (
                              <div
                                key={option}
                                className="self-stretch px-1.5 py-px flex items-center"
                                onClick={() => {
                                  const updatedPeople = [...peopleWithAccess];
                                  updatedPeople[index].permission = option;
                                  setPeopleWithAccess(updatedPeople);
                                  setOpenPersonDropdownIndex(null);
                                }}
                              >
                                <div
                                  className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-between items-center flex cursor-pointer transition-all duration-150"
                                  style={{ backgroundColor: 'transparent' }}
                                  onMouseEnter={(e) => {
                                    e.currentTarget.style.backgroundColor =
                                      colors['bg-tertiary'];
                                  }}
                                  onMouseLeave={(e) => {
                                    e.currentTarget.style.backgroundColor =
                                      'transparent';
                                  }}
                                >
                                  <div className="flex flex-col gap-1">
                                    <div
                                      className="text-sm font-medium"
                                      style={{ color: colors['text-primary'] }}
                                    >
                                      {option}
                                    </div>
                                    <div
                                      className="text-xs font-normal"
                                      style={{
                                        color: colors['text-secondary'],
                                      }}
                                    >
                                      {
                                        permissionDescriptions[
                                          option as Permission
                                        ]
                                      }
                                    </div>
                                  </div>
                                  {person.permission === option && (
                                    <img
                                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-icon3.svg`}
                                      alt="Selected"
                                      className="w-4 h-4"
                                    />
                                  )}
                                </div>
                              </div>
                            ))}
                          </div>
                        )}
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>

            {/* Divider */}
            {/* <div
              style={{ backgroundColor: colors['border-secondary'] }}
              className="w-full h-px my-4"
            ></div> */}

            {/* Teams with access */}
            {/* <div className="w-full">
              <h3
                style={{ color: colors['text-quaternary'] }}
                className="text-sm font-medium mb-3"
              >
                Teams with access
              </h3>
              <div className="space-y-3">
                {teamsWithAccess.map((team, index) => (
                  <div
                    key={index}
                    className="flex items-center justify-between"
                  >
                    <div className="flex items-center gap-3">
                      <div
                        style={{
                          backgroundColor:
                            team.color === 'blue'
                              ? '#EDF0FB'
                              : team.color === 'indigo'
                                ? '#EEF4FF'
                                : '#FDF2FA',
                          color:
                            team.color === 'blue'
                              ? '#374C99'
                              : team.color === 'indigo'
                                ? '#3538CD'
                                : '#C11574',
                          borderColor:
                            team.color === 'blue'
                              ? '#AEBBED'
                              : team.color === 'indigo'
                                ? '#C7D7FE'
                                : '#FCCEEE',
                        }}
                        className="px-2.5 py-0.5 text-xs font-medium rounded-lg border"
                      >
                        {team.name}
                      </div>
                    </div>
                    <div
                      ref={(el) => {
                        teamDropdownRefs.current[index] = el;
                      }}
                      className="relative"
                    >
                      <button
                        onClick={() =>
                          setOpenTeamDropdownIndex(
                            index === openTeamDropdownIndex ? null : index
                          )
                        }
                        style={{
                          color: colors['text-primary'],
                        }}
                        className="flex items-center gap-1 px-3 py-1.5 text-sm rounded transition-colors duration-150"
                        onMouseEnter={(e) => {
                          e.currentTarget.style.backgroundColor =
                            colors['bg-tertiary'];
                        }}
                        onMouseLeave={(e) => {
                          e.currentTarget.style.backgroundColor = 'transparent';
                        }}
                      >
                        {team.permission}
                        <svg
                          width="16"
                          height="16"
                          viewBox="0 0 16 16"
                          fill="none"
                          xmlns="http://www.w3.org/2000/svg"
                        >
                          <path
                            d="M4 6L8 10L12 6"
                            stroke="currentColor"
                            strokeWidth="1.5"
                            strokeLinecap="round"
                            strokeLinejoin="round"
                          />
                        </svg>
                      </button>

                      {index === openTeamDropdownIndex && (
                        <div
                          className="absolute right-0 mt-1 z-50 w-[180px] rounded-lg shadow-[0px_4px_6px_-2px_rgba(16,24,40,0.03),0px_12px_16px_-4px_rgba(16,24,40,0.08)] py-1 flex flex-col overflow-hidden"
                          style={{
                            backgroundColor: colors['bg-secondary'],
                            border: `1px solid ${colors['border-secondary']}`,
                            zIndex: 50,
                          }}
                        >
                          {personPermissionOptions.map((option) => (
                            <div
                              key={option}
                              className="self-stretch px-1.5 py-px flex items-center"
                              onClick={() => {
                                const updatedTeams = [...teamsWithAccess];
                                updatedTeams[index].permission = option;
                                setTeamsWithAccess(updatedTeams);
                                setOpenTeamDropdownIndex(null);
                              }}
                            >
                              <div
                                className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-between items-center flex cursor-pointer transition-all duration-150"
                                style={{ backgroundColor: 'transparent' }}
                                onMouseEnter={(e) => {
                                  e.currentTarget.style.backgroundColor =
                                    colors['bg-tertiary'];
                                }}
                                onMouseLeave={(e) => {
                                  e.currentTarget.style.backgroundColor =
                                    'transparent';
                                }}
                              >
                                <div className="flex flex-col gap-1">
                                  <div
                                    className="text-sm font-medium"
                                    style={{ color: colors['text-primary'] }}
                                  >
                                    {option}
                                  </div>
                                  <div
                                    className="text-xs font-normal"
                                    style={{ color: colors['text-secondary'] }}
                                  >
                                    {
                                      permissionDescriptions[
                                        option as Permission
                                      ]
                                    }
                                  </div>
                                </div>
                                {team.permission === option && (
                                  <img
                                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-icon3.svg`}
                                    alt="Selected"
                                    className="w-4 h-4"
                                  />
                                )}
                              </div>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </div> */}
          </>
        )}

        {activeTab === 'embed' && (
          <div className="w-full">
            <div className="w-full">
              <div
                className="w-full rounded-lg border overflow-hidden transition-colors duration-200"
                style={{
                  backgroundColor: colors['bg-secondary'],
                  borderColor: colors['border-secondary'],
                }}
              >
                <div className="flex flex-col items-center gap-[58px] py-[30px] px-[35px]">
                  {/* Logo and Title */}
                  <div className="flex flex-col items-center gap-[29px]">
                    <div className="flex flex-col items-center gap-[14.5px]">
                      <div className="flex items-center gap-3">
                        <div
                          className="flex items-center justify-center relative [&[data-fallback]]:before:content-[attr(data-fallback)] [&[data-fallback]]:before:text-lg [&[data-fallback]]:before:font-medium"
                          style={{ color: colors['text-primary'] }}
                        >
                          {showCustomBranding ? (
                            <div className="flex items-center gap-3">
                              {brandLogoUrl && (
                                <img
                                  src={brandLogoUrl}
                                  alt="Brand Logo"
                                  className="h-[40px] w-auto"
                                />
                              )}
                              {brandNameUrl && (
                                <img
                                  src={brandNameUrl}
                                  alt="Brand Name"
                                  className="h-[27px] w-auto"
                                />
                              )}
                            </div>
                          ) : (
                            <div
                              className="items-center gap-3 flex"
                              data-fallback-logo
                            >
                              <img
                                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`}
                                alt="ProcessFlow Logo Mark"
                                className="h-[40px] w-auto"
                              />
                              <img
                                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/pf-name.svg`}
                                alt="ProcessFlow Name"
                                className="h-[17px] w-auto"
                              />
                            </div>
                          )}
                        </div>
                      </div>
                    </div>
                    {!showCustomBranding && (
                      <span
                        className="text-[14.5px] leading-[1.5] font-medium text-center"
                        style={{ color: colors['text-primary'] }}
                      >
                        This process was created with Processflow. Create your
                        own processes now!
                      </span>
                    )}
                  </div>

                  {/* Action Buttons */}
                  <div className="flex flex-col items-center gap-[5.8px]">
                    <div
                      className="flex items-center gap-1 px-3 py-2 rounded-[5.8px] text-white"
                      style={{
                        backgroundColor: '#4E6BD7',
                        boxShadow:
                          '0px 1px 2px rgba(16, 24, 40, 0.05), inset 0px -2px 0px rgba(16, 24, 40, 0.05), inset 0px 0px 0px 1px rgba(16, 24, 40, 0.18)',
                      }}
                    >
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-right.svg`}
                        alt="Arrow Right"
                      />
                      <span className="text-[14.5px] font-semibold">
                        Show me how
                      </span>
                    </div>
                    <div className="flex items-center gap-1 px-3 py-2 text-[#475467]">
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/refresh-cw-01.svg`}
                        alt="Refresh"
                      />
                      <span className="text-[14.5px] font-semibold">
                        Restart Process
                      </span>
                    </div>
                  </div>
                </div>

                {/* Footer */}
                <div
                  className="flex justify-between items-center px-[17.5px] py-[2.9px] border-t transition-colors duration-200"
                  style={{
                    backgroundColor: colors['bg-tertiary'],
                    borderColor: colors['border-secondary'],
                  }}
                >
                  {!showCustomBranding && (
                    <div className="flex items-center gap-[8.7px]">
                      <span
                        className="text-[10.2px] leading-[1.43] font-normal"
                        style={{ color: colors['text-secondary'] }}
                      >
                        Made with
                      </span>
                      <div
                        className="items-center gap-2 flex"
                        data-fallback-logo-footer
                      >
                        <img
                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`}
                          alt="ProcessFlow Logo Mark"
                          className="h-[20px] w-auto"
                        />
                        <img
                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/pf-name.svg`}
                          alt="ProcessFlow Name"
                          className="h-[10px] w-auto"
                        />
                      </div>
                    </div>
                  )}
                  <div
                    className="flex items-center gap-2"
                    style={{
                      marginLeft: showCustomBranding ? 'auto' : undefined,
                    }}
                  >
                    <ButtonNormal
                      variant="tertiary"
                      iconOnly
                      size="small"
                      className="p-2 rounded-[5.8px]"
                      onClick={togglePreviewTheme}
                      leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${currentTheme === 'light' ? 'moon' : 'sun'}.svg`}
                    />
                    <ButtonNormal
                      variant="tertiary"
                      iconOnly
                      size="small"
                      className="p-2 rounded-[5.8px]"
                      onClick={handleCopyEmbedSnippet}
                      leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/link-external-02.svg`}
                    />
                  </div>
                </div>
              </div>
            </div>
          </div>
        )}
      </Modal>
    </>
  );
}
</file>

<file path="app/components/Switch.tsx">
'use client';

import React from 'react';
import { useColors } from '@/app/theme/hooks';

interface SwitchProps {
  isOn: boolean;
  handleToggle: () => void;
  label?: string;
  disabled?: boolean;
}

const Switch: React.FC<SwitchProps> = ({
  isOn,
  handleToggle,
  label,
  disabled = false,
}) => {
  const colors = useColors();

  return (
    <div className={`flex items-center ${disabled ? 'opacity-50' : ''}`}>
      <label
        htmlFor="switch"
        className={`flex items-center ${
          disabled ? 'cursor-not-allowed' : 'cursor-pointer'
        }`}
      >
        <div className="relative">
          <input
            id="switch"
            type="checkbox"
            className="sr-only"
            checked={isOn}
            onChange={handleToggle}
            disabled={disabled}
          />
          <div
            style={{
              backgroundColor: isOn
                ? colors['bg-brand-primary']
                : colors['bg-secondary'],
            }}
            className="block w-14 h-8 rounded-full transition-colors"
          ></div>
          <div
            className="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition-transform"
            style={{
              transform: isOn ? 'translateX(100%)' : 'translateX(0)',
              backgroundColor: colors['bg-primary'],
            }}
          ></div>
        </div>
        {label && (
          <span
            style={{ color: colors['text-primary'] }}
            className="ml-3 text-sm font-medium"
          >
            {label}
          </span>
        )}
      </label>
    </div>
  );
};

export default Switch;
</file>

<file path="app/context/FastThemeContext.tsx">
'use client';

import {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
} from 'react';

type ThemeMode = 'light' | 'dark';

interface FastThemeContextType {
  currentTheme: ThemeMode;
  setTheme: (theme: ThemeMode) => void;
  toggleTheme: () => void;
}

export const FastThemeContext = createContext<FastThemeContextType | undefined>(
  undefined
);

export function FastThemeProvider({ children }: { children: React.ReactNode }) {
  const [currentTheme, setCurrentTheme] = useState<ThemeMode>('light');

  const setTheme = useCallback((theme: ThemeMode) => {
    // INSTANT theme switching - just change one data attribute!
    document.documentElement.setAttribute('data-theme', theme);
    setCurrentTheme(theme);
    localStorage.setItem('theme-mode', theme);
  }, []);

  const toggleTheme = useCallback(() => {
    const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    setTheme(newTheme);
  }, [currentTheme, setTheme]);

  useEffect(() => {
    // Initialize theme on mount
    const savedTheme = localStorage.getItem('theme-mode') as ThemeMode;
    // const systemPrefersDark = window.matchMedia(
    //   '(prefers-color-scheme: dark)'
    // ).matches;

    const initialTheme = savedTheme || 'light';

    // Set initial theme
    document.documentElement.setAttribute('data-theme', initialTheme);
    setCurrentTheme(initialTheme);
  }, []);

  return (
    <FastThemeContext.Provider
      value={{
        currentTheme,
        setTheme,
        toggleTheme,
      }}
    >
      {children}
    </FastThemeContext.Provider>
  );
}

export function useFastTheme() {
  const context = useContext(FastThemeContext);
  if (context === undefined) {
    throw new Error('useFastTheme must be used within a FastThemeProvider');
  }
  return context;
}
</file>

<file path="app/dashboard/components/CreateFlowModal.tsx">
'use client';
import { useState } from 'react';
import ButtonNormal from '../../components/ButtonNormal';
import InputField from '../../components/InputFields';
import TextAreaInput from '../../components/TextAreaInput';
import DatePicker from '../../components/DatePicker';
import { useColors } from '@/app/theme/hooks';
import IconUpload from '../../components/IconUpload';
import IconModifier from './IconModifier';
import DOMPurify from 'dompurify';

interface CreateFlowModalProps {
  onClose: () => void;
  onCreateFlow: (
    name: string,
    description: string,
    process_owner: string,
    review_date: string,
    additional_notes: string,
    icon: string | null,
    signedIcon: string | null
  ) => Promise<void>;
}

export default function CreateFlowModal({
  onClose,
  onCreateFlow,
}: CreateFlowModalProps) {
  const colors = useColors();
  const [flowName, setFlowName] = useState('');
  const [processOwner, setProcessOwner] = useState('');
  const [reviewDate, setReviewDate] = useState('');
  const [description, setdescription] = useState('');
  const [additionalNotes, setAdditionalNotes] = useState('');
  const [isSaving, setIsSaving] = useState(false);
  const [flowIcon, setFlowIcon] = useState<string | null>(null);
  const [previewIcon, setPreviewIcon] = useState<string | null>(null);
  const [previewFile, setPreviewFile] = useState<File | null>(null);

  const handleModalClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  return (
    <div
      className="fixed inset-0 flex items-center justify-center p-8 animate-in fade-in-0 duration-200 z-[100]"
      onClick={onClose}
    >
      {/* Backdrop */}
      <div className="absolute inset-0 animate-in fade-in-0 duration-300">
        <div
          style={{ backgroundColor: colors['bg-overlay'] }}
          className="absolute inset-0 opacity-70"
        />
      </div>

      <div
        onClick={handleModalClick}
        style={{ backgroundColor: colors['bg-primary'] }}
        className="w-[550px] rounded-xl shadow-[0px_8px_8px_-4px_rgba(16,24,40,0.03)] flex-col justify-start items-start flex relative z-10 animate-in zoom-in-95 slide-in-from-bottom-4 duration-300 ease-out"
      >
        <div className="w-full overflow-visible">
          <div className="flex items-start gap-4 px-6 pt-6">
            <div
              style={{
                backgroundColor: colors['bg-secondary'],
                borderColor: colors['border-secondary'],
              }}
              className="w-12 h-12 p-3 rounded-[10px] shadow-[0px_1px_2px_0px_rgba(16,24,40,0.05)] border justify-center items-center inline-flex overflow-hidden"
            >
              <div className="w-6 h-6 relative flex-col justify-start items-start flex overflow-hidden">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/layers-three-01.svg`}
                  alt="3 layers icon"
                  className="w-6 h-6"
                />
              </div>
            </div>
            <div className="flex-col justify-start items-start gap-1 flex">
              <div
                style={{ color: colors['text-primary'] }}
                className="text-lg font-semibold font-['Inter'] leading-7"
              >
                Create a new Flow
              </div>
              <div
                style={{ color: colors['text-secondary'] }}
                className="text-sm font-normal font-['Inter'] leading-tight"
              >
                Give your Flow some context.
              </div>
            </div>
          </div>
          <div
            style={{ borderColor: colors['border-secondary'] }}
            className="self-stretch px-6 pt-4 pb-4 border-b flex-col justify-start items-start gap-5 flex"
          >
            {/* Flow name with icon */}
            <div className="w-full">
              <label
                className="block text-sm font-semibold mb-2"
                style={{ color: colors['input-label'] }}
              >
                Flow name{' '}
                <span style={{ color: colors['text-accent'] }}>*</span>
              </label>
              <div className="flex items-center gap-2 w-full">
                <div style={{ zIndex: 30 }}>
                  <IconModifier
                    initialIcon={previewIcon || undefined}
                    onUpdate={(icon, emote, signedIcon, file) => {
                      setFlowIcon(icon || null);
                      setPreviewIcon(signedIcon ? signedIcon : icon || null);
                      setPreviewFile(file || null);
                    }}
                    allowEmoji={false}
                    flow={true}
                  />
                </div>
                <div style={{ zIndex: 0 }} className="flex-1">
                  <InputField
                    type="default"
                    value={flowName}
                    onChange={(value) => setFlowName(value)}
                    placeholder="e.g Create a new task"
                    required
                  />
                </div>
              </div>
            </div>

            {/* Process Owner and Review Date row */}
            <div className="w-full flex gap-4">
              <div className="flex-1">
                <InputField
                  label="Flow owner"
                  type="default"
                  value={processOwner}
                  onChange={setProcessOwner}
                  placeholder="Enter owner name"
                />
              </div>
              <div className="flex-1">
                <DatePicker
                  label="Review Date"
                  value={reviewDate}
                  onChange={setReviewDate}
                  placeholder="Pick a date"
                />
              </div>
            </div>

            {/* Why does this process exist? */}
            <div className="w-full">
              <TextAreaInput
                label="Why does this Flow exist?"
                value={description}
                onChange={(value) => setdescription(value)}
                placeholder="Enter a description..."
              />
            </div>

            {/* How do we complete this process? */}
            <div className="w-full">
              <TextAreaInput
                label="Additional notes"
                value={additionalNotes}
                onChange={(value) => setAdditionalNotes(value)}
                placeholder="Enter a description..."
              />
            </div>
          </div>

          <div className="opacity-50 h-[296px] relative w-full px-6 pt-4 hidden">
            <div
              style={{ color: colors['text-primary'] }}
              className="text-sm font-semibold font-['Inter'] leading-tight mb-4"
            >
              Templates (coming soon...)
            </div>
            <div
              style={{
                backgroundColor: colors['bg-secondary'],
                borderColor: colors['border-secondary'],
              }}
              className="w-full h-[72px] p-4 rounded-xl border justify-start items-start gap-1 inline-flex"
            >
              <div className="grow shrink basis-0 h-10 justify-start items-start gap-3 flex">
                <div className="w-8 h-8 p-2 bg-[#DCFAE6] rounded-full justify-center items-center flex overflow-hidden">
                  <div className="w-4 h-4 relative flex-col justify-start items-start flex overflow-hidden">
                    <img
                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/layers-two-green.svg`}
                      alt="2 layers green icon"
                      className="w-4 h-4"
                    />
                  </div>
                </div>
                <div className="grow shrink basis-0 flex-col justify-start items-start inline-flex">
                  <div className="justify-start items-start gap-1 inline-flex">
                    <div
                      style={{ color: colors['text-primary'] }}
                      className="text-sm font-medium font-['Inter'] leading-tight"
                    >
                      Onboarding
                    </div>
                  </div>
                  <div
                    style={{ color: colors['text-secondary'] }}
                    className="self-stretch text-sm font-normal font-['Inter'] leading-tight"
                  >
                    Placeholder explaining the flow
                  </div>
                </div>
              </div>
              <div
                style={{ borderColor: colors['border-secondary'] }}
                className="w-4 h-4 relative rounded-full border"
              />
            </div>
          </div>

          <div
            style={{ borderColor: colors['border-secondary'] }}
            className="self-stretch py-6 border-t flex-col justify-start items-start flex"
          >
            <div className="self-stretch px-6 justify-start items-start gap-3 inline-flex">
              <ButtonNormal
                onClick={onClose}
                variant="secondary"
                size="small"
                className="grow shrink basis-0 transition-all duration-200 hover:scale-[1.02]"
              >
                Cancel
              </ButtonNormal>
              <ButtonNormal
                onClick={async () => {
                  if (!flowName.trim()) return;
                  setIsSaving(true);
                  const sanitizedFlowName = flowName;
                  const sanitizedProcessOwner = processOwner;
                  const sanitizeddescription = description;
                  const sanitizedadditionalNotes = additionalNotes;
                  let uploadedIconUrl = flowIcon;
                  let uploadedSignedIcon = previewIcon;
                  if (previewFile) {
                    try {
                      const formData = new FormData();
                      formData.append('file', previewFile);
                      const response = await fetch('/api/upload-icon', {
                        method: 'POST',
                        body: formData,
                      });
                      const data = await response.json();
                      if (!response.ok || !data.success)
                        throw new Error(data.error || 'Upload failed');
                      uploadedIconUrl = data.data.iconUrl;
                      // Optionally fetch signed URL if needed
                      uploadedSignedIcon =
                        data.data.publicUrl || uploadedIconUrl;
                      console.log('uploadedSignedIcon', uploadedSignedIcon);
                    } catch (error) {
                      console.error('Error uploading icon:', error);
                      setIsSaving(false);
                      return;
                    }
                  }
                  onCreateFlow(
                    sanitizedFlowName,
                    sanitizeddescription,
                    sanitizedProcessOwner,
                    reviewDate,
                    sanitizedadditionalNotes,
                    uploadedIconUrl,
                    uploadedSignedIcon
                  )
                    .then(() => {
                      setIsSaving(false);
                      onClose();
                    })
                    .catch((error) => {
                      console.error('Error creating flow:', error);
                      setIsSaving(false);
                    });
                }}
                variant="primary"
                size="small"
                className="grow shrink basis-0 transition-all duration-200 hover:scale-[1.02]"
                isLoading={isSaving}
                loadingText="Creating..."
                disabled={!flowName.trim() || isSaving}
              >
                Create Flow
              </ButtonNormal>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/dashboard/components/CreateFolderModal.tsx">
'use client';

import React, { useState } from 'react';
import IconModifier from './IconModifier';
import ButtonNormal from '@/app/components/ButtonNormal';
import InputField from '@/app/components/InputFields';
import { useColors } from '@/app/theme/hooks';
import Modal from '@/app/components/Modal';
import { checkFolderName } from '@/app/utils/checkNames';
import { toast } from 'sonner';
import DOMPurify from 'dompurify';

interface CreateFolderModalProps {
  onClose: () => void;
  onCreate: (
    folderName: string,
    icon_url?: string,
    emote?: string,
    signedIconUrl?: string
  ) => Promise<void>;
}

const CreateFolderModal: React.FC<CreateFolderModalProps> = ({
  onClose,
  onCreate,
}) => {
  const [folderName, setFolderName] = useState('');
  const [iconUrl, setIconUrl] = useState<string | undefined>(undefined);
  const [emote, setEmote] = useState<string | undefined>(undefined);
  const [previewIcon, setPreviewIcon] = useState<string | undefined>(undefined);
  const [previewFile, setPreviewFile] = useState<File | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const colors = useColors();

  const handleCreateFolder = async () => {
    if (!folderName.trim()) return;

    const nameError = checkFolderName(folderName);
    if (nameError) {
      toast.error(nameError.title, {
        description: nameError.description,
      });
      return;
    }

    setIsSubmitting(true);
    let uploadedIconUrl = iconUrl;
    let uploadedSignedIcon = previewIcon;
    if (previewFile) {
      try {
        const formData = new FormData();
        formData.append('file', previewFile);
        const response = await fetch('/api/upload-icon', {
          method: 'POST',
          body: formData,
        });
        const data = await response.json();
        if (!response.ok || !data.success)
          throw new Error(data.error || 'Upload failed');
        uploadedIconUrl = data.data.iconUrl;
        uploadedSignedIcon = data.data.publicUrl || uploadedIconUrl;
      } catch (error) {
        console.error('Error uploading icon:', error);
        setIsSubmitting(false);
        return;
      }
    }
    try {
      if (uploadedIconUrl)
        await onCreate(
          folderName,
          uploadedIconUrl,
          undefined,
          uploadedSignedIcon
        );
      else if (emote) await onCreate(folderName, undefined, emote);
      else await onCreate(folderName);
      onClose();
    } catch (error) {
      console.error('Error creating folder:', error);
      toast.error('Error Creating Folder', {
        description: 'An unexpected error occurred while creating the folder.',
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const updateIcon = (icon?: string, emote?: string) => {
    setIconUrl(icon);
    setEmote(emote);
  };

  // Define modal actions
  const modalActions = (
    <>
      <ButtonNormal
        variant="secondary"
        size="small"
        onClick={onClose}
        className="flex-1"
        disabled={isSubmitting}
      >
        Cancel
      </ButtonNormal>
      <ButtonNormal
        variant="primary"
        size="small"
        onClick={handleCreateFolder}
        disabled={!folderName.trim() || isSubmitting}
        className="flex-1"
      >
        {isSubmitting ? 'Creating...' : 'Create'}
      </ButtonNormal>
    </>
  );

  // Folder icon for this modal
  const folderIcon = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon.svg`;

  return (
    <Modal
      onClose={onClose}
      title="Create a folder"
      icon={folderIcon}
      actions={modalActions}
      showActionsSeparator={true}
    >
      <div className="flex flex-col gap-4">
        {/* Input Field */}
        <div>
          <label
            className="block text-sm font-semibold mb-2"
            style={{ color: colors['text-primary'] }}
          >
            Folder name <span style={{ color: colors['text-accent'] }}>*</span>
          </label>
          <div className="flex items-center gap-2">
            <IconModifier
              initialIcon={previewIcon}
              onUpdate={(icon, emote, signedIcon, file) => {
                setIconUrl(icon);
                setEmote(emote);
                setPreviewIcon(signedIcon ? signedIcon : icon || undefined);
                setPreviewFile(file || null);
              }}
              emote={emote}
            />
            <InputField
              type="default"
              value={folderName}
              onChange={setFolderName}
              placeholder="Enter folder name"
            />
          </div>
        </div>
      </div>
    </Modal>
  );
};

export default CreateFolderModal;
</file>

<file path="app/dashboard/components/CreateSubfolderModal.tsx">
import React, { useState } from 'react';
import IconModifier from './IconModifier';
import { Folder } from '@/types/workspace';
import InputField from '@/app/components/InputFields';
import ButtonNormal from '@/app/components/ButtonNormal';
import { useColors } from '@/app/theme/hooks';
import Modal from '@/app/components/Modal';
import DOMPurify from 'dompurify';

interface CreateSubfolderModalProps {
  onClose: () => void;
  onCreate: (
    folderName: string,
    parentId: number,
    icon_url?: string,
    emote?: string,
    signedIconUrl?: string
  ) => Promise<void>;
  parentId: number;
  parent: Folder;
}

const CreateSubfolderModal: React.FC<CreateSubfolderModalProps> = ({
  onClose,
  onCreate,
  parentId,
  parent,
}) => {
  const [folderName, setFolderName] = useState('');
  const [iconUrl, setIconUrl] = useState<string | undefined>(undefined);
  const [previewIcon, setPreviewIcon] = useState<string | undefined>(undefined);
  const [emote, setEmote] = useState<string | undefined>(undefined);
  const [previewFile, setPreviewFile] = useState<File | null>(null);
  const colors = useColors();
  const [isSaving, setIsSaving] = useState(false);

  const handleCreateSubfolder = async () => {
    if (!folderName.trim()) return;
    setIsSaving(true);
    let uploadedIconUrl = iconUrl;
    let uploadedSignedIcon = previewIcon;
    if (previewFile) {
      try {
        const formData = new FormData();
        formData.append('file', previewFile);
        const response = await fetch('/api/upload-icon', {
          method: 'POST',
          body: formData,
        });
        const data = await response.json();
        if (!response.ok || !data.success)
          throw new Error(data.error || 'Upload failed');
        uploadedIconUrl = data.data.iconUrl;
        uploadedSignedIcon = data.data.publicUrl || uploadedIconUrl;
      } catch (error) {
        console.error('Error uploading icon:', error);
        setIsSaving(false);
        return;
      }
    }
    try {
      if (uploadedIconUrl)
        await onCreate(
          folderName,
          parentId,
          uploadedIconUrl,
          undefined,
          uploadedSignedIcon
        );
      else if (emote) await onCreate(folderName, parentId, undefined, emote);
      else await onCreate(folderName, parentId);
      onClose();
    } catch (error) {
      // Optionally handle error (toast, etc.)
      console.error('Error creating subfolder:', error);
    } finally {
      setIsSaving(false);
    }
  };

  const updateIcon = (icon?: string, emote?: string, signedIcon?: string) => {
    if (icon) {
      setIconUrl(icon);
      setEmote(undefined);
      setPreviewIcon(signedIcon ? signedIcon : icon || undefined);
    } else if (emote) {
      setIconUrl(undefined);
      setEmote(emote);
      setPreviewIcon(undefined);
    } else {
      setIconUrl(undefined);
      setEmote(undefined);
      setPreviewIcon(undefined);
    }
  };

  // Modal actions
  const modalActions = (
    <>
      <ButtonNormal
        variant="secondary"
        size="small"
        onClick={onClose}
        className="flex-1"
        disabled={isSaving}
      >
        Cancel
      </ButtonNormal>
      <ButtonNormal
        variant="primary"
        size="small"
        onClick={handleCreateSubfolder}
        disabled={!folderName.trim() || isSaving}
        className="flex-1"
      >
        {isSaving ? 'Creating...' : 'Create'}
      </ButtonNormal>
    </>
  );

  // Folder icon for this modal
  const folderIcon = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon.svg`;

  return (
    <Modal
      onClose={onClose}
      title="Create a Subfolder"
      icon={folderIcon}
      actions={modalActions}
      showActionsSeparator={true}
    >
      <div className="flex flex-col gap-4">
        {/* Parent Info */}
        <div className="flex flex-row items-center gap-3">
          {parent.icon_url ? (
            <img
              src={
                parent.icon_url.startsWith('https://cdn.brandfetch.io/')
                  ? parent.icon_url
                  : parent.signedIconUrl
                    ? parent.signedIconUrl
                    : `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon-base.svg`
              }
              alt="icon"
              className="w-6 h-6 rounded mr-1"
            />
          ) : (
            <span className="text-lg mr-1">{parent.emote || ''}</span>
          )}
          <span
            className="text-sm font-medium"
            style={{ color: colors['text-secondary'] }}
          >
            Add a subfolder to <span className="ml-0.5">{parent.name}</span>
          </span>
        </div>
        {/* Input Field */}
        <div>
          <label
            className="block text-sm font-semibold mb-2"
            style={{ color: colors['text-primary'] }}
          >
            Folder name <span style={{ color: colors['text-accent'] }}>*</span>
          </label>
          <div className="flex items-center gap-2">
            <IconModifier
              initialIcon={previewIcon}
              onUpdate={(icon, emote, signedIcon, file) => {
                if (icon) {
                  setIconUrl(icon);
                  setEmote(undefined);
                  setPreviewIcon(signedIcon ? signedIcon : icon || undefined);
                  setPreviewFile(file || null);
                } else if (emote) {
                  setIconUrl(undefined);
                  setEmote(emote);
                  setPreviewIcon(undefined);
                  setPreviewFile(null);
                } else {
                  setIconUrl(undefined);
                  setEmote(undefined);
                  setPreviewIcon(undefined);
                  setPreviewFile(null);
                }
              }}
              emote={emote}
            />
            <InputField
              type="default"
              value={folderName}
              onChange={setFolderName}
              placeholder="Enter folder name"
            />
          </div>
        </div>
      </div>
    </Modal>
  );
};

export default CreateSubfolderModal;
</file>

<file path="app/dashboard/components/EditFlowModal.tsx">
'use client';
import { Workflow } from '@/types/workflow';
import { Folder } from '@/types/workspace';
import { useState } from 'react';
import ButtonNormal from '@/app/components/ButtonNormal';
import InputField from '@/app/components/InputFields';
import TextAreaInput from '@/app/components/TextAreaInput';
import DatePicker from '@/app/components/DatePicker';
import { useColors } from '@/app/theme/hooks';
import IconUpload from '@/app/components/IconUpload';
import IconModifier from './IconModifier';
import { toast } from 'sonner';
import DOMPurify from 'dompurify';

interface EditFlowModalProps {
  onClose: () => void;
  onConfirm: (
    id: number,
    name: string,
    description: string,
    process_owner: string,
    review_date: string,
    additional_notes: string,
    folder: Folder | null | undefined,
    icon: string | null,
    signedIcon: string | null
  ) => Promise<{
    workflow: Workflow | null;
    error?: { title: string; description: string };
  }>;
  selectedWorkflow: Workflow;
}

export default function EditFlowModal({
  onClose,
  onConfirm,
  selectedWorkflow,
}: EditFlowModalProps) {
  const colors = useColors();
  const [processName, setProcessName] = useState(selectedWorkflow.name);
  const [processOwner, setProcessOwner] = useState(
    selectedWorkflow.process_owner || ''
  );
  const [review_date, setreview_date] = useState(
    selectedWorkflow.review_date || ''
  );
  const [description, setdescription] = useState(
    selectedWorkflow.description || selectedWorkflow.description || ''
  );
  const [additionalNotes, setAdditionalNotes] = useState(
    selectedWorkflow.additional_notes || ''
  );
  const [isSaving, setIsSaving] = useState(false);
  const [flowIcon, setFlowIcon] = useState(selectedWorkflow.icon || null);
  const [previewIcon, setPreviewIcon] = useState(
    selectedWorkflow.icon &&
      selectedWorkflow.icon.startsWith('https://cdn.brandfetch.io/')
      ? selectedWorkflow.icon
      : selectedWorkflow.signedIconUrl || null
  );
  const [previewFile, setPreviewFile] = useState<File | null>(null);

  const handleSave = async () => {
    setIsSaving(true);
    try {
      if (previewFile) {
        const formData = new FormData();
        formData.append('file', previewFile);
        const response = await fetch('/api/upload-icon', {
          method: 'POST',
          body: formData,
        });
        const data = await response.json();
        if (!response.ok || !data.success)
          throw new Error(data.error || 'Upload failed');
        const uploadedIconUrl = data.data.iconUrl;
        const uploadedSignedIcon = data.data.publicUrl || uploadedIconUrl;
        const result = await onConfirm(
          selectedWorkflow.id,
          processName,
          description,
          processOwner,
          review_date,
          additionalNotes,
          undefined,
          uploadedIconUrl,
          uploadedSignedIcon
        );

        if (result.error) {
          toast.error(result.error.title, {
            description: result.error.description,
          });
          return;
        }

        if (result.workflow) {
          onClose();
        }
      } else {
        const result = await onConfirm(
          selectedWorkflow.id,
          processName,
          description,
          processOwner,
          review_date,
          additionalNotes,
          undefined,
          flowIcon,
          previewIcon
        );

        if (result.error) {
          toast.error(result.error.title, {
            description: result.error.description,
          });
          return;
        }

        if (result.workflow) {
          onClose();
        }
      }
    } catch (error) {
      console.error('Error saving flow:', error);
      toast.error('Error Saving Flow', {
        description: 'An unexpected error occurred while saving the flow.',
      });
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <div
      className="fixed inset-0 flex items-center justify-center z-[100] w-full"
      onClick={onClose}
    >
      {/* Backdrop */}
      <div className="absolute inset-0">
        <div
          style={{ backgroundColor: colors['bg-overlay'] }}
          className="absolute inset-0 opacity-70"
        />
      </div>

      {/* Modal content */}
      <div
        style={{ backgroundColor: colors['bg-primary'] }}
        className="w-[550px] rounded-xl shadow-lg flex-col justify-start items-center flex relative z-10"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="w-full overflow-visible">
          <div className="self-stretch px-6 pt-6 flex justify-start items-start gap-4">
            <div
              style={{
                backgroundColor: colors['bg-secondary'],
                borderColor: colors['border-secondary'],
              }}
              className="w-12 h-12 p-3 rounded-[10px] border shadow-sm flex items-center justify-center"
            >
              <div className="w-6 h-6 relative flex-col justify-start items-start flex overflow-hidden">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/layers-three-01.svg`}
                  alt="Flow icon"
                  className="w-6 h-6"
                />
              </div>
            </div>
            <div className="flex-col justify-start items-start gap-1 flex">
              <div
                style={{ color: colors['text-primary'] }}
                className="text-lg font-semibold leading-7"
              >
                Edit a Flow
              </div>
              <div
                style={{ color: colors['text-secondary'] }}
                className="text-sm font-normal leading-tight"
              >
                Edit your Flow's details
              </div>
            </div>
          </div>

          <div
            className="self-stretch px-6 pt-6 flex-col justify-start items-start gap-5 flex"
            style={{ zIndex: 0 }}
          >
            {/* Process name with icon */}
            <div className="self-stretch flex-col justify-start items-start gap-3 flex">
              <div className="justify-start items-start gap-0.5 inline-flex">
                <div
                  style={{ color: colors['input-label'] }}
                  className="text-sm font-semibold leading-tight"
                >
                  Flow name{' '}
                  <span style={{ color: colors['text-accent'] }}>*</span>
                </div>
              </div>
              <div className="flex items-center gap-2 w-full">
                <div style={{ zIndex: 30 }}>
                  <IconModifier
                    initialIcon={previewIcon || undefined}
                    onUpdate={(icon, emote, signedIcon, file) => {
                      setFlowIcon(icon || null);
                      setPreviewIcon(signedIcon ? signedIcon : icon || null);
                      setPreviewFile(file || null);
                    }}
                    allowEmoji={false}
                    flow={true}
                  />
                </div>
                <div style={{ zIndex: 0 }} className="flex-1">
                  <InputField
                    type="default"
                    value={processName}
                    onChange={setProcessName}
                    placeholder="Onboarding process"
                    required
                  />
                </div>
              </div>
            </div>

            {/* Process Owner and Review Date row */}
            <div className="w-full flex gap-4">
              <div className="flex-1">
                <InputField
                  label="Flow owner"
                  type="default"
                  value={processOwner}
                  onChange={setProcessOwner}
                  placeholder="Enter owner name"
                />
              </div>
              <div className="flex-1">
                <DatePicker
                  label="Review Date"
                  value={review_date}
                  onChange={setreview_date}
                  placeholder="Pick a date"
                />
              </div>
            </div>

            {/* Why does this process exist? */}
            <div className="w-full">
              <TextAreaInput
                label="Why does this Flow exist?"
                value={description}
                onChange={setdescription}
                placeholder="Enter a description..."
              />
            </div>

            {/* How do we complete this process? */}
            <div className="w-full">
              <TextAreaInput
                label="Additional notes"
                value={additionalNotes}
                onChange={setAdditionalNotes}
                placeholder="Enter a description..."
              />
            </div>
          </div>

          <div
            style={{ borderColor: colors['border-secondary'] }}
            className="self-stretch py-6 mt-6 border-t flex-col justify-start items-start flex"
          >
            <div className="self-stretch px-6 justify-start items-start gap-3 inline-flex">
              <ButtonNormal
                variant="secondary"
                size="small"
                onClick={onClose}
                className="flex-1"
              >
                Discard changes
              </ButtonNormal>
              <ButtonNormal
                variant="primary"
                size="small"
                isLoading={isSaving}
                loadingText="Saving changes..."
                onClick={handleSave}
                className="flex-1"
                disabled={!processName.trim() || isSaving}
              >
                Save changes
              </ButtonNormal>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/dashboard/components/EditFolderModal.tsx">
'use client';

import React, { useState } from 'react';
import IconModifier from './IconModifier';
import { Folder } from '@/types/workspace';
import ButtonNormal from '@/app/components/ButtonNormal';
import InputField from '@/app/components/InputFields';
import { useColors } from '@/app/theme/hooks';
import Modal from '@/app/components/Modal';
import { checkFolderName } from '@/app/utils/checkNames';
import { toast } from 'sonner';
import DOMPurify from 'dompurify';

interface EditFolderModalProps {
  onClose: () => void;
  onEdit: (
    folderName: string,
    icon_url?: string,
    emote?: string,
    signedIconUrl?: string
  ) => Promise<void>;
  initialIcon?: string;
  folder: Folder;
}

const EditFolderModal: React.FC<EditFolderModalProps> = ({
  onClose,
  onEdit,
  folder,
}) => {
  const colors = useColors();
  const [folderName, setFolderName] = useState(folder.name);
  const [iconUrl, setIconUrl] = useState<string | undefined>(
    folder.icon_url || undefined
  );
  const [previewIcon, setPreviewIcon] = useState<string | undefined>(
    folder.icon_url && folder.icon_url.startsWith('https://cdn.brandfetch.io/')
      ? folder.icon_url
      : folder.signedIconUrl || undefined
  );
  const [emote, setEmote] = useState<string | undefined>(folder.emote);
  const [previewFile, setPreviewFile] = useState<File | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const updateIcon = (
    icon?: string,
    emote?: string,
    signedIcon?: string,
    file?: File
  ) => {
    if (icon) {
      setIconUrl(icon);
      setEmote(undefined);
      setPreviewIcon(signedIcon ? signedIcon : icon || undefined);
      setPreviewFile(file || null);
    } else if (emote) {
      setIconUrl(undefined);
      setEmote(emote);
      setPreviewIcon(undefined);
      setPreviewFile(null);
    } else {
      setIconUrl(undefined);
      setEmote(undefined);
      setPreviewIcon(undefined);
      setPreviewFile(null);
    }
  };


  // Define modal actions
  const modalActions = (
    <>
      <ButtonNormal
        variant="secondary"
        size="small"
        onClick={onClose}
        className="flex-1"
        disabled={isSubmitting}
      >
        Discard changes
      </ButtonNormal>
      <ButtonNormal
        variant="primary"
        size="small"
        onClick={async () => {
          if (!folderName.trim()) return;
          const nameError = checkFolderName(folderName);
          if (nameError) {
            toast.error(nameError.title, {
              description: nameError.description,
            });
            return;
          }
          setIsSubmitting(true);
          let uploadedIconUrl = iconUrl;
          let uploadedSignedIcon = previewIcon;
          if (previewFile) {
            try {
              const formData = new FormData();
              formData.append('file', previewFile);
              const response = await fetch('/api/upload-icon', {
                method: 'POST',
                body: formData,
              });
              const data = await response.json();
              if (!response.ok || !data.success)
                throw new Error(data.error || 'Upload failed');
              uploadedIconUrl = data.data.iconUrl;
              uploadedSignedIcon = data.data.publicUrl || uploadedIconUrl;
            } catch (error) {
              console.error('Error uploading icon:', error);
              setIsSubmitting(false);
              return;
            }
          }
          try {
            if (uploadedIconUrl)
              await onEdit(
                folderName,
                uploadedIconUrl,
                undefined,
                uploadedSignedIcon
              );
            else if (emote) await onEdit(folderName, undefined, emote);
            else await onEdit(folderName);
            onClose();
          } catch (error) {
            console.error('Error editing folder:', error);
            toast.error('Error Saving Folder', {
              description:
                'An unexpected error occurred while saving the folder.',
            });
          } finally {
            setIsSubmitting(false);
          }
        }}
        disabled={!folderName.trim() || isSubmitting}
        className="flex-1"
      >
        {isSubmitting ? 'Saving...' : 'Save changes'}
      </ButtonNormal>
    </>
  );

  // Folder icon for this modal
  const folderIcon = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon.svg`;

  return (
    <Modal
      onClose={onClose}
      title="Edit a folder"
      icon={folderIcon}
      iconBackgroundColor={colors['bg-secondary']}
      actions={modalActions}
      showActionsSeparator={true}
    >
      <div className="flex flex-col gap-4">
        {/* Input Field */}
        <div>
          <label
            className="block text-sm font-semibold mb-2"
            style={{ color: colors['text-primary'] }}
          >
            Folder name <span style={{ color: colors['text-accent'] }}>*</span>
          </label>
          <div className="flex items-center gap-2">
            <IconModifier
              initialIcon={previewIcon || undefined}
              onUpdate={updateIcon}
              emote={emote}
            />
            <InputField
              type="default"
              value={folderName}
              onChange={setFolderName}
              placeholder="Enter folder name"
            />
          </div>
        </div>
      </div>
    </Modal>
  );
};

export default EditFolderModal;
</file>

<file path="app/dashboard/components/IconModifier.tsx">
import React, { useState, useRef, useEffect, useCallback } from 'react';
import IconSelector from './IconSelector';
import { useColors } from '@/app/theme/hooks';
import ReactDOM from 'react-dom';
import { fetchSignedUrl } from '@/utils/supabase/fetch_url';
import {
  fetchIconsBatch,
  preloadCriticalIcons,
} from '@/utils/optimizedIconFetch';

interface Entity {
  basicUrl: string;
  signedUrl: string;
}

interface IconModifierProps {
  initialIcon?: string; // Optional initial icon
  emote?: string;
  onUpdate: (
    icon?: string,
    emote?: string,
    signedIcon?: string,
    file?: File
  ) => void; // Callback when an icon is updated
  allowEmoji?: boolean; // Add this prop
  flow?: boolean;
}

export default function IconModifier({
  initialIcon,
  onUpdate,
  emote,
  allowEmoji = true, // Default to true
  flow = false,
}: IconModifierProps) {
  const colors = useColors();
  const [showSelector, setShowSelector] = useState(false);
  const [selectorPosition, setSelectorPosition] = useState<{
    top: number;
    left: number;
  } | null>(null);
  const iconButtonRef = useRef<HTMLDivElement>(null);
  const [iconUrl, setIconUrl] = useState<string | undefined>(initialIcon);
  const [applist, setAppList] = useState<Entity[]>([]);
  const [iconlist, setIconList] = useState<Entity[]>([]);

  // Calculate and set the position for the IconSelector
  useEffect(() => {
    if (showSelector && iconButtonRef.current) {
      const rect = iconButtonRef.current.getBoundingClientRect();
      // Place the selector below the icon button, with a small gap
      setSelectorPosition({
        top: rect.bottom + 8,
        left: rect.left,
      });
    }
  }, [showSelector]);

  // Only close selector on Escape key
  useEffect(() => {
    if (!showSelector) return;
    const handleKey = (e: KeyboardEvent) => {
      if (e.key === 'Escape') setShowSelector(false);
    };
    document.addEventListener('keydown', handleKey);
    return () => document.removeEventListener('keydown', handleKey);
  }, [showSelector]);

  useEffect(() => {
    setIconUrl(initialIcon);
  }, [initialIcon]);

  // Fetch icons and signed URLs with optimized batch loading
  useEffect(() => {
    const fetchIcons = async () => {
      try {
        const response = await fetch('/api/step-icons');
        if (!response.ok) throw new Error('Failed to fetch icons');
        const data = await response.json();

        // Use optimized batch fetching with caching and fallback
        const { applistResult, iconlistResult } = await fetchIconsBatch(
          data.applist,
          data.iconlist
        );

        // Convert to Entity format
        const appEntities: Entity[] = applistResult.map((item) => ({
          basicUrl: item.basicUrl,
          signedUrl: item.signedUrl,
        }));

        const iconEntities: Entity[] = iconlistResult.map((item) => ({
          basicUrl: item.basicUrl,
          signedUrl: item.signedUrl,
        }));

        setAppList(appEntities);
        setIconList(iconEntities);

        // Preload critical icons for better perceived performance
        const criticalIconUrls = [
          ...appEntities.slice(0, 10).map((item) => item.signedUrl),
          ...iconEntities.slice(0, 10).map((item) => item.signedUrl),
        ].filter((url) => url);

        if (criticalIconUrls.length > 0) {
          preloadCriticalIcons(criticalIconUrls, 20);
        }
      } catch (error) {
        console.error('Error fetching icons:', error);

        // Fallback to old method if new approach fails completely
        try {
          const response = await fetch('/api/step-icons');
          if (!response.ok) throw new Error('Failed to fetch icons');
          const data = await response.json();

          // Set initial lists with empty signedUrl
          const applistResult: Entity[] = data.applist.map((app: string) => ({
            basicUrl: `step-icons/apps/${app}`,
            signedUrl: '',
          }));
          const iconlistResult: Entity[] = data.iconlist.map(
            (icon: string) => ({
              basicUrl: `step-icons/default-icons/${icon}`,
              signedUrl: '',
            })
          );

          setAppList(applistResult);
          setIconList(iconlistResult);

          // Fetch signed URLs individually as fallback
          data.applist.forEach(async (app: string, idx: number) => {
            const basicUrl = `step-icons/apps/${app}`;
            const signedUrl = await fetchSignedUrl(basicUrl);
            setAppList((prev) =>
              prev.map((item, i) =>
                i === idx ? { ...item, signedUrl: signedUrl || '' } : item
              )
            );
          });

          data.iconlist.forEach(async (icon: string, idx: number) => {
            const basicUrl = `step-icons/default-icons/${icon}`;
            const signedUrl = await fetchSignedUrl(basicUrl);
            setIconList((prev) =>
              prev.map((item, i) =>
                i === idx ? { ...item, signedUrl: signedUrl || '' } : item
              )
            );
          });
        } catch (fallbackError) {
          console.error('Fallback icon fetching also failed:', fallbackError);
        }
      }
    };

    fetchIcons();
  }, []);

  const handleIconSelect = (
    icon?: string,
    emote?: string,
    signedIcon?: string,
    file?: File
  ) => {
    onUpdate(icon, emote, signedIcon, file);
    setShowSelector(false);
  };

  // The icon button
  const iconButton = (
    <div
      ref={iconButtonRef}
      className="p-2 rounded-md shadow-inner flex justify-center items-center w-10 cursor-pointer transition-colors duration-200"
      style={{
        backgroundColor: colors['bg-primary'],
        borderWidth: '1px',
        borderStyle: 'solid',
        borderColor: colors['border-secondary'],
      }}
      onClick={() => setShowSelector((v) => !v)}
    >
      {iconUrl && !emote ? (
        <img
          src={iconUrl}
          alt="Selected Icon"
          className="w-6 h-6 select-none pointer-events-none"
          referrerPolicy="strict-origin-when-cross-origin"
        />
      ) : emote ? (
        <div className="w-6 h-6 flex items-center justify-center">{emote}</div>
      ) : (
        <div className="w-6 h-6 flex justify-center items-center">
          <img
            src={`${
              flow
                ? `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`
                : `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon-base.svg`
            }`}
            alt="Default Icon"
            className="w-6 h-6 select-none pointer-events-none"
          />
        </div>
      )}
    </div>
  );

  // Only render the selector, no backdrop
  const selectorPortal =
    showSelector && selectorPosition
      ? ReactDOM.createPortal(
          <>
            {/* Backdrop to capture outside clicks */}
            <div
              className="fixed inset-0 z-[9999]"
              onClick={() => setShowSelector(false)}
            />
            <div
              className="fixed z-[10000]"
              style={{
                top: selectorPosition.top,
                left: selectorPosition.left,
              }}
            >
              <IconSelector
                onSelect={handleIconSelect}
                allowEmoji={allowEmoji}
                applist={applist}
                iconlist={iconlist}
              />
            </div>
          </>,
          document.body
        )
      : null;

  return (
    <>
      {iconButton}
      {selectorPortal}
    </>
  );
}
</file>

<file path="app/dashboard/components/IconSelector.tsx">
import React, { useEffect, useState, useCallback } from 'react';
import { useColors } from '@/app/theme/hooks';
import Tooltip from '@/app/components/Tooltip';
import OptimizedIcon from '@/app/components/OptimizedIcon';
import { fetchSignedUrl } from '@/utils/supabase/fetch_url';

const BRANDFETCH_TIMEOUT = 10000; // 10 seconds timeout
const ACCEPTED_FILE_TYPES = 'image/png,image/jpeg,image/svg+xml';
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

interface Entity {
  basicUrl: string;
  signedUrl: string;
}

interface IconSelectorProps {
  onSelect: (
    previewUrl?: string,
    emote?: string,
    signedIcon?: string,
    file?: File
  ) => void;
  allowEmoji?: boolean;
  applist: Entity[];
  iconlist: Entity[];
}

const IconSelector: React.FC<IconSelectorProps> = ({
  onSelect,
  allowEmoji = true,
  applist,
  iconlist,
}) => {
  const colors = useColors();
  const [searchTerm, setSearchTerm] = useState<string>('');
  const [activeTab, setActiveTab] = useState<string>('Icons');
  const [hoveredButton, setHoveredButton] = useState<string | null>(null);
  const [uploadError, setUploadError] = useState<string>('');
  const [isUploading, setIsUploading] = useState(false);
  const [emojiList] = useState<string[]>([
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
  ]);

  // Add state for BrandFetch preview loading
  const [brandFetchLoading, setBrandFetchLoading] = useState(false);
  const [brandFetchUrl, setBrandFetchUrl] = useState<string | null>(null);
  const [brandFetchError, setBrandFetchError] = useState(false);

  const [hoveredIcon, setHoveredIcon] = useState<{
    name: string;
    type: string;
  } | null>(null);

  const TABS = allowEmoji
    ? ['Icons', 'Apps', 'Upload', 'Emoji']
    : ['Icons', 'Apps', 'Upload'];

  const handleFileUpload = useCallback(
    async (file: File) => {
      if (!file.type.match(ACCEPTED_FILE_TYPES.replace(/,/g, '|'))) {
        setUploadError(
          'Invalid file type. Please upload PNG, JPEG, or SVG files.'
        );
        return;
      }

      if (file.size > MAX_FILE_SIZE) {
        setUploadError('File size exceeds 5MB limit.');
        return;
      }

      setIsUploading(true);
      setUploadError('');

      try {
        const previewUrl = URL.createObjectURL(file);
        onSelect(previewUrl, undefined, undefined, file);
      } catch (error) {
        console.error('Upload error:', error);
        setUploadError(
          error instanceof Error
            ? error.message
            : 'Failed to upload file. Please try again.'
        );
      } finally {
        setIsUploading(false);
      }
    },
    [onSelect]
  );

  // Update effect for BrandFetch search
  useEffect(() => {
    const fetchBrandIcon = async () => {
      if (
        !searchTerm ||
        applist.some((app) =>
          app.basicUrl.toLowerCase().includes(searchTerm.toLowerCase())
        )
      ) {
        setBrandFetchUrl(null);
        return;
      }

      setBrandFetchLoading(true);
      setBrandFetchError(false);
      setBrandFetchUrl(null);

      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(
          () => controller.abort(),
          BRANDFETCH_TIMEOUT
        );

        const response = await fetch(
          `/api/logo-search?q=${encodeURIComponent(searchTerm)}`,
          {
            signal: controller.signal,
          }
        );

        clearTimeout(timeoutId);

        if (!response.ok) throw new Error('Failed to fetch brand icon');
        const data = await response.json();

        if (data.icon) {
          setBrandFetchUrl(data.icon);
        } else {
          setBrandFetchError(true);
        }
      } catch (error) {
        setBrandFetchError(true);
      } finally {
        setBrandFetchLoading(false);
      }
    };

    const debounceTimer = setTimeout(fetchBrandIcon, 500);
    return () => clearTimeout(debounceTimer);
  }, [searchTerm, applist]);

  return (
    <div
      className="w-[502px] h-[328px] rounded-xl flex flex-col overflow-hidden shadow-lg"
      style={{
        backgroundColor: colors['bg-primary'],
        borderWidth: '1px',
        borderStyle: 'solid',
        borderColor: colors['border-secondary'],
      }}
    >
      {/* Tabs */}
      <div
        className="self-stretch flex justify-between items-center"
        style={{
          borderBottomWidth: '1px',
          borderBottomStyle: 'solid',
          borderBottomColor: colors['border-secondary'],
        }}
      >
        <div className="flex gap-3 pt-3 px-3">
          {TABS.map((tab) => (
            <div
              key={tab}
              className={`px-2 pb-3 cursor-pointer transition-colors duration-200 ${
                activeTab === tab ? 'border-b-2 font-medium' : ''
              }`}
              style={{
                color:
                  activeTab === tab
                    ? colors['text-brand-secondary']
                    : colors['text-secondary'],
                borderBottomColor:
                  activeTab === tab ? colors['bg-brand-solid'] : 'transparent',
              }}
              onClick={() => setActiveTab(tab)}
            >
              {tab}
            </div>
          ))}
        </div>
        <div
          className="px-4 cursor-pointer transition-colors duration-200"
          style={{ color: colors['text-secondary'] }}
          onClick={() => onSelect()}
        >
          Reset
        </div>
      </div>

      {/* Search Bar */}
      <div
        className="self-stretch px-4 py-3 flex flex-col gap-2"
        style={{
          backgroundColor: colors['bg-primary'],
          borderBottomWidth: '1px',
          borderBottomStyle: 'solid',
          borderBottomColor: colors['border-secondary'],
          display: activeTab === 'Upload' ? 'none' : 'flex',
        }}
      >
        <div className="flex items-center gap-2">
          <img
            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/search-lg-icon.svg`}
            alt="Search icon"
            className="w-4 h-4 select-none pointer-events-none"
          />
          <input
            type="text"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            placeholder="Search..."
            className="flex-grow text-sm bg-transparent focus:outline-none placeholder:text-secondary"
            style={{ color: colors['text-primary'] }}
          />
        </div>
        {activeTab === 'Apps' && (
          <div
            className="flex items-start gap-2 mt-1 px-3 py-2 rounded-md text-xs"
            style={{
              backgroundColor: colors['bg-quaternary'],
              color: colors['text-secondary'],
              borderLeft: `3px solid ${colors['border-brand_alt']}`,
            }}
          >
            <svg
              className="w-4 h-4 mt-0.5 flex-shrink-0"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              viewBox="0 0 24 24"
            >
              <circle
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                strokeWidth="2"
                fill="none"
              />
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M12 16v-4m0-4h.01"
              />
            </svg>
            <span>
              You can search for any company logo by typing a domain (e.g.,{' '}
              <span className="font-semibold">google.com</span>) or brand name.
              If not found, we'll fetch it.
            </span>
          </div>
        )}
      </div>

      {/* Content */}
      <div
        className="self-stretch h-60 flex flex-col overflow-y-auto p-3"
        style={{ backgroundColor: colors['bg-primary'] }}
      >
        {activeTab === 'Apps' && (
          <div className="grid grid-cols-12 gap-3">
            {applist
              .filter((app) =>
                app.basicUrl.toLowerCase().includes(searchTerm.toLowerCase())
              )
              .map((app, index) => (
                <button
                  key={index}
                  onClick={() => {
                    if (!app.signedUrl) return;
                    onSelect(app.basicUrl, undefined, app.signedUrl);
                  }}
                  className="w-10 h-10 rounded-md flex items-center justify-center transition-colors duration-200 relative"
                  style={{
                    backgroundColor:
                      hoveredButton === `app-${index}`
                        ? colors['bg-quaternary']
                        : 'transparent',
                  }}
                  onMouseEnter={() => {
                    setHoveredButton(`app-${index}`);
                    setHoveredIcon({
                      name: app.basicUrl.split('/').pop()?.split('.')[0] || '',
                      type: 'App',
                    });
                  }}
                  onMouseLeave={() => {
                    setHoveredButton(null);
                    setHoveredIcon(null);
                  }}
                >
                  <OptimizedIcon
                    src={app.signedUrl}
                    alt={app.basicUrl}
                    loading="eager"
                  />
                  <Tooltip
                    text={hoveredIcon?.name || ''}
                    visible={
                      hoveredIcon?.type === 'App' &&
                      hoveredButton === `app-${index}`
                    }
                  />
                </button>
              ))}
            {/* BrandFetch integration in Apps tab */}
            {searchTerm &&
              applist.filter((app) =>
                app.basicUrl.toLowerCase().includes(searchTerm.toLowerCase())
              ).length === 0 && (
                <button
                  className="w-10 h-10 rounded-md flex items-center justify-center transition-colors duration-200 relative"
                  style={{
                    backgroundColor:
                      hoveredButton === 'apps-brandfetch'
                        ? colors['bg-quaternary']
                        : 'transparent',
                  }}
                  onClick={() => brandFetchUrl && onSelect(brandFetchUrl)}
                  onMouseEnter={() => setHoveredButton('apps-brandfetch')}
                  onMouseLeave={() => setHoveredButton(null)}
                  disabled={!brandFetchUrl || brandFetchError}
                >
                  {brandFetchLoading && (
                    <svg
                      className="animate-spin w-6 h-6"
                      viewBox="0 0 24 24"
                      fill="none"
                      style={{ color: colors['border-brand_alt'] }}
                    >
                      <circle
                        className="opacity-25"
                        cx="12"
                        cy="12"
                        r="10"
                        stroke="currentColor"
                        strokeWidth="4"
                      />
                      <path
                        className="opacity-75"
                        fill="currentColor"
                        d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"
                      />
                    </svg>
                  )}
                  {brandFetchUrl && !brandFetchLoading && (
                    <img
                      src={brandFetchUrl}
                      alt={`Logo for ${searchTerm}`}
                      className="w-6 h-6 object-contain select-none pointer-events-none"
                      referrerPolicy="strict-origin-when-cross-origin"
                      onError={() => setBrandFetchError(true)}
                    />
                  )}
                  {brandFetchError && !brandFetchLoading && (
                    <svg
                      className="w-6 h-6"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                      style={{ color: colors['text-error'] }}
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
                      />
                    </svg>
                  )}
                </button>
              )}
          </div>
        )}

        {activeTab === 'Icons' && (
          <div className="grid grid-cols-12 gap-3">
            {iconlist
              .filter((icon) =>
                icon.basicUrl.toLowerCase().includes(searchTerm.toLowerCase())
              )
              .map((icon, index) => (
                <button
                  key={index}
                  onClick={() => {
                    if (!icon.signedUrl) return;
                    onSelect(icon.basicUrl, undefined, icon.signedUrl);
                  }}
                  className="w-10 h-10 rounded-md flex items-center justify-center transition-colors duration-200 relative"
                  style={{
                    backgroundColor:
                      hoveredButton === `icon-${index}`
                        ? colors['bg-quaternary']
                        : 'transparent',
                  }}
                  onMouseEnter={() => {
                    setHoveredButton(`icon-${index}`);
                    setHoveredIcon({
                      name: icon.basicUrl.split('/').pop()?.split('.')[0] || '',
                      type: 'Icon',
                    });
                  }}
                  onMouseLeave={() => {
                    setHoveredButton(null);
                    setHoveredIcon(null);
                  }}
                >
                  <OptimizedIcon
                    src={icon.signedUrl}
                    alt={icon.basicUrl}
                    loading="eager"
                  />
                  <Tooltip
                    text={hoveredIcon?.name || ''}
                    visible={
                      hoveredIcon?.type === 'Icon' &&
                      hoveredButton === `icon-${index}`
                    }
                  />
                </button>
              ))}
          </div>
        )}

        {activeTab === 'Upload' && (
          <div className="flex flex-col items-center justify-center h-full gap-4 px-6">
            <div
              className={`w-full p-5 border border-dashed rounded-lg flex flex-col items-center gap-3 transition-colors duration-200 cursor-pointer ${
                isUploading
                  ? 'opacity-50 cursor-not-allowed'
                  : 'hover:border-brand-secondary'
              }`}
              style={{ borderColor: colors['border-secondary'] }}
              onDragOver={(e) => {
                e.preventDefault();
                e.stopPropagation();
              }}
              onDrop={(e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!isUploading && e.dataTransfer.files?.[0]) {
                  handleFileUpload(e.dataTransfer.files[0]);
                }
              }}
              onClick={() => {
                if (!isUploading) {
                  const input = document.createElement('input');
                  input.type = 'file';
                  input.accept = ACCEPTED_FILE_TYPES;
                  input.onchange = (e) => {
                    const file = (e.target as HTMLInputElement).files?.[0];
                    if (file) handleFileUpload(file);
                  };
                  input.click();
                }
              }}
            >
              {isUploading ? (
                <div className="flex flex-col items-center gap-2">
                  <svg
                    className="animate-spin w-6 h-6"
                    viewBox="0 0 24 24"
                    fill="none"
                    style={{ color: colors['border-brand_alt'] }}
                  >
                    <circle
                      className="opacity-25"
                      cx="12"
                      cy="12"
                      r="10"
                      stroke="currentColor"
                      strokeWidth="4"
                    />
                    <path
                      className="opacity-75"
                      fill="currentColor"
                      d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"
                    />
                  </svg>
                  <span style={{ color: colors['text-secondary'] }}>
                    Uploading...
                  </span>
                </div>
              ) : (
                <>
                  <div
                    className="w-12 h-12 rounded-lg flex items-center justify-center"
                    style={{
                      backgroundColor: colors['bg-primary'],
                      boxShadow:
                        '0px 1px 2px 0px rgba(16, 24, 40, 0.05), inset 0px -2px 0px 0px rgba(16, 24, 40, 0.05), inset 0px 0px 0px 1px rgba(16, 24, 40, 0.18)',
                    }}
                  >
                    <img
                      src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/upload-cloud-02.svg`}
                      alt="Upload icon"
                      className="w-6 h-6 select-none pointer-events-none"
                    />
                  </div>
                  <div className="flex flex-col items-center gap-1">
                    <div className="flex items-center gap-1">
                      <span
                        className="text-sm font-semibold"
                        style={{ color: colors['text-brand-secondary'] }}
                      >
                        Click to upload
                      </span>
                      <span
                        className="text-sm"
                        style={{ color: colors['text-secondary'] }}
                      >
                        or drag and drop
                      </span>
                    </div>
                    <p
                      className="text-xs text-center"
                      style={{ color: colors['text-secondary'] }}
                    >
                      SVG, PNG, JPG
                    </p>
                  </div>
                </>
              )}
            </div>
            {uploadError && (
              <div
                className="text-sm px-4 py-2 rounded-md"
                style={{
                  backgroundColor: colors['bg-error'],
                  color: colors['text-error'],
                }}
              >
                {uploadError}
              </div>
            )}
          </div>
        )}

        {activeTab === 'Emoji' && (
          <div className="grid grid-cols-12 gap-3 text-xl">
            {emojiList.map((emoji, index) => (
              <button
                key={index}
                onClick={() => onSelect(undefined, emoji)}
                className="w-10 h-10 flex items-center justify-center rounded-md transition-colors duration-200 relative"
                style={{
                  backgroundColor:
                    hoveredButton === `emoji-${index}`
                      ? colors['bg-quaternary']
                      : 'transparent',
                }}
                onMouseEnter={() => {
                  setHoveredButton(`emoji-${index}`);
                  setHoveredIcon({
                    name: `Emoji ${emoji}`,
                    type: 'Emoji',
                  });
                }}
                onMouseLeave={() => {
                  setHoveredButton(null);
                  setHoveredIcon(null);
                }}
              >
                {emoji}
                <Tooltip
                  text={hoveredIcon?.name || ''}
                  visible={
                    hoveredIcon?.type === 'Emoji' &&
                    hoveredButton === `emoji-${index}`
                  }
                />
              </button>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default IconSelector;
</file>

<file path="app/dashboard/components/SettingsPage.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { User } from '@/types/user';
import ButtonNormal from '@/app/components/ButtonNormal';
import WorkspaceSettings from './WorkspaceSettings';
import { Workspace } from '@/types/workspace';
import { useColors, useTheme } from '@/app/theme/hooks';
import type { ThemeMode } from '@/app/theme/types';
import CheckoutButton from '@/app/components/CheckoutButton';
import { WorkspaceProvider } from '@/hooks/useWorkspace';
import { useSearchParams } from 'next/navigation';
import { toast } from 'sonner';
import { STRIPE_PRICE_IDS } from '@/lib/stripe';
import Modal from '@/app/components/Modal';
import BillingInfoForm from './BillingInfoForm';
import useSWR from 'swr';

const fetcher = (url: string) => fetch(url).then((res) => res.json());

interface SettingsPageProps {
  user: User | null;
  onClose: () => void;
  workspace?: Workspace;
  onWorkspaceUpdate?: (updates: Partial<Workspace>) => Promise<boolean>;
  onWorkspaceDelete?: (workspaceId: number) => Promise<void>;
  initialTab?: string;
}

export default function SettingsPage({
  user,
  onClose,
  workspace,
  onWorkspaceUpdate,
  onWorkspaceDelete,
  initialTab,
}: SettingsPageProps) {
  const colors = useColors();
  const { currentTheme, setTheme } = useTheme();
  const tabs = ['Workspace', 'Plan', 'Billing', 'Appearance'];
  const defaultTab = 'Workspace';

  // Initialize activeTab based on initialTab or defaultTab
  const [activeTab, setActiveTab] = useState(
    initialTab && tabs.includes(initialTab) ? initialTab : defaultTab
  );

  const [billingPeriod, setBillingPeriod] = useState<'monthly' | 'annual'>(
    'monthly'
  );
  const [currentPlan, setCurrentPlan] = useState<'free' | 'earlyAdopter'>(
    'free'
  );
  const [isLoadingPlan, setIsLoadingPlan] = useState(true);
  const [subscriptionStatus, setSubscriptionStatus] = useState<string | null>(
    null
  );
  const [subscriptionEnd, setSubscriptionEnd] = useState<Date | null>(null);
  const [nextPaymentAmount, setNextPaymentAmount] = useState<number | null>(
    null
  );
  const [showDowngradeConfirmation, setShowDowngradeConfirmation] =
    useState(false);
  const [isUpdatingBillingPeriod, setIsUpdatingBillingPeriod] = useState(false);
  const searchParams = useSearchParams();
  const [currentBillingType, setCurrentBillingType] = useState<
    'monthly' | 'annual' | null
  >(null);

  // State for plan change confirmation modal
  const [showPlanChangeConfirmation, setShowPlanChangeConfirmation] =
    useState(false);
  const [pendingBillingPeriod, setPendingBillingPeriod] = useState<
    'monthly' | 'annual' | null
  >(null);

  const {
    data: subscriptionData,
    error: subscriptionError,
    mutate: mutateSubscription,
  } = useSWR<{
    plan_type: string;
    status: string;
    current_period_end: string | null;
    price_id: string | null;
    next_payment_amount: number | null;
    users: Array<{ id: number; email: string }>;
  }>(`/api/subscription?workspaceId=${workspace?.id}`, fetcher, {
    revalidateOnFocus: false,
    revalidateOnReconnect: false,
  });

  const { data: invoicesData, error: invoicesError } = useSWR<{
    invoices: Array<{
      id: string;
      number: string;
      created: number;
      status: string;
      amount: number;
      currency: string;
      pdfUrl: string;
      hostedUrl: string;
      plan: string;
    }>;
  }>(
    workspace?.id ? `/api/invoices?workspaceId=${workspace.id}` : null,
    fetcher,
    {
      revalidateOnFocus: false,
      revalidateOnReconnect: false,
    }
  );

  const fetchSubscription = async () => {
    if (!workspace) return;

    try {
      setIsLoadingPlan(true);
      const res = await fetch(`/api/subscription?workspaceId=${workspace.id}`);

      if (!res.ok) {
        const errorData = await res.json();
        console.error('Subscription API error:', {
          status: res.status,
          error: errorData.error || 'Unknown error',
          workspaceId: workspace.id,
        });
        setCurrentPlan('free');
        return false;
      }

      const data = await res.json();

      if (data.error) {
        console.error('Subscription data error:', data.error);
        setCurrentPlan('free');
        return false;
      }

      // Map the plan_type from database to our UI plan types
      const planMap: { [key: string]: 'free' | 'earlyAdopter' } = {
        FREE: 'free',
        EARLY_ADOPTER: 'earlyAdopter',
      };

      setCurrentPlan(planMap[data.plan_type] || 'free');
      setSubscriptionStatus(data.status);
      setSubscriptionEnd(
        data.current_period_end ? new Date(data.current_period_end) : null
      );
      setNextPaymentAmount(data.next_payment_amount || null);

      // Set the billing period based on the subscription price ID
      if (data.price_id) {
        // Check if the price ID matches annual or monthly
        if (
          data.price_id === STRIPE_PRICE_IDS.EARLY_ADOPTER.ANNUAL ||
          data.price_id ===
            process.env.NEXT_PUBLIC_STRIPE_EARLY_ADOPTER_ANNUAL_PRICE_ID
        ) {
          setBillingPeriod('annual');
          setCurrentBillingType('annual');
        } else {
          setBillingPeriod('monthly');
          setCurrentBillingType('monthly');
        }
      } else {
        // Default to monthly if no price ID is available
        setBillingPeriod('monthly');
        setCurrentBillingType(null);
      }

      // Return true if subscription is active
      return (
        data.plan_type === 'EARLY_ADOPTER' &&
        (data.status === 'ACTIVE' || data.status === 'TRIALING')
      );
    } catch (error) {
      console.error('Error fetching subscription:', error);
      setCurrentPlan('free');
      return false;
    } finally {
      setIsLoadingPlan(false);
    }
  };

  // Initial fetch on mount
  useEffect(() => {
    fetchSubscription();
  }, [workspace]);

  // Refetch when returning from checkout
  useEffect(() => {
    const checkoutStatus = searchParams ? searchParams.get('checkout') : null;
    const message = searchParams ? searchParams.get('message') : null;
    const error = searchParams ? searchParams.get('error') : null;
    const action = searchParams ? searchParams.get('action') : null;

    // Check for URL parameters or stored notification data
    const showNotification = () => {
      // First check localStorage for pending notifications
      const storedNotification =
        typeof window !== 'undefined'
          ? localStorage.getItem('checkoutNotification')
          : null;

      if (storedNotification) {
        try {
          const notification = JSON.parse(storedNotification);

          // Show the appropriate toast based on stored data
          if (notification.status === 'success') {
            if (notification.action === 'upgrade') {
              toast.success('Successfully Upgraded! ', {
                description:
                  'Your subscription has been upgraded to the Early Adopter plan. Enjoy all the premium features!',
                duration: 7000,
              });
            } else {
              toast.success('Subscription Activated', {
                description:
                  'Your Early Adopter subscription has been successfully activated.',
                duration: 5000,
              });
            }
          } else if (notification.status === 'failed') {
            toast.error('Checkout Failed', {
              description:
                notification.error ||
                'There was an issue processing your payment. Please try again.',
              duration: 0, // Keep until dismissed
            });
          }

          // Clear the stored notification after showing it
          localStorage.removeItem('checkoutNotification');
        } catch (e) {
          console.error('Error parsing stored notification:', e);
          localStorage.removeItem('checkoutNotification');
        }

        return true; // Notification was shown from localStorage
      }

      return false; // No stored notification was found
    };

    // Handle URL parameters and store notification if needed
    if (checkoutStatus) {
      fetchSubscription();

      // If we have URL parameters, store them before they're cleared
      if (checkoutStatus === 'success' || checkoutStatus === 'failed') {
        const notificationData = {
          status: checkoutStatus,
          action: action || null,
          error: error || null,
          timestamp: new Date().getTime(),
        };

        // Store in localStorage for persistence across reloads
        localStorage.setItem(
          'checkoutNotification',
          JSON.stringify(notificationData)
        );
      }

      // Clear the checkout parameters from URL to avoid unnecessary refetches
      const newUrl = new URL(window.location.href);
      newUrl.searchParams.delete('checkout');
      newUrl.searchParams.delete('message');
      newUrl.searchParams.delete('error');
      newUrl.searchParams.delete('action');
      window.history.replaceState({}, '', newUrl.toString());

      // Try to show notification now (if localStorage was already set)
      showNotification();
    } else {
      // No URL parameters, check if we have a stored notification
      showNotification();
    }
  }, [searchParams]);

  // Check for stored notifications on mount (for cases where the effect above doesn't run)
  useEffect(() => {
    const storedNotification =
      typeof window !== 'undefined'
        ? localStorage.getItem('checkoutNotification')
        : null;

    if (storedNotification) {
      try {
        const notification = JSON.parse(storedNotification);

        // Only show notifications that are less than 1 minute old
        // This prevents showing very old notifications after long periods
        const currentTime = new Date().getTime();
        const notificationTime = notification.timestamp || 0;

        if (currentTime - notificationTime < 60000) {
          // Show the appropriate toast based on stored data
          if (notification.status === 'success') {
            if (notification.action === 'upgrade') {
              toast.success('Successfully Upgraded! ', {
                description:
                  'Your subscription has been upgraded to the Early Adopter plan. Enjoy all the premium features!',
                duration: 7000,
              });
            } else {
              toast.success('Subscription Activated', {
                description:
                  'Your Early Adopter subscription has been successfully activated.',
                duration: 5000,
              });
            }
          } else if (notification.status === 'failed') {
            toast.error('Checkout Failed', {
              description:
                notification.error ||
                'There was an issue processing your payment. Please try again.',
              duration: 0, // Keep until dismissed
            });
          }
        }

        // Clear the stored notification after showing it
        localStorage.removeItem('checkoutNotification');
      } catch (e) {
        console.error('Error parsing stored notification:', e);
        localStorage.removeItem('checkoutNotification');
      }
    }
  }, []);

  // Ensure activeTab is always valid
  useEffect(() => {
    if (!tabs.includes(activeTab)) {
      setActiveTab(defaultTab);
    }
  }, [activeTab]);

  useEffect(() => {
    if (initialTab && tabs.includes(initialTab)) {
      setActiveTab(initialTab);
    }
  }, [initialTab]);

  const handleDowngradeClick = () => {
    setShowDowngradeConfirmation(true);
  };

  const handleConfirmDowngrade = async () => {
    if (!workspace) return;

    try {
      setIsLoadingPlan(true);

      // Call the API to cancel the subscription
      const response = await fetch('/api/subscription/cancel', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          workspaceId: workspace.id,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        toast.error('Failed to Downgrade', {
          description:
            data.details ||
            data.error ||
            'An error occurred while downgrading your plan',
          duration: 5000,
        });
        console.error('Error downgrading plan:', data);
        return;
      }

      // Update the UI to reflect the change
      setCurrentPlan('free');
      setSubscriptionStatus('CANCELED');

      // Show success toast
      toast.success('Successfully Downgraded', {
        description:
          'Your subscription has been canceled. You will continue to have access to Early Adopter features until the end of your billing period.',
        duration: 7000,
      });
    } catch (error) {
      console.error('Error downgrading to free plan:', error);
      toast.error('Failed to Downgrade', {
        description:
          'An unexpected error occurred. Please try again or contact support.',
        duration: 5000,
      });
    } finally {
      setIsLoadingPlan(false);
      setShowDowngradeConfirmation(false);
    }
  };

  // Function to update the subscription billing period
  const updateBillingPeriod = async (period: 'monthly' | 'annual') => {
    if (!workspace || currentPlan !== 'earlyAdopter') return;

    try {
      setIsUpdatingBillingPeriod(true);

      const response = await fetch('/api/subscription/update', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          workspaceId: workspace.id,
          billingPeriod: period,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(
          data.details || data.error || 'Failed to update subscription'
        );
      }

      // Update the billing period and subscription end date
      setBillingPeriod(period);
      setCurrentBillingType(period); // Update the current billing type

      if (data.current_period_end) {
        setSubscriptionEnd(new Date(data.current_period_end));
      }

      // Use the detailed message from the API
      const title = data.is_upgrade
        ? 'Upgraded to Annual Billing'
        : 'Switched to Monthly Billing';

      toast.success(title, {
        description:
          data.details ||
          `Your subscription has been updated to ${period} billing.`,
      });

      // Refresh subscription data
      fetchSubscription();

      return data;
    } catch (error) {
      console.error('Error updating billing period:', error);
      toast.error('Failed to Update Billing', {
        description:
          error instanceof Error
            ? error.message
            : 'An unexpected error occurred',
      });
      throw error;
    } finally {
      setIsUpdatingBillingPeriod(false);
    }
  };

  // Function to handle billing period toggle clicks - now only updates UI state
  const handleBillingPeriodChange = (period: 'monthly' | 'annual') => {
    // Simply update the UI state without changing subscription
    setBillingPeriod(period);
  };

  const handleTabClick = (tab: string) => {
    setActiveTab(tab);
  };

  // Plan pricing and structure
  const PLAN_DATA = {
    free: {
      name: 'Free. Forever.',
      price: '$0',
      features: [
        '5 conditional processes',
        'Edit mode',
        'Read mode',
        'Basic export and sharing',
      ],
    },
    earlyAdopter: {
      monthly: {
        price: '$15',
        period: 'per user/month billed monthly',
        priceId:
          process.env.NEXT_PUBLIC_STRIPE_EARLY_ADOPTER_MONTHLY_PRICE_ID || '',
      },
      annual: {
        price: '$12',
        period: 'per user/month billed annually',
        priceId:
          process.env.NEXT_PUBLIC_STRIPE_EARLY_ADOPTER_ANNUAL_PRICE_ID || '',
      },
      name: 'Early Adopter',
      features: [
        'All Free features +',
        'Unlimited conditional processes',
        'Early access to new features',
        'Branded processes & exports',
        'Priority support from the founders',
        'Remove ProcessFlow branding',
      ],
    },
  };

  // Function to determine the correct button text for the plan
  const getPlanButtonText = (
    planType: 'free' | 'earlyAdopter',
    currentBillingType: 'monthly' | 'annual' | null,
    selectedBillingPeriod: 'monthly' | 'annual'
  ): React.ReactNode => {
    // For the free plan, show simple upgrade text
    if (planType === 'free') {
      return `Upgrade to ${selectedBillingPeriod === 'annual' ? 'annual' : 'monthly'} plan`;
    }

    // For users already on the Early Adopter plan
    if (planType === 'earlyAdopter') {
      // If they've selected the same billing period they already have
      if (currentBillingType === selectedBillingPeriod) {
        return 'Current plan';
      }

      // If they're on monthly and want to switch to annual (upgrade)
      if (
        currentBillingType === 'monthly' &&
        selectedBillingPeriod === 'annual'
      ) {
        return (
          <div className="flex items-center gap-1">
            <span>Upgrade to annual billing</span>
            <span
              style={{
                backgroundColor: colors['bg-brand-primary'],
                color: colors['text-brand-primary'],
                borderColor: colors['border-brand'],
              }}
              className="text-xs px-2 py-0.5 rounded-full border"
            >
              Save 20%
            </span>
          </div>
        );
      }

      // If they're on annual and want to switch to monthly
      if (
        currentBillingType === 'annual' &&
        selectedBillingPeriod === 'monthly'
      ) {
        return 'Switch to monthly billing';
      }
    }

    // Default fallback text
    return 'Select plan';
  };

  // Function to handle plan button click
  const handlePlanButtonClick = async (planType: 'free' | 'earlyAdopter') => {
    // If they're not changing their current plan, do nothing
    if (
      planType === currentPlan &&
      subscriptionStatus === 'ACTIVE' &&
      ((currentBillingType === 'monthly' && billingPeriod === 'monthly') ||
        (currentBillingType === 'annual' && billingPeriod === 'annual'))
    ) {
      return;
    }

    // If they're on a free plan, we don't need to do anything special -
    // the regular checkout flow will handle it
    if (currentPlan === 'free') {
      return;
    }

    // If they're already on Early Adopter plan but want to change billing period
    if (
      currentPlan === 'earlyAdopter' &&
      subscriptionStatus === 'ACTIVE' &&
      currentBillingType !== billingPeriod
    ) {
      // Show confirmation modal instead of immediately updating
      setPendingBillingPeriod(billingPeriod);
      setShowPlanChangeConfirmation(true);
    }
  };

  // Function to confirm and actually process the plan change
  const confirmPlanChange = async () => {
    if (!pendingBillingPeriod) return;

    try {
      // Show appropriate message based on the change
      const isUpgrade = pendingBillingPeriod === 'annual';
      const toastTitle = isUpgrade
        ? 'Upgrading to Annual Billing'
        : 'Switching to Monthly Billing';

      toast.info(toastTitle, {
        description: 'Processing your request...',
      });

      // Update the subscription billing period
      const result = await updateBillingPeriod(pendingBillingPeriod);

      // Hide confirmation modal
      setShowPlanChangeConfirmation(false);
      setPendingBillingPeriod(null);

      // Success is handled in updateBillingPeriod function
    } catch (error) {
      // Error handling is done in updateBillingPeriod
      console.error('Error handling plan change confirmation:', error);

      // Hide confirmation modal even on error
      setShowPlanChangeConfirmation(false);
      setPendingBillingPeriod(null);
    }
  };

  return (
    <WorkspaceProvider value={{ workspace: workspace || null }}>
      <div
        style={{ backgroundColor: colors['bg-primary'] }}
        className="h-screen"
      >
        {/* Header */}
        <div className="px-8 py-6">
          <h1
            style={{ color: colors['text-primary'] }}
            className="text-2xl font-semibold"
          >
            Settings
          </h1>
        </div>

        {/* Tabs */}
        <div className="px-8 mb-6">
          <div
            style={{
              backgroundColor: colors['bg-secondary'],
              borderColor: colors['border-secondary'],
            }}
            className="inline-flex w-full p-1 rounded-lg border"
          >
            {tabs.map((tab) => (
              <button
                key={tab}
                onClick={() => handleTabClick(tab)}
                style={{
                  backgroundColor:
                    activeTab === tab ? colors['bg-primary'] : 'transparent',
                  borderColor:
                    activeTab === tab
                      ? colors['border-secondary']
                      : 'transparent',
                  color:
                    activeTab === tab
                      ? colors['text-primary']
                      : colors['text-quaternary'],
                }}
                className={`px-3 py-2 text-sm font-medium rounded-md transition-colors duration-200 border hover:text-[var(--text-primary)]`}
              >
                {tab}
              </button>
            ))}
          </div>
        </div>

        {/* Content */}
        <div className="h-[calc(100vh-210px)] overflow-y-auto pb-10">
          {activeTab === 'Workspace' && workspace && onWorkspaceUpdate && (
            <div className="px-8">
              <WorkspaceSettings
                workspace={workspace}
                onUpdate={onWorkspaceUpdate}
                onDelete={onWorkspaceDelete}
              />
            </div>
          )}
          {activeTab === 'Team' && (
            <div className="px-8">
              <div className="flex justify-between items-center mb-4">
                <div>
                  <h2
                    style={{ color: colors['text-primary'] }}
                    className="text-lg font-semibold"
                  >
                    Team members
                  </h2>
                  <p
                    style={{ color: colors['text-tertiary'] }}
                    className="text-sm"
                  >
                    Manage your team members and their account permissions here.
                  </p>
                </div>
                <div className="flex gap-3">
                  <ButtonNormal variant="secondary" size="small">
                    Download CSV
                  </ButtonNormal>
                  <ButtonNormal variant="primary" size="small">
                    Add user
                  </ButtonNormal>
                </div>
              </div>

              {/* Team members table */}
              <div
                style={{ borderColor: colors['border-secondary'] }}
                className="mt-6 border rounded-lg overflow-hidden"
              >
                {/* Table header */}
                <div
                  style={{
                    backgroundColor: colors['bg-secondary'],
                    color: colors['text-tertiary'],
                  }}
                  className="grid grid-cols-12 gap-4 px-6 py-3 text-sm font-medium"
                >
                  <div className="col-span-4">Name</div>
                  <div className="col-span-2">Role</div>
                  <div className="col-span-4">Email address</div>
                  <div className="col-span-2">Teams</div>
                </div>

                {/* Table content would go here */}
                {/* This would be populated with actual team member data */}
              </div>
            </div>
          )}

          {activeTab === 'Plan' && (
            <div className="flex flex-col justify-center items-center">
              <div className="flex w-full justify-center">
                {/* Billing Toggle */}
                <div
                  style={{
                    backgroundColor: colors['bg-secondary'],
                    borderColor: colors['border-secondary'],
                  }}
                  className="inline-flex rounded-lg border p-1 mb-12"
                >
                  <button
                    onClick={() => handleBillingPeriodChange('monthly')}
                    disabled={isUpdatingBillingPeriod}
                    style={{
                      backgroundColor:
                        billingPeriod === 'monthly'
                          ? colors['bg-primary']
                          : 'transparent',
                      borderColor:
                        billingPeriod === 'monthly'
                          ? colors['border-primary']
                          : 'transparent',
                      color:
                        billingPeriod === 'monthly'
                          ? colors['text-primary']
                          : colors['text-tertiary'],
                    }}
                    className="px-4 py-2 rounded-lg transition-all text-sm font-medium border"
                  >
                    Monthly billing
                  </button>
                  <button
                    onClick={() => handleBillingPeriodChange('annual')}
                    disabled={isUpdatingBillingPeriod}
                    style={{
                      backgroundColor:
                        billingPeriod === 'annual'
                          ? colors['bg-primary']
                          : 'transparent',
                      borderColor:
                        billingPeriod === 'annual'
                          ? colors['border-primary']
                          : 'transparent',
                      color:
                        billingPeriod === 'annual'
                          ? colors['text-primary']
                          : colors['text-tertiary'],
                    }}
                    className="px-4 py-2 rounded-lg flex items-center gap-2 transition-all text-sm font-medium border"
                  >
                    Annual billing
                    <span
                      style={{
                        backgroundColor: colors['bg-brand-primary'],
                        color: colors['text-brand-primary'],
                        borderColor: colors['border-brand'],
                      }}
                      className="text-xs px-3 py-0.5 rounded-full border"
                    >
                      Save 20%
                    </span>
                  </button>
                </div>
              </div>
              {/* Pricing Cards */}
              <div className="grid md:grid-cols-2 gap-8 w-fit">
                {/* Free Plan */}
                <div
                  style={{
                    backgroundColor: colors['bg-primary'],
                    borderColor: colors['border-primary'],
                  }}
                  className="border rounded-xl p-8 shadow-sm flex flex-col"
                >
                  <div className="mb-8">
                    <h2
                      style={{ color: colors['text-primary'] }}
                      className="text-2xl font-semibold mb-2"
                    >
                      {PLAN_DATA.free.name}
                    </h2>
                    <div
                      style={{ color: colors['text-primary'] }}
                      className="text-2xl font-bold"
                    >
                      {PLAN_DATA.free.price}
                    </div>
                  </div>

                  <div className="space-y-4 mb-8">
                    {PLAN_DATA.free.features.map((feature, index) => (
                      <div key={index} className="flex items-center gap-3">
                        <img
                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/blue-check.svg`}
                          alt="check"
                          className="w-5 h-5"
                        />
                        <span
                          style={{ color: colors['text-tertiary'] }}
                          className="text-base font-normal"
                        >
                          {feature}
                        </span>
                      </div>
                    ))}
                  </div>

                  <div className="mt-auto">
                    <ButtonNormal
                      variant="secondary"
                      size="small"
                      className="w-full"
                      disabled={isLoadingPlan || currentPlan === 'free'}
                      onClick={
                        currentPlan !== 'free'
                          ? handleDowngradeClick
                          : undefined
                      }
                    >
                      {isLoadingPlan
                        ? 'Loading...'
                        : currentPlan === 'free'
                          ? 'Current plan'
                          : 'Downgrade to Free'}
                    </ButtonNormal>
                  </div>
                </div>

                {/* Early Adopter Plan */}
                <div
                  style={{
                    backgroundColor: colors['bg-primary'],
                    borderColor: colors['border-primary'],
                  }}
                  className="border rounded-xl p-8 shadow-sm relative"
                >
                  {currentPlan === 'earlyAdopter' &&
                    subscriptionStatus === 'ACTIVE' && (
                      <div
                        style={{
                          backgroundColor: colors['bg-brand-primary'],
                          color: colors['text-brand-primary'],
                          borderColor: colors['border-brand'],
                        }}
                        className="absolute -top-3 left-1/2 transform -translate-x-1/2 px-4 py-1 rounded-full text-xs font-medium border"
                      >
                        Current plan
                      </div>
                    )}

                  <div className="mb-8">
                    <h2
                      style={{ color: colors['text-primary'] }}
                      className="text-2xl font-semibold mb-2"
                    >
                      {PLAN_DATA.earlyAdopter.name}
                    </h2>
                    <div
                      style={{ color: colors['text-primary'] }}
                      className="text-2xl font-bold"
                    >
                      {billingPeriod === 'monthly'
                        ? PLAN_DATA.earlyAdopter.monthly.price
                        : PLAN_DATA.earlyAdopter.annual.price}
                      <span
                        style={{ color: colors['text-tertiary'] }}
                        className="text-sm font-normal ml-2"
                      >
                        {billingPeriod === 'monthly'
                          ? PLAN_DATA.earlyAdopter.monthly.period
                          : PLAN_DATA.earlyAdopter.annual.period}
                      </span>
                    </div>
                  </div>

                  <div className="space-y-4 mb-8">
                    {PLAN_DATA.earlyAdopter.features.map((feature, index) => (
                      <div key={index} className="flex items-center gap-3">
                        <img
                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/blue-check.svg`}
                          alt="check"
                          className="w-5 h-5"
                        />
                        <span
                          style={{ color: colors['text-tertiary'] }}
                          className="text-base font-normal"
                        >
                          {feature}
                        </span>
                      </div>
                    ))}
                  </div>

                  {currentPlan === 'earlyAdopter' &&
                  subscriptionStatus === 'ACTIVE' ? (
                    // If they're already on this plan, show an upgrade/downgrade button based on billing period
                    <ButtonNormal
                      variant="primary"
                      size="small"
                      className="w-full mt-4"
                      onClick={() => handlePlanButtonClick('earlyAdopter')}
                      disabled={
                        currentBillingType === billingPeriod ||
                        isUpdatingBillingPeriod
                      }
                    >
                      {isUpdatingBillingPeriod
                        ? 'Updating...'
                        : getPlanButtonText(
                            'earlyAdopter',
                            currentBillingType,
                            billingPeriod
                          )}
                    </ButtonNormal>
                  ) : (
                    // If they're not on this plan, show a checkout button
                    <CheckoutButton
                      priceId={
                        billingPeriod === 'monthly'
                          ? PLAN_DATA.earlyAdopter.monthly.priceId
                          : PLAN_DATA.earlyAdopter.annual.priceId
                      }
                      isCurrentPlan={false}
                      variant="primary"
                      size="small"
                      fullWidth
                    >
                      {isLoadingPlan
                        ? 'Loading...'
                        : getPlanButtonText('free', null, billingPeriod)}
                    </CheckoutButton>
                  )}
                </div>
              </div>
            </div>
          )}

          {activeTab === 'Billing' && (
            <div className="flex flex-col gap-10 min-h-full">
              {/* Header */}
              <div className="px-8">
                <div className="flex flex-col gap-6">
                  <div className="flex flex-col gap-5">
                    <div className="flex flex-wrap items-start gap-4">
                      <div className="flex-1 min-w-[320px] flex flex-col gap-1">
                        <h2
                          style={{ color: colors['text-primary'] }}
                          className="text-[30px] font-semibold leading-[38px]"
                        >
                          Billing
                        </h2>
                        <p
                          style={{ color: colors['text-tertiary'] }}
                          className="text-base leading-6"
                        >
                          Manage your billing and payment details.
                        </p>
                      </div>
                    </div>
                    <div
                      style={{ backgroundColor: colors['border-secondary'] }}
                      className="h-px w-full"
                    />
                  </div>
                </div>
              </div>

              {/* Current Plan Overview */}
              <div className="px-8">
                <div className="flex flex-col gap-4">
                  <div
                    style={{
                      backgroundColor: colors['bg-secondary'],
                      borderColor: colors['border-secondary'],
                    }}
                    className="w-full rounded-xl border p-6"
                  >
                    <div className="flex justify-between items-start">
                      <div className="flex flex-col gap-1 pt-1">
                        <div className="flex items-center gap-2">
                          <h3
                            style={{ color: colors['text-primary'] }}
                            className="text-lg font-semibold leading-7"
                          >
                            {currentPlan === 'earlyAdopter'
                              ? 'Early Adopter'
                              : 'Free Plan'}
                          </h3>
                          {currentPlan === 'earlyAdopter' &&
                            subscriptionStatus === 'ACTIVE' && (
                              <div
                                style={{
                                  backgroundColor: colors['bg-brand-primary'],
                                  color: colors['text-brand-primary'],
                                  borderColor: colors['border-brand'],
                                }}
                                className="px-1.5 py-0.5 text-xs font-medium rounded-md border"
                              >
                                Current plan
                              </div>
                            )}
                        </div>
                        <p
                          style={{ color: colors['text-tertiary'] }}
                          className="text-sm leading-5"
                        >
                          {currentPlan === 'earlyAdopter'
                            ? currentBillingType === 'annual'
                              ? '$12 per user/mo, billed annually'
                              : '$15 per user/mo, billed monthly'
                            : 'Free forever'}
                        </p>
                      </div>
                      <div className="flex gap-16">
                        <div className="flex flex-col gap-1 items-end pt-1">
                          <p
                            style={{ color: colors['text-tertiary'] }}
                            className="text-sm font-medium leading-5"
                          >
                            Users
                          </p>
                          <div className="flex items-center gap-2">
                            <span
                              style={{ color: colors['text-primary'] }}
                              className="text-lg font-semibold leading-7"
                            >
                              {subscriptionData?.users?.length || 0}
                            </span>
                          </div>
                        </div>
                        {currentPlan === 'earlyAdopter' &&
                          subscriptionStatus === 'ACTIVE' && (
                            <div className="flex flex-col gap-1 items-end pt-1">
                              <p
                                style={{ color: colors['text-tertiary'] }}
                                className="text-sm font-medium leading-5"
                              >
                                Next renewal
                              </p>
                              <div className="flex items-center gap-2">
                                <span
                                  style={{ color: colors['text-primary'] }}
                                  className="text-lg font-semibold leading-7"
                                >
                                  $
                                  {nextPaymentAmount
                                    ? (nextPaymentAmount / 100).toLocaleString()
                                    : '0'}{' '}
                                  on{' '}
                                  {subscriptionEnd
                                    ? new Date(
                                        subscriptionEnd
                                      ).toLocaleDateString('en-US', {
                                        month: 'long',
                                        day: 'numeric',
                                        year: 'numeric',
                                      })
                                    : 'N/A'}
                                </span>
                              </div>
                            </div>
                          )}
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              {/* Billing Details */}
              <div className="px-8">
                <div className="flex flex-col gap-6">
                  <h3
                    style={{ color: colors['text-primary'] }}
                    className="text-lg font-semibold leading-7"
                  >
                    Billing Details
                  </h3>
                  <div className="flex flex-col gap-4">
                    {/* Personal Info */}
                    <BillingInfoForm
                      workspaceId={workspace?.id || 0}
                      isFreePlan={currentPlan === 'free'}
                    />
                  </div>
                </div>
              </div>

              {/* Invoices */}
              <div className="px-8">
                <div className="flex flex-col gap-6">
                  <h3
                    style={{ color: colors['text-primary'] }}
                    className="text-lg font-semibold leading-7"
                  >
                    Invoices
                  </h3>

                  {/* Invoices Table */}
                  {Boolean(
                    invoicesData?.invoices && invoicesData.invoices.length > 0
                  ) ? (
                    <div
                      style={{
                        backgroundColor: colors['bg-secondary'],
                        borderColor: colors['border-secondary'],
                      }}
                      className="w-full rounded-xl border overflow-hidden"
                    >
                      {/* Table Header */}
                      <div
                        style={{
                          borderColor: colors['border-secondary'],
                        }}
                        className="grid grid-cols-[1fr,1fr,1fr,1fr,auto] gap-4 border-b px-6"
                      >
                        <div className="py-3">
                          <span
                            style={{ color: colors['text-tertiary'] }}
                            className="text-sm font-medium"
                          >
                            Invoice n
                          </span>
                        </div>
                        <div className="py-3">
                          <span
                            style={{ color: colors['text-tertiary'] }}
                            className="text-sm font-medium"
                          >
                            Billing date
                          </span>
                        </div>
                        <div className="py-3">
                          <span
                            style={{ color: colors['text-tertiary'] }}
                            className="text-sm font-medium"
                          >
                            Amount
                          </span>
                        </div>
                        <div className="py-3">
                          <span
                            style={{ color: colors['text-tertiary'] }}
                            className="text-sm font-medium"
                          >
                            Subscription
                          </span>
                        </div>
                        <div className="py-3 w-[100px]"></div>
                      </div>

                      {/* Table Body */}
                      {invoicesData?.invoices
                        .filter(
                          (invoice) =>
                            invoice.number && invoice.created && invoice.amount
                        )
                        .map((invoice) => (
                          <div
                            key={invoice.id}
                            style={{
                              borderColor: colors['border-secondary'],
                            }}
                            className="grid grid-cols-[1fr,1fr,1fr,1fr,auto] gap-4 border-b px-6 items-center hover:bg-[rgba(255,255,255,0.02)]"
                          >
                            <div className="py-3">
                              <span
                                style={{ color: colors['text-primary'] }}
                                className="text-sm font-medium"
                              >
                                {invoice.number}
                              </span>
                            </div>
                            <div className="py-3">
                              <span
                                style={{ color: colors['text-tertiary'] }}
                                className="text-sm"
                              >
                                {new Date(
                                  invoice.created * 1000
                                ).toLocaleDateString('en-US', {
                                  month: 'long',
                                  day: 'numeric',
                                  year: 'numeric',
                                })}
                              </span>
                            </div>
                            <div className="py-3">
                              <span
                                style={{ color: colors['text-tertiary'] }}
                                className="text-sm"
                              >
                                {invoice.currency.toUpperCase()}{' '}
                                {(invoice.amount / 100).toFixed(2)}
                              </span>
                            </div>
                            <div className="py-3">
                              <span
                                style={{ color: colors['text-tertiary'] }}
                                className="text-sm"
                              >
                                {invoice.plan}
                              </span>
                            </div>
                            <div className="py-3 w-[100px]">
                              <button
                                style={{ color: colors['text-primary'] }}
                                className="text-sm font-medium hover:opacity-80"
                                onClick={() =>
                                  window.open(invoice.hostedUrl, '_blank')
                                }
                              >
                                View
                              </button>
                            </div>
                          </div>
                        ))}
                    </div>
                  ) : (
                    <div
                      style={{
                        backgroundColor: colors['bg-secondary'],
                        borderColor: colors['border-secondary'],
                        color: colors['text-tertiary'],
                      }}
                      className="w-full rounded-xl border p-8 text-center"
                    >
                      {invoicesError
                        ? 'Failed to load invoices. Please try again later.'
                        : 'No invoices found.'}
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}

          {activeTab === 'Appearance' && (
            <div className="px-8">
              <div className="mb-6">
                <h2
                  style={{ color: colors['text-primary'] }}
                  className="text-lg font-semibold mb-1"
                >
                  Theme
                </h2>
                <p
                  style={{ color: colors['text-tertiary'] }}
                  className="text-sm"
                >
                  Customize your UI theme
                </p>
              </div>

              <div className="grid grid-cols-3 gap-4 max-w-3xl">
                {/* Light Theme Option */}
                <div
                  className="relative cursor-pointer group"
                  onClick={() => setTheme('light')}
                >
                  <div
                    style={{
                      backgroundColor: colors['bg-primary'],
                      borderColor:
                        currentTheme === 'light'
                          ? colors['text-accent']
                          : colors['border-secondary'],
                    }}
                    className="aspect-[4/3] rounded-xl border-2 overflow-hidden transition-all duration-200 hover:border-[#4761c4]"
                  >
                    <div className="w-full h-full p-2">
                      <div className="w-full h-full rounded-lg bg-[#F9FAFB] overflow-hidden">
                        <div className="h-2 w-8 bg-[#D0D5DD] rounded-full m-2"></div>
                        <div className="space-y-1 px-2">
                          <div className="h-1 w-3/4 bg-[#D0D5DD] rounded-full"></div>
                          <div className="h-1 w-1/2 bg-[#D0D5DD] rounded-full"></div>
                          <div className="h-1 w-2/3 bg-[#D0D5DD] rounded-full"></div>
                        </div>
                      </div>
                    </div>
                  </div>
                  {currentTheme === 'light' && (
                    <div className="absolute -right-1 -top-1">
                      <div
                        style={{
                          backgroundColor: colors['bg-primary'],
                          borderColor: colors['border-primary'],
                        }}
                        className="w-6 h-6 rounded-full border-2 flex items-center justify-center"
                      >
                        <div className="w-4 h-4 rounded-full bg-[#4761c4] flex items-center justify-center">
                          <img
                            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-white.svg`}
                            alt="Selected"
                            className="w-3 h-3"
                          />
                        </div>
                      </div>
                    </div>
                  )}
                  <p
                    style={{ color: colors['text-primary'] }}
                    className="mt-2 text-sm font-medium text-center"
                  >
                    Light
                  </p>
                </div>

                {/* Dark Theme Option */}
                <div
                  className="relative cursor-pointer group"
                  onClick={() => setTheme('dark')}
                >
                  <div
                    style={{
                      backgroundColor: colors['bg-primary'],
                      borderColor:
                        currentTheme === 'dark'
                          ? colors['text-accent']
                          : colors['border-secondary'],
                    }}
                    className="aspect-[4/3] rounded-xl border-2 overflow-hidden transition-all duration-200 hover:border-[#4761c4]"
                  >
                    <div className="w-full h-full p-2">
                      <div className="w-full h-full rounded-lg bg-[#1C1C1C] overflow-hidden">
                        <div className="h-2 w-8 bg-[#2C2C2C] rounded-full m-2"></div>
                        <div className="space-y-1 px-2">
                          <div className="h-1 w-3/4 bg-[#2C2C2C] rounded-full"></div>
                          <div className="h-1 w-1/2 bg-[#2C2C2C] rounded-full"></div>
                          <div className="h-1 w-2/3 bg-[#2C2C2C] rounded-full"></div>
                        </div>
                      </div>
                    </div>
                  </div>
                  {currentTheme === 'dark' && (
                    <div className="absolute -right-1 -top-1">
                      <div
                        style={{
                          backgroundColor: colors['bg-primary'],
                          borderColor: colors['border-primary'],
                        }}
                        className="w-6 h-6 rounded-full border-2 flex items-center justify-center"
                      >
                        <div className="w-4 h-4 rounded-full bg-[#4761c4] flex items-center justify-center">
                          <img
                            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-white.svg`}
                            alt="Selected"
                            className="w-3 h-3"
                          />
                        </div>
                      </div>
                    </div>
                  )}
                  <p
                    style={{ color: colors['text-primary'] }}
                    className="mt-2 text-sm font-medium text-center"
                  >
                    Dark
                  </p>
                </div>

                {/* System Theme Option */}
                <div
                  className="relative cursor-pointer group hidden"
                  onClick={() => setTheme('light')}
                >
                  <div
                    style={{
                      backgroundColor: colors['bg-primary'],
                      borderColor:
                        currentTheme === 'light'
                          ? colors['text-accent']
                          : colors['border-secondary'],
                    }}
                    className="aspect-[4/3] rounded-xl border-2 overflow-hidden transition-all duration-200 hover:border-[#4761c4]"
                  >
                    <div className="w-full h-full p-2">
                      <div className="w-full h-full rounded-lg bg-[#F9FAFB] overflow-hidden">
                        <div className="h-2 w-8 bg-[#D0D5DD] rounded-full m-2"></div>
                        <div className="space-y-1 px-2">
                          <div className="h-1 w-3/4 bg-[#D0D5DD] rounded-full"></div>
                          <div className="h-1 w-1/2 bg-[#D0D5DD] rounded-full"></div>
                          <div className="h-1 w-2/3 bg-[#D0D5DD] rounded-full"></div>
                        </div>
                      </div>
                    </div>
                  </div>
                  {currentTheme === 'light' && (
                    <div className="absolute -right-1 -top-1">
                      <div
                        style={{
                          backgroundColor: colors['bg-primary'],
                          borderColor: colors['border-primary'],
                        }}
                        className="w-6 h-6 rounded-full border-2 flex items-center justify-center"
                      >
                        <div className="w-4 h-4 rounded-full bg-[#4761c4] flex items-center justify-center">
                          <img
                            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-white.svg`}
                            alt="Selected"
                            className="w-3 h-3"
                          />
                        </div>
                      </div>
                    </div>
                  )}
                  <p
                    style={{ color: colors['text-primary'] }}
                    className="mt-2 text-sm font-medium text-center"
                  >
                    Light
                  </p>
                </div>
              </div>
            </div>
          )}
        </div>

        {/* Downgrade Confirmation Modal */}
        {showDowngradeConfirmation && (
          <Modal
            title="Downgrade to Free Plan"
            subtitle="You'll still have access to Premium features until the end of your current billing period"
            onClose={() => setShowDowngradeConfirmation(false)}
            showHeaderSeparator={true}
            actions={
              <div className="flex justify-end gap-3 w-full">
                <ButtonNormal
                  variant="secondary"
                  size="small"
                  onClick={() => setShowDowngradeConfirmation(false)}
                >
                  Cancel
                </ButtonNormal>
                <ButtonNormal
                  variant="primary"
                  size="small"
                  onClick={handleConfirmDowngrade}
                  disabled={isLoadingPlan}
                >
                  {isLoadingPlan ? 'Downgrading...' : 'Confirm Downgrade'}
                </ButtonNormal>
              </div>
            }
          >
            <div className="space-y-4 py-2">
              <p style={{ color: colors['text-secondary'] }}>
                By downgrading to the Free plan, you'll lose access to:
              </p>
              <ul
                className="list-disc pl-5 space-y-2"
                style={{ color: colors['text-secondary'] }}
              >
                <li>Unlimited conditional processes</li>
                <li>Early access to new features</li>
                <li>Branded processes & exports</li>
                <li>Priority support from the founders</li>
                <li>ProcessFlow branding removal</li>
              </ul>
              <p
                style={{ color: colors['text-secondary'] }}
                className="font-semibold"
              >
                You'll continue to have access to Premium features until the end
                of your current billing period.
              </p>
            </div>
          </Modal>
        )}

        {/* Plan Change Confirmation Modal */}
        {showPlanChangeConfirmation && (
          <Modal
            title={
              pendingBillingPeriod === 'annual'
                ? 'Upgrade to Annual Billing'
                : 'Switch to Monthly Billing'
            }
            subtitle={
              pendingBillingPeriod === 'annual'
                ? 'You will be upgrading from monthly to annual billing'
                : 'You will be switching from annual to monthly billing'
            }
            onClose={() => setShowPlanChangeConfirmation(false)}
            showHeaderSeparator={true}
            actions={
              <div className="flex justify-end gap-3 w-full">
                <ButtonNormal
                  variant="secondary"
                  size="small"
                  onClick={() => setShowPlanChangeConfirmation(false)}
                >
                  Cancel
                </ButtonNormal>
                <ButtonNormal
                  variant="primary"
                  size="small"
                  onClick={confirmPlanChange}
                  disabled={isUpdatingBillingPeriod}
                >
                  {isUpdatingBillingPeriod ? (
                    'Confirming...'
                  ) : pendingBillingPeriod === 'annual' ? (
                    <div className="flex items-center gap-1">
                      <span>Confirm Upgrade</span>
                      <span
                        style={{
                          backgroundColor: colors['bg-brand-primary'],
                          color: colors['text-brand-primary'],
                          borderColor: colors['border-brand'],
                        }}
                        className="text-xs px-2 py-0.5 rounded-full border"
                      >
                        Save 20%
                      </span>
                    </div>
                  ) : (
                    'Confirm Change'
                  )}
                </ButtonNormal>
              </div>
            }
          >
            <div className="space-y-4 py-2">
              {pendingBillingPeriod === 'annual' ? (
                <>
                  <p style={{ color: colors['text-secondary'] }}>
                    By upgrading to annual billing, you'll benefit from:
                  </p>
                  <ul
                    className="list-disc pl-5 space-y-2"
                    style={{ color: colors['text-secondary'] }}
                  >
                    <li>
                      <strong>20% savings</strong> compared to monthly billing
                    </li>
                    <li>
                      Your subscription will be charged{' '}
                      <strong>annually</strong> instead of monthly
                    </li>
                    <li>
                      Your new price will be{' '}
                      <strong>
                        {PLAN_DATA.earlyAdopter.annual.price} per user/month
                      </strong>
                      , billed annually
                    </li>
                    <li>
                      The change will take effect at the start of your next
                      billing cycle
                    </li>
                  </ul>
                  <p
                    style={{ color: colors['text-secondary'] }}
                    className="font-semibold"
                  >
                    You will continue to have access to all Early Adopter
                    features during this transition.
                  </p>
                </>
              ) : (
                <>
                  <p style={{ color: colors['text-secondary'] }}>
                    By switching to monthly billing:
                  </p>
                  <ul
                    className="list-disc pl-5 space-y-2"
                    style={{ color: colors['text-secondary'] }}
                  >
                    <li>
                      Your subscription will be charged <strong>monthly</strong>{' '}
                      instead of annually
                    </li>
                    <li>
                      Your new price will be{' '}
                      <strong>
                        {PLAN_DATA.earlyAdopter.monthly.price} per user/month
                      </strong>
                    </li>
                    <li>You'll no longer receive the 20% annual discount</li>
                    <li>
                      The change will take effect at the end of your current
                      annual billing period
                    </li>
                    <li>
                      No refunds will be issued for the remaining time on your
                      annual plan
                    </li>
                  </ul>
                  <p
                    style={{ color: colors['text-secondary'] }}
                    className="font-semibold"
                  >
                    You will continue to have access to all Early Adopter
                    features during this transition.
                  </p>
                </>
              )}
            </div>
          </Modal>
        )}
      </div>
    </WorkspaceProvider>
  );
}
</file>

<file path="app/dashboard/components/Sidebar.tsx">
'use client';

import React, { useState, useRef, useEffect, useCallback } from 'react';
import WorkspaceDropdownMenu from './WorkspaceDropdownMenu';
import { Folder, Workspace } from '@/types/workspace';
import { User } from '@/types/user';
import TabButton from '@/app/components/TabButton';
import { cache } from 'react';
import { createClient } from '@/utils/supabase/client';
import Image from 'next/image';
import { useTheme, useColors } from '@/app/theme/hooks';
import ButtonNormal from '@/app/components/ButtonNormal';
import CreateWorkspaceModal from './CreateWorkspaceModal';
import { useRouter } from 'next/navigation';
import { toast } from 'react-hot-toast';
import SortableFolderList from './SortableFolderList';
import { useFolderPositioning } from '../hooks/useFolderPositioning';
import { checkWorkspaceName } from '@/app/utils/checkNames';
import { AnimatePresence } from 'framer-motion';

interface SidebarProps {
  workspaces: Workspace[];
  userEmail: string;
  activeWorkspace: Workspace;
  setActiveWorkspace: (workspace: Workspace) => Promise<void>;
  onCreateFolder: (parentId?: number) => void;
  onEditFolder: (folder: Folder) => void;
  onCreateSubfolder: (parentFolder: Folder) => void;
  onDeleteFolder: (folder: Folder) => Promise<void>;
  user: User | null;
  onSelectFolder: (folder?: Folder) => void;
  onSelectFolderView: (folder?: Folder) => void;
  onOpenUserSettings: () => void;
  onOpenHelpCenter: () => void;
  selectedFolder?: Folder;
  onLogout: () => void;
  isSettingsView: boolean;
  setIsSettingsView: (isSettingsView: boolean) => void;
  setWorkspaces: (workspaces: Workspace[]) => void;
  setActiveTab?: (tab: string) => void;
}

export default function Sidebar({
  workspaces,
  userEmail,
  activeWorkspace,
  setActiveWorkspace,
  onCreateFolder,
  onEditFolder,
  onCreateSubfolder,
  onDeleteFolder,
  user,
  onSelectFolder,
  onSelectFolderView,
  onOpenUserSettings,
  onOpenHelpCenter,
  selectedFolder,
  onLogout,
  isSettingsView,
  setIsSettingsView,
  setWorkspaces,
  setActiveTab,
}: SidebarProps) {
  const { currentTheme } = useTheme();
  const colors = useColors();
  const [activeTabId, setActiveTabId] = useState<string | null>('flows');
  const [expandedFolders, setExpandedFolders] = useState<Set<number>>(
    new Set()
  );
  const folderContainerRef = useRef<HTMLDivElement>(null);
  const [dropdownVisible, setDropdownVisible] = useState(false);
  const [sidebarWidth, setSidebarWidth] = useState(240);
  const [isResizing, setIsResizing] = useState(false);
  const sidebarRef = useRef<HTMLDivElement>(null);
  const [showCreateWorkspaceModal, setShowCreateWorkspaceModal] =
    useState(false);
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);

  // Use the folder positioning hook
  const { updateFolderPositions, isUpdating } = useFolderPositioning(
    activeWorkspace,
    setWorkspaces,
    workspaces
  );

  const startResizing = useCallback(
    (mouseDownEvent: React.MouseEvent) => {
      setIsResizing(true);
      const startWidth = sidebarWidth;
      const startX = mouseDownEvent.clientX;

      const handleMouseMove = (mouseMoveEvent: MouseEvent) => {
        const newWidth = startWidth + mouseMoveEvent.clientX - startX;
        setSidebarWidth(Math.min(Math.max(240, newWidth), 480));
      };

      const handleMouseUp = () => {
        setIsResizing(false);
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };

      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    },
    [sidebarWidth]
  );

  const handleTabClick = (tabId: string | null, folder?: Folder) => {
    if (isSettingsView && (tabId === 'flows' || tabId?.startsWith('folder-'))) {
      setIsSettingsView(false);
    }
    setActiveTabId(tabId);
    if (folder) {
      onSelectFolder(folder);
      onSelectFolderView(folder);
    } else {
      onSelectFolderView(undefined);
    }
    // If this is a settings tab and setActiveTab is provided, call it
    if (tabId && !tabId.startsWith('folder-') && setActiveTab) {
      setActiveTab(tabId);
    }
  };

  const toggleFolder = (folderId: number) => {
    setExpandedFolders((prev) => {
      const newExpandedFolders = new Set(prev);
      newExpandedFolders.has(folderId)
        ? newExpandedFolders.delete(folderId)
        : newExpandedFolders.add(folderId);
      return newExpandedFolders;
    });
  };

  const toggleDropdown = () => {
    setDropdownVisible((prev) => !prev);
  };

  const closeDropDown = () => {
    setDropdownVisible(false);
  };

  const handleOpenCreateWorkspaceModal = () => {
    setShowCreateWorkspaceModal(true);
  };

  const handleCreateWorkspace = async (workspaceData: {
    name: string;
    logo?: File;
    url: string;
  }) => {
    try {
      setIsLoading(true);
      // Format the URL slug to be URL-friendly
      const urlSlug = workspaceData.url
        .toLowerCase()
        .replace(/\s+/g, '-')
        .replace(/[^a-z0-9-]/g, '');

      let response;

      const nameError = checkWorkspaceName(workspaceData.name);
      if (nameError) {
        toast.error(nameError.title + ' ' + nameError.description);
        return;
      }
      // If there's a logo, we need to use FormData
      if (workspaceData.logo) {
        const formData = new FormData();
        formData.append('logo', workspaceData.logo);
        formData.append(
          'data',
          JSON.stringify({
            name: workspaceData.name,
            slug: urlSlug,
          })
        );

        response = await fetch('/api/workspace/create', {
          method: 'POST',
          body: formData,
        });
      } else {
        // Otherwise, use JSON
        response = await fetch('/api/workspace/create', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            name: workspaceData.name,
            slug: urlSlug,
          }),
        });
      }

      if (!response.ok) {
        const error = await response.json();
        console.error('Error creating workspace:', error);
        toast.error(
          'Failed to create workspace: ' + (error.error || 'Unknown error')
        );
        setIsLoading(false);
        return;
      }

      const result = await response.json();

      // Add the new workspace to local state
      if (workspaces && result.workspace) {
        setWorkspaces([...workspaces, result.workspace]);
      }

      // Close the modal
      setShowCreateWorkspaceModal(false);

      // Display success message
      toast.success('Workspace created successfully!');

      // Navigate to the new workspace
      if (result.workspace && result.workspace.id) {
        router.push(`/workspace/${result.workspace.id}`);
      }
    } catch (error) {
      console.error('Error creating workspace:', error);
      toast.error('An error occurred while creating your workspace');
    } finally {
      setIsLoading(false);
    }
  };

  const renderFolderWithSubfolders = (folder: Folder) => {
    const isExpanded = expandedFolders.has(folder.id);
    const subfolders = activeWorkspace.folders.filter(
      (f) => f.parent_id === folder.id
    );

    let folderIcon;
    if (folder.icon_url) {
      folderIcon = folder.icon_url.startsWith('https://cdn.brandfetch.io/')
        ? folder.icon_url
        : folder.signedIconUrl
          ? folder.signedIconUrl
          : `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon-base.svg`;
    } else {
      folderIcon = `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon-base.svg`;
    }

    return (
      <div key={folder.id} className="mt-1 max-w-full">
        <TabButton
          icon={folder.emote ? '' : folderIcon}
          label={folder.name}
          emote={folder.emote}
          isActive={!isSettingsView && activeTabId === `folder-${folder.id}`}
          onClick={() => handleTabClick(`folder-${folder.id}`, folder)}
          isFolder={true}
          folder={folder}
          onCreateSubfolder={onCreateSubfolder}
          onEditFolder={onEditFolder}
          onDeleteFolder={onDeleteFolder}
          hasSubfolders={subfolders.length > 0}
          isExpanded={isExpanded}
          onToggleExpand={() => toggleFolder(folder.id)}
        />

        {isExpanded && subfolders.length > 0 && (
          <div className="ml-4">
            {subfolders.map((subfolder) =>
              renderFolderWithSubfolders(subfolder)
            )}
          </div>
        )}
      </div>
    );
  };

  const getHeaderStyles = () => {
    const headerId = `workspace-header-${Math.random().toString(36).substr(2, 9)}`;
    return {
      id: headerId,
      style: {
        backgroundColor: colors['bg-primary'],
      },
      hoverStyle: `
        #${headerId}:hover {
          background-color: ${colors['bg-secondary']} !important;
        }
      `,
    };
  };

  const { id, style, hoverStyle } = getHeaderStyles();

  return (
    <>
      <style>{hoverStyle}</style>
      <div
        ref={sidebarRef}
        style={{
          width: `${sidebarWidth}px`,
          backgroundColor: colors['bg-primary'],
          borderColor: colors['border-secondary'],
        }}
        className="h-full border-r flex flex-col relative z-20"
      >
        {/* Sidebar Header */}
        <div className="h-[72px] w-full px-4 py-3 flex-col justify-start items-start inline-flex">
          <div
            id={id}
            onClick={toggleDropdown}
            style={style}
            className="self-stretch px-3 py-2.5 cursor-pointer rounded-md flex justify-between items-center overflow-hidden transition-colors"
            data-testid="workspace-switcher"
          >
            <div className="flex items-center gap-2 flex-1 min-w-0">
              <div className="relative w-8 h-8">
                {activeWorkspace.icon_url && (
                  <img
                    src={activeWorkspace.icon_url}
                    alt={activeWorkspace.name}
                    className="w-8 h-8 rounded-lg object-cover absolute inset-0"
                    onError={(e) => {
                      e.currentTarget.style.display = 'none';
                    }}
                  />
                )}
                <div
                  className="w-8 h-8 rounded-lg flex items-center justify-center text-white text-xs font-medium absolute inset-0"
                  style={{
                    backgroundColor:
                      activeWorkspace.background_colour || '#4299E1',
                    display: 'flex',
                    opacity: activeWorkspace.icon_url ? 0 : 1,
                  }}
                >
                  {activeWorkspace.name.charAt(0).toUpperCase()}
                </div>
              </div>
              {/* Display activeWorkspace name */}
              <div className="relative flex flex-col px-0.5 min-w-0 flex-1">
                <div
                  style={{ color: colors['text-primary'] }}
                  className="text-sm font-medium font-['Inter'] leading-tight flex items-center justify-between gap-2 min-w-0"
                >
                  <span className="truncate min-w-0">
                    {activeWorkspace.name}
                  </span>
                  <Image
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/chevron-selector-vertical.svg`}
                    alt="Open workspace menu"
                    width={20}
                    height={20}
                    className="w-5 h-5 flex-shrink-0"
                  />
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Workspace Dropdown Overlay */}
        <AnimatePresence>
          {dropdownVisible && (
            <div className="fixed inset-0 z-10" onClick={closeDropDown}>
              <div
                className="absolute top-14 left-4 mt-2"
                onClick={(e) => e.stopPropagation()}
              >
                <WorkspaceDropdownMenu
                  userEmail={userEmail}
                  workspaces={workspaces}
                  activeWorkspace={activeWorkspace}
                  setActiveWorkspace={setActiveWorkspace}
                  onClose={closeDropDown}
                  onOpenSettings={() => setIsSettingsView(true)}
                  onLogout={onLogout}
                  onOpenCreateWorkspaceModal={handleOpenCreateWorkspaceModal}
                />
              </div>
            </div>
          )}
        </AnimatePresence>

        {/* Divider */}
        <div
          style={{ borderColor: colors['border-secondary'] }}
          className="self-stretch h-px border-t my-0"
        />

        {/* "My Workflows" Button */}
        <div className="px-4 p-2">
          <TabButton
            icon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/layers-icon.svg`}
            label="My Flows"
            isActive={!isSettingsView && activeTabId === 'flows'}
            onClick={() => handleTabClick('flows')}
          />
        </div>

        <div
          style={{ borderColor: colors['border-secondary'] }}
          className="self-stretch h-px border-t my-0"
        />

        {/* Folder section with proper scrolling */}
        <div ref={folderContainerRef} className="flex-grow overflow-y-auto">
          {/* My folders header */}
          <div className="flex flex-col">
            <div
              className="flex items-center justify-between px-7 py-4"
              data-testid="folders-section"
            >
              <span
                style={{ color: colors['text-tertiary'] }}
                className="text-xs font-normal"
              >
                MY FOLDERS
              </span>
              <button
                onClick={() => onCreateFolder()}
                className="w-5 h-5 relative overflow-hidden transition-all duration-200 hover:scale-110 hover:rotate-90"
              >
                <Image
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/plus-icon.svg`}
                  alt="Add Folder"
                  width={20}
                  height={20}
                  className="w-5 h-5"
                />
              </button>
            </div>

            {/* Folders container - REPLACED WITH SORTABLE FOLDER LIST */}
            <div className="px-4">
              <SortableFolderList
                activeWorkspace={activeWorkspace}
                expandedFolders={expandedFolders}
                onToggleFolder={toggleFolder}
                activeTabId={activeTabId}
                onTabClick={handleTabClick}
                onCreateSubfolder={onCreateSubfolder}
                onEditFolder={onEditFolder}
                onDeleteFolder={onDeleteFolder}
                onSelectFolder={onSelectFolder}
                isSettingsView={isSettingsView}
                updateFolderPositions={updateFolderPositions}
              />
            </div>
          </div>
        </div>

        {/* Integrated Footer */}
        <div
          style={{
            backgroundColor: colors['bg-primary'],
            borderColor: colors['border-secondary'],
          }}
          className="w-full p-4 flex-col justify-start items-center gap-3 inline-flex border-t"
        >
          {/* Free Plan Notification Card - Show when on free plan or no subscription */}
          {(!activeWorkspace.subscription ||
            activeWorkspace.subscription?.plan_type === 'FREE') &&
            activeWorkspace.workflows.length >= 4 && (
              <div
                style={{ backgroundColor: colors['bg-secondary'] }}
                className="w-full p-4 flex flex-col gap-4 rounded-lg relative"
              >
                <div className="flex flex-col gap-1">
                  <div className="flex">
                    <span
                      style={{ color: colors['text-primary'] }}
                      className="text-sm font-semibold font-['Inter']"
                    >
                      Free plan
                    </span>
                  </div>
                  <span
                    style={{ color: colors['text-secondary'] }}
                    className="text-sm font-normal font-['Inter']"
                  >
                    {activeWorkspace.workflows.length === 5
                      ? "You've reached the limit of 5 workflows in the free plan. Upgrade to create more!"
                      : `Your team has used ${activeWorkspace.workflows.length}/5 workflows in the free plan. Need more?`}
                  </span>
                </div>

                {/* Progress Bar */}
                <div className="flex items-center gap-3 w-full">
                  <div className="flex-grow h-2 bg-gray-100 dark:bg-gray-700 rounded-full overflow-hidden">
                    <div
                      className="h-full bg-[#4761C4] rounded-full"
                      style={{
                        width: `${Math.min((activeWorkspace.workflows.length / 5) * 100, 100)}%`,
                      }}
                    />
                  </div>
                  <span
                    style={{ color: colors['text-primary'] }}
                    className="text-sm font-medium"
                  >
                    {Math.min(
                      Math.round((activeWorkspace.workflows.length / 5) * 100),
                      100
                    )}
                    %
                  </span>
                </div>

                {/* Action Buttons */}
                <div className="flex">
                  <ButtonNormal
                    variant="link-color"
                    size="small"
                    onClick={() => {
                      setIsSettingsView(true);
                      if (setActiveTab) {
                        setActiveTab('Plan');
                      }
                    }}
                  >
                    {activeWorkspace.workflows.length === 5
                      ? 'Upgrade to create more'
                      : 'Upgrade plan'}
                  </ButtonNormal>
                </div>
              </div>
            )}

          <ButtonNormal
            variant="secondary"
            size="small"
            className="w-full"
            leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/send-01.svg`}
            onClick={() =>
              window.open(
                `https://tally.so/r/wkRej6?email=${encodeURIComponent(userEmail)}`,
                '_blank'
              )
            }
          >
            Send a feedback
          </ButtonNormal>
          <div
            style={{ color: colors['text-tertiary'] }}
            className="w-full justify-center items-center gap-2 inline-flex"
          >
            <div className="text-center text-sm font-normal font-['Inter'] leading-tight">
              @ 2025 ProcessFlow, Inc.
            </div>
          </div>
        </div>

        {/* Add resize handle */}
        <style>{`
          .resize-handle:hover {
            background-color: ${colors['border-secondary']} !important;
            opacity: 0.5 !important;
          }
        `}</style>
        <div
          style={{
            backgroundColor: isResizing
              ? colors['bg-secondary']
              : 'transparent',
          }}
          className="absolute right-0 top-0 bottom-0 w-[3px] cursor-col-resize resize-handle transition-all"
          onMouseDown={startResizing}
        />
      </div>

      {/* CreateWorkspaceModal overlay */}
      {showCreateWorkspaceModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center">
          <div
            style={{ backgroundColor: 'rgba(0, 0, 0, 0.5)' }}
            className="absolute inset-0"
            onClick={() => setShowCreateWorkspaceModal(false)}
          />
          <div className="relative z-50">
            <CreateWorkspaceModal
              onClose={() => setShowCreateWorkspaceModal(false)}
              onCreateWorkspace={handleCreateWorkspace}
            />
          </div>
        </div>
      )}
    </>
  );
}

export const getUser = cache(async () => {
  const supabase = createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();
  return user;
});
</file>

<file path="app/dashboard/components/WorkspaceDropdownMenu.tsx">
'use client';

import { Workspace } from '@/types/workspace';
import React, { useState, useEffect, useRef } from 'react';
import CreateWorkspaceModal from './CreateWorkspaceModal';
import { useColors } from '@/app/theme/hooks';
import { useRouter } from 'next/navigation';
import { motion, AnimatePresence } from 'framer-motion';

interface WorkspaceDropdownMenuProps {
  userEmail: string;
  workspaces: Workspace[];
  activeWorkspace: Workspace | null;
  setActiveWorkspace: (workspace: Workspace) => Promise<void>;
  onClose: () => void;
  onOpenSettings: () => void;
  onLogout: () => void;
  onOpenCreateWorkspaceModal: () => void;
}

// Fonction utilitaire pour gnrer une couleur  partir d'une chane
function getColorFromString(str: string): string {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
  }
  let color = '#';
  for (let i = 0; i < 3; i++) {
    const value = (hash >> (i * 8)) & 0xff;
    color += ('00' + value.toString(16)).slice(-2);
  }
  return color;
}

export default function WorkspaceDropdownMenu({
  userEmail,
  workspaces,
  activeWorkspace,
  setActiveWorkspace,
  onClose,
  onOpenSettings,
  onLogout,
  onOpenCreateWorkspaceModal,
}: WorkspaceDropdownMenuProps) {
  const colors = useColors();
  const router = useRouter();
  const [isWorkspaceListVisible, setIsWorkspaceListVisible] = useState(false);
  const submenuRef = useRef<HTMLDivElement>(null);

  const handleSettingsClick = () => {
    onOpenSettings();
    onClose();
  };

  const handleCreateWorkspace = (workspaceData: {
    name: string;
    logo?: File;
    url: string;
  }) => {
    // TODO: Implement workspace creation logic, likely calling an API
    // For now, just close the modal
    onClose();
  };

  const handleOpenCreateWorkspaceModal = () => {
    // Call the parent's handler to open the modal
    onOpenCreateWorkspaceModal();
    // Close the dropdown
    onClose();
  };

  return (
    <>
      <motion.div
        initial={{ opacity: 0, scale: 0.95, y: -10 }}
        animate={{ opacity: 1, scale: 1, y: 0 }}
        exit={{ opacity: 0, scale: 0.95, y: -10 }}
        transition={{
          duration: 0.15,
          ease: [0.16, 1, 0.3, 1], // Custom easing for smooth feel
        }}
        style={{
          backgroundColor: colors['bg-secondary'],
          borderColor: colors['border-primary'],
        }}
        className="w-fit py-1 rounded-lg shadow-[0px_4px_6px_-2px_rgba(16,24,40,0.03)] border flex flex-col justify-start items-start overflow-visible"
      >
        {/* Settings Option */}
        <button
          onClick={handleSettingsClick}
          onMouseEnter={() => setIsWorkspaceListVisible(false)}
          className="w-[200px] px-1.5 py-px justify-start items-center inline-flex cursor-pointer"
        >
          <div
            style={
              {
                '--hover-bg': colors['bg-quaternary'],
              } as React.CSSProperties
            }
            className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-between items-center flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
          >
            <div className="flex items-center gap-2">
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/settings-icon.svg`}
                className="w-4 h-4"
              />
              <div
                style={{ color: colors['text-primary'] }}
                className="text-sm font-normal font-['Inter'] leading-tight"
              >
                Settings
              </div>
            </div>
          </div>
        </button>

        {/* Separator */}
        <div
          style={{ borderColor: colors['border-secondary'] }}
          className="self-stretch h-px border-b my-1 hidden"
        />

        {/* Switch Workspace Option */}
        <div className="group relative w-full">
          <button
            className="w-full px-1.5 py-px justify-start items-center inline-flex cursor-pointer"
            onMouseEnter={() => setIsWorkspaceListVisible(true)}
            onClick={(e) => {
              e.stopPropagation();
              setIsWorkspaceListVisible(!isWorkspaceListVisible);
            }}
          >
            <div
              style={
                {
                  '--hover-bg': colors['bg-quaternary'],
                } as React.CSSProperties
              }
              className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-between items-center flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden gap-9"
            >
              <div className="flex items-center gap-2">
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/switch-horizontal-01.svg`}
                  className="w-4 h-4"
                />
                <div
                  style={{ color: colors['text-primary'] }}
                  className="text-sm font-normal font-['Inter'] leading-tight"
                >
                  Switch workspace
                </div>
              </div>
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/right-filled-chevron.svg`}
                className="w-2 h-2"
              />
            </div>
          </button>

          {/* Workspace List Submenu */}
          <AnimatePresence>
            {isWorkspaceListVisible && (
              <motion.div
                ref={submenuRef}
                initial={{ opacity: 0, scale: 0.95, x: -10 }}
                animate={{ opacity: 1, scale: 1, x: 0 }}
                exit={{ opacity: 0, scale: 0.95, x: -10 }}
                transition={{
                  duration: 0.15,
                  ease: [0.16, 1, 0.3, 1],
                }}
                style={{
                  backgroundColor: colors['bg-secondary'],
                  borderColor: colors['border-primary'],
                }}
                className="absolute left-full top-[-7px] w-[264px] rounded-lg shadow-[0px_4px_6px_-2px_rgba(16,24,40,0.03)] py-1 border"
              >
                {/* Email Header */}
                <div className="px-1.5 py-px">
                  <div
                    style={{ color: colors['text-tertiary'] }}
                    className="px-2.5 py-[9px] text-sm font-normal cursor-default"
                  >
                    {userEmail}
                  </div>
                </div>

                <div
                  style={{ borderColor: colors['border-secondary'] }}
                  className="self-stretch h-px border-b my-1"
                />

                {/* Workspace List */}
                <div>
                  {workspaces.map((workspace) => (
                    <button
                      key={workspace.id}
                      onClick={async () => {
                        try {
                          // Call the API to switch workspace
                          const res = await fetch(
                            '/api/user/switch-workspace',
                            {
                              method: 'POST',
                              headers: { 'Content-Type': 'application/json' },
                              body: JSON.stringify({
                                workspaceId: workspace.id,
                              }),
                            }
                          );
                          if (!res.ok) {
                            const error = await res.json();
                            throw new Error(
                              error.error || 'Failed to switch workspace'
                            );
                          }
                          // Close the dropdown menu
                          onClose();
                          // Small delay to ensure state updates are processed
                          setTimeout(() => {
                            router.refresh();
                          }, 100);
                        } catch (error) {
                          console.error('Error switching workspace:', error);
                          alert('Failed to switch workspace.');
                        }
                      }}
                      className="w-full px-1.5 py-px justify-start items-center inline-flex cursor-pointer"
                    >
                      <div
                        style={
                          {
                            '--hover-bg': colors['bg-quaternary'],
                          } as React.CSSProperties
                        }
                        className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-between items-center flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
                      >
                        <div className="flex items-center gap-2">
                          {workspace.icon_url ? (
                            <img
                              src={workspace.icon_url}
                              alt={workspace.name}
                              className="w-6 h-6 rounded-lg object-cover"
                              onError={(e) => {
                                // If image fails to load, fallback to the default letter display
                                e.currentTarget.style.display = 'none';
                                const sibling = e.currentTarget
                                  .nextElementSibling as HTMLElement;
                                if (sibling) {
                                  sibling.style.display = 'flex';
                                }
                              }}
                            />
                          ) : null}
                          <div
                            className="w-6 h-6 rounded-lg flex items-center justify-center text-white text-xs font-normal"
                            style={{
                              backgroundColor:
                                workspace.background_colour || '#4299E1',
                              display: workspace.icon_url ? 'none' : 'flex',
                            }}
                          >
                            {workspace.name.charAt(0).toUpperCase()}
                          </div>
                          <div
                            style={{ color: colors['text-primary'] }}
                            className="text-sm font-normal"
                          >
                            {workspace.name}
                          </div>
                        </div>
                        {activeWorkspace?.id === workspace.id && (
                          <img
                            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-icon3.svg`}
                            alt="Active"
                            className="w-4 h-4"
                          />
                        )}
                      </div>
                    </button>
                  ))}
                </div>

                <div
                  style={{ borderColor: colors['border-secondary'] }}
                  className="self-stretch h-px hidden border-b my-1"
                />

                {/* Create/Join Options */}
                <button
                  onClick={handleOpenCreateWorkspaceModal}
                  className="w-full px-1.5 py-px justify-start items-center hidden cursor-pointer"
                >
                  <div
                    style={
                      {
                        '--hover-bg': colors['bg-quaternary'],
                      } as React.CSSProperties
                    }
                    className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
                  >
                    <div className="flex items-center gap-2">
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/plus-icon-grey.svg`}
                        className="w-4 h-4"
                      />
                      <div
                        style={{ color: colors['text-primary'] }}
                        className="text-sm font-normal"
                      >
                        Create a new workspace
                      </div>
                    </div>
                  </div>
                </button>
                <button
                  onClick={onClose}
                  className="w-full px-1.5 py-px justify-start items-center hidden cursor-pointer"
                >
                  <div
                    style={
                      {
                        '--hover-bg': colors['bg-quaternary'],
                      } as React.CSSProperties
                    }
                    className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
                  >
                    <div className="flex items-center gap-2">
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/user-circle (1).svg`}
                        className="w-4 h-4"
                      />
                      <div
                        style={{ color: colors['text-primary'] }}
                        className="text-sm font-normal"
                      >
                        Add an account
                      </div>
                    </div>
                  </div>
                </button>
              </motion.div>
            )}
          </AnimatePresence>
        </div>

        {/* Separator */}
        <div
          style={{ borderColor: colors['border-secondary'] }}
          className="self-stretch h-px border-b my-1"
        />

        {/* Log out Option */}
        <button
          onClick={onLogout}
          onMouseEnter={() => setIsWorkspaceListVisible(false)}
          className="w-full px-1.5 py-px justify-start items-center inline-flex cursor-pointer"
        >
          <div
            style={
              {
                '--hover-bg': colors['bg-quaternary'],
              } as React.CSSProperties
            }
            className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-between items-center flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
          >
            <div className="flex items-center gap-2">
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/log-out-icon.svg`}
                className="w-4 h-4"
              />
              <div
                style={{ color: colors['text-primary'] }}
                className="text-sm font-normal font-['Inter'] leading-tight"
              >
                Log out
              </div>
            </div>
          </div>
        </button>
      </motion.div>
    </>
  );
}
</file>

<file path="app/dashboard/components/WorkspaceSettings.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { Workspace } from '@/types/workspace';
import ButtonNormal from '../../components/ButtonNormal';
import InputField from '../../components/InputFields';
import ButtonDestructive from '@/app/components/ButtonDestructive';
import { useColors } from '@/app/theme/hooks';
import Modal from '@/app/components/Modal';
import { checkWorkspaceName } from '@/app/utils/checkNames';
import { sanitizeWorkspaceNameInput } from '@/app/onboarding/utils/inputSanitizer';
import { toast } from 'sonner';
import Switch from '@/app/components/Switch';

interface WorkspaceSettingsProps {
  workspace: Workspace;
  onUpdate: (updates: Partial<Workspace>) => Promise<boolean>;
  onDelete?: (workspaceId: number) => Promise<void>;
}

// Maximum file size (1MB)
const MAX_FILE_SIZE = 1 * 1024 * 1024;

// Allowed image MIME types
const ALLOWED_IMAGE_TYPES = [
  'image/png',
  'image/jpeg',
  'image/gif',
  'image/svg+xml',
  'image/avif',
];

// Utility to check file extension if MIME type is missing or unreliable
function hasAllowedImageExtension(fileName: string): boolean {
  return /\.(png|jpe?g|gif|svg|avif)$/i.test(fileName);
}

export default function WorkspaceSettings({
  workspace,
  onUpdate,
  onDelete,
}: WorkspaceSettingsProps) {
  const colors = useColors();
  const [name, setName] = useState(workspace.name || '');
  const [url, setUrl] = useState('');
  const [urlPlaceholder, setUrlPlaceholder] = useState('');
  const [reportsEnabled, setReportsEnabled] = useState(true);
  const [emailsEnabled, setEmailsEnabled] = useState(true);
  const [logoFile, setLogoFile] = useState<File | null>(null);
  const [logoPreview, setLogoPreview] = useState<string | null>(
    workspace.icon_url || null
  );
  const [isUploadingLogo, setIsUploadingLogo] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [saveSuccess, setSaveSuccess] = useState(false);
  const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const [deleteConfirmText, setDeleteConfirmText] = useState('');
  const [copySuccess, setCopySuccess] = useState(false);
  const [error, setError] = useState('');
  const [nameError, setNameError] = useState('');
  const [brandingEnabled, setBrandingEnabled] = useState(
    workspace.branding_enabled || false
  );
  const fileInputRef = useRef<HTMLInputElement>(null);

  const isFreePlan = workspace.subscription?.plan_type === 'FREE';

  useEffect(() => {
    if (name) {
      const suggestedUrl = name
        .toLowerCase()
        .replace(/\s+/g, '-')
        .replace(/[^a-z0-9-]/g, '');

      setUrlPlaceholder(suggestedUrl);
    } else {
      setUrlPlaceholder('');
    }
  }, [name]);

  const handleBrandingToggle = async () => {
    const newBrandingStatus = !brandingEnabled;
    setBrandingEnabled(newBrandingStatus);
    await onUpdate({ branding_enabled: newBrandingStatus });
  };

  // Update name input handler to limit and sanitize
  const handleNameChange = (value: string) => {
    const sanitized = sanitizeWorkspaceNameInput(value);
    setName(sanitized);
  };

  // Update file change handler to check type and size
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) {
      setError('No file selected. Please choose an image file.');
      setLogoFile(null);
      setLogoPreview(null);
      return;
    }

    // Check file type and extension
    const isAllowedType = ALLOWED_IMAGE_TYPES.includes(file.type);
    const isAllowedExt = hasAllowedImageExtension(file.name);

    if (!isAllowedType && !isAllowedExt) {
      setError(
        'Invalid file type. Please upload a PNG, JPEG, GIF, SVG, or AVIF image.'
      );
      if (e.target) e.target.value = '';
      setLogoFile(null);
      setLogoPreview(null);
      return;
    }
    // Check file size before processing
    if (file.size > MAX_FILE_SIZE) {
      setError('File is too large. Maximum size is 1MB.');
      if (e.target) e.target.value = '';
      setLogoFile(null);
      setLogoPreview(null);
      return;
    }

    setError(''); // Clear any previous errors
    setLogoFile(file);
    const reader = new FileReader();
    reader.onloadend = () => {
      setLogoPreview(reader.result as string);
    };
    reader.readAsDataURL(file);
  };

  const handleLogoClick = () => {
    fileInputRef.current?.click();
  };

  const handleSave = async () => {
    if (isSaving) return;

    // Validate workspace name using utility function
    const nameCheck = checkWorkspaceName(name);
    if (nameCheck) {
      setNameError(nameCheck.description);
      return;
    } else {
      setNameError('');
    }

    setIsSaving(true);
    setSaveSuccess(false);

    try {
      const updates: Partial<Workspace> = {
        name,
        slug: name.toLowerCase().replace(/\s+/g, '-'),
      };

      if (logoFile) {
        setIsUploadingLogo(true);
        try {
          // Create a FormData object to upload the file
          const formData = new FormData();
          formData.append('file', logoFile);
          formData.append('workspaceId', workspace.id.toString());

          // Upload the logo file
          const uploadResponse = await fetch('/api/upload/workspace-logo', {
            method: 'POST',
            body: formData,
          });

          if (!uploadResponse.ok) {
            const errorData = await uploadResponse.json();
            throw new Error(errorData.error || 'Failed to upload logo');
          }

          // Get the URL of the uploaded file and update the logo preview
          const { url } = await uploadResponse.json();
          setLogoPreview(url);

          // We need to update workspace in the parent component
          // Since the API directly updates the database, we need to sync the state
          // with the updated data to ensure immediate UI updates
          const updatedWorkspace = {
            ...workspace,
            icon_url: url,
          };

          // Call onUpdate to ensure the parent component knows about the change
          const success = await onUpdate({
            icon_url: url,
          });
          if (!success) return;
        } catch (error) {
          console.error('Error uploading logo:', error);
          throw error;
        } finally {
          setIsUploadingLogo(false);
        }
      } else if (logoPreview === null && workspace.icon_url) {
        updates.icon_url = null as unknown as string;
      }

      if (
        updates.name !== workspace.name ||
        (logoPreview === null && workspace.icon_url)
      ) {
        const success = await onUpdate(updates);
        setSaveSuccess(success);

        if (success) {
          // Reset success message after a delay
          setTimeout(() => {
            setSaveSuccess(false);
          }, 3000);
        }
      }
    } catch (error) {
      console.error('Error saving workspace settings:', error);
      setSaveSuccess(false);
    } finally {
      setIsSaving(false);
    }
  };

  const handleDeleteClick = () => {
    setIsDeleteModalOpen(true);
  };

  const closeDeleteModal = () => {
    setIsDeleteModalOpen(false);
    setDeleteConfirmText('');
  };

  const handleDeleteWorkspace = async () => {
    if (!onDelete || deleteConfirmText !== workspace.name) return;

    setIsDeleting(true);
    try {
      await onDelete(workspace.id);
      // The parent component will handle redirecting after successful deletion
    } catch (error) {
      console.error('Error deleting workspace:', error);
      setIsDeleting(false);
      setIsDeleteModalOpen(false);
    }
  };

  const copyWorkspaceName = () => {
    try {
      navigator.clipboard
        .writeText(workspace.name)
        .then(() => {
          // Show success message
          setCopySuccess(true);
          // Hide it after 2 seconds
          setTimeout(() => {
            setCopySuccess(false);
          }, 2000);
        })
        .catch((err) => {
          console.error('Failed to copy workspace name: ', err);
        });
    } catch (error) {
      console.error('Copy to clipboard failed:', error);
    }
  };

  return (
    <div className="flex flex-col gap-6">
      {/* Header */}
      <div className="flex flex-col gap-5">
        <div className="flex justify-between items-start gap-4">
          <div className="flex flex-col gap-1">
            <h2
              style={{ color: colors['text-primary'] }}
              className="text-[18px] font-semibold"
            >
              Company profile
            </h2>
            <p style={{ color: colors['text-tertiary'] }} className="text-sm">
              Update your company photo and details here.
            </p>
          </div>
          <div className="flex items-center gap-3">
            <ButtonNormal variant="secondary" size="small">
              Cancel
            </ButtonNormal>
            <ButtonNormal
              variant="primary"
              size="small"
              onClick={handleSave}
              disabled={isSaving}
            >
              {isSaving ? (
                <div className="flex items-center gap-2">
                  <div className="animate-spin rounded-full h-3 w-3 border-2 border-t-transparent border-r-transparent"></div>
                  <span>Saving...</span>
                </div>
              ) : (
                'Save'
              )}
            </ButtonNormal>
          </div>
        </div>
        <div
          style={{ backgroundColor: colors['border-secondary'] }}
          className="h-px"
        />
      </div>

      {/* Content */}
      <div className="flex flex-col gap-5">
        {/* Public Profile Section */}
        <div className="flex gap-8">
          <div className="flex-1">
            <div className="flex items-center gap-0.5">
              <span
                style={{ color: colors['text-primary'] }}
                className="text-sm font-semibold"
              >
                Workspace name
              </span>
              <span style={{ color: colors['text-brand-tertiary'] }}>*</span>
            </div>
            <p style={{ color: colors['text-tertiary'] }} className="text-sm">
              This will be used to identify your workspace in the URL.
            </p>
          </div>
          <div className="flex-1 flex flex-col gap-4">
            <InputField
              type="default"
              value={name}
              onChange={handleNameChange}
              placeholder="Enter workspace name"
            />

            {nameError && (
              <div className="text-red-500 text-xs mt-1">{nameError}</div>
            )}
            <div className="flex">
              <span
                style={{
                  backgroundColor: colors['bg-secondary'],
                  borderColor: colors['border-secondary'],
                  color: colors['text-primary'],
                }}
                className="px-3.5 py-2.5 border border-r-0 rounded-l-lg"
              >
                app.process-flow.io/
              </span>
              <input
                type="text"
                placeholder={urlPlaceholder}
                value={url}
                readOnly
                style={{
                  borderColor: colors['border-secondary'],
                  color: colors['text-primary'],
                  backgroundColor: colors['bg-primary'],
                }}
                className="flex-1 px-3.5 py-2.5 border rounded-r-lg shadow-sm focus:outline-none cursor-default bg-gray-50"
                tabIndex={-1}
              />
            </div>
          </div>
        </div>

        <div
          style={{ backgroundColor: colors['border-secondary'] }}
          className="h-px hidden"
        />

        {/* Company Logo Section */}
        <div className="gap-8 flex">
          <div className="flex-1">
            <div className="flex flex-col gap-1">
              <div className="flex items-center">
                <span
                  style={{ color: colors['text-primary'] }}
                  className="text-sm font-semibold"
                >
                  Company logo
                </span>
                <span
                  style={{ color: colors['text-brand-tertiary'] }}
                  className="ml-0.5"
                >
                  *
                </span>
              </div>
              <span
                className="text-sm font-normal"
                style={{ color: colors['text-tertiary'] }}
              >
                Update your company logo and then choose where you want it to
                display.
              </span>
              <p
                style={{ color: colors['text-tertiary'] }}
                className="text-xs mt-1"
              >
                Maximum size: 1MB / Recommended size: 256x256px
              </p>
            </div>
          </div>
          <div className="flex-1 flex items-center gap-4">
            <input
              type="file"
              ref={fileInputRef}
              onChange={handleFileChange}
              accept="image/png,image/jpeg,image/gif,image/svg+xml,image/avif"
              className="hidden"
            />
            <div
              className="relative group cursor-pointer"
              onClick={handleLogoClick}
            >
              {logoPreview ? (
                <div className="relative">
                  <div
                    style={{
                      backgroundImage: `url(${logoPreview})`,
                      backgroundSize: 'cover',
                      backgroundPosition: 'center',
                      backgroundRepeat: 'no-repeat',
                      width: '50px',
                      height: '50px',
                      borderRadius: '8px',
                      border: `2px solid ${colors['border-secondary']}`,
                    }}
                    className="shadow-sm"
                  />
                  {/* Edit overlay on hover */}
                  <div className="absolute inset-0 bg-black bg-opacity-40 rounded-lg opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex items-center justify-center">
                    <div className="w-8 h-8 bg-white bg-opacity-20 rounded-full flex items-center justify-center">
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                        alt="Edit"
                        className="w-5 h-5 brightness-[10]"
                      />
                    </div>
                  </div>
                </div>
              ) : (
                <div className="relative">
                  <div
                    style={{
                      backgroundColor: colors['bg-brand'],
                      color: colors['text-brand'],
                    }}
                    className="w-20 h-20 rounded-lg flex items-center justify-center font-semibold text-xl"
                  >
                    {workspace.name
                      ? workspace.name.charAt(0).toUpperCase()
                      : 'U'}
                  </div>
                  {/* Edit overlay on hover */}
                  <div className="absolute inset-0 bg-black bg-opacity-40 rounded-lg opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex items-center justify-center">
                    <div className="w-8 h-8 bg-white bg-opacity-20 rounded-full flex items-center justify-center">
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/edit-05.svg`}
                        alt="Edit"
                        className="w-5 h-5 brightness-[10]"
                      />
                    </div>
                  </div>
                </div>
              )}
            </div>

            <div className="flex flex-col gap-2">
              {error && <div className="text-red-500 text-xs">{error}</div>}

              <div className="flex items-center gap-3">
                {logoPreview && (
                  <ButtonNormal
                    variant="tertiary"
                    size="small"
                    leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-icon.svg`}
                    onClick={(e) => {
                      e.preventDefault();
                      setLogoPreview(null);
                      setLogoFile(null);
                    }}
                  >
                    Remove
                  </ButtonNormal>
                )}
                {isUploadingLogo && (
                  <div className="flex items-center">
                    <div
                      className="animate-spin rounded-full h-5 w-5 border-2 border-t-transparent border-r-transparent"
                      style={{ borderColor: colors['text-brand'] }}
                    ></div>
                    <span
                      className="ml-2 text-sm"
                      style={{ color: colors['text-secondary'] }}
                    >
                      Uploading...
                    </span>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>

        <div
          style={{ backgroundColor: colors['border-secondary'] }}
          className="h-px hidden"
        />

        {/* Branding Section */}
        <div className="space-y-8 mt-8">
          <Switch
            isOn={brandingEnabled && !isFreePlan}
            handleToggle={handleBrandingToggle}
            label="Enable Branding"
            disabled={isFreePlan}
          />
          {brandingEnabled && !isFreePlan && (
            <>
              {/* Brand Logo Section */}
              <div>
                <h3
                  style={{ color: colors['text-primary'] }}
                  className="text-base font-medium mb-2"
                >
                  Brand Logo
                </h3>
                <div className="flex items-center gap-4">
                  {workspace?.brand_logo_url ? (
                    <div className="relative">
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_STORAGE_PATH}/${workspace.brand_logo_url}`}
                        alt="Brand Logo"
                        className="h-16 w-auto object-contain"
                      />
                      <button
                        onClick={async () => {
                          try {
                            const response = await fetch(
                              `/api/upload/workspace-brand-logo?workspaceId=${workspace.id}`,
                              {
                                method: 'DELETE',
                              }
                            );
                            if (!response.ok)
                              throw new Error('Failed to delete logo');
                            // Update workspace state
                            await onUpdate({
                              brand_logo_url: undefined,
                            });
                            toast.success('Brand logo removed successfully');
                          } catch (error) {
                            console.error('Error deleting logo:', error);
                            toast.error('Failed to remove brand logo');
                          }
                        }}
                        style={{
                          backgroundColor: colors['bg-primary'],
                          borderColor: colors['border-primary'],
                        }}
                        className="absolute -top-2 -right-2 w-6 h-6 rounded-full border flex items-center justify-center hover:opacity-80"
                      >
                        <span style={{ color: colors['text-primary'] }}></span>
                      </button>
                    </div>
                  ) : (
                    <div
                      style={{
                        backgroundColor: colors['bg-secondary'],
                        borderColor: colors['border-secondary'],
                      }}
                      className="h-16 w-32 border rounded-lg flex items-center justify-center"
                    >
                      <span
                        style={{ color: colors['text-tertiary'] }}
                        className="text-sm"
                      >
                        No logo
                      </span>
                    </div>
                  )}
                  <div>
                    <input
                      type="file"
                      id="brand-logo-upload"
                      accept="image/*"
                      className="hidden"
                      onChange={async (e) => {
                        const file = e.target.files?.[0];
                        if (!file || !workspace) return;
                        // Check file size (1MB limit)
                        if (file.size > 1024 * 1024) {
                          toast.error('File size must be less than 1MB');
                          return;
                        }
                        const formData = new FormData();
                        formData.append('file', file);
                        formData.append('workspaceId', workspace.id.toString());
                        try {
                          const response = await fetch(
                            '/api/upload/workspace-brand-logo',
                            {
                              method: 'POST',
                              body: formData,
                            }
                          );
                          if (!response.ok) throw new Error('Upload failed');
                          const data = await response.json();
                          // Update workspace state
                          await onUpdate({
                            brand_logo_url: data.filePath,
                          });
                          toast.success('Brand logo uploaded successfully');
                        } catch (error) {
                          console.error('Upload error:', error);
                          toast.error('Failed to upload brand logo');
                        }
                      }}
                    />
                    <ButtonNormal
                      variant="secondary"
                      size="small"
                      onClick={() =>
                        document.getElementById('brand-logo-upload')?.click()
                      }
                    >
                      Upload Logo
                    </ButtonNormal>
                    <p
                      style={{ color: colors['text-tertiary'] }}
                      className="text-xs mt-2"
                    >
                      Max file size: 1MB. Supported formats: PNG, JPG, GIF, SVG
                    </p>
                  </div>
                </div>
              </div>

              {/* Brand Name Image Section */}
              <div>
                <h3
                  style={{ color: colors['text-primary'] }}
                  className="text-base font-medium mb-2"
                >
                  Brand Name Image
                </h3>
                <div className="flex items-center gap-4">
                  {workspace?.brand_name_img_url ? (
                    <div className="relative">
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_STORAGE_PATH}/${workspace.brand_name_img_url}`}
                        alt="Brand Name"
                        className="h-16 w-auto object-contain"
                      />
                      <button
                        onClick={async () => {
                          try {
                            const response = await fetch(
                              `/api/upload/workspace-brand-name?workspaceId=${workspace.id}`,
                              {
                                method: 'DELETE',
                              }
                            );
                            if (!response.ok)
                              throw new Error('Failed to delete brand name');
                            // Update workspace state
                            await onUpdate({
                              brand_name_img_url: undefined,
                            });
                            toast.success(
                              'Brand name image removed successfully'
                            );
                          } catch (error) {
                            console.error('Error deleting brand name:', error);
                            toast.error('Failed to remove brand name image');
                          }
                        }}
                        style={{
                          backgroundColor: colors['bg-primary'],
                          borderColor: colors['border-primary'],
                        }}
                        className="absolute -top-2 -right-2 w-6 h-6 rounded-full border flex items-center justify-center hover:opacity-80"
                      >
                        <span style={{ color: colors['text-primary'] }}></span>
                      </button>
                    </div>
                  ) : (
                    <div
                      style={{
                        backgroundColor: colors['bg-secondary'],
                        borderColor: colors['border-secondary'],
                      }}
                      className="h-16 w-32 border rounded-lg flex items-center justify-center"
                    >
                      <span
                        style={{ color: colors['text-tertiary'] }}
                        className="text-sm"
                      >
                        No image
                      </span>
                    </div>
                  )}
                  <div>
                    <input
                      type="file"
                      id="brand-name-upload"
                      accept="image/*"
                      className="hidden"
                      onChange={async (e) => {
                        const file = e.target.files?.[0];
                        if (!file || !workspace) return;
                        // Check file size (1MB limit)
                        if (file.size > 1024 * 1024) {
                          toast.error('File size must be less than 1MB');
                          return;
                        }
                        const formData = new FormData();
                        formData.append('file', file);
                        formData.append('workspaceId', workspace.id.toString());
                        try {
                          const response = await fetch(
                            '/api/upload/workspace-brand-name',
                            {
                              method: 'POST',
                              body: formData,
                            }
                          );
                          if (!response.ok) throw new Error('Upload failed');
                          const data = await response.json();
                          // Update workspace state
                          await onUpdate({
                            brand_name_img_url: data.filePath,
                          });
                          toast.success(
                            'Brand name image uploaded successfully'
                          );
                        } catch (error) {
                          console.error('Upload error:', error);
                          toast.error('Failed to upload brand name image');
                        }
                      }}
                    />
                    <ButtonNormal
                      variant="secondary"
                      size="small"
                      onClick={() =>
                        document.getElementById('brand-name-upload')?.click()
                      }
                    >
                      Upload Brand Name
                    </ButtonNormal>
                    <p
                      style={{ color: colors['text-tertiary'] }}
                      className="text-s mt-2"
                    >
                      Max file size: 1MB. Supported formats: PNG, JPG, GIF, SVG
                    </p>
                  </div>
                </div>
              </div>
            </>
          )}
        </div>

        <div
          style={{ backgroundColor: colors['border-secondary'] }}
          className="h-px hidden"
        />

        {/* Branding Section */}
        <div className="hidden gap-8">
          <div className="flex-1 flex flex-col gap-3">
            <div className="flex flex-col">
              <span
                style={{ color: colors['text-primary'] }}
                className="text-sm font-semibold"
              >
                Branding
              </span>
              <p style={{ color: colors['text-tertiary'] }} className="text-sm">
                Add your logo to reports and emails.
              </p>
            </div>
          </div>
          <div className="flex-1 flex flex-col gap-4">
            <label className="flex items-start gap-2">
              <input
                type="checkbox"
                checked={reportsEnabled}
                onChange={(e) => setReportsEnabled(e.target.checked)}
                className="mt-1"
              />
              <div>
                <p
                  style={{ color: colors['text-primary'] }}
                  className="text-sm font-medium"
                >
                  Reports
                </p>
                <p
                  style={{ color: colors['text-tertiary'] }}
                  className="text-sm"
                >
                  Include my logo in summary reports.
                </p>
              </div>
            </label>
            <label className="flex items-start gap-2">
              <input
                type="checkbox"
                checked={emailsEnabled}
                onChange={(e) => setEmailsEnabled(e.target.checked)}
                className="mt-1"
              />
              <div>
                <p
                  style={{ color: colors['text-primary'] }}
                  className="text-sm font-medium"
                >
                  Emails
                </p>
                <p
                  style={{ color: colors['text-tertiary'] }}
                  className="text-sm"
                >
                  Include my logo in customer emails.
                </p>
              </div>
            </label>
          </div>
        </div>

        <div
          style={{ backgroundColor: colors['border-secondary'] }}
          className="h-px hidden"
        />

        {/* Danger Zone Section */}
        <div className="flex flex-col gap-6 mt-6">
          <div
            style={{ backgroundColor: colors['border-secondary'] }}
            className="h-px"
          />

          <div className="flex gap-8">
            <div className="flex-1 flex flex-col gap-3">
              <div className="flex flex-col">
                <span
                  style={{ color: colors['text-primary'] }}
                  className="text-sm font-semibold"
                >
                  Danger zone
                </span>
                <p
                  style={{ color: colors['text-tertiary'] }}
                  className="text-sm"
                >
                  Delete your workspace
                </p>
              </div>
            </div>
            <div className="flex-1 flex">
              <ButtonDestructive
                variant="secondary"
                size="small"
                onClick={handleDeleteClick}
              >
                Delete workspace
              </ButtonDestructive>
            </div>
          </div>
        </div>
      </div>

      {/* Buttons at the bottom */}
      <div className="flex justify-end gap-3 mt-8">
        {saveSuccess && (
          <div className="flex items-center text-green-600">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              className="h-5 w-5 mr-1"
              viewBox="0 0 20 20"
              fill="currentColor"
            >
              <path
                fillRule="evenodd"
                d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
                clipRule="evenodd"
              />
            </svg>
            <span>Changes saved</span>
          </div>
        )}
      </div>

      {/* Delete Workspace Confirmation Modal */}
      {isDeleteModalOpen && (
        <Modal
          onClose={closeDeleteModal}
          title="Delete workspace"
          icon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-delete.svg`}
          iconBackgroundColor="#fee3e1"
          actions={
            <>
              <ButtonNormal
                variant="secondary"
                size="small"
                onClick={closeDeleteModal}
                className="flex-1"
                disabled={isDeleting}
              >
                Cancel
              </ButtonNormal>
              <ButtonDestructive
                variant="primary"
                size="small"
                onClick={handleDeleteWorkspace}
                disabled={deleteConfirmText !== workspace.name || isDeleting}
                className="flex-1"
              >
                {isDeleting ? 'Deleting...' : 'Delete workspace'}
              </ButtonDestructive>
            </>
          }
          showActionsSeparator={true}
        >
          <div className="flex flex-col gap-4">
            <p style={{ color: colors['text-secondary'] }} className="text-sm">
              This action cannot be undone. This will permanently delete the
              workspace{' '}
              <span style={{ fontWeight: 'bold', userSelect: 'all' }}>
                {workspace.name}
              </span>{' '}
              and all of its data, including all workflows, folders, and
              settings.
            </p>
            <div
              style={{ color: colors['text-secondary'] }}
              className="text-sm mb-2"
            >
              <p>
                Please type{' '}
                <span style={{ fontWeight: 'bold' }}>{workspace.name}</span> to
                confirm.
              </p>
              <div className="flex items-center gap-2 mt-1">
                <button
                  onClick={copyWorkspaceName}
                  style={{
                    color: colors['primary'],
                    cursor: 'pointer',
                    fontSize: '12px',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '4px',
                    background: 'none',
                    border: 'none',
                    padding: 0,
                  }}
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="12"
                    height="12"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                  >
                    <rect
                      x="9"
                      y="9"
                      width="13"
                      height="13"
                      rx="2"
                      ry="2"
                    ></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                  </svg>
                  Copy workspace name
                </button>
                {copySuccess && (
                  <span
                    style={{
                      color: '#10B981', // Green color for success
                      fontSize: '12px',
                      display: 'flex',
                      alignItems: 'center',
                      gap: '2px',
                    }}
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="12"
                      height="12"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                    >
                      <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                    Copied!
                  </span>
                )}
              </div>
            </div>

            {/* Custom input field to match the style in ConfirmDeleteModal */}
            <div className="mt-1">
              <input
                type="text"
                placeholder={`Type "${workspace.name}" to confirm`}
                value={deleteConfirmText}
                onChange={(e) => setDeleteConfirmText(e.target.value)}
                className="w-full px-3 py-2 rounded-lg shadow-sm border text-sm"
                style={{
                  borderColor: colors['border-secondary'],
                  backgroundColor: colors['bg-primary'],
                  color: colors['text-primary'],
                }}
              />
            </div>
          </div>
        </Modal>
      )}
    </div>
  );
}
</file>

<file path="app/onboarding/components/CompletedStep.tsx">
'use client';

import React, { useRef } from 'react';
import ButtonNormal from '@/app/components/ButtonNormal';
import { useOnboarding } from '../context/OnboardingContext';

const CompletedStep: React.FC = () => {
  const videoRef = useRef<HTMLIFrameElement>(null);
  const {
    error,
    handleCompletedContinue,
    setCurrentStep,
    setError,
    setWorkspaceCreationStarted,
    workspaceInfo,
  } = useOnboarding();

  // Destructure from workspaceInfo
  const { isCreatingWorkflow, workflowCreationError } = workspaceInfo;

  // Add a manual logout function that will clear all authentication data
  const handleEmergencyLogout = () => {
    // Clear all storage data
    localStorage.clear();
    sessionStorage.clear();

    // Clear any auth cookies by setting them to expired
    document.cookie.split(';').forEach((c) => {
      document.cookie = c
        .replace(/^ +/, '')
        .replace(/=.*/, `=;expires=${new Date().toUTCString()};path=/`);
    });

    // Force reload to the root page
    window.location.href = '/';
  };

  return (
    <div
      className="w-full max-w-[600px] flex flex-col gap-6 mx-auto"
      data-testid="completed-step"
    >
      <div className="text-center text-2xl font-semibold font-['Inter'] text-gray-900">
        {isCreatingWorkflow
          ? 'Setting up your workspace'
          : error
            ? 'Workspace Setup Issue'
            : 'Your workspace is ready!'}
      </div>
      <div className="text-center text-base font-normal font-['Inter'] text-gray-600">
        {isCreatingWorkflow
          ? 'This will take less than a minute.'
          : error
            ? 'We encountered an issue while setting up your workspace.'
            : 'Watch this short video to get started with ProcessFlow.'}
      </div>
      {/* Video Container - Only show when no error */}
      {!error && (
        <div className="w-full aspect-video rounded-lg mb-4 bg-gray-100 overflow-hidden">
          <iframe
            ref={videoRef}
            className="w-full h-full"
            src="https://www.youtube.com/embed/8WyxhEpbx14"
            title="ProcessFlow Introduction"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowFullScreen
          ></iframe>
        </div>
      )}
      {/* Creation Status */}
      <div className="flex flex-col items-center gap-4">
        {isCreatingWorkflow ? (
          <div className="flex items-center gap-3">
            <div className="w-6 h-6 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
            <span className="text-gray-600">Setting up your workspace...</span>
          </div>
        ) : error ? (
          <div className="flex flex-col items-center gap-3">
            <div className="flex items-center gap-3">
              <svg
                className="w-6 h-6 text-red-500"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  d="M6 18L18 6M6 6l12 12"
                ></path>
              </svg>
              <span className="text-red-500">{error}</span>
            </div>
            <div className="mt-2 text-sm text-center text-gray-600">
              You can still proceed to the dashboard and try creating a
              workspace again.
            </div>
          </div>
        ) : (
          <div className="flex items-center gap-3">
            <svg
              className="w-6 h-6 text-green-500"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth="2"
                d="M5 13l4 4L19 7"
              ></path>
            </svg>
            <span data-testid="workspace-ready-message" className="text-gray-600">
              Your workspace is ready to use!
            </span>
          </div>
        )}
        {workflowCreationError && !isCreatingWorkflow && !error && (
          <div className="flex items-center gap-3">
            <svg
              className="w-6 h-6 text-yellow-500"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth="2"
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              ></path>
            </svg>
            <span className="text-yellow-500">{workflowCreationError}</span>
          </div>
        )}
      </div>
      {/* Continue Button - Always enabled after initial loading */}
      <div className="mt-6">
        <ButtonNormal
          variant="primary"
          size="small"
          onClick={handleCompletedContinue}
          disabled={isCreatingWorkflow}
          className="w-full"
        >
          {error ? 'Continue to Dashboard Anyway' : 'Continue to Dashboard'}
        </ButtonNormal>
      </div>
      {/* Retry Button - Show when there's an error */}
      {error && error.includes('workspace with the name') && (
        <div className="mt-2">
          <ButtonNormal
            variant="secondary"
            size="small"
            onClick={() => {
              setCurrentStep('WORKSPACE_SETUP');
              setError('');
              setWorkspaceCreationStarted(false);
              localStorage.removeItem('workspaceCreationStarted');
            }}
            className="w-full"
          >
            Go Back and Change Workspace Name
          </ButtonNormal>
        </div>
      )}
      {/* Emergency Logout Button */}
      <div className="mt-4 hidden">
        <button
          onClick={handleEmergencyLogout}
          className="w-full text-red-500 text-sm font-medium py-2 hover:underline focus:outline-none"
        >
          Logout
        </button>
      </div>
    </div>
  );
};

export default CompletedStep;
</file>

<file path="app/onboarding/components/PersonalInfoStep.tsx">
'use client';

import React from 'react';
import InputField from '@/app/components/InputFields';
import ButtonNormal from '@/app/components/ButtonNormal';
import { useOnboarding } from '../context/OnboardingContext';
import { sanitizeNameInput } from '../utils/inputSanitizer';

const PersonalInfoStep: React.FC = () => {
  const {
    personalInfo: { firstName, lastName, setFirstName, setLastName },
    isLoading,
    submitPersonalInfo,
  } = useOnboarding();

  const handleLastNameChange = (value: string) => {
    // Allow spaces and special characters, only limit length
    if (value.length <= 40) {
      const sanitized = sanitizeNameInput(value);
      setLastName(sanitized);
    }
  };

  const handleFirstNameChange = (value: string) => {
    // Allow spaces and special characters, only limit length
    if (value.length <= 40) {
      const sanitized = sanitizeNameInput(value);
      setFirstName(sanitized);
    }
  };

  return (
    <div
      className="w-full max-w-[442px] flex flex-col gap-6 mx-auto"
      data-testid="personal-info-step"
    >
      <div className="text-center text-2xl font-semibold font-['Inter'] text-gray-900 dark:text-white">
        Welcome to ProcessFlow!
      </div>
      <div className="text-center text-base font-normal font-['Inter'] text-gray-600 dark:text-gray-300">
        You can always change your name later.
      </div>
      <div className="pt-6 flex-col gap-6 flex">
        <InputField
          dataTestId="last-name-input"
          label="Last Name"
          placeholder="Jobs"
          value={lastName}
          onChange={handleLastNameChange}
          type="default"
          size="medium"
        />
        <InputField
          dataTestId="first-name-input"
          label="First Name"
          placeholder="Steve"
          value={firstName}
          onChange={handleFirstNameChange}
          type="default"
          size="medium"
        />
        <div className="mt-4">
          <ButtonNormal
            variant="primary"
            size="small"
            onClick={submitPersonalInfo}
            disabled={isLoading || !firstName || !lastName}
            className="w-full"
          >
            {isLoading ? 'Loading...' : 'Continue'}
          </ButtonNormal>
        </div>
      </div>
    </div>
  );
};

export default PersonalInfoStep;
</file>

<file path="app/onboarding/components/ProgressIndicator.tsx">
'use client';

import React from 'react';
import { useOnboarding } from '../context/OnboardingContext';

const ProgressIndicator: React.FC = () => {
  const { currentStep } = useOnboarding();

  return (
    <div
      className="flex items-center justify-center w-64 my-4 mx-auto"
      data-testid="progress-indicator"
    >
      {/* First step indicator */}
      {currentStep === 'PERSONAL_INFO' ? (
        // Active first step
        <div
          className="relative z-10 flex items-center justify-center w-8 h-8 rounded-full border-2 border-[#4761c4]"
          style={{ backgroundColor: '#edf0fb' }}
        >
          <div className="flex items-center justify-center w-6 h-6 bg-[#4761c4] rounded-full">
            <div className="w-2 h-2 bg-white rounded-full" />
          </div>
        </div>
      ) : (
        // Completed first step
        <img
          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/validated-step-icon.svg`}
          alt="Validated step icon"
          className="w-8 h-8"
        />
      )}

      {/* First connecting line */}
      <div
        className={`flex-grow h-[1px] mx-2 ${
          currentStep === 'PERSONAL_INFO' ? 'bg-[#e4e7ec]' : 'bg-[#4761c4]'
        }`}
      />

      {/* Second step indicator */}
      {currentStep === 'PROFESSIONAL_INFO' ? (
        // Active second step
        <div
          className="relative z-10 flex items-center justify-center w-8 h-8 rounded-full border-2 border-[#4761c4]"
          style={{ backgroundColor: '#edf0fb' }}
        >
          <div className="flex items-center justify-center w-6 h-6 bg-[#4761c4] rounded-full">
            <div className="w-2 h-2 bg-white rounded-full" />
          </div>
        </div>
      ) : currentStep === 'PERSONAL_INFO' ? (
        // Inactive second step
        <div
          className="relative z-10 flex items-center justify-center w-8 h-8 rounded-full border border-[#e4e7ec]"
          style={{ backgroundColor: '#f9fafb' }}
        >
          <div className="flex items-center justify-center w-6 h-6 rounded-full border border-[#e4e7ec]">
            <div className="w-2 h-2 bg-[#d0d5dd] rounded-full" />
          </div>
        </div>
      ) : (
        // Completed second step
        <img
          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/validated-step-icon.svg`}
          alt="Validated step icon"
          className="w-8 h-8"
        />
      )}

      {/* Second connecting line */}
      <div
        className={`flex-grow h-[1px] mx-2 ${
          currentStep === 'PERSONAL_INFO' || currentStep === 'PROFESSIONAL_INFO'
            ? 'bg-[#e4e7ec]'
            : 'bg-[#4761c4]'
        }`}
      />

      {/* Third step indicator */}
      {currentStep === 'WORKSPACE_SETUP' ? (
        // Active third step
        <div
          className="relative z-10 flex items-center justify-center w-8 h-8 rounded-full border-2 border-[#4761c4]"
          style={{ backgroundColor: '#edf0fb' }}
        >
          <div className="flex items-center justify-center w-6 h-6 bg-[#4761c4] rounded-full">
            <div className="w-2 h-2 bg-white rounded-full" />
          </div>
        </div>
      ) : currentStep === 'COMPLETED' ? (
        // Completed third step
        <img
          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/validated-step-icon.svg`}
          alt="Validated step icon"
          className="w-8 h-8"
        />
      ) : (
        // Inactive third step
        <div
          className="relative z-10 flex items-center justify-center w-8 h-8 rounded-full border border-[#e4e7ec]"
          style={{ backgroundColor: '#f9fafb' }}
        >
          <div className="flex items-center justify-center w-6 h-6 rounded-full border border-[#e4e7ec]">
            <div className="w-2 h-2 bg-[#d0d5dd] rounded-full" />
          </div>
        </div>
      )}
    </div>
  );
};

export default ProgressIndicator;
</file>

<file path="app/onboarding/components/WorkspaceSetupStep.tsx">
'use client';

import React, { useState, useRef, useEffect, useCallback } from 'react';
import ButtonNormal from '@/app/components/ButtonNormal';
import InputField from '@/app/components/InputFields';
import { useOnboarding } from '../context/OnboardingContext';
import { checkWorkspaceName } from '@/app/utils/checkNames';
import {
  sanitizeWorkspaceNameInput,
  generateSlugFromName,
} from '../utils/inputSanitizer';

const WorkspaceSetupStep: React.FC = () => {
  const {
    workspaceInfo: {
      workspaceName,
      workspaceURL,
      logo,
      logoFile,
      setWorkspaceName,
      setWorkspaceURL,
      setLogo,
      setLogoFile,
    },
    isLoading,
    isNavigatingBack,
    error,
    setError,
    submitWorkspaceSetup,
    goToPreviousStep,
  } = useOnboarding();

  // UI states
  const [isFocused, setIsFocused] = useState(false);
  const [urlError, setUrlError] = useState('');
  const [showWorkspaceNameError, setShowWorkspaceNameError] = useState(false);
  const [isCheckingSlug, setIsCheckingSlug] = useState(false);
  const [slugAvailability, setSlugAvailability] = useState<{
    available: boolean;
    message: string;
  } | null>(null);

  // References
  const slugCheckTimeoutRef = useRef<NodeJS.Timeout>();
  const fileInputRef = useRef<HTMLInputElement | null>(null);

  // Constants for file upload
  const ALLOWED_IMAGE_TYPES = [
    'image/png',
    'image/jpeg',
    'image/jpg',
    'image/gif',
    'image/svg+xml',
    'image/avif',
  ];
  const MAX_IMAGE_SIZE_MB = 5;
  const MAX_IMAGE_SIZE_BYTES = MAX_IMAGE_SIZE_MB * 1024 * 1024;

  // Check slug availability
  const checkSlugAvailability = useCallback(async (slug: string) => {
    if (!slug) {
      setSlugAvailability(null);
      return;
    }

    try {
      setIsCheckingSlug(true);
      const response = await fetch(
        `/api/workspace/check-slug?slug=${encodeURIComponent(slug)}`
      );
      const data = await response.json();

      setSlugAvailability({
        available: data.available,
        message: data.message,
      });
    } catch (error) {
      console.error('Error checking slug availability:', error);
      setSlugAvailability(null);
    } finally {
      setIsCheckingSlug(false);
    }
  }, []);

  // Clean up slug check timeout
  useEffect(() => {
    return () => {
      if (slugCheckTimeoutRef.current) {
        clearTimeout(slugCheckTimeoutRef.current);
      }
    };
  }, []);

  // Handle workspace name input change
  const handleWorkspaceNameChange = (value: string) => {
    const sanitized = sanitizeWorkspaceNameInput(value);
    setWorkspaceName(sanitized);

    // Generate the URL slug from the workspace name
    const slug = generateSlugFromName(sanitized);
    setWorkspaceURL(slug);

    // Clear any existing timeout
    if (slugCheckTimeoutRef.current) {
      clearTimeout(slugCheckTimeoutRef.current);
    }

    // Set new timeout for slug check
    slugCheckTimeoutRef.current = setTimeout(() => {
      checkSlugAvailability(slug);
    }, 500);
  };

  // Handle URL change
  const handleURLChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setWorkspaceURL(value);

    // Check for invalid characters
    const hasInvalidChars = /[^a-zA-Z0-9-]/.test(value);

    if (hasInvalidChars && value !== '') {
      setUrlError('Only letters, numbers, and hyphens (-) are allowed');
      setSlugAvailability(null);
      setError('');
    } else {
      setUrlError('');

      // Clear any existing timeout
      if (slugCheckTimeoutRef.current) {
        clearTimeout(slugCheckTimeoutRef.current);
      }

      // Set new timeout for slug check
      slugCheckTimeoutRef.current = setTimeout(() => {
        checkSlugAvailability(value);
      }, 500);
    }
  };

  // File upload handlers
  const handleFileUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      // Type check
      if (!ALLOWED_IMAGE_TYPES.includes(file.type)) {
        setError(
          'Invalid file type. Please upload a PNG, JPG, GIF, or SVG image.'
        );
        return;
      }
      // Size check
      if (file.size > MAX_IMAGE_SIZE_BYTES) {
        setError(`File is too large. Maximum size is ${MAX_IMAGE_SIZE_MB}MB.`);
        return;
      }

      setLogoFile(file);
      setError('');

      // Convert the file to a base64 string for proper storage and API transmission
      const reader = new FileReader();
      reader.onloadend = () => {
        const base64String = reader.result as string;
        setLogo(base64String);
      };
      reader.readAsDataURL(file);
    }
  };

  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
  };

  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    const file = e.dataTransfer.files?.[0];
    if (file) {
      // Type check
      if (!ALLOWED_IMAGE_TYPES.includes(file.type)) {
        setError(
          'Invalid file type. Please upload a PNG, JPG, GIF, or SVG image.'
        );
        return;
      }
      // Size check
      if (file.size > MAX_IMAGE_SIZE_BYTES) {
        setError(`File is too large. Maximum size is ${MAX_IMAGE_SIZE_MB}MB.`);
        return;
      }

      setLogoFile(file);
      setError('');

      // Convert the file to a base64 string for proper storage and API transmission
      const reader = new FileReader();
      reader.onloadend = () => {
        const base64String = reader.result as string;
        setLogo(base64String);
      };
      reader.readAsDataURL(file);
    }
  };

  const handleFileInputClick = () => {
    fileInputRef.current?.click();
  };

  // Focus/blur handlers
  const handleFocus = () => {
    setIsFocused(true);
  };

  const handleBlur = () => {
    setIsFocused(false);
  };

  // Form validation
  const isFormValid = () => {
    if (!workspaceName) return false;
    // Only allow letters, numbers, spaces, and hyphens in workspace name
    if (/[^a-zA-Z0-9\- ]/.test(workspaceName)) return false;
    if (/[^a-zA-Z0-9-]/.test(workspaceURL)) return false;
    if (!slugAvailability || !slugAvailability.available) return false;
    return true;
  };

  // Handle submit workspace
  const handleSubmitWorkspace = () => {
    if (!workspaceName || !isFormValid()) {
      if (!workspaceName) {
        setError('Workspace name is required');
        setShowWorkspaceNameError(true);
      }
      // Show error for invalid workspace name
      if (/[^a-zA-Z0-9\- ]/.test(workspaceName)) {
        setError(
          'Workspace name can only contain letters, numbers, spaces, and hyphens'
        );
      }
      if (urlError) {
        setError('Please fix the URL format before continuing');
      }
      return;
    }

    const nameError = checkWorkspaceName(workspaceName);
    if (nameError) {
      setError(nameError.title + ' : ' + nameError.description);
      return;
    }

    // Submit to context
    submitWorkspaceSetup();
  };

  return (
    <div
      className="w-full max-w-[442px] flex flex-col gap-4 sm:gap-6 mx-auto mb-8"
      data-testid="workspace-setup-step"
    >
      <div className="self-stretch flex-col justify-start items-center gap-2 sm:gap-4 flex">
        <div className="self-stretch text-center text-xl sm:text-2xl font-semibold font-['Inter'] leading-relaxed sm:leading-loose text-gray-900 dark:text-white">
          Set up your workspace
        </div>
        <div className="self-stretch text-center text-sm sm:text-base font-normal font-['Inter'] leading-normal text-gray-600 dark:text-gray-300">
          You will still be able to modify your workspace later.
        </div>
      </div>

      {/* Only show error if it's not related to slug availability */}
      {error && !error.includes('workspace URL') && (
        <div className="self-stretch text-center text-red-600 text-sm font-normal">
          {error}
        </div>
      )}

      <div className="w-full flex-col justify-start items-start gap-4 sm:gap-6 flex pt-4 sm:pt-6">
        {/* Workspace Name Input */}
        <InputField
          dataTestId="workspace-name-input"
          label="Workspace Name"
          required
          type="default"
          placeholder="Processflow"
          value={workspaceName}
          onChange={handleWorkspaceNameChange}
          disabled={isLoading}
          destructive={!!error && !workspaceName}
          errorMessage={
            error && !workspaceName ? 'Workspace name is required' : ''
          }
        />

        {/* Workspace URL Input */}
        <div className="w-full flex-col justify-start items-start gap-1.5 flex">
          <div className="text-sm font-medium font-['Inter'] leading-tight text-gray-900 dark:text-white">
            Workspace URL
          </div>
          <div className="w-full flex items-center rounded-lg shadow-[0px_1px_2px_0px_rgba(16,24,40,0.05)] border transition-all duration-200 bg-white dark:bg-gray-900 border-gray-300 dark:border-gray-700">
            <div className="min-w-fit px-3 py-2 rounded-tl-lg rounded-bl-lg">
              <span className="text-gray-600 dark:text-gray-300">
                app.process-flow.io/
              </span>
            </div>
            <input
              type="text"
              disabled
              value={workspaceURL}
              onFocus={handleFocus}
              onBlur={handleBlur}
              onChange={handleURLChange}
              placeholder={
                workspaceName
                  .toLowerCase()
                  .replace(/\s+/g, '-')
                  .replace(/[^a-zA-Z0-9-]/g, '') || 'processflow'
              }
              className="flex-grow w-full px-3 py-2 rounded-tr-lg rounded-br-lg border-l focus:outline-none transition-colors duration-200 bg-white dark:bg-gray-900 border-l-gray-300 dark:border-l-gray-700 text-gray-900 dark:text-white"
            />
          </div>
          {urlError && (
            <div className="text-red-500 text-xs mt-1">{urlError}</div>
          )}
          {!urlError && (
            <div
              className={`text-xs mt-1 ${
                isCheckingSlug
                  ? 'text-gray-500'
                  : slugAvailability
                    ? slugAvailability.available
                      ? 'text-green-600'
                      : 'text-red-500'
                    : ''
              }`}
            >
              {isCheckingSlug
                ? 'Checking availability...'
                : slugAvailability
                  ? slugAvailability.message
                  : ''}
            </div>
          )}
        </div>

        {/* Workspace Logo Upload */}
        <div className="self-stretch flex-col justify-start items-start gap-2 flex">
          <div className="w-40 text-sm font-medium font-['Inter'] leading-tight text-gray-900 dark:text-white">
            Workspace Logo
          </div>
          <div className="self-stretch flex flex-col sm:flex-row items-center gap-3 sm:gap-5">
            {/* Upload Circle */}
            <label
              htmlFor="logo-upload"
              className="w-16 h-16 flex-shrink-0 flex items-center justify-center rounded-full border cursor-pointer bg-white dark:bg-gray-900 border-gray-300 dark:border-gray-700"
            >
              {logo ? (
                <img
                  src={logo}
                  alt="Workspace Logo"
                  className="w-16 h-16 rounded-full object-cover"
                />
              ) : (
                <img
                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/image-plus.svg`}
                  alt="Add Workspace Logo"
                  className="w-8 h-8"
                />
              )}
            </label>
            <input
              ref={fileInputRef}
              id="logo-upload"
              type="file"
              accept="image/*"
              onChange={handleFileUpload}
              className="hidden"
            />

            {/* Drag & Drop Zone */}
            <div
              className="w-full flex-grow flex-col justify-start items-start gap-4 cursor-pointer mt-2 sm:mt-0"
              onDragOver={handleDragOver}
              onDrop={handleDrop}
              onClick={handleFileInputClick}
            >
              <div className="w-full h-[74px] px-3 sm:px-6 py-3 sm:py-4 rounded-xl border hover:border-[#4E6BD7] transition-colors duration-300 flex flex-col justify-start items-center gap-1 bg-white dark:bg-gray-900 border-gray-300 dark:border-gray-700">
                <div className="w-full h-[42px] flex flex-col justify-center items-center gap-1 sm:gap-3">
                  <div className="w-full flex flex-col justify-center items-center">
                    <div className="w-full flex flex-wrap justify-center items-center gap-1 text-xs sm:text-sm">
                      <div className="flex justify-center items-center gap-1 overflow-hidden">
                        <div className="font-semibold font-['Inter'] leading-tight text-[#4761c4]">
                          Click to upload
                        </div>
                      </div>
                      <div className="font-normal font-['Inter'] leading-tight text-gray-600 dark:text-gray-300">
                        or drag and drop
                      </div>
                    </div>
                    <div className="w-full text-center text-xs font-normal font-['Inter'] leading-[18px] text-gray-600 dark:text-gray-300">
                      SVG, PNG, JPG or GIF (max. 800400px)
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Buttons */}
      <div className="h-10 flex flex-row justify-between items-start w-full mt-4 sm:mt-6 gap-4">
        <ButtonNormal
          variant="secondary"
          size="small"
          onClick={goToPreviousStep}
          className="w-1/3"
        >
          Back
        </ButtonNormal>

        <ButtonNormal
          variant="primary"
          size="small"
          onClick={handleSubmitWorkspace}
          disabled={
            isLoading || !isFormValid() || isNavigatingBack || isCheckingSlug
          }
          className="w-2/3"
        >
          {isLoading ? 'Loading...' : 'Continue'}
        </ButtonNormal>
      </div>
    </div>
  );
};

export default WorkspaceSetupStep;
</file>

<file path="app/onboarding/context/OnboardingContext.tsx">
'use client';

import React, { createContext, useContext, useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';

export type OnboardingStep =
  | 'PERSONAL_INFO'
  | 'PROFESSIONAL_INFO'
  | 'WORKSPACE_SETUP'
  | 'COMPLETED';

interface OnboardingContextType {
  // Step management
  currentStep: OnboardingStep;
  setCurrentStep: (step: OnboardingStep) => void;
  goToNextStep: () => void;
  goToPreviousStep: () => void;

  // Global state
  isLoading: boolean;
  setIsLoading: (loading: boolean) => void;
  error: string;
  setError: (error: string) => void;
  isLoadingInitialState: boolean;

  // Flags
  workspaceCreationStarted: boolean;
  setWorkspaceCreationStarted: (started: boolean) => void;
  isNavigatingBack: boolean;
  setIsNavigatingBack: (navigating: boolean) => void;

  // Step data
  personalInfo: {
    firstName: string;
    lastName: string;
    setFirstName: (name: string) => void;
    setLastName: (name: string) => void;
  };

  professionalInfo: {
    industry: string;
    role: string;
    companySize: string;
    source: string;
    setIndustry: (industry: string) => void;
    setRole: (role: string) => void;
    setCompanySize: (size: string) => void;
    setSource: (source: string) => void;
  };

  workspaceInfo: {
    workspaceName: string;
    workspaceURL: string;
    logo: string | null;
    logoFile: File | null;
    isCreatingWorkflow: boolean;
    isWorkflowCreated: boolean;
    workflowCreationError: string;
    setWorkspaceName: (name: string) => void;
    setWorkspaceURL: (url: string) => void;
    setLogo: (logo: string | null) => void;
    setLogoFile: (file: File | null) => void;
    setIsCreatingWorkflow: (creating: boolean) => void;
    setIsWorkflowCreated: (created: boolean) => void;
    setWorkflowCreationError: (error: string) => void;
    createWorkspace: () => Promise<void>;
  };

  // API Functions
  submitPersonalInfo: () => Promise<void>;
  submitProfessionalInfo: (forceComplete?: boolean) => Promise<void>;
  submitWorkspaceSetup: () => void;

  // Completed step functions
  handleCompletedContinue: () => Promise<void>;
}

export const OnboardingContext = createContext<
  OnboardingContextType | undefined
>(undefined);

export const OnboardingProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const router = useRouter();
  const [currentStep, setCurrentStep] =
    useState<OnboardingStep>('PERSONAL_INFO');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [isLoadingInitialState, setIsLoadingInitialState] =
    useState<boolean>(true);
  const [workspaceCreationStarted, setWorkspaceCreationStarted] =
    useState(false);
  const [isNavigatingBack, setIsNavigatingBack] = useState(false);

  // Personal Info state
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  // Professional Info state
  const [industry, setIndustry] = useState('');
  const [role, setRole] = useState('');
  const [companySize, setCompanySize] = useState('');
  const [source, setSource] = useState('');

  // Workspace setup state
  const [workspaceName, setWorkspaceName] = useState('');
  const [workspaceURL, setWorkspaceURL] = useState('');
  const [logo, setLogo] = useState<string | null>(null);
  const [logoFile, setLogoFile] = useState<File | null>(null);
  const [isCreatingWorkflow, setIsCreatingWorkflow] = useState(false);
  const [isWorkflowCreated, setIsWorkflowCreated] = useState(false);
  const [workflowCreationError, setWorkflowCreationError] = useState('');

  // Check server-side onboarding status
  useEffect(() => {
    const checkServerOnboardingStatus = async () => {
      try {
        setIsLoadingInitialState(true);
        const response = await fetch('/api/auth/check-onboarding');

        if (response.ok) {
          const data = await response.json();
          console.log('Server onboarding status:', data);

          // If the server says onboarding is completed, redirect to dashboard
          if (data.completed) {
            router.push('/');
            return;
          }

          // Trust the server's state about what step we're on
          const serverStep = data.onboardingStep as OnboardingStep;

          // Override local state with server state
          setCurrentStep(serverStep);

          // Only set workspace creation started if we're on the COMPLETED step
          const shouldMarkCreationStarted = serverStep === 'COMPLETED';
          setWorkspaceCreationStarted(shouldMarkCreationStarted);

          // Sync localStorage with server state
          if (shouldMarkCreationStarted) {
            localStorage.setItem('workspaceCreationStarted', 'true');
          } else {
            localStorage.removeItem('workspaceCreationStarted');
          }
        } else {
          console.error(
            'Error fetching onboarding status:',
            await response.text()
          );
        }
      } catch (error) {
        console.error('Exception checking onboarding status:', error);
      } finally {
        setIsLoadingInitialState(false);
      }
    };

    checkServerOnboardingStatus();
  }, [router]);

  // Load saved data for each step
  useEffect(() => {
    // Skip if we're still loading the initial state from server
    if (isLoadingInitialState) return;

    // Load personal info
    if (currentStep === 'PERSONAL_INFO') {
      const savedData = localStorage.getItem('personalInfoData');
      if (savedData) {
        try {
          const parsedData = JSON.parse(savedData);
          setFirstName(parsedData.firstName || '');
          setLastName(parsedData.lastName || '');
        } catch (e) {
          console.warn('Error loading saved personal info data:', e);
        }
      }
    }

    // Load professional info
    if (currentStep === 'PROFESSIONAL_INFO') {
      const savedData = localStorage.getItem('professionalInfoData');
      if (savedData) {
        try {
          const parsedData = JSON.parse(savedData);
          setIndustry(parsedData.industry || '');
          setRole(parsedData.role || '');
          setCompanySize(parsedData.companySize || '');
          setSource(parsedData.source || '');
        } catch (e) {
          console.warn('Error loading saved form data:', e);
        }
      }
    }

    // Load workspace setup data
    if (currentStep === 'WORKSPACE_SETUP') {
      const savedData = localStorage.getItem('workspaceSetupData');
      if (savedData) {
        try {
          const parsedData = JSON.parse(savedData);
          if (parsedData.workspaceName) {
            setWorkspaceName(parsedData.workspaceName);
          }
          if (parsedData.workspaceURL) setWorkspaceURL(parsedData.workspaceURL);
          if (parsedData.logo) setLogo(parsedData.logo);
        } catch (e) {
          console.warn('Error loading saved workspace data:', e);
        }
      }
    }

    // Start creating workspace and workflow when user reaches the completed step
    if (
      currentStep === 'COMPLETED' &&
      !isWorkflowCreated &&
      !isCreatingWorkflow &&
      !error
    ) {
      createWorkspace();

      // Set flag that workspace creation has started if not already set
      if (!workspaceCreationStarted) {
        setWorkspaceCreationStarted(true);
      }
    }
  }, [
    currentStep,
    workspaceCreationStarted,
    isLoadingInitialState,
    isWorkflowCreated,
    isCreatingWorkflow,
    error,
  ]);

  // Save form data when it changes
  useEffect(() => {
    if (currentStep === 'PERSONAL_INFO' && (firstName || lastName)) {
      localStorage.setItem(
        'personalInfoData',
        JSON.stringify({
          firstName,
          lastName,
        })
      );
    }

    if (
      currentStep === 'PROFESSIONAL_INFO' &&
      (industry || role || companySize || source)
    ) {
      localStorage.setItem(
        'professionalInfoData',
        JSON.stringify({
          industry,
          role,
          companySize,
          source,
        })
      );
    }

    if (
      currentStep === 'WORKSPACE_SETUP' &&
      (workspaceName || workspaceURL || logo)
    ) {
      localStorage.setItem(
        'workspaceSetupData',
        JSON.stringify({
          workspaceName,
          workspaceURL,
          logo,
        })
      );
    }
  }, [
    firstName,
    lastName,
    industry,
    role,
    companySize,
    source,
    workspaceName,
    workspaceURL,
    logo,
    currentStep,
  ]);

  // Step navigation functions
  const goToNextStep = () => {
    switch (currentStep) {
      case 'PERSONAL_INFO':
        setCurrentStep('PROFESSIONAL_INFO');
        break;
      case 'PROFESSIONAL_INFO':
        setCurrentStep('WORKSPACE_SETUP');
        break;
      case 'WORKSPACE_SETUP':
        setCurrentStep('COMPLETED');
        break;
      default:
        break;
    }
  };

  const goToPreviousStep = () => {
    // If workspace creation has started, don't allow navigation back
    if (workspaceCreationStarted) {
      setCurrentStep('COMPLETED');
      return;
    }

    switch (currentStep) {
      case 'PROFESSIONAL_INFO':
        setCurrentStep('PERSONAL_INFO');
        break;
      case 'WORKSPACE_SETUP':
        setCurrentStep('PROFESSIONAL_INFO');
        break;
      case 'COMPLETED':
        setCurrentStep('WORKSPACE_SETUP');
        break;
      default:
        break;
    }
  };

  // Form submission functions
  const submitPersonalInfo = async () => {
    if (!firstName || !lastName) {
      return; // Validation simple
    }

    // First update the UI state to provide immediate feedback
    setCurrentStep('PROFESSIONAL_INFO');

    // Then make the API call in the background
    setIsLoading(true);
    try {
      await fetch('/api/onboarding/email', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          step: 'PERSONAL_INFO',
          data: {
            first_name: firstName,
            last_name: lastName,
            full_name: `${firstName} ${lastName}`,
            onboarding_step: 'PROFESSIONAL_INFO',
          },
        }),
      });
    } catch (error) {
      console.error('Error updating personal info:', error);
      // Don't reset the step on error - just log it
    } finally {
      setIsLoading(false);
    }
  };

  const submitProfessionalInfo = async (forceComplete?: boolean) => {
    if (!industry || !role || !companySize || !source) {
      setError('Please fill in all fields');
      return;
    }

    // First update the UI state to provide immediate feedback
    setCurrentStep(forceComplete ? 'COMPLETED' : 'WORKSPACE_SETUP');
    setError('');

    // Then make the API call in the background
    setIsLoading(true);
    try {
      await fetch('/api/onboarding/email', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          step: 'PROFESSIONAL_INFO',
          data: {
            industry,
            professional_role: role,
            company_size: companySize,
            source,
            onboarding_step: forceComplete ? 'COMPLETED' : 'WORKSPACE_SETUP',
            forceComplete,
          },
        }),
      });

      // if (forceComplete) {
      //   await fetch('/api/user/onboarding-complete', {
      //     method: 'POST',
      //     headers: { 'Content-Type': 'application/json' },
      //   });
      //   setCurrentStep('COMPLETED');
      //   // window.location.href = '/';
      //   return;
      // }
    } catch (error) {
      console.error(
        'Client error:',
        error instanceof Error ? error.message : 'Unknown error'
      );
      // Don't show error message or reset the step if API fails
    } finally {
      setIsLoading(false);
    }
  };

  const submitWorkspaceSetup = () => {
    if (!workspaceName) {
      setError('Workspace name is required');
      return;
    }

    // Just transition to completed step without creating workspace yet
    setCurrentStep('COMPLETED');
  };

  // Workspace creation function
  const createWorkspace = async () => {
    // Prevent multiple simultaneous attempts
    if (isLoading || isCreatingWorkflow) return;

    setIsLoading(true);
    setError('');
    setIsCreatingWorkflow(true);

    // Mark that workspace creation has started - prevents going back to previous steps
    setWorkspaceCreationStarted(true);
    localStorage.setItem('workspaceCreationStarted', 'true');

    // Get the initial slug
    let currentSlug =
      workspaceURL ||
      workspaceName
        .toLowerCase()
        .replace(/\s+/g, '-')
        .replace(/[^a-zA-Z0-9-]/g, '');

    const MAX_RETRIES = 5;
    let retryCount = 0;
    let success = false;

    // console.log(`Attempting to create workspace with name: "${workspaceName}" and slug: "${currentSlug}"`);

    while (!success && retryCount <= MAX_RETRIES) {
      try {
        const response = await fetch('/api/onboarding/email', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            step: 'WORKSPACE_SETUP',
            data: {
              workspace_name: workspaceName,
              workspace_url: currentSlug,
              workspace_icon_url: logo || null,
              onboarding_step: 'COMPLETED',
            },
          }),
        });

        if (response.ok) {
          success = true;
          if (process.env.NODE_ENV === 'development') {
            console.log(
              `Workspace created successfully with slug: "${currentSlug}"`
            );
          }

          // Verify that onboarding state is properly updated on the server
          const onboardingCheck = await fetch('/api/auth/check-onboarding');
          if (onboardingCheck.ok) {
            const onboardingData = await onboardingCheck.json();
            if (process.env.NODE_ENV === 'development') {
              console.log(
                'Onboarding status after workspace creation:',
                onboardingData
              );
            }

            if (!onboardingData.completed) {
              console.warn(
                'Server still shows onboarding as incomplete after workspace creation'
              );
            }
          }

          // After workspace creation succeeds, create the default workflow
          setIsWorkflowCreated(true);
        } else {
          const data = await response.json();
          console.error('Workspace creation failed with error:', data);

          // Check for slug constraint violation
          const isSlugError =
            data.error &&
            ((data.error.includes('constraint failed') &&
              data.error.includes('slug')) ||
              data.error.includes('duplicate key') ||
              data.error.includes('already exists') ||
              data.error.includes('unique constraint'));

          if (isSlugError) {
            retryCount++;

            if (retryCount <= MAX_RETRIES) {
              currentSlug = `${
                workspaceURL ||
                workspaceName
                  .toLowerCase()
                  .replace(/\s+/g, '-')
                  .replace(/[^a-zA-Z0-9-]/g, '')
              }-${retryCount}`;
              console.log(
                `Retrying workspace creation with modified slug: "${currentSlug}" (attempt ${retryCount} of ${MAX_RETRIES})`
              );
            } else {
              console.error(
                `Max retries (${MAX_RETRIES}) reached. Unable to create workspace.`
              );
              setError(
                `Unable to create workspace with the name "${workspaceName}". Please try a different name.`
              );
              setIsWorkflowCreated(false);
            }
          } else {
            console.error('Non-slug related error:', data.error);
            setError(
              data.error || 'An error occurred while creating your workspace'
            );
            setIsWorkflowCreated(false);
            break;
          }
        }
      } catch (error) {
        console.error('Exception during workspace creation:', error);
        setError('A connection error occurred. Please try again.');
        setIsWorkflowCreated(false);
        break;
      }
    }

    setIsLoading(false);
    setIsCreatingWorkflow(false);
  };

  // Handle completed step continue button
  const handleCompletedContinue = async () => {
    // Clear all onboarding data
    localStorage.removeItem('personalInfoData');
    localStorage.removeItem('professionalInfoData');
    localStorage.removeItem('workspaceSetupData');

    // Verify with the server that onboarding is actually complete
    try {
      const response = await fetch('/api/auth/check-onboarding');
      if (response.ok) {
        const data = await response.json();

        if (!data.completed) {
          console.warn(
            'Server reports onboarding incomplete, but proceeding to dashboard'
          );

          // Force update on server that onboarding is complete to prevent being stuck
          await fetch('/api/onboarding/force-complete', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
          }).catch((err) => {
            console.error('Failed to force complete onboarding:', err);
          });
        }
      }
    } catch (error) {
      console.error('Error verifying onboarding completion:', error);
    }

    // Force navigation to dashboard even if there were errors
    router.push('/');
  };

  const value = {
    currentStep,
    setCurrentStep,
    goToNextStep,
    goToPreviousStep,

    isLoading,
    setIsLoading,
    error,
    setError,
    isLoadingInitialState,

    workspaceCreationStarted,
    setWorkspaceCreationStarted,
    isNavigatingBack,
    setIsNavigatingBack,

    personalInfo: {
      firstName,
      lastName,
      setFirstName,
      setLastName,
    },

    professionalInfo: {
      industry,
      role,
      companySize,
      source,
      setIndustry,
      setRole,
      setCompanySize,
      setSource,
    },

    workspaceInfo: {
      workspaceName,
      workspaceURL,
      logo,
      logoFile,
      isCreatingWorkflow,
      isWorkflowCreated,
      workflowCreationError,
      setWorkspaceName,
      setWorkspaceURL,
      setLogo,
      setLogoFile,
      setIsCreatingWorkflow,
      setIsWorkflowCreated,
      setWorkflowCreationError,
      createWorkspace,
    },

    submitPersonalInfo,
    submitProfessionalInfo,
    submitWorkspaceSetup,

    handleCompletedContinue,
  };

  return (
    <OnboardingContext.Provider value={value}>
      {children}
    </OnboardingContext.Provider>
  );
};

export const useOnboarding = () => {
  const context = useContext(OnboardingContext);
  if (context === undefined) {
    throw new Error('useOnboarding must be used within an OnboardingProvider');
  }
  return context;
};
</file>

<file path="app/BodyClassProvider.tsx">
"use client";
import { usePathname } from "next/navigation";
import { useEffect } from "react";

export function BodyClassProvider({ children }: { children: React.ReactNode }) {
  const pathname = usePathname();
  const isOnboarding = pathname?.startsWith("/onboarding") ?? false;
  
  useEffect(() => {
    if (isOnboarding) {
      document.body.classList.add("force-light-theme");
    } else {
      document.body.classList.remove("force-light-theme");
    }
  }, [isOnboarding]);

  return children;
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import Script from 'next/script';
import './globals.css';
import { PostHogProvider } from './providers';
import { FastThemeProvider } from './context/FastThemeContext';
import AuthCheck from './components/AuthCheck';
import { Toaster } from 'sonner';
import { BodyClassProvider } from './BodyClassProvider';
import { SpeedInsights } from '@vercel/speed-insights/next';
// Import environment checker
import '../lib/env-check';

const inter = Inter({ subsets: ['latin'] });

// Server-side environment check
function checkServerEnvironment() {
  return;
  if (process.env.NODE_ENV !== 'production') {
    const stripeKey = process.env.STRIPE_SECRET_KEY;
    if (!stripeKey) {
      console.warn(' Server-side check: STRIPE_SECRET_KEY is missing!');
      console.warn(
        'Available env vars:',
        Object.keys(process.env)
          .filter((key) => !key.includes('SECRET') && !key.includes('KEY'))
          .join(', ')
      );
    } else {
      console.log(' STRIPE_SECRET_KEY is available on the server');
    }
  }
  return null;
}

// Run the check during server rendering
checkServerEnvironment();

export const metadata: Metadata = {
  title: 'ProcessFlow',
  description: '',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html className="font-sans" lang="en">
      <head>
        {/* Google Font preconnect for performance */}
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link
          rel="preconnect"
          href="https://fonts.gstatic.com"
          crossOrigin="anonymous"
        />

        {/* Favicons */}
        <link rel="icon" type="image/png" sizes="32x32" href="/32x32.png" />
        <link rel="icon" type="image/png" sizes="48x48" href="/48x48.png" />
        <link rel="icon" type="image/png" sizes="64x64" href="/64x64.png" />
        <link rel="icon" type="image/png" sizes="256x256" href="/256x256.png" />
        <link rel="icon" type="image/png" sizes="512x512" href="/512x512.png" />
        <link
          rel="stylesheet"
          href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap"
        />
      </head>
      <body>
        <BodyClassProvider>
          <FastThemeProvider>
            <PostHogProvider>
              <AuthCheck>{children}</AuthCheck>
              <Toaster />
              <SpeedInsights />
            </PostHogProvider>
          </FastThemeProvider>
          {/* External Scripts - Load after interactive */}
          <Script
            src="https://media-editor.cloudinary.com/all.js"
            strategy="afterInteractive"
          />
          <Script
            src="//js.hs-scripts.com/47874121.js"
            strategy="afterInteractive"
            id="hs-script-loader"
          />
        </BodyClassProvider>
      </body>
    </html>
  );
}
</file>

<file path="e2e/features/authentication/authentication_email_confirmation.feature">
Feature: Email Confirmation Flow
  As a new user
  I want to confirm my email address
  So that I can complete my registration

  # Scenario: Email confirmation success
  #   Given I have registered with email "user@example.com"
  #   And I received a confirmation email
  #   When I click the confirmation link in the email
  #   Then I should be redirected to "/auth/confirm"
  #   And my email should be marked as confirmed
  #   And I should be automatically logged in
  #   And I should be redirected to "/onboarding"

  # Scenario: Email confirmation with invalid token
  #   When I access "/auth/confirm" with an invalid token
  #   Then I should see an error message
  #   And my email should remain unconfirmed

  # Scenario: Resending confirmation email
  #   Given I have registered but not confirmed my email
  #   When I try to log in
  #   Then I should see option to resend confirmation email
  #   When I click "resend confirmation"
  #   Then a new confirmation email should be sent
</file>

<file path="e2e/features/authentication/authentication_login.feature">
Feature: User Authentication
  As a registered user
  I want to log into my account
  So that I can access ProcessFlow

  Background:
    Given I am on the login page
    And I am not authenticated

  # Scenario: Successful login with confirmed email (new user)
  #   Given a new user exists with email "newuser@example.com" and confirmed email
  #   And the user has not completed onboarding
  #   When I enter email "newuser@example.com"
  #   And I enter the correct password
  #   And I click the "Log in" button
  #   Then I should be logged in successfully
  #   And I should be redirected to "/onboarding"
  #   And a session cookie should be set

  # Scenario: Successful login with confirmed email (existing user)
  #   Given an existing user with email "user@example.com" and confirmed email
  #   And the user has completed onboarding
  #   When I enter email "user@example.com"
  #   And I enter the correct password
  #   And I click the "Log in" button
  #   Then I should be logged in successfully
  #   And I should be redirected to the dashboard "/"
  #   And a session cookie should be set

  # Scenario: Login attempt with unconfirmed email
  #   Given a user exists with email "unconfirmed@example.com" and unconfirmed email
  #   When I enter email "unconfirmed@example.com"
  #   And I enter the correct password
  #   And I click the "Log in" button
  #   Then I should see message "Please confirm your email before logging in"
  #   And I should not be logged in

  # Scenario: Login with invalid credentials
  #   When I enter email "user@example.com"
  #   And I enter an incorrect password
  #   And I click the "Log in" button
  #   Then I should see error "Login Failed"
  #   And I should not be logged in
  #   And the failed attempt should be tracked

  # Scenario: Login with invalid email format
  #   When I enter an invalid email "invalid-email"
  #   And I enter any password
  #   And I click the "Log in" button
  #   Then I should see error "Invalid Email"
  #   And the login should not proceed

  # Scenario: Google OAuth login (new user)
  #   When I click "Log in with Google"
  #   Then I should be redirected to Google OAuth
  #   And after successful Google authentication
  #   Then I should be redirected to "/auth/callback"
  #   And I should be logged in automatically
  #   And I should be redirected to "/onboarding"

  # Scenario: Google OAuth login (existing user)
  #   Given an existing user with Google account
  #   And the user has completed onboarding
  #   When I click "Log in with Google"
  #   Then I should be redirected to Google OAuth
  #   And after successful Google authentication
  #   Then I should be redirected to "/auth/callback"
  #   And I should be logged in automatically
  #   And I should be redirected to the dashboard
</file>

<file path="e2e/features/authentication/authentication_registration.feature">
Feature: User Registration
  As a new user
  I want to create an account
  So that I can access ProcessFlow

  Background:
    Given I am on the signup page
    And I am not authenticated

  # Scenario: Successful email/password registration
  #   When I enter a valid email "user@example.com"
  #   And I enter a strong password "StrongPass123!"
  #   And I click the "Sign up" button
  #   Then I should see a success message
  #   And I should be redirected to login page with pre-filled email
  #   And a confirmation email should be sent to "user@example.com"

  # Scenario: Registration with weak password
  #   When I enter a valid email "user@example.com"
  #   And I enter a weak password "123"
  #   And I click the "Sign up" button
  #   Then I should see error "Password must be at least 8 characters and include uppercase, lowercase, number, and special character."
  #   And the signup should not proceed

  # Scenario: Registration with invalid email
  #   When I enter an invalid email "invalid-email"
  #   And I enter a strong password "StrongPass123!"
  #   And I click the "Sign up" button
  #   Then I should see error "Please enter a valid email address."
  #   And the signup should not proceed

  # Scenario: Registration with existing email
  #   Given a user already exists with email "existing@example.com"
  #   When I enter email "existing@example.com"
  #   Then the system should perform an immediate email availability check
  #   And no visual feedback should be shown about email existence
  #   When I enter a strong password "StrongPass123!"
  #   And I click the "Sign up" button
  #   Then the system should perform a final email existence check
  #   And I should see message "If your signup was successful, check your email."
  #   And no new account should be created
  #   And no confirmation email should be sent
  #   And I should be redirected to login page with pre-filled email

  # Scenario: Google OAuth registration
  #   When I click "Sign up with Google"
  #   Then I should be redirected to Google OAuth
  #   And after successful Google authentication
  #   Then I should be redirected to "/auth/callback"
  #   And a new user account should be created
  #   And I should be redirected to the onboarding page
</file>

<file path="e2e/features/authentication/authentication_security.feature">
Feature: Authentication Security
  As a security-conscious system
  I want to protect against authentication attacks
  So that user accounts remain secure

  # Scenario: Rate limiting on failed login attempts
  #   Given I am on the login page
  #   When I make 30 failed login attempts within 10 minutes
  #   Then I should be blocked from further attempts
  #   And I should see message "Too many failed attempts"
  #   And I should be blocked for 10 minutes
  #   And the block timer should count down

  # Scenario: Rate limiting on auth routes
  #   Given I am accessing authentication routes
  #   When I make more than 20 requests per minute
  #   Then I should receive a "429 Too many requests" response
  #   And further requests should be blocked

  # Scenario: Password strength validation
  #   Given I am on the signup page
  #   When I enter a password without uppercase letters
  #   Then I should see password strength error
  #   When I enter a password without lowercase letters
  #   Then I should see password strength error
  #   When I enter a password without numbers
  #   Then I should see password strength error
  #   When I enter a password without special characters
  #   Then I should see password strength error
  #   When I enter a password shorter than 8 characters
  #   Then I should see password strength error

  # Scenario: Session management
  #   Given I am logged in
  #   When my session is valid
  #   Then I should have access to protected routes
  #   When my session expires
  #   Then I should be redirected to login page
  #   When I log out
  #   Then my session should be invalidated
  #   And I should be redirected to login page
</file>

<file path="e2e/features/dashboard/access_and_layout.feature">
Feature: Dashboard Access and Layout
  As a logged-in user
  I want to access and navigate the dashboard
  So that I can manage my workflows and workspace

  Background:
    Given I am a logged-in user
    And I have completed onboarding
    And I am on the dashboard page "/"

  # Scenario: Dashboard loads successfully
  #   When I access the dashboard
  #   Then I should see the sidebar with workspace information on the left corner
  #   And I should see the main canvas area
  #   And I should see the "My Flows" header
  #   And I should see my user profile in the header bar on the right

  # Scenario: Recently used workflows section
  #   Given I have workflows with recent activity
  #   When I view the dashboard
  #   Then I should see a "Recently Used" section
  #   And it should show up to 4 most recently used workflows
  #   And workflows should be ordered by last_opened timestamp

  # Scenario: Empty state handling
  #   Given I have no workflows in my workspace
  #   When I view the dashboard
  #   Then I should see an appropriate empty state like 'No workflows found'
  #   And I should see options to create my first workflow
</file>

<file path="e2e/features/dashboard/error_handling_and_edge_cases.feature">
Feature: Error Handling and Edge Cases
  As a user
  I want the system to handle errors gracefully
  So that I can continue working even when issues occur

  Background:
    Given I am on the dashboard

  # Scenario: Network connectivity issues
  #   When I lose network connectivity
  #   And I try to perform an action
  #   Then I should see an appropriate error message like "Something went wrong. Please try again."
  #   And the action should not complete
  #   When connectivity is restored 
  #   Then I should be able to retry the action 

  # Scenario: API failure handling
  #   When an API call fails during workflow creation
  #   Then I should see an error notification like "Failed to create workflow"
  #   And the modal should remain open
  #   And I should be able to retry the operation

  # Scenario: File upload failures
  #   When a file upload fails due to network issues
  #   And I should be able to retry the upload
  #   When the upload succeeds on retry
  #   Then I should see a success confirmation

  # Scenario: Validation error handling
  #   When I submit a form with invalid data
  #   Then I should see specific validation errors like "Name is required"
  #   And the form should not submit
  #   And invalid fields should be highlighted
  #   When I correct the errors
  #   Then the validation should clear
  #   And I should be able to submit successfully

  # Scenario: Browser refresh handling
  #   When I refresh the page during an operation
  #   Then I should return to a consistent state
  #   And any unsaved changes should be handled appropriately
  #   And I should see appropriate notifications about lost changes like "Changes not saved"

  # Scenario: Modal and overlay error handling
  #   When an error occurs while a modal is open
  #   Then the error should be displayed within the modal context like "An error occurred"
  #   And I should have options to retry or cancel
  #   When multiple modals are triggered simultaneously
  #   Then they should be handled in a logical order
  #   And the UI should remain stable
</file>

<file path="e2e/features/dashboard/folder_management.feature">
Feature: Folder Management
  As a user
  I want to organize my workflows in folders
  So that I can maintain a structured workspace

  Background:
    Given I am on the dashboard
    And I have folder management permissions

  # Scenario: Creating a new folder
  #   When I click the "+" button next to folders
  #   Then I should see the "Create a folder" modal
  #   When I enter folder name "HR Processes"
  #   And I select an icon or emoji
  #   And I click "Create"
  #   Then the folder should appear in the sidebar
  #   And I should see a success notification

  # Scenario: Folder name validation
  #   When I create a folder
  #   And I leave the folder name empty
  #   Then the "Create" button should be disabled
  #   When I enter a folder name with 101 characters
  #   Then only the first 100 characters should be accepted
  #   And an error message should be displayed like "Folder name must be less than 100 characters"
  #   And the "Create" button should be disabled

  # Scenario: Creating a subfolder
  #   Given I have a folder named "HR Processes"
  #   When I right-click on the folder
  #   And I select "Create subfolder"
  #   Then I should see the "Create a Subfolder" modal
  #   And I should see the parent folder context
  #   When I enter subfolder name "Onboarding"
  #   And I click "Create"
  #   Then the subfolder should appear under the parent folder

  # Scenario: Editing a folder
  #   Given I have a folder named "HR Processes"
  #   When I right-click on the folder
  #   And I select "Edit folder"
  #   Then I should see the "Edit a folder" modal
  #   And the form should be pre-filled with current folder data
  #   When I change the name to "Human Resources"
  #   And I click "Save changes"
  #   Then the folder should show the updated name

  # Scenario: Deleting a folder
  #   Given I have a folder with no workflows
  #   When I right-click on the folder
  #   And I select "Delete folder"
  #   Then I should see a confirmation modal
  #   And it should warn that the action cannot be undone
  #   And it should mention that flows inside will not be deleted
  #   When I click "Delete"
  #   Then the folder should be removed
  #   And any workflows should remain in the workspace

  # Scenario: Folder icon and emoji selection
  #   When I create or edit a folder
  #   And I click the icon selector
  #   Then I should see icon selection options
  #   When I select a company logo
  #   Then the logo should be applied to the folder
  #   When I select an emoji
  #   Then the emoji should be displayed as the folder icon

  # Scenario: Folder expansion and collapse
  #   Given I have a folder with subfolders
  #   When I click the folder expand/collapse arrow
  #   Then the folder should expand to show subfolders
  #   When I click the arrow again
  #   Then the folder should collapse to hide subfolders

  # Scenario: Navigating to folder contents
  #   Given I have a folder with workflows
  #   When I click on the folder name
  #   Then the main canvas should show only workflows in that folder
  #   And the header should show the folder name and icon
  #   And I should see a breadcrumb or back navigation option
</file>

<file path="e2e/features/dashboard/help_and_tutorial.feature">
Feature: Help and Tutorial
  As a user
  I want to access help and tutorial features
  So that I can learn how to use the platform effectively

  Background:
    Given I am on the dashboard

  # Scenario: Accessing help center
  #   When I click on my user profile
  #   And I select "Help center"
  #   Then I should see the help center modal
  #   And I should see options for different types of help

  # Scenario: Help center options
  #   When I open the help center
  #   Then I should see "Reach out to us" option
  #   And I should see "Take a look at our roadmap" option
  #   And I should see "Join our Slack community" option
  #   When I click "Reach out to us"
  #   Then my email client should open with a pre-filled email
  #   When I click "Join our Slack community"
  #   Then I should be redirected to the Slack invitation link

  # Scenario: Tutorial functionality
  #   When I access the tutorial option
  #   Then I should see the tutorial overlay
  #   And I should see step-by-step guidance
  #   When I click "Next" on tutorial steps
  #   Then I should progress through the tutorial
  #   And relevant UI elements should be highlighted

  # Scenario: Tutorial navigation
  #   When I am in the tutorial
  #   Then I should see current step indicators
  #   And I should see options to skip or continue
  #   When I click "Skip"
  #   Then the tutorial should end
  #   And I should return to normal dashboard view

  # Scenario: Tutorial completion
  #   When I complete all tutorial steps
  #   Then the tutorial should end automatically
  #   And my tutorial status should be marked as complete
  #   And I should not see tutorial prompts again

  # Scenario: Restarting tutorial
  #   Given I have completed the tutorial previously
  #   When I access the help center
  #   And I select restart tutorial option
  #   Then the tutorial should start from the beginning
  #   And my tutorial status should be reset
</file>

<file path="e2e/features/dashboard/search_and_filtering.feature">
Feature: Search and Filtering
  As a user
  I want to search and filter my workflows
  So that I can quickly find what I need

  Background:
    Given I am on the dashboard
    And I have multiple workflows and folders

  # Scenario: Basic workflow search
  #   When I enter "onboarding" in the search bar
  #   Then I should see only workflows containing "onboarding" in the name
  #   And other workflows should be hidden
  #   When I clear the search
  #   Then all workflows should be visible again

  # Scenario: Search with no results
  #   When I enter "nonexistent" in the search bar
  #   Then I should see a "no results" message
  #   And no workflows should be displayed

  # Scenario: Search is case insensitive
  #   When I enter "ONBOARDING" in the search bar
  #   Then I should see workflows containing "onboarding" (lowercase)
  #   And the search should work regardless of case

  # Scenario: Real-time search filtering
  #   When I start typing in the search bar
  #   Then the results should update in real-time
  #   And I should not need to press Enter to search

  # Scenario: Search within specific folder
  #   Given I am viewing a specific folder
  #   When I enter a search term
  #   Then I should see only workflows from that folder matching the search
  #   And workflows from other folders should not appear

  # Scenario: Folder filtering
  #   When I select a folder from the sidebar
  #   Then the main canvas should show only workflows in that folder
  #   And the header should indicate the current folder
  #   When I select "My Flows" (root level)
  #   Then I should see all workflows not in folders
</file>

<file path="e2e/features/dashboard/settings_and_configuration.feature">
Feature: Settings and Configuration
  As a user
  I want to configure my workspace and billing settings
  So that I can customize my experience and manage my subscription

  Background:
    Given I am on the dashboard
    And I have access to settings

  # Scenario: Navigating settings tabs
  #   When I open settings
  #   Then I should see tabs for Plan, billing, workspace and appearance
  #   When I click on the workspace tab
  #   Then I should see workspace-specific settings
  #   When I click on the billing tab
  #   Then I should see billing and subscription information

  # Scenario: Workspace settings management
  #   When I am in workspace settings
  #   Then I should see the current workspace name and logo
  #   When I change the workspace name
  #   And I click "Save changes"
  #   Then the workspace should be updated
  #   And the changes should be reflected throughout the UI

  # Scenario: Workspace logo upload - valid file types
  #   When I upload a PNG file smaller than 5MB
  #   Then the logo should be accepted and displayed
  #   When I upload a JPEG file smaller than 5MB
  #   Then the logo should be accepted and displayed
  #   When I upload an SVG file smaller than 5MB
  #   Then the logo should be accepted and displayed
  #   When I upload a file with an invalid type
  #   Then I should see an error message like "Invalid file type. Please upload a PNG, JPG, GIF, or SVG image."
  #   When I upload a file with an invalid size
  #   Then I should see an error message like "File is too large. Maximum size is 5MB."
  #   And the file should not be accepted

  # Scenario: Workspace name validation
  #   When I am in workspace settings
  #   And I leave the workspace name empty
  #   Then I should see a validation error like "Workspace name is required"
  #   And the "Save" button should be disabled
  #   When I enter a workspace name with 51 characters
  #   Then only the first 50 characters should be accepted
  #   And I should see a validation error like "Workspace name cannot be longer than 50 characters"
  #   When I enter workspace name with invalid characters "Invalid!Name@#$"
  #   Then the invalid characters should be removed automatically
  #   And only valid characters (letters, numbers, spaces, hyphens) should remain
  #   When I enter a valid workspace name "My Company-123"
  #   Then the validation should clear
  #   And the "Save" button should be enabled

  # Scenario: Billing information display
  #   When I am in billing settings
  #   Then I should see my current subscription plan
  #   And I should see billing address information
  #   And I should see payment method details if configured
  #   When I click "Edit Billing Details"
  #   Then I should be redirected to the Stripe customer portal

  # Scenario: Subscription plan management
  #   Given I have a subscription
  #   When I am in billing settings
  #   Then I should see options to change my plan
  #   And I should see billing period options (monthly/annual)
  #   When I select a different plan
  #   Then I should see pricing information
  #   And I should be able to confirm the change

  # Scenario: Plan downgrade confirmation
  #   Given I have a paid subscription
  #   When I attempt to downgrade to a free plan
  #   Then I should see a confirmation dialog
  #   And I should see information about feature limitations
  #   When I confirm the downgrade
  #   Then my plan should be changed
  #   And I should see updated feature access

  # Scenario: Workspace deletion
  #   When I am in workspace settings
  #   And I click "Delete workspace"
  #   Then I should see a confirmation dialog
  #   And I should be required to type the workspace name
  #   When I enter the correct workspace name and confirm
  #   Then the workspace should be deleted
  #   And I should be redirected appropriately
</file>

<file path="e2e/features/dashboard/user_profile_management.feature">
Feature: User Profile Management
  As a user
  I want to manage my profile and account settings
  So that I can keep my information current and secure

  Background:
    Given I am logged in to the dashboard
    And I can access user settings

  # Scenario: Accessing user settings
  #   When I click on my user profile in the header bar on the right
  #   Then I should see a user dropdown menu
  #   When I select "Account settings"
  #   Then I should see the user settings page

  # Scenario: Updating profile information
  #   When I am in user settings
  #   And I change my first name to "John"
  #   And I change my last name to "Doe"
  #   And I click "Save changes"
  #   Then my profile should be updated
  #   And I should see a success notification
  #   And the changes should be reflected in the UI

  # Scenario: Profile information validation
  #   When I am editing my profile
  #   And I enter a first name with 41 characters
  #   Then only the first 40 characters should be accepted
  #   When I enter special characters in my name
  #   Then the input should be sanitized appropriately

  # Scenario: Changing email address
  #   When I am in user settings
  #   And I enter a new email address
  #   And I click "Change email"
  #   Then I should see a confirmation dialog
  #   When I confirm the change
  #   Then a verification email should be sent
  #   And I should see instructions to verify the new email

  # Scenario: Email validation
  #   When I enter an invalid email format
  #   Then I should see an error message
  #   And the save button should be disabled
  #   When I enter a valid email format
  #   Then the error should clear
  #   And the save button should be enabled

  # Scenario: Changing password
  #   When I am in user settings
  #   And I click "Change password"
  #   Then I should see a password change form
  #   When I enter my current password
  #   And I enter a new password
  #   And I confirm the new password
  #   And I click "Update password"
  #   Then I should see a confirmation dialog
  #   When I confirm the password change
  #   Then my password should be updated
  #   And I should be logged out of other devices

  # Scenario: Password validation
  #   When I am changing my password
  #   And I enter a password shorter than 8 characters
  #   Then I should see a validation error
  #   When I enter a password without uppercase letters
  #   Then I should see a validation error
  #   When I enter a password without lowercase letters
  #   Then I should see a validation error
  #   When I enter a password without numbers
  #   Then I should see a validation error
  #   When I enter a password without special characters
  #   Then I should see a validation error
  #   When I enter mismatched password confirmations
  #   Then I should see a validation error
  #   When I enter a valid password "StrongPass123!"
  #   And I confirm the same password "StrongPass123!"
  #   Then the validation should clear
  #   And the save button should be enabled

  # Scenario: Account deletion
  #   When I am in user settings
  #   And I click "Delete account"
  #   Then I should see a confirmation dialog
  #   And I should be required to enter my password
  #   When I enter my password and confirm deletion
  #   Then my account should be deleted
  #   And I should be redirected to the home page
</file>

<file path="e2e/features/dashboard/workflow_management.feature">
Feature: Workflow Management
  As a user
  I want to manage my workflows
  So that I can organize and maintain my processes

  Background:
    Given I am on the dashboard
    And I have access to workflow management features

  # Scenario: Creating a new workflow
  #   When I click the "New Flow" button
  #   Then I should see the "Create a new Flow" modal
  #   When I enter flow name like "Employee Onboarding"
  #   And I enter flow description like "Process for onboarding new employees"
  #   And I click the "Create Flow" button
  #   Then the modal should close
  #   And I should immeditely go into the new workflow
  #   And I should see a success notification like "Flow created successfully"

  # Scenario: Workflow name validation during creation
  #   When I open the create flow modal
  #   And I leave the flow name empty
  #   Then the "Create Flow" button should be disabled
  #   When I enter a flow name with 101 characters
  #   Then only the first 100 characters should be accepted
  #   Then I should see a validation error like "Flow name must be less than 100 characters"
  #   And the "Create Flow" button should be disabled
  #   When I enter flow name with special characters "<script>alert('xss')</script>"
  #   Then the input should be sanitized

  # Scenario: Editing an existing workflow
  #   Given I have a workflow named "Test Workflow"
  #   When I click the workflow actions menu
  #   And I select "Edit"
  #   Then I should see the "Edit a Flow" modal
  #   And the form should be pre-filled with current workflow data
  #   When I change the name to "Updated Workflow"
  #   And I click "Save changes"
  #   Then the modal should close
  #   And the workflow should show the updated name

  # Scenario: Workflow icon selection
  #   When I create or edit a workflow
  #   And I click the icon selector
  #   Then I should see the icon selection modal
  #   And I should see tabs for Icons, Apps, Upload
  #   When I select an icon from the Icons tab
  #   Then the icon should be applied to the workflow

  # Scenario: Deleting a workflow
  #   Given I have a workflow named "Test Workflow"
  #   When I click the workflow actions menu
  #   And I select "Delete"
  #   Then I should see a confirmation modal
  #   And the modal should warn that the action cannot be undone
  #   When I click "Delete"
  #   Then the workflow should be removed from the workspace
  #   And I should see a success notification

  # Scenario: Duplicating a workflow
  #   Given I have a workflow named "Original Workflow"
  #   When I click the workflow actions menu
  #   And I select "Duplicate"
  #   Then a copy of the workflow should be created
  #   And it should be named "Original Workflow (Copy)"
  #   And both workflows should be visible in the workspace

  # Scenario: Moving a workflow to a folder
  #   Given I have a workflow and multiple folders
  #   When I click the workflow actions menu
  #   And I select "Move"
  #   Then I should see the "Move Flow" modal
  #   And I should see a folder tree structure
  #   When I select a target folder
  #   And I click "Move"
  #   Then the workflow should be moved to the selected folder
  #   And it should no longer appear in the current view if filtered
  #   And I should see a success notification like "Flow moved successfully"
  #   And My view should be updated to show the workflow in the new folder

  # Scenario: Workflow status management
  #   Given I have a workflow
  #   When I click the workflow status indicator
  #   Then I should see status options (Draft, Active, Archived, In Review, Needs Update)
  #   When I select "Active"
  #   Then the workflow status should update
  #   And the status indicator should reflect the change

  # Scenario: Copying workflow link
  #   Given I have a workflow
  #   When I click the workflow actions menu
  #   And I select "Copy link"
  #   Then the workflow URL should be copied to clipboard
  #   And I should see a "Link copied!" notification

  # Scenario: Sharing a workflow
  #   Given I have a workflow
  #   When I click the workflow actions menu
  #   And I select "Share"
  #   Then I should see the share modal
  #   And I should see sharing options and link
  #   And I should be able to switch between sharing options like "Public" and "Private"
  #   And I should be able to switch between "Share" and "Embed" options
  #   And I should be able to copy the link to the clipboard
  #   And I should see a "Link copied!" notification
</file>

<file path="e2e/features/editor/access_and_layout.feature">
Feature: Editor Access and Layout
  As a logged-in user
  I want to access and navigate the workflow editor
  So that I can create and modify my workflows

  Background:
    Given I am a logged-in user
    And I am on the editor page of a workflow

  # Scenario: Editor loads successfully
  #   When I access the workflow editor
  #   Then I should see the workflow header with the workflow name
  #   And I should see the main canvas area
  #   And I should see the sidebar on the left
  #   And I should see zoom controls
  #   And I should see a "Begin" block on the canvas
  #   And I should see navigation breadcrumbs

  # Scenario: Editor header functionality
  #   When I am in the editor
  #   Then I should see the workflow title in the header
  #   And I should see a "Read Mode" button
  #   When I click the workflow title
  #   Then I should be able to edit the workflow title inline
  #   When I click "Read Mode"
  #   Then I should be redirected to the read view of the workflow

  # Scenario: Sidebar navigation
  #   When I am in the editor
  #   Then I should see the sidebar with workflow navigation
  #   And I should see a list of all blocks in the workflow
  #   And I should see block hierarchy with proper indentation
  #   When I click on a block in the sidebar
  #   Then the canvas should center on that block
  #   And the block should be highlighted

  # Scenario: Canvas interaction
  #   When I am in the editor
  #   Then I should be able to pan the canvas by dragging
  #   And I should be able to zoom in and out using mouse wheel
  #   And I should be able to zoom using the zoom controls
  #   When I double-click on an empty area
  #   Then the canvas should fit all blocks in view
</file>

<file path="e2e/features/editor/block_actions_and_context_menu.feature">
Feature: Block Actions and Context Menu
  As a user
  I want to perform various actions on blocks
  So that I can efficiently manage my workflow

  Background:
    Given I am in the workflow editor
    And I have multiple blocks in my workflow

  # Scenario: Block context menu
  #   When I click the three dots menu on a Step block
  #   Then I should see a context menu with options
  #   And I should see "Edit", "Copy", "Delete", "Connect Blocks", and "Copy Link" options

  # Scenario: Copying a block
  #   When I click the three dots menu on a Step block
  #   And I select "Copy"
  #   Then the block should be copied to the clipboard
  #   And I should see a "Block copied" notification

  # Scenario: Pasting a block
  #   Given I have copied a block to the clipboard
  #   When I click the "+" button at any position
  #   Then I should see a "Paste Block" option in the dropdown
  #   When I select "Paste Block"
  #   Then a copy of the block should be created at that position
  #   And the new block should have "(copy)" appended to its title

  # Scenario: Deleting a block
  #   When I click the three dots menu on a Step block
  #   And I select "Delete"
  #   Then I should see a confirmation modal
  #   When I confirm the deletion
  #   Then the block should be removed from the workflow
  #   And subsequent blocks should move up to fill the gap

  # Scenario: Connecting blocks with stroke lines
  #   When I click the three dots menu on a Step block
  #   And I select "Connect Blocks"
  #   Then I'll see a modal with a search bar
  #   When I search for a block
  #   Then I should see the block in the search results
  #   When I click on the block
  #   Then I should see the connection modal
  #   When I enter a connection label "If rejected"
  #   And I click "Connect"
  #   Then a stroke line should be created between the blocks
  #   And the line should display the label
</file>

<file path="e2e/features/editor/block_creation_and_management.feature">
Feature: Block Creation and Management
  As a user
  I want to create and manage different types of blocks
  So that I can build comprehensive workflows

  Background:
    Given I am in the workflow editor
    And I can see the canvas with a "Begin" block

  # Scenario: Adding a Step block
  #   When I click the "+" button after the Begin block
  #   Then I should see the add block dropdown menu
  #   And I should at least see the "Step" block option
  #   When I select "Step"
  #   Then a new Step block should be added to the workflow
  #   And the block should have a default title like "Untitled Block"
  #   And the block should have a default icon
  #   And the dropdown menu should close

  # Scenario: Adding a Condition block
  #   When I click the "+" button after the Begin block
  #   And I select "Condition"
  #   Then I should see the "Create a new condition" modal
  #   When I enter condition name "Approval Decision"
  #   And I enter condition description "Determine if the request is approved or rejected"
  #   And I add path names "Approved" and "Rejected"
  #   And I click "Create Paths"
  #   Then the modal should close
  #   And a Condition block should be created
  #   And two parallel paths should be created with the specified names
  #   And each path should have its own branch on the canvas

  # Scenario: Adding a Delay block
  #   When I click the "+" button after a Step block
  #   And I select "Delay"
  #   Then I should see the delay type selection modal
  #   When I select "Fixed Duration"
  #   Then I should see the fixed delay configuration modal
  #   When I set the delay to 2 hours and 30 minutes
  #   And I click "Create Delay"
  #   Then a Fixed Delay block should be added
  #   And the block should display "2h 30m" as the delay time

  # Scenario: Adding an Event Delay block
  #   When I click the "+" button after a Step block
  #   And I select "Delay"
  #   And I select "Wait For Event"
  #   Then I should see the event delay configuration modal
  #   When I enter event name "Client Response"
  #   And I set maximum wait time to 3 days
  #   And I click "Create Delay"
  #   Then an Event Delay block should be added
  #   And the block should display "Wait for Client Response (max 3 days)"

  # Scenario: Adding an End block
  #   Given I have a workflow with multiple blocks
  #   When I click the "+" button after the last block in a path
  #   Then I should see the add block dropdown menu
  #   And I should see an "End Block" option
  #   When I select "End Block"
  #   Then an End block should be added
</file>

<file path="e2e/features/editor/block_editing_and_properties.feature">
Feature: Block Editing and Properties
  As a user
  I want to edit block properties and content
  So that I can provide detailed information for each step

  Background:
    Given I am in the workflow editor
    And I have a Step block on the canvas

  # Scenario: Opening block details sidebar
  #   When I click on a Step block
  #   Then the block details sidebar should open on the right
  #   And I should see the block's current title
  #   And I should see the block's icon
  #   And I should see fields for description, average time, and media
  #   And I should see a close button
  #   And when I click on the canvas, the sidebar should close

  # Scenario: Editing block title
  #   When I open the block details sidebar
  #   And I click on the block title
  #   Then the title should become editable
  #   When I change the title to "Review Application"
  #   Then the title should be updated
  #   And the sidebar should show the new title
  #   And the block on the canvas should show the new title

  # Scenario: Editing block description
  #   When I open the block details sidebar
  #   And I click in the description area
  #   Then the description field should become editable
  #   When I enter "Review the submitted application for completeness and accuracy"
  #   And I click outside the description field
  #   Then the description should be saved
  #   And the description should be visible in the sidebar

  # Scenario: Changing block icon
  #   When I open the block details sidebar
  #   And I click on the block icon
  #   Then I should see the icon selection modal
  #   And I should see tabs for "Icons", "Apps", and "Upload"
  #   When I select an icon from the Icons tab
  #   Then the icon should be applied to the block
  #   And the modal should close
  #   And the block should display the new icon

  # Scenario: Adding block media
  #   When I open the block details sidebar
  #   And I click in the media section
  #   Then I should see a file upload area
  #   When I drag and drop an image file
  #   Then the image should be uploaded
  #   And the image should be displayed in the media section
  #   And I should see options to edit or remove the image

  # Scenario: Editing block media
  #   Given I have a block with an uploaded image
  #   When I open the block details sidebar
  #   And I click the edit button on the image
  #   Then I should see the image editor modal
  #   When I make edits to the image
  #   And I click "Save"
  #   Then the edited image should be saved
  #   And the original image should be preserved for reset option
</file>

<file path="e2e/features/editor/canvas_interaction_and_navigation.feature">
Feature: Canvas Interaction and Navigation
  As a user
  I want to interact with the canvas effectively
  So that I can navigate and work with large workflows

  Background:
    Given I am in the workflow editor
    And I have a workflow with multiple blocks

  # Scenario: Canvas panning and zooming
  #   When I drag on an empty area of the canvas
  #   Then the canvas should pan in the direction of the drag
  #   When I use the mouse wheel
  #   Then the canvas should zoom in or out
  #   When I use the zoom controls
  #   Then the canvas should zoom to the specified level
</file>

<file path="e2e/features/editor/documentation_and_help.feature">
Feature: Documentation and Help
  As a user
  I want to access help and documentation
  So that I can learn how to use the editor effectively

  Background:
    Given I am in the workflow editor

  # Scenario: Accessing documentation
  #   When I click the help or documentation button
  #   Then I should see the documentation modal
  #   And I should see tabs for different block types
  #   And I should see "Step", "Delay", "Link", "Condition", "Merge", "Path Labels", and "End" tabs

  # Scenario: Documentation content
  #   When I open the documentation modal
  #   And I click on the "Step" tab
  #   Then I should see information about Step blocks
  #   And I should see "When to use" guidance
  #   And I should see "How to add" instructions
  #   When I click on the "Delay" tab
  #   Then I should see information about both Fixed Duration and Wait For Event delays

  # Scenario: Documentation search
  #   When I open the documentation modal
  #   And I enter "condition" in the search box
  #   Then I should see only documentation related to conditions
  #   And irrelevant tabs should be filtered out
</file>

<file path="e2e/features/editor/error_handling_and_validation.feature">
Feature: Error Handling and Validation
  As a user
  I want the editor to handle errors gracefully
  So that I can continue working even when issues occur

  Background:
    Given I am in the workflow editor

  # Scenario: Network connectivity issues
  #   When I lose network connectivity
  #   And I try to create a new block
  #   Then I should see an error message like "Something went wrong. Please try again."
  #   And the action should not complete
  #   When connectivity is restored
  #   Then I should be able to retry the action

  # Scenario: Path creation validation
  #   When I try to create parallel paths with empty names
  #   Then I should see validation errors
  #   And the "Create Paths" button should be disabled
  #   When I provide valid path names
  #   Then the validation should clear
  #   And I should be able to create the paths
</file>

<file path="e2e/features/editor/path_management_and_conditions.feature">
Feature: Path Management and Conditions
  As a user
  I want to create and manage conditional paths
  So that I can model complex decision-based workflows

  Background:
    Given I am in the workflow editor
    And I have a workflow with at least one Condition block

  # Scenario: Editing existing paths
  #   Given I have a Condition block with 3 paths
  #   When I click the three dots menu on the Condition block
  #   And I select "Edit"
  #   Then I should see the "Update Paths" modal
  #   And I should see the current paths listed
  #   When I modify a path name from "Approved" to "Fully Approved"
  #   And I add a new path "Conditionally Approved"
  #   And I remove the "Rejected" path
  #   And I click "Update Paths"
  #   Then the paths should be updated accordingly
  #   And the workflow should reflect the changes

  # Scenario: Merging paths
  #   Given I have multiple parallel paths that need to converge
  #   When I click the three dots menu on the last step block of a path
  #   And I select "Merge Paths"
  #   Then I should enter merge mode
  #   And I should see path selection indicators
  #   When I select the paths I want to merge
  #   And I click "Merge Selected Paths"
  #   Then the selected paths should converge into a single path

  # Scenario: Path labels and editing
  #   Given I have conditional paths
  #   When I click on a path label
  #   Then the label should become editable
  #   When I change the label text
  #   And I press Enter or I click outside the label
  #   Then the label should be updated
  #   And the change should be reflected in the workflow
</file>

<file path="e2e/features/editor/sidebar_navigation_and_block_management.feature">
Feature: Sidebar Navigation and Block Management
  As a user
  I want to navigate and manage blocks through the sidebar
  So that I can efficiently work with large workflows

  Background:
    Given I am in the workflow editor
    And I have a complex workflow with multiple paths and blocks

  # Scenario: Sidebar block hierarchy
  #   When I look at the sidebar
  #   Then I should see all blocks organized hierarchically
  #   And I should see proper indentation for nested paths
  #   And I should see block icons and titles
  #   And I should see block duration estimates

  # Scenario: Sidebar search functionality
  #   When I enter "approval" in the sidebar search box
  #   Then only blocks containing "approval" should be visible
  #   And other blocks should be filtered out
  #   When I clear the search
  #   Then all blocks should be visible again

  # Scenario: Sidebar block navigation
  #   When I click on a block in the sidebar
  #   Then the canvas should center on that block
  #   And the block should be highlighted
  #   And I should see the block details sidebar open on the right

  # Scenario: Sidebar path collapsing
  #   Given I have paths with multiple nested blocks
  #   When I click the collapse arrow next to a path
  #   Then the path's child blocks should be hidden
  #   When I click the expand arrow
  #   Then the child blocks should be visible again
</file>

<file path="e2e/features/editor/stroke_lines_and_connections.feature">
Feature: Stroke Lines and Connections
  As a user
  I want to create custom connections between blocks
  So that I can model complex workflows with loops and non-linear flows

  Background:
    Given I am in the workflow editor
    And I have multiple blocks in different paths

  # Scenario: Creating a stroke line connection
  #   When I click the three dots menu on a source block
  #   And I select "Connect Blocks"
  #   Then I should enter connection mode
  #   When I click on a target block
  #   Then I should see the connection modal
  #   And I should see the source and target blocks highlighted
  #   When I enter connection label "Return for revision"
  #   And I click "Create Connection"
  #   Then a stroke line should be drawn between the blocks
  #   And the line should display the label

  # Scenario: Deleting stroke lines
  #   Given I have a stroke line connection
  #   When I click on the stroke line
  #   And I select "Delete"
  #   Then I should see a confirmation modal
  #   When I confirm the deletion
  #   Then the stroke line should be removed
  #   And the connection should no longer exist

  # Scenario: Stroke line visibility toggle
  #   Given I have multiple stroke lines in my workflow
  #   When I click the stroke lines visibility toggle
  #   Then all stroke lines should be hidden
  #   When I click the toggle again
  #   Then all stroke lines should be visible again

  # Scenario: Editing stroke line control points
  #   Given I have a stroke line with a curved path
  #   When I hover over the stroke line
  #   Then I should see control points for adjusting the curve
  #   When I drag a control point
  #   Then the stroke line path should adjust accordingly
  #   And the new path should be saved
</file>

<file path="e2e/features/editor/zoom_and_view_controls.feature">
Feature: Zoom and View Controls
  As a user
  I want to control the view and zoom level
  So that I can work effectively with workflows of different sizes

  Background:
    Given I am in the workflow editor

  # Scenario: Zoom controls functionality
  #   When I click the zoom in button
  #   Then the canvas should zoom in by a standard increment
  #   When I click the zoom out button
  #   Then the canvas should zoom out by a standard increment
  #   When I click the zoom percentage
  #   Then I should see a dropdown with preset zoom levels
  #   When I select "50%" from the dropdown
  #   Then the canvas should zoom to 50%

  # Scenario: Zoom limits
  #   When I zoom in to the maximum level
  #   Then the zoom in button should be disabled
  #   When I zoom out to the minimum level
  #   Then the zoom out button should be disabled

  # Scenario: Zoom to fit
  #   Given I have a large workflow that extends beyond the visible area
  #   When I click "Zoom to fit"
  #   Then the entire workflow should be visible
  #   And the zoom level should adjust automatically
</file>

<file path="e2e/features/login/user_login.feature">
Feature: User login

  As a registered user
  I want to log into the application
  So that I can access my dashboard

  # Scenario: Successful login
  #   Given I am on the login page
  #   When I enter a valid email and password
  #   And I click the "Log in" button
  #   Then I should be redirected to the dashboard
  #   And I should see a welcome message

  # Scenario: Failed login with wrong password
  #   Given I am on the login page
  #   When I enter a valid email and an incorrect password
  #   And I click the "Log in" button
  #   Then I should see an error message

  # Scenario: Attempt login with empty fields
  #   Given I am on the login page
  #   When I click the "Log in" button without entering credentials
  #   Then I should see validation errors for both email and password
</file>

<file path="e2e/features/onboarding/completion_step_and_workspace_creation.feature">
Feature: Completion Step and Workspace Creation
  As a new user
  I want to see my workspace being created
  So that I know the onboarding is completing successfully

  Background:
    Given I have completed all onboarding steps
    And I am on the completion step

  # Scenario: Successful workspace and workflow creation
  #   When I reach the completion step
  #   Then I should see "Setting up your workspace" message
  #   And I should see a loading spinner
  #   And the workspace creation should start automatically
  #   And default workflows should be created
  #   When the workspace creation completes successfully
  #   Then I should see "Your workspace is ready!" message
  #   And I should see a success checkmark
  #   And I should see the introduction video
  #   And the "Continue to Dashboard" button should be enabled

  # Scenario: Default workflow creation warnings
  #   When the workspace is created successfully
  #   But default workflow creation has warnings
  #   Then I should see the workspace as ready
  #   And warnings should be logged but not shown to user
  #   And I should be able to continue to dashboard

  # Scenario: Email scheduling during completion
  #   When the workspace creation completes
  #   Then a welcome email should be scheduled immediately
  #   And a follow-up email should be scheduled for 4 days later
  #   And a feedback request email should be scheduled for 7 days later
  #   And a feature update email should be scheduled for 4 days later
  #   When email scheduling fails
  #   Then the onboarding should still complete successfully
  #   And warnings should be logged

  # Scenario: Continue to dashboard
  #   When the workspace creation is complete
  #   And I click "Continue to Dashboard"
  #   Then all onboarding data should be cleared from localStorage
  #   And my onboarding should be marked as complete on the server
  #   And I should be redirected to the dashboard "/"
  #   And I should not be able to access "/onboarding" anymore

  # Scenario: Browser back button prevention
  #   Given workspace creation has started
  #   When I try to use the browser back button
  #   Then I should remain on the completion step
  #   And navigation should be prevented

  # Scenario: Force completion fallback
  #   Given the server shows onboarding as incomplete
  #   Then the button "Continue to Dashboard" is disabled
</file>

<file path="e2e/features/onboarding/error_handling_and_edge_cases.feature">
Feature: Error Handling and Edge Cases
  As a user going through onboarding
  I want graceful error handling
  So that I can complete onboarding even when issues occur

  # Scenario: API failure resilience
  #   When an API call fails during step submission
  #   Then I should be blocked from proceeding to the next step
  #   And the UI should provide an error message "Something went wrong. Please try again."

  # Scenario: Network connectivity issues
  #   When I lose network connectivity during onboarding
  #   Then my form data should be preserved locally
  #   And I should be able to continue when connectivity returns
  #   And slug availability checks should handle timeouts gracefully

  # Scenario: Workspace creation timeout handling
  #   When workspace creation takes longer than expected
  #   Then I should see appropriate loading messages
  #   And the process should not timeout prematurely
  #   And I should have options to retry or continue

  # Scenario: Duplicate workspace name handling
  #   When I enter a workspace name that already exists
  #   Then the system should automatically suggest alternatives
  #   And I should be able to proceed with the modified name
  #   And the slug conflict should be resolved automatically

  # Scenario: File upload error recovery
  #   When logo upload fails due to network issues
  #   Then I should see the error message "Something went wrong. Please try again."
  #   And I should be able to retry the upload
  #   And I should be able to continue without a logo

  # Scenario: Concurrent user scenarios
  #   When multiple users try to create workspaces simultaneously
  #   Then each should get unique slugs
  #   And no conflicts should occur
  #   And all users should complete successfully
</file>

<file path="e2e/features/onboarding/navigation_and_state_management.feature">
Feature: Navigation and State Management
  As a user going through onboarding
  I want smooth navigation between steps
  So that I can complete the process efficiently

  # Scenario: Progress indicator accuracy
  #   Given I am on the personal information step
  #   Then step 1 should be highlighted as active
  #   And steps 2 and 3 should be inactive
  #   Given I am on the professional information step
  #   Then step 1 should show as completed
  #   And step 2 should be highlighted as active
  #   And step 3 should be inactive
  #   Given I am on the workspace setup step
  #   Then steps 1 and 2 should show as completed
  #   And step 3 should be highlighted as active

  # Scenario: Data persistence across page refreshes
  #   Given I have partially completed onboarding
  #   When I refresh the page at any step
  #   Then I should return to the correct step
  #   And my previously entered data should be restored
  #   And the progress indicator should show the correct state

  # Scenario: Server state synchronization
  #   Given I am going through onboarding
  #   When each step is completed
  #   Then the server should be updated with my progress
  #   And the onboarding status should be synchronized
  #   When I reload the page
  #   Then the server state should determine my current step

  # Scenario: Onboarding completion detection
  #   Given I have completed onboarding previously
  #   When I try to access "/onboarding"
  #   Then I should be redirected to the dashboard "/"
  #   And I should not see the onboarding flow

  # Scenario: Authentication requirement
  #   Given I am not authenticated
  #   When I try to access "/onboarding"
  #   Then I should be redirected to the login page
  #   When I am authenticated but onboarding is complete
  #   Then I should be redirected to the dashboard

  # Scenario: Light theme enforcement
  #   When I am on any onboarding step
  #   Then the interface should use light theme
  #   And dark mode should be disabled
  #   And the theme should be forced regardless of system preference
</file>

<file path="e2e/features/onboarding/personal_information_step.feature">
Feature: Personal Information Step
  As a new user
  I want to provide my personal information
  So that I can proceed with the onboarding

  Background:
    Given I am on the personal information step
    And I see the progress indicator showing step 1 of 3 active

  # Scenario: Successful personal information submission
  #   When I enter first name "Steve"
  #   And I enter last name "Jobs"
  #   And I click the "Continue" button
  #   Then I should proceed to the professional information step
  #   And the progress indicator should show step 1 completed
  #   And the progress indicator should show step 2 active
  #   And my personal information should be saved to localStorage
  #   And an API call should be made to save personal info

  # Scenario: Personal information validation - empty fields
  #   When I leave the first name field empty
  #   And I enter last name "Jobs"
  #   Then the "Continue" button should be disabled
  #   When I enter first name "Steve"
  #   And I leave the last name field empty
  #   Then the "Continue" button should be disabled

  # Scenario: Personal information validation - character limits
  #   When I enter a first name with 41 characters
  #   Then only the first 40 characters should be accepted
  #   When I enter a last name with 41 characters
  #   Then only the first 40 characters should be accepted

  # Scenario: Personal information validation - character sanitization
  #   When I enter first name "Steve<script>alert('xss')</script>"
  #   Then HTML tags should be removed and only "Stevealert('xss')" should remain
  #   When I enter first name "Steve123!@#"
  #   Then special characters should be removed and only "Steve" should remain
  #   When I enter first name "Steve-O'Connor"
  #   Then hyphens and apostrophes should be allowed

  # Scenario: Personal information persistence
  #   Given I have entered first name "Steve"
  #   And I have entered last name "Jobs"
  #   When I refresh the page
  #   Then my entered information should be restored from localStorage
  #   And the form should be pre-filled with my data

  # Scenario: Loading state during submission
  #   When I enter valid personal information
  #   And I click the "Continue" button
  #   Then the button should show "Loading..." text
  #   And the button should be disabled during submission
  #   And I should proceed to the next step even if API call fails
</file>

<file path="e2e/features/onboarding/professional_information_step.feature">
Feature: Professional Information Step
  As a new user
  I want to provide my professional information
  So that ProcessFlow can be customized to my needs

  Background:
    Given I am on the professional information step
    And I see the progress indicator showing step 2 of 3 active

  # Scenario: Successful professional information submission
  #   When I select industry "IT"
  #   And I select role "Founder"
  #   And I select company size "10-49"
  #   And I select source "ProductHunt"
  #   And I click the "Continue" button
  #   Then I should proceed to the workspace setup step
  #   And the progress indicator should show step 2 completed
  #   And the progress indicator should show step 3 active
  #   And my professional information should be saved to localStorage

  # Scenario: Professional information validation - all fields required
  #   When I select industry "IT"
  #   And I select role "Founder"
  #   And I select company size "10-49"
  #   And I leave source unselected
  #   And I click the "Continue" button
  #   Then I should see error "Please fill in all fields"
  #   And I should remain on the professional information step

  # Scenario: Professional information dropdown options validation
  #   When I view the industry dropdown
  #   Then I should see options: "IT", "Healthcare", "Finance", "Education", "Retail", "Other"
  #   When I view the role dropdown
  #   Then I should see options: "Founder", "Manager", "Product Manager", "Analyst", "Designer", "Sales", "Marketing", "HR", "Customer Success", "Freelancer", "Other"
  #   When I view the company size dropdown
  #   Then I should see options: "1", "2-9", "10-49", "50-199", "200-499", "500+"
  #   When I view the source dropdown
  #   Then I should see options: "ProductHunt", "LinkedIn", "Google", "Friend", "Other"

  # Scenario: Navigation back to personal information
  #   When I click the "Back" button
  #   Then I should return to the personal information step
  #   And the progress indicator should show step 1 active
  #   And my previously entered personal information should be preserved

  # Scenario: Professional information persistence
  #   Given I have selected all professional information fields
  #   When I navigate to the next step and then back
  #   Then my professional information should be restored from localStorage
  #   And all dropdowns should show my previous selections

  # Scenario: Loading state during submission
  #   When I enter valid professional information
  #   And I click the "Continue" button
  #   Then the button should show "Loading..." text
  #   And the button should be disabled during submission
  #   And I should proceed to the next step even if API call fails
</file>

<file path="e2e/features/onboarding/user_onboarding_flow.feature">
Feature: User Onboarding Flow
  As a new user
  I want to complete the onboarding process
  So that I can set up my workspace and start using ProcessFlow

  Background:
    Given I am a newly registered user
    And I am logged in
    And my onboarding is not complete
    And I am on the onboarding page "/onboarding"
</file>

<file path="e2e/features/onboarding/workspace_setup_step.feature">
Feature: Workspace Setup Step
  As a new user
  I want to set up my workspace
  So that I can start organizing my workflows

  Background:
    Given I am on the workspace setup step
    And I see the progress indicator showing step 3 of 3 active

  # Scenario: Successful workspace setup with auto-generated URL
  #   When I enter workspace name "My Company"
  #   And the workspace URL is auto-generated as "my-company"
  #   And the slug availability check shows "Available"
  #   Then the "Continue" button should be enabled
  #   When I click the "Continue" button
  #   Then I should proceed to the completion step
  #   And my workspace should be created with the generated slug

  # Scenario: Workspace name validation - required field
  #   When I leave the workspace name field empty
  #   Then the "Continue" button should be disabled
  #   And A tooltip must indicate that the field workspace name is required
  #   When I enter workspace name "My Company"
  #   Then the "Continue" button should be enabled

  # Scenario: Workspace name validation - character limits
  #   When I enter a workspace name with 51 characters
  #   Then only the first 50 characters should be accepted
  #   And the input should be automatically truncated

  # Scenario: Workspace name validation - allowed characters
  #   When I enter workspace name "Valid Name-123"
  #   Then the name should be accepted
  #   When I enter workspace name "Invalid!Name@#$"
  #   Then special characters should be removed automatically
  #   And only "InvalidName" should remain

  # Scenario: Workspace URL slug generation and validation
  #   When I enter workspace name "My Awesome Company"
  #   Then the workspace URL should be auto-generated as "my-awesome-company"
  #   When I enter workspace name "Company!@# 123"
  #   Then the workspace URL should be auto-generated as "company-123"

  # Scenario: Workspace URL availability checking
  #   When I enter a workspace name
  #   Then a slug availability check should be performed after 500ms delay
  #   And I should see "Checking availability..." message
  #   When the slug is available
  #   Then I should see "Available" message in green
  #   When the slug is already taken
  #   Then I should see "This URL is already taken" message in red
  #   And the "Continue" button should be disabled

  # Scenario: Workspace URL manual editing (disabled)
  #   When I try to manually edit the workspace URL field
  #   Then the field should be disabled
  #   And I should not be able to modify it directly

  # Scenario: Workspace logo upload - valid file types
  #   When I upload a PNG file smaller than 5MB
  #   Then the logo should be accepted and displayed
  #   When I upload a JPEG file smaller than 5MB
  #   Then the logo should be accepted and displayed
  #   When I upload an SVG file smaller than 5MB
  #   Then the logo should be accepted and displayed
  #   When I upload a GIF file smaller than 5MB
  #   Then the logo should be accepted and displayed
  #   When I upload an AVIF file smaller than 5MB
  #   Then the logo should be accepted and displayed

  # Scenario: Workspace logo upload - invalid file types
  #   When I upload a PDF file
  #   Then I should see error "Invalid file type. Please upload a PNG, JPG, GIF, or SVG image."
  #   When I upload a TXT file
  #   Then I should see error "Invalid file type. Please upload a PNG, JPG, GIF, or SVG image."

  # Scenario: Workspace logo upload - file size validation
  #   When I upload an image file larger than 5MB
  #   Then I should see error "File is too large. Maximum size is 5MB."
  #   And the file should not be accepted

  # Scenario: Workspace logo upload - drag and drop
  #   When I drag a valid image file over the upload area
  #   Then the upload area should show visual feedback
  #   When I drop a valid image file on the upload area
  #   Then the logo should be uploaded and displayed
  #   When I drop an invalid file on the upload area
  #   Then I should see appropriate error message

  # Scenario: Navigation back to professional information
  #   When I click the "Back" button
  #   Then I should return to the professional information step
  #   And my workspace setup data should be preserved

  # Scenario: Form validation before submission
  #   When I have a valid workspace name
  #   And the slug is available
  #   Then the "Continue" button should be enabled
  #   When I have an invalid workspace name
  #   Then the "Continue" button should be disabled
  #   When the slug is not available
  #   Then the "Continue" button should be disabled
  #   When the slug availability is still being checked
  #   Then the "Continue" button should be disabled

  # Scenario: Workspace setup persistence
  #   Given I have entered workspace information
  #   When I navigate away and return to this step
  #   Then my workspace setup data should be restored from localStorage
  #   And the logo preview should be displayed if uploaded
</file>

<file path="e2e/features/read-mode/access_and_layout.feature">
Feature: Read Mode Access and Layout
  As a user
  I want to access and view workflows in read mode
  So that I can follow processes and understand workflow steps

  Background:
    Given I am a logged-in user
    And I have access to a workflow in read mode
    And I am on the read page of a workflow

  # Scenario: Read mode loads successfully
  #   When I access a workflow in read mode
  #   Then I should see the workflow header with navigation controls
  #   And I should see the main content area
  #   And I should see the sidebar on the left with workspace information
  #   And I should see the view mode switch controls
  #   And I should see the process card with workflow information
  #   And I should see breadcrumb navigation

  # Scenario: Read mode header functionality
  #   When I am in read mode
  #   Then I should see the workflow title in the breadcrumbs
  #   And I should see an "Edit" button
  #   And I should see a "Share" button
  #   And I should see my user profile dropdown
  #   When I click the "Edit" button
  #   Then I should be redirected to the edit mode of the workflow
  #   When I click the back button
  #   Then I should navigate to the previous page

  # Scenario: Process card display
  #   When I view the process card
  #   Then I should see the workflow icon
  #   And I should see the workflow name and description
  #   And I should see integration badges for connected apps
  #   And I should see author information if available
  #   And I should see the last update timestamp
  #   When there are more than 5 integrations
  #   Then I should see a "+X" badge for additional integrations
  #   When I hover over the "+X" badge
  #   Then I should see a popover with the additional integrations

  # Scenario: Sidebar workspace navigation
  #   When I look at the sidebar
  #   Then I should see the workspace name and icon
  #   And I should see a hierarchical list of workflow steps
  #   When I click on the workspace name
  #   Then I should be redirected to the workspace dashboard
</file>

<file path="e2e/features/read-mode/conditional_path_handling.feature">
Feature: Conditional Path Handling
  As a user
  I want to make choices at decision points
  So that I can follow the appropriate path for my situation

  Background:
    Given I am in read mode
    And I have a workflow with conditional paths

  # Scenario: Displaying path options
  #   Given I reach a step with multiple path options
  #   Then I should see the step content
  #   And I should see a "Select an option" section
  #   And I should see radio buttons for each available path
  #   And each option should show the path name
  #   And the "Next step" button should be disabled until I make a selection

  # Scenario: Selecting a path option
  #   Given I am on a step with path options
  #   When I select a path option
  #   Then the radio button should be marked as selected
  #   And the "Next step" button should become enabled
  #   When I click "Next step"
  #   Then I should proceed to the first step of the selected path
  #   And subsequent steps should follow the selected path

  # Scenario: Path selection persistence
  #   Given I have selected a path option
  #   When I navigate back to the decision step
  #   Then my previous selection should still be marked
  #   When I change my selection to a different path
  #   And I proceed forward
  #   Then I should follow the newly selected path
  #   And any progress on the previous path should be reset

  # Scenario: Multiple decision points
  #   Given I have a workflow with multiple decision points
  #   When I make selections at each decision point
  #   Then each selection should be remembered
  #   And I should be able to navigate back and see my choices
  #   When I change a selection at an earlier decision point
  #   Then all subsequent selections should be reset
  #   And I should need to make new selections for later decision points
</file>

<file path="e2e/features/read-mode/content_display_and_media.feature">
Feature: Content Display and Media
  As a user
  I want to view rich content and media in workflow steps
  So that I can understand the instructions clearly

  Background:
    Given I am in read mode
    And I have steps with various content types

  # Scenario: Basic step content display
  #   When I view a step
  #   Then I should see the step icon
  #   And I should see the step title
  #   And I should see the step description if available
  #   And I should see any estimated time duration
  #   And text content should be properly formatted

  # Scenario: Fullscreen image viewing
  #   Given I have opened an image in fullscreen
  #   Then I should see the image at full size
  #   And I should see close button
  #   And I should see zoom controls
  #   When I press the Escape key
  #   Then the fullscreen view should close
  #   When I click outside the image
  #   Then the fullscreen view should close

  # Scenario: Rich text content with links
  #   Given I have a step with text containing URLs
  #   When I view the step description
  #   Then URLs should be automatically converted to clickable links
  #   And links should open in a new tab when clicked
  #   And links should be visually distinguished from regular text

  # Scenario: App integration icons
  #   Given I have steps with app integrations
  #   When I view these steps
  #   Then I should see the appropriate app icons
  #   And icons should load from the correct sources
  #   When an app icon fails to load
  #   Then I should see a default fallback icon
</file>

<file path="e2e/features/read-mode/delay_block_handling.feature">
Feature: Delay Block Handling
  As a user
  I want to understand delay blocks in workflows
  So that I know when to wait and what to expect

  Background:
    Given I am in read mode
    And I have a workflow with delay blocks

  # Scenario: Fixed duration delay display
  #   Given I reach a fixed duration delay block
  #   Then I should see a delay icon (clock/stopwatch)
  #   And I should see "Fixed Duration" as the delay type
  #   And I should see the delay time formatted (e.g., "2h 30m")
  #   And I should see a message like "Flow paused for 2 hours and 30 minutes"
  #   And I should see an info box explaining the delay

  # Scenario: Event-based delay display
  #   Given I reach an event-based delay block
  #   Then I should see a delay icon (calendar/clock)
  #   And I should see "Event-Based Delay" as the delay type
  #   And I should see the event name being waited for
  #   And I should see "Waiting for: [Event Name]"
  #   If the delay has an expiration time
  #   Then I should see "Expires after [time]" with an hourglass icon
  #   And I should see appropriate pause messaging
</file>

<file path="e2e/features/read-mode/error_handling_and_edge_cases.feature">
Feature: Error Handling and Edge Cases
  As a user
  I want the system to handle errors gracefully
  So that I can continue using the workflow even when issues occur

  Background:
    Given I am in read mode

  # Scenario: Network connectivity issues
  #   When I lose network connectivity
  #   And I try to navigate to a new step
  #   Then I should see an appropriate error message
  #   And the interface should remain functional for local actions
  #   When connectivity is restored
  #   Then I should be able to continue normally

  # Scenario: Missing or broken media
  #   Given I have a step with an image that fails to load
  #   When I view that step
  #   Then I should see a placeholder or error state
  #   And the step should still be functional
  #   And other content should display normally

  # Scenario: Invalid workflow access
  #   When I try to access a workflow that doesn't exist
  #   Then I should see a 404 error page
  #   When I try to access a private workflow without permission
  #   Then I should be redirected to login
</file>

<file path="e2e/features/read-mode/header_controls_and_navigation.feature">
Feature: Header Controls and Navigation
  As a user
  I want to access workflow controls and navigation
  So that I can manage my workflow viewing experience

  Background:
    Given I am in read mode
    And I can see the header controls

  # Scenario: Breadcrumb navigation
  #   When I look at the header
  #   Then I should see breadcrumb navigation
  #   And I should see the workspace name (if applicable)
  #   And I should see folder names (if workflow is in a folder)
  #   And I should see the workflow name as the final breadcrumb
  #   When I click on a breadcrumb item with a link
  #   Then I should navigate to that location

  # Scenario: Edit mode navigation
  #   When I click the "Edit" button in the header
  #   Then I should be redirected to the edit mode
  #   And the URL should change to the edit mode URL
  #   And I should see the workflow editor interface

  # Scenario: User profile dropdown
  #   When I click on my user profile in the header
  #   Then I should see a dropdown menu
  #   And I should see "Account settings" option
  #   And I should see "Help center" option
  #   When I select "Account settings"
  #   Then I should see the user settings modal
  #   When I select "Help center"
  #   Then I should see the help center modal
</file>

<file path="e2e/features/read-mode/process_completion_and_restart.feature">
Feature: Process Completion and Restart
  As a user
  I want to complete workflows and restart them
  So that I can finish processes and repeat them as needed

  Background:
    Given I am in read mode in carousel mode
    And I have progressed through a workflow

  # Scenario: Reaching workflow completion
  #   Given I am on the last step of the workflow
  #   When I click "Complete" or reach the end
  #   Then I should see the completion screen
  #   And I should see a success icon (checkmark)
  #   And I should see a congratulations message
  #   And I should see "You've completed the process" text
  #   And I should see sharing encouragement message

  # Scenario: Completion screen actions
  #   When I am on the completion screen
  #   Then I should see a "Copy link" button
  #   And I should see a "Restart process" button
  #   When I click "Copy link"
  #   Then the workflow share link should be copied
  #   And I should see a "Link copied!" notification
  #   When I click "Restart process"
  #   Then I should return to the initial state
  #   And all step progress should be reset
  #   And all path selections should be cleared

  # Scenario: Completion with conditional paths
  #   Given I completed a workflow with multiple path choices
  #   When I restart the process
  #   Then all my previous path selections should be cleared
  #   And I should be able to make different choices
  #   And follow different paths through the workflow
</file>

<file path="e2e/features/read-mode/sharing_and_access_control.feature">
Feature: Sharing and Access Control
  As a user
  I want to share workflows and control access
  So that I can collaborate with others effectively

  Background:
    Given I am in read mode
    And I have sharing permissions for the workflow

  # Scenario: Opening share modal
  #   When I click the "Share" button
  #   Then I should see the share modal
  #   And I should see the workflow name in the modal
  #   And I should see the current sharing status (Public/Private)
  #   And I should see the share URL
  #   And I should see copy link button

  # Scenario: Toggling workflow access
  #   Given the workflow is currently public
  #   When I toggle back to private
  #   Then I should see "Workflow is now private" notification
  #   When I toggle back to public
  #   Then I should see "Workflow is now public" notification

  # Scenario: Copying share link
  #   When I click "Copy link" in the share modal
  #   Then the workflow URL should be copied to clipboard
  #   And I should see a "Link copied!" notification
  #   And the copied link should be the correct share URL

  # Scenario: Share modal with workspace branding
  #   Given my workspace has a custom logo
  #   When I open the share modal
  #   Then I should see the workspace logo in the modal
  #   And the modal should reflect the workspace branding

  # Scenario: Public workflow access
  #   Given I have a public workflow link
  #   When I access the workflow without being logged in
  #   Then I should be able to view the workflow
  #   And I should see limited functionality (no edit access)
  #   And I should not see user-specific controls
</file>

<file path="e2e/features/read-mode/sidebar_navigation_and_step_management.feature">
Feature: Sidebar Navigation and Step Management
  As a user
  I want to navigate efficiently through the workflow
  So that I can jump to specific steps and understand the structure

  Background:
    Given I am in vertical mode
    And I can see the sidebar

  # Scenario: Sidebar step hierarchy display
  #   When I look at the sidebar
  #   Then I should see all workflow paths organized hierarchically
  #   And I should see proper indentation for nested paths
  #   And I should see step icons and titles
  #   And I should see expand/collapse arrows for paths with multiple steps

  # Scenario: Sidebar step navigation
  #   When I click on a step in the sidebar
  #   Then the main content should scroll to that step
  #   And the step should be highlighted
  #   And if the step was collapsed, it should expand

  # Scenario: Path collapsing and expanding
  #   Given I have paths with multiple steps
  #   When I click the collapse arrow next to a path
  #   Then the path's child steps should be hidden
  #   And the arrow should change to indicate collapsed state
  #   When I click the expand arrow
  #   Then the child steps should be visible again
  #   And the arrow should change to indicate expanded state

  # Scenario: Active step highlighting
  #   Given I am progressing through the workflow
  #   When I am on a specific step
  #   Then that step should be highlighted in the sidebar
  #   And it should be visually distinct from other steps
  #   When I navigate to a different step
  #   Then the highlighting should move to the new step

  # Scenario: Sidebar workspace navigation
  #   When I click on the workspace name in the sidebar
  #   Then I should be redirected to the workspace dashboard
  #   And I should see a hover effect on the workspace area
  #   And the workspace icon and name should be clearly visible
</file>

<file path="e2e/features/read-mode/step_navigation_and_progression.feature">
Feature: Step Navigation and Progression
  As a user
  I want to navigate through workflow steps
  So that I can follow the process systematically

  Background:
    Given I am in read mode
    And I have a workflow with multiple steps

  # Scenario: Linear step progression in carousel mode
  #   Given I am in carousel mode
  #   And I am on the first step
  #   When I click "Next step"
  #   Then I should proceed to the second step
  #   And the second step should be displayed
  #   And I should see a "Previous step" button
  #   When I click "Previous step"
  #   Then I should return to the first step

  # Scenario: Step navigation in vertical mode
  #   Given I am in vertical mode
  #   When I got a conditionnal step
  #   Then I should see the conditionnal step content
  #   And I should see the path options
  #   When I select a path option
  #   Then I should proceed to the first step of the selected path
  #   And subsequent steps should follow the selected path
</file>

<file path="e2e/features/read-mode/view_mode_management.feature">
Feature: View Mode Management
  As a user
  I want to switch between different view modes
  So that I can choose the best way to follow the workflow

  Background:
    Given I am in read mode
    And I can see the view mode switch controls

  # Scenario: Switching to vertical view mode
  #   When I click the vertical view mode button
  #   Then the interface should switch to vertical mode
  #   And I should see all steps displayed in a scrollable list
  #   And I should see the sidebar with step navigation
  #   And I should see step expansion controls
  #   And the view mode button should show as active

  # Scenario: Switching to carousel view mode
  #   When I click the carousel view mode button
  #   Then the interface should switch to carousel mode
  #   And I should see one step displayed at a time
  #   And I should see navigation buttons (Previous/Next)
  #   And I should see a "Get Started" button initially
  #   And the sidebar should be hidden
  #   And the view mode button should show as active
</file>

<file path="e2e/raw/authentication.feature">
# ProcessFlow Authentication BDD Test

## Feature: User Registration

Feature: User Registration
              As a new user
              I want to create an account
  So that I can access ProcessFlow

        Background:
            Given I am on the signup page
              And I am not authenticated

        Scenario: Successful email/password registration
             When I enter a valid email "user@example.com"
              And I enter a strong password "StrongPass123!"
              And I click the "Sign up" button
             Then I should see a success message
              And I should be redirected to login page with pre-filled email
              And a confirmation email should be sent to "user@example.com"

        Scenario: Registration with weak password
             When I enter a valid email "user@example.com"
              And I enter a weak password "123"
              And I click the "Sign up" button
             Then I should see error "Password must be at least 8 characters and include uppercase, lowercase, number, and special character."
              And the signup should not proceed

        Scenario: Registration with invalid email
             When I enter an invalid email "invalid-email"
              And I enter a strong password "StrongPass123!"
              And I click the "Sign up" button
             Then I should see error "Please enter a valid email address."
              And the signup should not proceed

        Scenario: Registration with existing email
            Given a user already exists with email "existing@example.com"
             When I enter email "existing@example.com"
             Then the system should perform an immediate email availability check
              And no visual feedback should be shown about email existence
             When I enter a strong password "StrongPass123!"
              And I click the "Sign up" button
             Then the system should perform a final email existence check
              And I should see message "If your signup was successful, check your email."
              And no new account should be created
              And no confirmation email should be sent
              And I should be redirected to login page with pre-filled email

        Scenario: Google OAuth registration
             When I click "Sign up with Google"
             Then I should be redirected to Google OAuth
              And after successful Google authentication
             Then I should be redirected to "/auth/callback"
              And a new user account should be created
              And I should be redirected to the onboarding page

## Feature: User Authentication

Feature: User Authentication
              As a registered user
              I want to log into my account
  So that I can access ProcessFlow

        Background:
            Given I am on the login page
              And I am not authenticated

        Scenario: Successful login with confirmed email (new user)
            Given a new user exists with email "newuser@example.com" and confirmed email
              And the user has not completed onboarding
             When I enter email "newuser@example.com"
              And I enter the correct password
              And I click the "Log in" button
             Then I should be logged in successfully
              And I should be redirected to "/onboarding"
              And a session cookie should be set

        Scenario: Successful login with confirmed email (existing user)
            Given an existing user with email "user@example.com" and confirmed email
              And the user has completed onboarding
             When I enter email "user@example.com"
              And I enter the correct password
              And I click the "Log in" button
             Then I should be logged in successfully
              And I should be redirected to the dashboard "/"
              And a session cookie should be set

        Scenario: Login attempt with unconfirmed email
            Given a user exists with email "unconfirmed@example.com" and unconfirmed email
             When I enter email "unconfirmed@example.com"
              And I enter the correct password
              And I click the "Log in" button
             Then I should see message "Please confirm your email before logging in"
              And I should not be logged in

        Scenario: Login with invalid credentials
             When I enter email "user@example.com"
              And I enter an incorrect password
              And I click the "Log in" button
             Then I should see error "Login Failed"
              And I should not be logged in
              And the failed attempt should be tracked

        Scenario: Login with invalid email format
             When I enter an invalid email "invalid-email"
              And I enter any password
              And I click the "Log in" button
             Then I should see error "Invalid Email"
              And the login should not proceed

        Scenario: Google OAuth login (new user)
             When I click "Log in with Google"
             Then I should be redirected to Google OAuth
              And after successful Google authentication
             Then I should be redirected to "/auth/callback"
              And I should be logged in automatically
              And I should be redirected to "/onboarding"

        Scenario: Google OAuth login (existing user)
            Given an existing user with Google account
              And the user has completed onboarding
             When I click "Log in with Google"
             Then I should be redirected to Google OAuth
              And after successful Google authentication
             Then I should be redirected to "/auth/callback"
              And I should be logged in automatically
              And I should be redirected to the dashboard

Feature: Authentication Security
              As a security-conscious system
              I want to protect against authentication attacks
  So that user accounts remain secure

        Scenario: Rate limiting on failed login attempts
            Given I am on the login page
             When I make 30 failed login attempts within 10 minutes
             Then I should be blocked from further attempts
              And I should see message "Too many failed attempts"
              And I should be blocked for 10 minutes
              And the block timer should count down

        Scenario: Rate limiting on auth routes
            Given I am accessing authentication routes
             When I make more than 20 requests per minute
             Then I should receive a "429 Too many requests" response
              And further requests should be blocked

        Scenario: Password strength validation
            Given I am on the signup page
             When I enter a password without uppercase letters
             Then I should see password strength error
             When I enter a password without lowercase letters
             Then I should see password strength error
             When I enter a password without numbers
             Then I should see password strength error
             When I enter a password without special characters
             Then I should see password strength error
             When I enter a password shorter than 8 characters
             Then I should see password strength error

        Scenario: Session management
            Given I am logged in
             When my session is valid
             Then I should have access to protected routes
             When my session expires
             Then I should be redirected to login page
             When I log out
             Then my session should be invalidated
              And I should be redirected to login page

Feature: Navigation Control
              As the application
              I want to control user navigation based on authentication state
  So that users see appropriate content

        Scenario: Authenticated user accessing auth routes
            Given I am logged in
             When I try to access "/login"
             Then I should be redirected to dashboard "/"
             When I try to access "/signup"
             Then I should be redirected to dashboard "/"
             When I try to access "/reset-password"
             Then I should be redirected to dashboard "/"

        Scenario: Unauthenticated user accessing protected routes
            Given I am not authenticated
             When I try to access "/dashboard"
             Then I should be redirected to "/login"
              And the redirect parameter should include original path
             When I try to access "/workspace/123"
             Then I should be redirected to "/login"

        Scenario: Onboarding flow for new users
            Given I am a newly registered user
              And my onboarding is not complete
             When I log in successfully
             Then I should be redirected to "/onboarding"
            Given my onboarding is complete
             When I try to access "/onboarding"
             Then I should be redirected to dashboard "/"

        Scenario: Complete onboarding flow for new user
            Given I am a newly registered user
              And my onboarding is not complete
             When I log in successfully
             Then I should be redirected to "/onboarding"
              And I should see the onboarding progress indicator
             When I complete the personal information step
             Then I should proceed to the professional information step
             When I complete the professional information step
             Then I should proceed to the workspace setup step
             When I complete the workspace setup step
             Then I should proceed to the completion step
              And the system should create my workspace
              And the system should create default workflows
             When I click "Continue to Dashboard"
             Then I should be redirected to dashboard "/"
              And An email should be sent to the user with the subject "Welcome to ProcessFlow"
              And my onboarding should be marked as complete
              And I should not be able to access "/onboarding" anymore

        Scenario: URL sanitization
            Given I access a URL with encoded spaces "/workspace%20name/flow"
             Then I should be redirected to "/workspace-name/flow"
              And the URL should be properly formatted

        Scenario: Embed route protection
            Given I access an embed route "/shared/flow/123/embed"
             Then the response should include headers:
                  | X-Frame-Options         | ALLOWALL          |
                  | Content-Security-Policy | frame-ancestors * |

Feature: Email Confirmation Flow
              As a new user
              I want to confirm my email address
  So that I can complete my registration

        Scenario: Email confirmation success
            Given I have registered with email "user@example.com"
              And I received a confirmation email
             When I click the confirmation link in the email
             Then I should be redirected to "/auth/confirm"
              And my email should be marked as confirmed
              And I should be automatically logged in
              And I should be redirected to "/onboarding"

        Scenario: Email confirmation with invalid token
             When I access "/auth/confirm" with an invalid token
             Then I should see an error message
              And my email should remain unconfirmed

        Scenario: Resending confirmation email
            Given I have registered but not confirmed my email
             When I try to log in
             Then I should see option to resend confirmation email
             When I click "resend confirmation"
             Then a new confirmation email should be sent
</file>

<file path="e2e/raw/dashboard.feature">
# ProcessFlow Dashboard BDD Tests

Feature: Dashboard Access and Layout
  As a logged-in user
  I want to access and navigate the dashboard
  So that I can manage my workflows and workspace

  Background:
    Given I am a logged-in user
    And I have completed onboarding
    And I am on the dashboard page "/"

  Scenario: Dashboard loads successfully
    When I access the dashboard
    Then I should see the sidebar with workspace information on the left corner
    And I should see the main canvas area
    And I should see the "My Flows" header
    And I should see my user profile in the header bar on the right

  Scenario: Recently used workflows section
    Given I have workflows with recent activity
    When I view the dashboard
    Then I should see a "Recently Used" section
    And it should show up to 4 most recently used workflows
    And workflows should be ordered by last_opened timestamp

  Scenario: Empty state handling
    Given I have no workflows in my workspace
    When I view the dashboard
    Then I should see an appropriate empty state like 'No workflows found'
    And I should see options to create my first workflow

Feature: Workflow Management
  As a user
  I want to manage my workflows
  So that I can organize and maintain my processes

  Background:
    Given I am on the dashboard
    And I have access to workflow management features

  Scenario: Creating a new workflow
    When I click the "New Flow" button
    Then I should see the "Create a new Flow" modal
    When I enter flow name like "Employee Onboarding"
    And I enter flow description like "Process for onboarding new employees"
    And I click the "Create Flow" button
    Then the modal should close
    And I should immeditely go into the new workflow
    And I should see a success notification like "Flow created successfully"

  Scenario: Workflow name validation during creation
    When I open the create flow modal
    And I leave the flow name empty
    Then the "Create Flow" button should be disabled
    When I enter a flow name with 101 characters
    Then only the first 100 characters should be accepted
    Then I should see a validation error like "Flow name must be less than 100 characters"
    And the "Create Flow" button should be disabled
    When I enter flow name with special characters "<script>alert('xss')</script>"
    Then the input should be sanitized

  Scenario: Editing an existing workflow
    Given I have a workflow named "Test Workflow"
    When I click the workflow actions menu
    And I select "Edit"
    Then I should see the "Edit a Flow" modal
    And the form should be pre-filled with current workflow data
    When I change the name to "Updated Workflow"
    And I click "Save changes"
    Then the modal should close
    And the workflow should show the updated name

  Scenario: Workflow icon selection
    When I create or edit a workflow
    And I click the icon selector
    Then I should see the icon selection modal
    And I should see tabs for Icons, Apps, Upload
    When I select an icon from the Icons tab
    Then the icon should be applied to the workflow

  Scenario: Deleting a workflow
    Given I have a workflow named "Test Workflow"
    When I click the workflow actions menu
    And I select "Delete"
    Then I should see a confirmation modal
    And the modal should warn that the action cannot be undone
    When I click "Delete"
    Then the workflow should be removed from the workspace
    And I should see a success notification

  Scenario: Duplicating a workflow
    Given I have a workflow named "Original Workflow"
    When I click the workflow actions menu
    And I select "Duplicate"
    Then a copy of the workflow should be created
    And it should be named "Original Workflow (Copy)"
    And both workflows should be visible in the workspace

  Scenario: Moving a workflow to a folder
    Given I have a workflow and multiple folders
    When I click the workflow actions menu
    And I select "Move"
    Then I should see the "Move Flow" modal
    And I should see a folder tree structure
    When I select a target folder
    And I click "Move"
    Then the workflow should be moved to the selected folder
    And it should no longer appear in the current view if filtered
    And I should see a success notification like "Flow moved successfully"
    And My view should be updated to show the workflow in the new folder

  Scenario: Workflow status management
    Given I have a workflow
    When I click the workflow status indicator
    Then I should see status options (Draft, Active, Archived, In Review, Needs Update)
    When I select "Active"
    Then the workflow status should update
    And the status indicator should reflect the change

  Scenario: Copying workflow link
    Given I have a workflow
    When I click the workflow actions menu
    And I select "Copy link"
    Then the workflow URL should be copied to clipboard
    And I should see a "Link copied!" notification

  Scenario: Sharing a workflow
    Given I have a workflow
    When I click the workflow actions menu
    And I select "Share"
    Then I should see the share modal
    And I should see sharing options and link
    And I should be able to switch between sharing options like "Public" and "Private"
    And I should be able to switch between "Share" and "Embed" options
    And I should be able to copy the link to the clipboard
    And I should see a "Link copied!" notification

Feature: Folder Management
  As a user
  I want to organize my workflows in folders
  So that I can maintain a structured workspace

  Background:
    Given I am on the dashboard
    And I have folder management permissions

  Scenario: Creating a new folder
    When I click the "+" button next to folders
    Then I should see the "Create a folder" modal
    When I enter folder name "HR Processes"
    And I select an icon or emoji
    And I click "Create"
    Then the folder should appear in the sidebar
    And I should see a success notification

  Scenario: Folder name validation
    When I create a folder
    And I leave the folder name empty
    Then the "Create" button should be disabled
    When I enter a folder name with 101 characters
    Then only the first 100 characters should be accepted
    And an error message should be displayed like "Folder name must be less than 100 characters"
    And the "Create" button should be disabled

  Scenario: Creating a subfolder
    Given I have a folder named "HR Processes"
    When I right-click on the folder
    And I select "Create subfolder"
    Then I should see the "Create a Subfolder" modal
    And I should see the parent folder context
    When I enter subfolder name "Onboarding"
    And I click "Create"
    Then the subfolder should appear under the parent folder

  Scenario: Editing a folder
    Given I have a folder named "HR Processes"
    When I right-click on the folder
    And I select "Edit folder"
    Then I should see the "Edit a folder" modal
    And the form should be pre-filled with current folder data
    When I change the name to "Human Resources"
    And I click "Save changes"
    Then the folder should show the updated name

  Scenario: Deleting a folder
    Given I have a folder with no workflows
    When I right-click on the folder
    And I select "Delete folder"
    Then I should see a confirmation modal
    And it should warn that the action cannot be undone
    And it should mention that flows inside will not be deleted
    When I click "Delete"
    Then the folder should be removed
    And any workflows should remain in the workspace

  Scenario: Folder icon and emoji selection
    When I create or edit a folder
    And I click the icon selector
    Then I should see icon selection options
    When I select a company logo
    Then the logo should be applied to the folder
    When I select an emoji
    Then the emoji should be displayed as the folder icon

  Scenario: Folder expansion and collapse
    Given I have a folder with subfolders
    When I click the folder expand/collapse arrow
    Then the folder should expand to show subfolders
    When I click the arrow again
    Then the folder should collapse to hide subfolders

  Scenario: Navigating to folder contents
    Given I have a folder with workflows
    When I click on the folder name
    Then the main canvas should show only workflows in that folder
    And the header should show the folder name and icon
    And I should see a breadcrumb or back navigation option

Feature: Search and Filtering
  As a user
  I want to search and filter my workflows
  So that I can quickly find what I need

  Background:
    Given I am on the dashboard
    And I have multiple workflows and folders

  Scenario: Basic workflow search
    When I enter "onboarding" in the search bar
    Then I should see only workflows containing "onboarding" in the name
    And other workflows should be hidden
    When I clear the search
    Then all workflows should be visible again

  Scenario: Search with no results
    When I enter "nonexistent" in the search bar
    Then I should see a "no results" message
    And no workflows should be displayed

  Scenario: Search is case insensitive
    When I enter "ONBOARDING" in the search bar
    Then I should see workflows containing "onboarding" (lowercase)
    And the search should work regardless of case

  Scenario: Real-time search filtering
    When I start typing in the search bar
    Then the results should update in real-time
    And I should not need to press Enter to search

  Scenario: Search within specific folder
    Given I am viewing a specific folder
    When I enter a search term
    Then I should see only workflows from that folder matching the search
    And workflows from other folders should not appear

  Scenario: Folder filtering
    When I select a folder from the sidebar
    Then the main canvas should show only workflows in that folder
    And the header should indicate the current folder
    When I select "My Flows" (root level)
    Then I should see all workflows not in folders

Feature: User Profile Management
  As a user
  I want to manage my profile and account settings
  So that I can keep my information current and secure

  Background:
    Given I am logged in to the dashboard
    And I can access user settings

  Scenario: Accessing user settings
    When I click on my user profile in the header bar on the right
    Then I should see a user dropdown menu
    When I select "Account settings"
    Then I should see the user settings page

  Scenario: Updating profile information
    When I am in user settings
    And I change my first name to "John"
    And I change my last name to "Doe"
    And I click "Save changes"
    Then my profile should be updated
    And I should see a success notification
    And the changes should be reflected in the UI

  Scenario: Profile information validation
    When I am editing my profile
    And I enter a first name with 41 characters
    Then only the first 40 characters should be accepted
    When I enter special characters in my name
    Then the input should be sanitized appropriately

  Scenario: Changing email address
    When I am in user settings
    And I enter a new email address
    And I click "Change email"
    Then I should see a confirmation dialog
    When I confirm the change
    Then a verification email should be sent
    And I should see instructions to verify the new email

  Scenario: Email validation
    When I enter an invalid email format
    Then I should see an error message
    And the save button should be disabled
    When I enter a valid email format
    Then the error should clear
    And the save button should be enabled

  Scenario: Changing password
    When I am in user settings
    And I click "Change password"
    Then I should see a password change form
    When I enter my current password
    And I enter a new password
    And I confirm the new password
    And I click "Update password"
    Then I should see a confirmation dialog
    When I confirm the password change
    Then my password should be updated
    And I should be logged out of other devices

  Scenario: Password validation
    When I am changing my password
    And I enter a password shorter than 8 characters
    Then I should see a validation error
    When I enter a password without uppercase letters
    Then I should see a validation error
    When I enter a password without lowercase letters
    Then I should see a validation error
    When I enter a password without numbers
    Then I should see a validation error
    When I enter a password without special characters
    Then I should see a validation error
    When I enter mismatched password confirmations
    Then I should see a validation error
    When I enter a valid password "StrongPass123!"
    And I confirm the same password "StrongPass123!"
    Then the validation should clear
    And the save button should be enabled

  Scenario: Account deletion
    When I am in user settings
    And I click "Delete account"
    Then I should see a confirmation dialog
    And I should be required to enter my password
    When I enter my password and confirm deletion
    Then my account should be deleted
    And I should be redirected to the home page

Feature: Settings and Configuration
  As a user
  I want to configure my workspace and billing settings
  So that I can customize my experience and manage my subscription

  Background:
    Given I am on the dashboard
    And I have access to settings

  Scenario: Navigating settings tabs
    When I open settings
    Then I should see tabs for Plan, billing, workspace and appearance
    When I click on the workspace tab
    Then I should see workspace-specific settings
    When I click on the billing tab
    Then I should see billing and subscription information

  Scenario: Workspace settings management
    When I am in workspace settings
    Then I should see the current workspace name and logo
    When I change the workspace name
    And I click "Save changes"
    Then the workspace should be updated
    And the changes should be reflected throughout the UI

  Scenario: Workspace logo upload - valid file types
    When I upload a PNG file smaller than 5MB
    Then the logo should be accepted and displayed
    When I upload a JPEG file smaller than 5MB
    Then the logo should be accepted and displayed
    When I upload an SVG file smaller than 5MB
    Then the logo should be accepted and displayed
    When I upload a file with an invalid type
    Then I should see an error message like "Invalid file type. Please upload a PNG, JPG, GIF, or SVG image."
    When I upload a file with an invalid size
    Then I should see an error message like "File is too large. Maximum size is 5MB."
    And the file should not be accepted

  Scenario: Workspace name validation
    When I am in workspace settings
    And I leave the workspace name empty
    Then I should see a validation error like "Workspace name is required"
    And the "Save" button should be disabled
    When I enter a workspace name with 51 characters
    Then only the first 50 characters should be accepted
    And I should see a validation error like "Workspace name cannot be longer than 50 characters"
    When I enter workspace name with invalid characters "Invalid!Name@#$"
    Then the invalid characters should be removed automatically
    And only valid characters (letters, numbers, spaces, hyphens) should remain
    When I enter a valid workspace name "My Company-123"
    Then the validation should clear
    And the "Save" button should be enabled

  Scenario: Billing information display
    When I am in billing settings
    Then I should see my current subscription plan
    And I should see billing address information
    And I should see payment method details if configured
    When I click "Edit Billing Details"
    Then I should be redirected to the Stripe customer portal

  Scenario: Subscription plan management
    Given I have a subscription
    When I am in billing settings
    Then I should see options to change my plan
    And I should see billing period options (monthly/annual)
    When I select a different plan
    Then I should see pricing information
    And I should be able to confirm the change

  Scenario: Plan downgrade confirmation
    Given I have a paid subscription
    When I attempt to downgrade to a free plan
    Then I should see a confirmation dialog
    And I should see information about feature limitations
    When I confirm the downgrade
    Then my plan should be changed
    And I should see updated feature access

  Scenario: Workspace deletion
    When I am in workspace settings
    And I click "Delete workspace"
    Then I should see a confirmation dialog
    And I should be required to type the workspace name
    When I enter the correct workspace name and confirm
    Then the workspace should be deleted
    And I should be redirected appropriately

Feature: Help and Tutorial
  As a user
  I want to access help and tutorial features
  So that I can learn how to use the platform effectively

  Background:
    Given I am on the dashboard

  Scenario: Accessing help center
    When I click on my user profile
    And I select "Help center"
    Then I should see the help center modal
    And I should see options for different types of help

  Scenario: Help center options
    When I open the help center
    Then I should see "Reach out to us" option
    And I should see "Take a look at our roadmap" option
    And I should see "Join our Slack community" option
    When I click "Reach out to us"
    Then my email client should open with a pre-filled email
    When I click "Join our Slack community"
    Then I should be redirected to the Slack invitation link

  Scenario: Tutorial functionality
    When I access the tutorial option
    Then I should see the tutorial overlay
    And I should see step-by-step guidance
    When I click "Next" on tutorial steps
    Then I should progress through the tutorial
    And relevant UI elements should be highlighted

  Scenario: Tutorial navigation
    When I am in the tutorial
    Then I should see current step indicators
    And I should see options to skip or continue
    When I click "Skip"
    Then the tutorial should end
    And I should return to normal dashboard view

  Scenario: Tutorial completion
    When I complete all tutorial steps
    Then the tutorial should end automatically
    And my tutorial status should be marked as complete
    And I should not see tutorial prompts again

  Scenario: Restarting tutorial
    Given I have completed the tutorial previously
    When I access the help center
    And I select restart tutorial option
    Then the tutorial should start from the beginning
    And my tutorial status should be reset


Feature: Error Handling and Edge Cases
  As a user
  I want the system to handle errors gracefully
  So that I can continue working even when issues occur

  Background:
    Given I am on the dashboard

  Scenario: Network connectivity issues
    When I lose network connectivity
    And I try to perform an action
    Then I should see an appropriate error message like "Something went wrong. Please try again."
    And the action should not complete
    When connectivity is restored 
    Then I should be able to retry the action 

  Scenario: API failure handling
    When an API call fails during workflow creation
    Then I should see an error notification like "Failed to create workflow"
    And the modal should remain open
    And I should be able to retry the operation

  Scenario: File upload failures
    When a file upload fails due to network issues
    And I should be able to retry the upload
    When the upload succeeds on retry
    Then I should see a success confirmation

  Scenario: Validation error handling
    When I submit a form with invalid data
    Then I should see specific validation errors like "Name is required"
    And the form should not submit
    And invalid fields should be highlighted
    When I correct the errors
    Then the validation should clear
    And I should be able to submit successfully

  Scenario: Browser refresh handling
    When I refresh the page during an operation
    Then I should return to a consistent state
    And any unsaved changes should be handled appropriately
    And I should see appropriate notifications about lost changes like "Changes not saved"

  Scenario: Modal and overlay error handling
    When an error occurs while a modal is open
    Then the error should be displayed within the modal context like "An error occurred"
    And I should have options to retry or cancel
    When multiple modals are triggered simultaneously
    Then they should be handled in a logical order
    And the UI should remain stable
</file>

<file path="e2e/raw/editor.feature">
# ProcessFlow Editor BDD Tests

Feature: Editor Access and Layout
  As a logged-in user
  I want to access and navigate the workflow editor
  So that I can create and modify my workflows

  Background:
    Given I am a logged-in user
    And I am on the editor page of a workflow

  Scenario: Editor loads successfully
    When I access the workflow editor
    Then I should see the workflow header with the workflow name
    And I should see the main canvas area
    And I should see the sidebar on the left
    And I should see zoom controls
    And I should see a "Begin" block on the canvas
    And I should see navigation breadcrumbs

  Scenario: Editor header functionality
    When I am in the editor
    Then I should see the workflow title in the header
    And I should see a "Read Mode" button
    When I click the workflow title
    Then I should be able to edit the workflow title inline
    When I click "Read Mode"
    Then I should be redirected to the read view of the workflow

  Scenario: Sidebar navigation
    When I am in the editor
    Then I should see the sidebar with workflow navigation
    And I should see a list of all blocks in the workflow
    And I should see block hierarchy with proper indentation
    When I click on a block in the sidebar
    Then the canvas should center on that block
    And the block should be highlighted

  Scenario: Canvas interaction
    When I am in the editor
    Then I should be able to pan the canvas by dragging
    And I should be able to zoom in and out using mouse wheel
    And I should be able to zoom using the zoom controls
    When I double-click on an empty area
    Then the canvas should fit all blocks in view

Feature: Block Creation and Management
  As a user
  I want to create and manage different types of blocks
  So that I can build comprehensive workflows

  Background:
    Given I am in the workflow editor
    And I can see the canvas with a "Begin" block

  Scenario: Adding a Step block
    When I click the "+" button after the Begin block
    Then I should see the add block dropdown menu
    And I should at least see the "Step" block option
    When I select "Step"
    Then a new Step block should be added to the workflow
    And the block should have a default title like "Untitled Block"
    And the block should have a default icon
    And the dropdown menu should close

  Scenario: Adding a Condition block
    When I click the "+" button after the Begin block
    And I select "Condition"
    Then I should see the "Create a new condition" modal
    When I enter condition name "Approval Decision"
    And I enter condition description "Determine if the request is approved or rejected"
    And I add path names "Approved" and "Rejected"
    And I click "Create Paths"
    Then the modal should close
    And a Condition block should be created
    And two parallel paths should be created with the specified names
    And each path should have its own branch on the canvas

  Scenario: Adding a Delay block
    When I click the "+" button after a Step block
    And I select "Delay"
    Then I should see the delay type selection modal
    When I select "Fixed Duration"
    Then I should see the fixed delay configuration modal
    When I set the delay to 2 hours and 30 minutes
    And I click "Create Delay"
    Then a Fixed Delay block should be added
    And the block should display "2h 30m" as the delay time

  Scenario: Adding an Event Delay block
    When I click the "+" button after a Step block
    And I select "Delay"
    And I select "Wait For Event"
    Then I should see the event delay configuration modal
    When I enter event name "Client Response"
    And I set maximum wait time to 3 days
    And I click "Create Delay"
    Then an Event Delay block should be added
    And the block should display "Wait for Client Response (max 3 days)"

  Scenario: Adding an End block
    Given I have a workflow with multiple blocks
    When I click the "+" button after the last block in a path
    Then I should see the add block dropdown menu
    And I should see an "End Block" option
    When I select "End Block"
    Then an End block should be added


Feature: Block Editing and Properties
  As a user
  I want to edit block properties and content
  So that I can provide detailed information for each step

  Background:
    Given I am in the workflow editor
    And I have a Step block on the canvas

  Scenario: Opening block details sidebar
    When I click on a Step block
    Then the block details sidebar should open on the right
    And I should see the block's current title
    And I should see the block's icon
    And I should see fields for description, average time, and media
    And I should see a close button
    And when I click on the canvas, the sidebar should close

  Scenario: Editing block title
    When I open the block details sidebar
    And I click on the block title
    Then the title should become editable
    When I change the title to "Review Application"
    Then the title should be updated
    And the sidebar should show the new title
    And the block on the canvas should show the new title

  Scenario: Editing block description
    When I open the block details sidebar
    And I click in the description area
    Then the description field should become editable
    When I enter "Review the submitted application for completeness and accuracy"
    And I click outside the description field
    Then the description should be saved
    And the description should be visible in the sidebar

  Scenario: Changing block icon
    When I open the block details sidebar
    And I click on the block icon
    Then I should see the icon selection modal
    And I should see tabs for "Icons", "Apps", and "Upload"
    When I select an icon from the Icons tab
    Then the icon should be applied to the block
    And the modal should close
    And the block should display the new icon

  Scenario: Adding block media
    When I open the block details sidebar
    And I click in the media section
    Then I should see a file upload area
    When I drag and drop an image file
    Then the image should be uploaded
    And the image should be displayed in the media section
    And I should see options to edit or remove the image

  Scenario: Editing block media
    Given I have a block with an uploaded image
    When I open the block details sidebar
    And I click the edit button on the image
    Then I should see the image editor modal
    When I make edits to the image
    And I click "Save"
    Then the edited image should be saved
    And the original image should be preserved for reset option

Feature: Block Actions and Context Menu
  As a user
  I want to perform various actions on blocks
  So that I can efficiently manage my workflow

  Background:
    Given I am in the workflow editor
    And I have multiple blocks in my workflow

  Scenario: Block context menu
    When I click the three dots menu on a Step block
    Then I should see a context menu with options
    And I should see "Edit", "Copy", "Delete", "Connect Blocks", and "Copy Link" options

  Scenario: Copying a block
    When I click the three dots menu on a Step block
    And I select "Copy"
    Then the block should be copied to the clipboard
    And I should see a "Block copied" notification

  Scenario: Pasting a block
    Given I have copied a block to the clipboard
    When I click the "+" button at any position
    Then I should see a "Paste Block" option in the dropdown
    When I select "Paste Block"
    Then a copy of the block should be created at that position
    And the new block should have "(copy)" appended to its title

  Scenario: Deleting a block
    When I click the three dots menu on a Step block
    And I select "Delete"
    Then I should see a confirmation modal
    When I confirm the deletion
    Then the block should be removed from the workflow
    And subsequent blocks should move up to fill the gap

  Scenario: Connecting blocks with stroke lines
    When I click the three dots menu on a Step block
    And I select "Connect Blocks"
    Then I'll see a modal with a search bar
    When I search for a block
    Then I should see the block in the search results
    When I click on the block
    Then I should see the connection modal
    When I enter a connection label "If rejected"
    And I click "Connect"
    Then a stroke line should be created between the blocks
    And the line should display the label

Feature: Path Management and Conditions
  As a user
  I want to create and manage conditional paths
  So that I can model complex decision-based workflows

  Background:
    Given I am in the workflow editor
    And I have a workflow with at least one Condition block

  Scenario: Editing existing paths
    Given I have a Condition block with 3 paths
    When I click the three dots menu on the Condition block
    And I select "Edit"
    Then I should see the "Update Paths" modal
    And I should see the current paths listed
    When I modify a path name from "Approved" to "Fully Approved"
    And I add a new path "Conditionally Approved"
    And I remove the "Rejected" path
    And I click "Update Paths"
    Then the paths should be updated accordingly
    And the workflow should reflect the changes

  Scenario: Merging paths
    Given I have multiple parallel paths that need to converge
    When I click the three dots menu on the last step block of a path
    And I select "Merge Paths"
    Then I should enter merge mode
    And I should see path selection indicators
    When I select the paths I want to merge
    And I click "Merge Selected Paths"
    Then the selected paths should converge into a single path

  Scenario: Path labels and editing
    Given I have conditional paths
    When I click on a path label
    Then the label should become editable
    When I change the label text
    And I press Enter or I click outside the label
    Then the label should be updated
    And the change should be reflected in the workflow

Feature: Stroke Lines and Connections
  As a user
  I want to create custom connections between blocks
  So that I can model complex workflows with loops and non-linear flows

  Background:
    Given I am in the workflow editor
    And I have multiple blocks in different paths

  Scenario: Creating a stroke line connection
    When I click the three dots menu on a source block
    And I select "Connect Blocks"
    Then I should enter connection mode
    When I click on a target block
    Then I should see the connection modal
    And I should see the source and target blocks highlighted
    When I enter connection label "Return for revision"
    And I click "Create Connection"
    Then a stroke line should be drawn between the blocks
    And the line should display the label

  Scenario: Deleting stroke lines
    Given I have a stroke line connection
    When I click on the stroke line
    And I select "Delete"
    Then I should see a confirmation modal
    When I confirm the deletion
    Then the stroke line should be removed
    And the connection should no longer exist

  Scenario: Stroke line visibility toggle
    Given I have multiple stroke lines in my workflow
    When I click the stroke lines visibility toggle
    Then all stroke lines should be hidden
    When I click the toggle again
    Then all stroke lines should be visible again

  Scenario: Editing stroke line control points
    Given I have a stroke line with a curved path
    When I hover over the stroke line
    Then I should see control points for adjusting the curve
    When I drag a control point
    Then the stroke line path should adjust accordingly
    And the new path should be saved

Feature: Sidebar Navigation and Block Management
  As a user
  I want to navigate and manage blocks through the sidebar
  So that I can efficiently work with large workflows

  Background:
    Given I am in the workflow editor
    And I have a complex workflow with multiple paths and blocks

  Scenario: Sidebar block hierarchy
    When I look at the sidebar
    Then I should see all blocks organized hierarchically
    And I should see proper indentation for nested paths
    And I should see block icons and titles
    And I should see block duration estimates

  Scenario: Sidebar search functionality
    When I enter "approval" in the sidebar search box
    Then only blocks containing "approval" should be visible
    And other blocks should be filtered out
    When I clear the search
    Then all blocks should be visible again

  Scenario: Sidebar block navigation
    When I click on a block in the sidebar
    Then the canvas should center on that block
    And the block should be highlighted
    And I should see the block details sidebar open on the right

  Scenario: Sidebar path collapsing
    Given I have paths with multiple nested blocks
    When I click the collapse arrow next to a path
    Then the path's child blocks should be hidden
    When I click the expand arrow
    Then the child blocks should be visible again

Feature: Canvas Interaction and Navigation
  As a user
  I want to interact with the canvas effectively
  So that I can navigate and work with large workflows

  Background:
    Given I am in the workflow editor
    And I have a workflow with multiple blocks

  Scenario: Canvas panning and zooming
    When I drag on an empty area of the canvas
    Then the canvas should pan in the direction of the drag
    When I use the mouse wheel
    Then the canvas should zoom in or out
    When I use the zoom controls
    Then the canvas should zoom to the specified level

Feature: Zoom and View Controls
  As a user
  I want to control the view and zoom level
  So that I can work effectively with workflows of different sizes

  Background:
    Given I am in the workflow editor

  Scenario: Zoom controls functionality
    When I click the zoom in button
    Then the canvas should zoom in by a standard increment
    When I click the zoom out button
    Then the canvas should zoom out by a standard increment
    When I click the zoom percentage
    Then I should see a dropdown with preset zoom levels
    When I select "50%" from the dropdown
    Then the canvas should zoom to 50%

  Scenario: Zoom limits
    When I zoom in to the maximum level
    Then the zoom in button should be disabled
    When I zoom out to the minimum level
    Then the zoom out button should be disabled

  Scenario: Zoom to fit
    Given I have a large workflow that extends beyond the visible area
    When I click "Zoom to fit"
    Then the entire workflow should be visible
    And the zoom level should adjust automatically

Feature: Documentation and Help
  As a user
  I want to access help and documentation
  So that I can learn how to use the editor effectively

  Background:
    Given I am in the workflow editor

  Scenario: Accessing documentation
    When I click the help or documentation button
    Then I should see the documentation modal
    And I should see tabs for different block types
    And I should see "Step", "Delay", "Link", "Condition", "Merge", "Path Labels", and "End" tabs

  Scenario: Documentation content
    When I open the documentation modal
    And I click on the "Step" tab
    Then I should see information about Step blocks
    And I should see "When to use" guidance
    And I should see "How to add" instructions
    When I click on the "Delay" tab
    Then I should see information about both Fixed Duration and Wait For Event delays

  Scenario: Documentation search
    When I open the documentation modal
    And I enter "condition" in the search box
    Then I should see only documentation related to conditions
    And irrelevant tabs should be filtered out

Feature: Error Handling and Validation
  As a user
  I want the editor to handle errors gracefully
  So that I can continue working even when issues occur

  Background:
    Given I am in the workflow editor

  Scenario: Network connectivity issues
    When I lose network connectivity
    And I try to create a new block
    Then I should see an error message like "Something went wrong. Please try again."
    And the action should not complete
    When connectivity is restored
    Then I should be able to retry the action

  Scenario: Path creation validation
    When I try to create parallel paths with empty names
    Then I should see validation errors
    And the "Create Paths" button should be disabled
    When I provide valid path names
    Then the validation should clear
    And I should be able to create the paths
</file>

<file path="e2e/raw/login.feature">
Feature: User login

  As a registered user
  I want to log into the application
  So that I can access my dashboard

  Scenario: Successful login
    Given I am on the login page
    When I enter a valid email and password
    And I click the "Log in" button
    Then I should be redirected to the dashboard
    And I should see a welcome message

  Scenario: Failed login with wrong password
    Given I am on the login page
    When I enter a valid email and an incorrect password
    And I click the "Log in" button
    Then I should see an error message

  Scenario: Attempt login with empty fields
    Given I am on the login page
    When I click the "Log in" button without entering credentials
    Then I should see validation errors for both email and password
</file>

<file path="e2e/raw/onboarding.feature">
# ProcessFlow Onboarding BDD Test

## Feature: User Onboarding Flow

Feature: User Onboarding Flow
              As a new user
              I want to complete the onboarding process
  So that I can set up my workspace and start using ProcessFlow

        Background:
            Given I am a newly registered user
              And I am logged in
              And my onboarding is not complete
              And I am on the onboarding page "/onboarding"

## Feature: Personal Information Step

```gherkin
Feature: Personal Information Step
              As a new user
              I want to provide my personal information
  So that I can proceed with the onboarding

        Background:
            Given I am on the personal information step
              And I see the progress indicator showing step 1 of 3 active

        Scenario: Successful personal information submission
             When I enter first name "Steve"
              And I enter last name "Jobs"
              And I click the "Continue" button
             Then I should proceed to the professional information step
              And the progress indicator should show step 1 completed
              And the progress indicator should show step 2 active
              And my personal information should be saved to localStorage
              And an API call should be made to save personal info

        Scenario: Personal information validation - empty fields
             When I leave the first name field empty
              And I enter last name "Jobs"
             Then the "Continue" button should be disabled
             When I enter first name "Steve"
              And I leave the last name field empty
             Then the "Continue" button should be disabled

        Scenario: Personal information validation - character limits
             When I enter a first name with 41 characters
             Then only the first 40 characters should be accepted
             When I enter a last name with 41 characters
             Then only the first 40 characters should be accepted

        Scenario: Personal information validation - character sanitization
             When I enter first name "Steve<script>alert('xss')</script>"
             Then HTML tags should be removed and only "Stevealert('xss')" should remain
             When I enter first name "Steve123!@#"
             Then special characters should be removed and only "Steve" should remain
             When I enter first name "Steve-O'Connor"
             Then hyphens and apostrophes should be allowed

        Scenario: Personal information persistence
            Given I have entered first name "Steve"
              And I have entered last name "Jobs"
             When I refresh the page
             Then my entered information should be restored from localStorage
              And the form should be pre-filled with my data

        Scenario: Loading state during submission
             When I enter valid personal information
              And I click the "Continue" button
             Then the button should show "Loading..." text
              And the button should be disabled during submission
              And I should proceed to the next step even if API call fails
```

## Feature: Professional Information Step

```gherkin
Feature: Professional Information Step
              As a new user
              I want to provide my professional information
  So that ProcessFlow can be customized to my needs

        Background:
            Given I am on the professional information step
              And I see the progress indicator showing step 2 of 3 active

        Scenario: Successful professional information submission
             When I select industry "IT"
              And I select role "Founder"
              And I select company size "10-49"
              And I select source "ProductHunt"
              And I click the "Continue" button
             Then I should proceed to the workspace setup step
              And the progress indicator should show step 2 completed
              And the progress indicator should show step 3 active
              And my professional information should be saved to localStorage

        Scenario: Professional information validation - all fields required
             When I select industry "IT"
              And I select role "Founder"
              And I select company size "10-49"
              And I leave source unselected
              And I click the "Continue" button
             Then I should see error "Please fill in all fields"
              And I should remain on the professional information step

        Scenario: Professional information dropdown options validation
             When I view the industry dropdown
             Then I should see options: "IT", "Healthcare", "Finance", "Education", "Retail", "Other"
             When I view the role dropdown
             Then I should see options: "Founder", "Manager", "Product Manager", "Analyst", "Designer", "Sales", "Marketing", "HR", "Customer Success", "Freelancer", "Other"
             When I view the company size dropdown
             Then I should see options: "1", "2-9", "10-49", "50-199", "200-499", "500+"
             When I view the source dropdown
             Then I should see options: "ProductHunt", "LinkedIn", "Google", "Friend", "Other"

        Scenario: Navigation back to personal information
             When I click the "Back" button
             Then I should return to the personal information step
              And the progress indicator should show step 1 active
              And my previously entered personal information should be preserved

        Scenario: Professional information persistence
            Given I have selected all professional information fields
             When I navigate to the next step and then back
             Then my professional information should be restored from localStorage
              And all dropdowns should show my previous selections

        Scenario: Loading state during submission
             When I enter valid professional information
              And I click the "Continue" button
             Then the button should show "Loading..." text
              And the button should be disabled during submission
              And I should proceed to the next step even if API call fails
```

## Feature: Workspace Setup Step

```gherkin
Feature: Workspace Setup Step
              As a new user
              I want to set up my workspace
  So that I can start organizing my workflows

        Background:
            Given I am on the workspace setup step
              And I see the progress indicator showing step 3 of 3 active

        Scenario: Successful workspace setup with auto-generated URL
             When I enter workspace name "My Company"
              And the workspace URL is auto-generated as "my-company"
              And the slug availability check shows "Available"
             Then the "Continue" button should be enabled
             When I click the "Continue" button
             Then I should proceed to the completion step
              And my workspace should be created with the generated slug

        Scenario: Workspace name validation - required field
             When I leave the workspace name field empty
             Then the "Continue" button should be disabled
             And A tooltip must indicate that the field workspace name is required
             When I enter workspace name "My Company"
             Then the "Continue" button should be enabled

        Scenario: Workspace name validation - character limits
             When I enter a workspace name with 51 characters
             Then only the first 50 characters should be accepted
              And the input should be automatically truncated

        Scenario: Workspace name validation - allowed characters
             When I enter workspace name "Valid Name-123"
             Then the name should be accepted
             When I enter workspace name "Invalid!Name@#$"
             Then special characters should be removed automatically
              And only "InvalidName" should remain

        Scenario: Workspace URL slug generation and validation
             When I enter workspace name "My Awesome Company"
             Then the workspace URL should be auto-generated as "my-awesome-company"
             When I enter workspace name "Company!@# 123"
             Then the workspace URL should be auto-generated as "company-123"

        Scenario: Workspace URL availability checking
             When I enter a workspace name
             Then a slug availability check should be performed after 500ms delay
              And I should see "Checking availability..." message
             When the slug is available
             Then I should see "Available" message in green
             When the slug is already taken
             Then I should see "This URL is already taken" message in red
              And the "Continue" button should be disabled

        Scenario: Workspace URL manual editing (disabled)
             When I try to manually edit the workspace URL field
             Then the field should be disabled
              And I should not be able to modify it directly

        Scenario: Workspace logo upload - valid file types
             When I upload a PNG file smaller than 5MB
             Then the logo should be accepted and displayed
             When I upload a JPEG file smaller than 5MB
             Then the logo should be accepted and displayed
             When I upload an SVG file smaller than 5MB
             Then the logo should be accepted and displayed
             When I upload a GIF file smaller than 5MB
             Then the logo should be accepted and displayed
             When I upload an AVIF file smaller than 5MB
             Then the logo should be accepted and displayed

        Scenario: Workspace logo upload - invalid file types
             When I upload a PDF file
             Then I should see error "Invalid file type. Please upload a PNG, JPG, GIF, or SVG image."
             When I upload a TXT file
             Then I should see error "Invalid file type. Please upload a PNG, JPG, GIF, or SVG image."

        Scenario: Workspace logo upload - file size validation
             When I upload an image file larger than 5MB
             Then I should see error "File is too large. Maximum size is 5MB."
              And the file should not be accepted

        Scenario: Workspace logo upload - drag and drop
             When I drag a valid image file over the upload area
             Then the upload area should show visual feedback
             When I drop a valid image file on the upload area
             Then the logo should be uploaded and displayed
             When I drop an invalid file on the upload area
             Then I should see appropriate error message

        Scenario: Navigation back to professional information
             When I click the "Back" button
             Then I should return to the professional information step
              And my workspace setup data should be preserved

        Scenario: Form validation before submission
             When I have a valid workspace name
              And the slug is available
             Then the "Continue" button should be enabled
             When I have an invalid workspace name
             Then the "Continue" button should be disabled
             When the slug is not available
             Then the "Continue" button should be disabled
             When the slug availability is still being checked
             Then the "Continue" button should be disabled

        Scenario: Workspace setup persistence
            Given I have entered workspace information
             When I navigate away and return to this step
             Then my workspace setup data should be restored from localStorage
              And the logo preview should be displayed if uploaded
```

## Feature: Completion Step and Workspace Creation

```gherkin
Feature: Completion Step and Workspace Creation
              As a new user
              I want to see my workspace being created
  So that I know the onboarding is completing successfully

        Background:
            Given I have completed all onboarding steps
              And I am on the completion step

        Scenario: Successful workspace and workflow creation
             When I reach the completion step
             Then I should see "Setting up your workspace" message
              And I should see a loading spinner
              And the workspace creation should start automatically
              And default workflows should be created
             When the workspace creation completes successfully
             Then I should see "Your workspace is ready!" message
              And I should see a success checkmark
              And I should see the introduction video
              And the "Continue to Dashboard" button should be enabled

        Scenario: Default workflow creation warnings
             When the workspace is created successfully
              But default workflow creation has warnings
             Then I should see the workspace as ready
              And warnings should be logged but not shown to user
              And I should be able to continue to dashboard

        Scenario: Email scheduling during completion
             When the workspace creation completes
             Then a welcome email should be scheduled immediately
              And a follow-up email should be scheduled for 4 days later
              And a feedback request email should be scheduled for 7 days later
              And a feature update email should be scheduled for 4 days later
             When email scheduling fails
             Then the onboarding should still complete successfully
              And warnings should be logged

        Scenario: Continue to dashboard
             When the workspace creation is complete
              And I click "Continue to Dashboard"
             Then all onboarding data should be cleared from localStorage
              And my onboarding should be marked as complete on the server
              And I should be redirected to the dashboard "/"
              And I should not be able to access "/onboarding" anymore

        Scenario: Browser back button prevention
            Given workspace creation has started
             When I try to use the browser back button
             Then I should remain on the completion step
              And navigation should be prevented

        Scenario: Force completion fallback
            Given the server shows onboarding as incomplete
             Then the button "Continue to Dashboard" is disabled
             ```

## Feature: Navigation and State Management

```gherkin
Feature: Navigation and State Management
              As a user going through onboarding
              I want smooth navigation between steps
  So that I can complete the process efficiently

        Scenario: Progress indicator accuracy
            Given I am on the personal information step
             Then step 1 should be highlighted as active
              And steps 2 and 3 should be inactive
            Given I am on the professional information step
             Then step 1 should show as completed
              And step 2 should be highlighted as active
              And step 3 should be inactive
            Given I am on the workspace setup step
             Then steps 1 and 2 should show as completed
              And step 3 should be highlighted as active

        Scenario: Data persistence across page refreshes
            Given I have partially completed onboarding
             When I refresh the page at any step
             Then I should return to the correct step
              And my previously entered data should be restored
              And the progress indicator should show the correct state

        Scenario: Server state synchronization
            Given I am going through onboarding
             When each step is completed
             Then the server should be updated with my progress
              And the onboarding status should be synchronized
             When I reload the page
             Then the server state should determine my current step

        Scenario: Onboarding completion detection
            Given I have completed onboarding previously
             When I try to access "/onboarding"
             Then I should be redirected to the dashboard "/"
              And I should not see the onboarding flow

        Scenario: Authentication requirement
            Given I am not authenticated
             When I try to access "/onboarding"
             Then I should be redirected to the login page
             When I am authenticated but onboarding is complete
             Then I should be redirected to the dashboard

        Scenario: Light theme enforcement
             When I am on any onboarding step
             Then the interface should use light theme
              And dark mode should be disabled
              And the theme should be forced regardless of system preference
```

## Feature: Error Handling and Edge Cases

```gherkin
Feature: Error Handling and Edge Cases
              As a user going through onboarding
              I want graceful error handling
  So that I can complete onboarding even when issues occur

        Scenario: API failure resilience
             When an API call fails during step submission
             Then I should be blocked from proceeding to the next step
              And the UI should provide an error message "Something went wrong. Please try again."

        Scenario: Network connectivity issues
             When I lose network connectivity during onboarding
             Then my form data should be preserved locally
              And I should be able to continue when connectivity returns
              And slug availability checks should handle timeouts gracefully

        Scenario: Workspace creation timeout handling
             When workspace creation takes longer than expected
             Then I should see appropriate loading messages
              And the process should not timeout prematurely
              And I should have options to retry or continue

        Scenario: Duplicate workspace name handling
             When I enter a workspace name that already exists
             Then the system should automatically suggest alternatives
              And I should be able to proceed with the modified name
              And the slug conflict should be resolved automatically

        Scenario: File upload error recovery
             When logo upload fails due to network issues
             Then I should see the error message "Something went wrong. Please try again."
              And I should be able to retry the upload
              And I should be able to continue without a logo

        Scenario: Concurrent user scenarios
             When multiple users try to create workspaces simultaneously
             Then each should get unique slugs
              And no conflicts should occur
              And all users should complete successfully
```
</file>

<file path="e2e/raw/read-mode.feature">
# ProcessFlow Read Mode BDD Tests

Feature: Read Mode Access and Layout
  As a user
  I want to access and view workflows in read mode
  So that I can follow processes and understand workflow steps

  Background:
    Given I am a logged-in user
    And I have access to a workflow in read mode
    And I am on the read page of a workflow

  Scenario: Read mode loads successfully
    When I access a workflow in read mode
    Then I should see the workflow header with navigation controls
    And I should see the main content area
    And I should see the sidebar on the left with workspace information
    And I should see the view mode switch controls
    And I should see the process card with workflow information
    And I should see breadcrumb navigation

  Scenario: Read mode header functionality
    When I am in read mode
    Then I should see the workflow title in the breadcrumbs
    And I should see an "Edit" button
    And I should see a "Share" button
    And I should see my user profile dropdown
    When I click the "Edit" button
    Then I should be redirected to the edit mode of the workflow
    When I click the back button
    Then I should navigate to the previous page

  Scenario: Process card display
    When I view the process card
    Then I should see the workflow icon
    And I should see the workflow name and description
    And I should see integration badges for connected apps
    And I should see author information if available
    And I should see the last update timestamp
    When there are more than 5 integrations
    Then I should see a "+X" badge for additional integrations
    When I hover over the "+X" badge
    Then I should see a popover with the additional integrations

  Scenario: Sidebar workspace navigation
    When I look at the sidebar
    Then I should see the workspace name and icon
    And I should see a hierarchical list of workflow steps
    When I click on the workspace name
    Then I should be redirected to the workspace dashboard

Feature: View Mode Management
  As a user
  I want to switch between different view modes
  So that I can choose the best way to follow the workflow

  Background:
    Given I am in read mode
    And I can see the view mode switch controls

  Scenario: Switching to vertical view mode
    When I click the vertical view mode button
    Then the interface should switch to vertical mode
    And I should see all steps displayed in a scrollable list
    And I should see the sidebar with step navigation
    And I should see step expansion controls
    And the view mode button should show as active

  Scenario: Switching to carousel view mode
    When I click the carousel view mode button
    Then the interface should switch to carousel mode
    And I should see one step displayed at a time
    And I should see navigation buttons (Previous/Next)
    And I should see a "Get Started" button initially
    And the sidebar should be hidden
    And the view mode button should show as active

Feature: Step Navigation and Progression
  As a user
  I want to navigate through workflow steps
  So that I can follow the process systematically

  Background:
    Given I am in read mode
    And I have a workflow with multiple steps

  Scenario: Linear step progression in carousel mode
    Given I am in carousel mode
    And I am on the first step
    When I click "Next step"
    Then I should proceed to the second step
    And the second step should be displayed
    And I should see a "Previous step" button
    When I click "Previous step"
    Then I should return to the first step

Scenario: Step navigation in vertical mode
    Given I am in vertical mode
    When I got a conditionnal step
    Then I should see the conditionnal step content
    And I should see the path options
    When I select a path option
    Then I should proceed to the first step of the selected path
    And subsequent steps should follow the selected path


Feature: Conditional Path Handling
  As a user
  I want to make choices at decision points
  So that I can follow the appropriate path for my situation

  Background:
    Given I am in read mode
    And I have a workflow with conditional paths

  Scenario: Displaying path options
    Given I reach a step with multiple path options
    Then I should see the step content
    And I should see a "Select an option" section
    And I should see radio buttons for each available path
    And each option should show the path name
    And the "Next step" button should be disabled until I make a selection

  Scenario: Selecting a path option
    Given I am on a step with path options
    When I select a path option
    Then the radio button should be marked as selected
    And the "Next step" button should become enabled
    When I click "Next step"
    Then I should proceed to the first step of the selected path
    And subsequent steps should follow the selected path

  Scenario: Path selection persistence
    Given I have selected a path option
    When I navigate back to the decision step
    Then my previous selection should still be marked
    When I change my selection to a different path
    And I proceed forward
    Then I should follow the newly selected path
    And any progress on the previous path should be reset

  Scenario: Multiple decision points
    Given I have a workflow with multiple decision points
    When I make selections at each decision point
    Then each selection should be remembered
    And I should be able to navigate back and see my choices
    When I change a selection at an earlier decision point
    Then all subsequent selections should be reset
    And I should need to make new selections for later decision points

Feature: Content Display and Media
  As a user
  I want to view rich content and media in workflow steps
  So that I can understand the instructions clearly

  Background:
    Given I am in read mode
    And I have steps with various content types

  Scenario: Basic step content display
    When I view a step
    Then I should see the step icon
    And I should see the step title
    And I should see the step description if available
    And I should see any estimated time duration
    And text content should be properly formatted

  Scenario: Fullscreen image viewing
    Given I have opened an image in fullscreen
    Then I should see the image at full size
    And I should see close button
    And I should see zoom controls
    When I press the Escape key
    Then the fullscreen view should close
    When I click outside the image
    Then the fullscreen view should close

  Scenario: Rich text content with links
    Given I have a step with text containing URLs
    When I view the step description
    Then URLs should be automatically converted to clickable links
    And links should open in a new tab when clicked
    And links should be visually distinguished from regular text

  Scenario: App integration icons
    Given I have steps with app integrations
    When I view these steps
    Then I should see the appropriate app icons
    And icons should load from the correct sources
    When an app icon fails to load
    Then I should see a default fallback icon

Feature: Sidebar Navigation and Step Management
  As a user
  I want to navigate efficiently through the workflow
  So that I can jump to specific steps and understand the structure

  Background:
    Given I am in vertical mode
    And I can see the sidebar

  Scenario: Sidebar step hierarchy display
    When I look at the sidebar
    Then I should see all workflow paths organized hierarchically
    And I should see proper indentation for nested paths
    And I should see step icons and titles
    And I should see expand/collapse arrows for paths with multiple steps

  Scenario: Sidebar step navigation
    When I click on a step in the sidebar
    Then the main content should scroll to that step
    And the step should be highlighted
    And if the step was collapsed, it should expand

  Scenario: Path collapsing and expanding
    Given I have paths with multiple steps
    When I click the collapse arrow next to a path
    Then the path's child steps should be hidden
    And the arrow should change to indicate collapsed state
    When I click the expand arrow
    Then the child steps should be visible again
    And the arrow should change to indicate expanded state

  Scenario: Active step highlighting
    Given I am progressing through the workflow
    When I am on a specific step
    Then that step should be highlighted in the sidebar
    And it should be visually distinct from other steps
    When I navigate to a different step
    Then the highlighting should move to the new step

  Scenario: Sidebar workspace navigation
    When I click on the workspace name in the sidebar
    Then I should be redirected to the workspace dashboard
    And I should see a hover effect on the workspace area
    And the workspace icon and name should be clearly visible

Feature: Delay Block Handling
  As a user
  I want to understand delay blocks in workflows
  So that I know when to wait and what to expect

  Background:
    Given I am in read mode
    And I have a workflow with delay blocks

  Scenario: Fixed duration delay display
    Given I reach a fixed duration delay block
    Then I should see a delay icon (clock/stopwatch)
    And I should see "Fixed Duration" as the delay type
    And I should see the delay time formatted (e.g., "2h 30m")
    And I should see a message like "Flow paused for 2 hours and 30 minutes"
    And I should see an info box explaining the delay

  Scenario: Event-based delay display
    Given I reach an event-based delay block
    Then I should see a delay icon (calendar/clock)
    And I should see "Event-Based Delay" as the delay type
    And I should see the event name being waited for
    And I should see "Waiting for: [Event Name]"
    If the delay has an expiration time
    Then I should see "Expires after [time]" with an hourglass icon
    And I should see appropriate pause messaging

Feature: Header Controls and Navigation
  As a user
  I want to access workflow controls and navigation
  So that I can manage my workflow viewing experience

  Background:
    Given I am in read mode
    And I can see the header controls

  Scenario: Breadcrumb navigation
    When I look at the header
    Then I should see breadcrumb navigation
    And I should see the workspace name (if applicable)
    And I should see folder names (if workflow is in a folder)
    And I should see the workflow name as the final breadcrumb
    When I click on a breadcrumb item with a link
    Then I should navigate to that location

  Scenario: Edit mode navigation
    When I click the "Edit" button in the header
    Then I should be redirected to the edit mode
    And the URL should change to the edit mode URL
    And I should see the workflow editor interface

  Scenario: User profile dropdown
    When I click on my user profile in the header
    Then I should see a dropdown menu
    And I should see "Account settings" option
    And I should see "Help center" option
    When I select "Account settings"
    Then I should see the user settings modal
    When I select "Help center"
    Then I should see the help center modal

Feature: Sharing and Access Control
  As a user
  I want to share workflows and control access
  So that I can collaborate with others effectively

  Background:
    Given I am in read mode
    And I have sharing permissions for the workflow

  Scenario: Opening share modal
    When I click the "Share" button
    Then I should see the share modal
    And I should see the workflow name in the modal
    And I should see the current sharing status (Public/Private)
    And I should see the share URL
    And I should see copy link button

  Scenario: Toggling workflow access
    Given the workflow is currently public
    When I toggle back to private
    Then I should see "Workflow is now private" notification
    When I toggle back to public
    Then I should see "Workflow is now public" notification

  Scenario: Copying share link
    When I click "Copy link" in the share modal
    Then the workflow URL should be copied to clipboard
    And I should see a "Link copied!" notification
    And the copied link should be the correct share URL

  Scenario: Share modal with workspace branding
    Given my workspace has a custom logo
    When I open the share modal
    Then I should see the workspace logo in the modal
    And the modal should reflect the workspace branding

  Scenario: Public workflow access
    Given I have a public workflow link
    When I access the workflow without being logged in
    Then I should be able to view the workflow
    And I should see limited functionality (no edit access)
    And I should not see user-specific controls

Feature: Process Completion and Restart
  As a user
  I want to complete workflows and restart them
  So that I can finish processes and repeat them as needed

  Background:
    Given I am in read mode in carousel mode
    And I have progressed through a workflow

  Scenario: Reaching workflow completion
    Given I am on the last step of the workflow
    When I click "Complete" or reach the end
    Then I should see the completion screen
    And I should see a success icon (checkmark)
    And I should see a congratulations message
    And I should see "You've completed the process" text
    And I should see sharing encouragement message

  Scenario: Completion screen actions
    When I am on the completion screen
    Then I should see a "Copy link" button
    And I should see a "Restart process" button
    When I click "Copy link"
    Then the workflow share link should be copied
    And I should see a "Link copied!" notification
    When I click "Restart process"
    Then I should return to the initial state
    And all step progress should be reset
    And all path selections should be cleared

  Scenario: Completion with conditional paths
    Given I completed a workflow with multiple path choices
    When I restart the process
    Then all my previous path selections should be cleared
    And I should be able to make different choices
    And follow different paths through the workflow

Feature: Error Handling and Edge Cases
  As a user
  I want the system to handle errors gracefully
  So that I can continue using the workflow even when issues occur

  Background:
    Given I am in read mode

  Scenario: Network connectivity issues
    When I lose network connectivity
    And I try to navigate to a new step
    Then I should see an appropriate error message
    And the interface should remain functional for local actions
    When connectivity is restored
    Then I should be able to continue normally

  Scenario: Missing or broken media
    Given I have a step with an image that fails to load
    When I view that step
    Then I should see a placeholder or error state
    And the step should still be functional
    And other content should display normally

  Scenario: Invalid workflow access
    When I try to access a workflow that doesn't exist
    Then I should see a 404 error page
    When I try to access a private workflow without permission
    Then I should be redirected to login
</file>

<file path="e2e/step-definitions/dashboard.steps.ts">
// @ts-nocheck
const { Given, When, Then } = require('@cucumber/cucumber');

Given('an editor placeholder step', function () {
  // Placeholder step for editor
});
</file>

<file path="e2e/step-definitions/editor.steps.ts">
// @ts-nocheck
const { Given, When, Then } = require('@cucumber/cucumber');

Given('an editor placeholder step', function () {
  // Placeholder step for editor
});
</file>

<file path="e2e/step-definitions/onboarding.steps.ts">
// @ts-nocheck
const { Given, When, Then } = require('@cucumber/cucumber');

Given('an onboarding placeholder step', function () {
  // Placeholder step for onboarding
});
</file>

<file path="e2e/step-definitions/read-mode.steps.ts">
// @ts-nocheck
const { Given, When, Then } = require('@cucumber/cucumber');

Given('a read mode placeholder step', function () {
  // Placeholder step for read mode
});
</file>

<file path="lib/auth.ts">
import { isVercel } from '@/app/api/utils/isVercel';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { NextRequest } from 'next/server';

export async function getProtectedRoute(request: Request) {
  const userId = request.headers.get('x-user-id');
  const userRole = request.headers.get('x-user-role');
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  if (!userId) {
    throw new Error('User ID not found in request headers');
  }

  const user = await prisma_client.user.findUnique({ 
    where: { auth_id: userId }
  });
  if (isVercel()) await prisma_client.$disconnect();
  return user;
}

/**
 * Get the active user from the request
 * @param request Next.js request object
 * @returns The user object or null if not found
 */
export async function getActiveUser(request: NextRequest | Request) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const userId = request.headers.get('x-user-id');
    
    if (!userId) {
      console.warn('User ID not found in request headers');
      return null;
    }
    
    const user = await prisma_client.user.findUnique({ 
      where: { auth_id: userId }
    });
    return user;
  } catch (error) {
    console.error('Error getting active user:', error);
    return null;
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="lib/email.ts">
import nodemailer from 'nodemailer';
import { render } from '@react-email/render';
import * as React from 'react';

// Create a transporter using SMTP configuration
const createTransporter = () => {
  // Check if required environment variables are set
  const requiredEnvVars = ['SMTP_SERVER', 'SMTP_PORT', 'SMTP_USERNAME', 'SMTP_PASSWORD'];
  const missingEnvVars = requiredEnvVars.filter(envVar => !process.env[envVar]);
  
  if (missingEnvVars.length > 0) {
    console.warn(`Missing email configuration: ${missingEnvVars.join(', ')}. Email functionality may not work properly.`);
  }
  
  const transporterOptions: any = {
    host: process.env.SMTP_SERVER,
    port: Number(process.env.SMTP_PORT || '587'),
    secure: process.env.SMTP_SECURE === 'true', // true for 465, false for other ports
  };

  if (process.env.SMTP_USERNAME && process.env.SMTP_PASSWORD) {
    transporterOptions.auth = {
      user: process.env.SMTP_USERNAME,
      pass: process.env.SMTP_PASSWORD,
    };
  }

  return nodemailer.createTransport(transporterOptions);
};

const transporter = createTransporter();

// Define sender types
export type SenderType = 'contact' | 'jean' | 'noreply';

// Define sender information
export const senders = {
  contact: {
    email: process.env.EMAIL_SENDER_CONTACT || 'contact@process-flow.io',
    name: 'ProcessFlow Team',
    signature: 'ClientServiceSignature',
  },
  jean: {
    email: process.env.EMAIL_SENDER_JEAN || 'jean@process-flow.io',
    name: 'Jean - ProcessFlow',
    signature: 'JeanSignature',
  },
  noreply: {
    email: process.env.EMAIL_SENDER_NOREPLY || 'noreply@notifications.process-flow.io',
    name: 'ProcessFlow',
    signature: 'NoReplySignature',
  },
};

type SendEmailProps = {
  to: string;
  subject: string;
  emailHtml: string;
  sender?: SenderType;
  from?: string; // Optional override
};

/**
 * Sends an email using nodemailer
 */
export async function sendEmail({ to, subject, emailHtml, sender = 'noreply', from }: SendEmailProps) {
  try {
    if (!to || !subject || !emailHtml) {
      throw new Error('Missing required email parameters: to, subject, or emailHtml');
    }
    
    const senderInfo = senders[sender];
    if (!senderInfo) {
      throw new Error(`Invalid sender type: ${sender}`);
    }
    
    const fromAddress = from || `"${senderInfo.name}" <${senderInfo.email}>`;

    const info = await transporter.sendMail({
      from: fromAddress,
      to,
      subject,
      html: emailHtml,
      headers: {
        'Content-Type': 'text/html; charset=UTF-8',
      },
      // Add these settings to help with image rendering
      attachDataUrls: true,
      disableFileAccess: true,
      disableUrlAccess: false,
    });


    return { success: true, messageId: info.messageId };
  } catch (error) {
    console.error('Error sending email:', error);
    return { success: false, error };
  }
}

/**
 * Helper function to render a React component to HTML and send it as an email
 */
export async function sendReactEmail<T extends object>({
  to,
  subject,
  Component,
  props,
  sender = 'noreply',
  from,
}: {
  to: string;
  subject: string;
  Component: React.ComponentType<T>;
  props: T;
  sender?: SenderType;
  from?: string;
}) {
  try {
    // Log environment variables for debugging (redacted for security)
    console.log('Email environment check:', {
      supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL ? 'Set' : 'Not set',
      storagePath: process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH ? 'Set' : 'Not set',
      smtpServer: process.env.SMTP_SERVER ? 'Set' : 'Not set',
      productHuntUrl: process.env.NEXT_PUBLIC_PRODUCTHUNT_URL ? 'Set' : 'Not set',
      linkedinUrl: process.env.NEXT_PUBLIC_LINKEDIN_URL ? 'Set' : 'Not set',
      xUrl: process.env.NEXT_PUBLIC_X_URL ? 'Set' : 'Not set',
    });
    
    // Create a copy of the props
    const enhancedProps = { ...props } as any;
    
    // If publicUrls exists in props, enhance it with additional URLs
    if (enhancedProps.publicUrls) {
      enhancedProps.publicUrls = {
        ...enhancedProps.publicUrls,
        // Add social media URLs if not already present
        producthuntUrl: enhancedProps.publicUrls.producthuntUrl || process.env.NEXT_PUBLIC_PRODUCTHUNT_URL,
        linkedinUrl: enhancedProps.publicUrls.linkedinUrl || process.env.NEXT_PUBLIC_LINKEDIN_URL,
        xUrl: enhancedProps.publicUrls.xUrl || process.env.NEXT_PUBLIC_X_URL,
      };
    } else {
      // If publicUrls doesn't exist, create it
      enhancedProps.publicUrls = {
        supabasePublicUrl: process.env.NEXT_PUBLIC_SUPABASE_URL,
        supabaseStoragePath: process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH,
        producthuntUrl: process.env.NEXT_PUBLIC_PRODUCTHUNT_URL,
        linkedinUrl: process.env.NEXT_PUBLIC_LINKEDIN_URL,
        xUrl: process.env.NEXT_PUBLIC_X_URL,
      };
    }
    
    // Render the React component to HTML
    const emailHtml = await render(React.createElement(Component, enhancedProps as unknown as T));
    
   
    
    // Send the email
    return sendEmail({ to, subject, emailHtml, sender, from });
  } catch (error) {
    console.error('Error rendering or sending React email:', error);
    return { success: false, error };
  }
}
</file>

<file path="prisma/migrations/20250611092229_add_workspace_invitation/migration.sql">
-- CreateEnum
CREATE TYPE "invitation_status" AS ENUM ('PENDING', 'ACCEPTED', 'EXPIRED', 'REVOKED');

-- CreateTable
CREATE TABLE "workspace_invitation" (
    "id" SERIAL NOT NULL,
    "workspace_id" INTEGER NOT NULL,
    "email" TEXT NOT NULL,
    "inviter_id" INTEGER NOT NULL,
    "status" "invitation_status" NOT NULL DEFAULT 'PENDING',
    "invited_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "accepted_at" TIMESTAMP(3),
    "expired_at" TIMESTAMP(3),

    CONSTRAINT "workspace_invitation_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "workspace_invitation_workspace_id_idx" ON "workspace_invitation"("workspace_id");

-- CreateIndex
CREATE INDEX "workspace_invitation_email_idx" ON "workspace_invitation"("email");

-- CreateIndex
CREATE INDEX "workspace_invitation_status_idx" ON "workspace_invitation"("status");

-- AddForeignKey
ALTER TABLE "workspace_invitation" ADD CONSTRAINT "workspace_invitation_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "workspace"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "workspace_invitation" ADD CONSTRAINT "workspace_invitation_inviter_id_fkey" FOREIGN KEY ("inviter_id") REFERENCES "user"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250613111511_unique_userid_workspace_constraint/migration.sql">
/*
  Warnings:

  - A unique constraint covering the columns `[user_id,workspace_id]` on the table `user_workspace` will be added. If there are existing duplicate values, this will fail.

*/
-- CreateIndex
CREATE UNIQUE INDEX "user_workspace_user_id_workspace_id_key" ON "user_workspace"("user_id", "workspace_id");
</file>

<file path="prisma/migrations/20250618070313_brand_urls/migration.sql">
-- AlterTable
ALTER TABLE "workspace" ADD COLUMN     "brand_logo_url" TEXT,
ADD COLUMN     "brand_name_img_url" TEXT;
</file>

<file path="prisma/migrations/20250621164914_brand_urls/migration.sql">
-- AlterTable
ALTER TABLE "workspace" ADD COLUMN     "branding_enabled" BOOLEAN NOT NULL DEFAULT false;
</file>

<file path="types/workspace.ts">
import { Workflow } from './workflow';

export interface Folder {
  id: number;
  name: string;
  workspace_id: number;
  parent_id?: number;
  team_tags: string[];
  icon_url?: string;
  signedIconUrl?: string;
  emote?: string;
  position: number;
}

export type SubscriptionStatus = 'ACTIVE' | 'TRIALING' | 'CANCELED';
export type PlanType = 'FREE' | 'EARLY_ADOPTER';

export interface Subscription {
  id: number;
  workspace_id: number;
  plan_type: PlanType;
  status: SubscriptionStatus;
  current_period_start: Date;
  current_period_end: Date;
  canceled_at?: Date;
  trial_end_date?: Date;
  quantity_seats: number;
  stripe_subscription_id: string;
}

export interface Workspace {
  id: number;
  name: string;
  users: Array<{
    id: number;
    email: string;
    name?: string;
  }>;
  workflows: Workflow[];
  folders: Folder[];
  team_tags?: string[];
  icon_url?: string;
  brand_logo_url?: string;
  brand_name_img_url?: string;
  branding_enabled?: boolean;
  background_colour?: string;
  slug?: string;
  subscription?: Subscription;
}
</file>

<file path="app/[slug]/[flow]/edit/components/MediaUploader.tsx">
import React, { ChangeEvent, DragEvent, useState, useEffect, useRef, useCallback } from 'react';
import { Block } from '../../types';
import { useColors } from '@/app/theme/hooks';

interface MediaUploaderProps {
  block: Block;
  onUpdate: (updatedBlock: Partial<Block>) => void;
}

export default function MediaUploader({ block, onUpdate }: MediaUploaderProps) {
  const [isDragOver, setIsDragOver] = useState(false);
  const [clipboardHasImage, setClipboardHasImage] = useState(false);
  const colors = useColors();
  const containerRef = useRef<HTMLLabelElement>(null);

  // Helper for file validation
  const validateFile = useCallback((file: File): boolean => {
    if (!file.type.startsWith('image/')) {
      alert('Invalid file type. Please select an image file.');
      return false;
    }
    if (file.size > 1024 * 1024) {
      alert('File too large. Image must be less than 1MB.');
      return false;
    }
    return true;
  }, []);

  const handleFileChange = async (event: ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file && validateFile(file)) {
      await uploadFile(file);
    }
  };

  const handleDragOver = (event: DragEvent<HTMLLabelElement>) => {
    event.preventDefault();
    setIsDragOver(true);
  };

  const handleDragLeave = () => {
    setIsDragOver(false);
  };

  const handleDrop = async (event: DragEvent<HTMLLabelElement>) => {
    event.preventDefault();
    setIsDragOver(false);

    const file = event.dataTransfer.files[0];
    if (file && validateFile(file)) {
      await uploadFile(file);
    }
  };

  const uploadFile = useCallback(async (file: File) => {
    const formData = new FormData();
    formData.append('file', file);

    try {
      const response = await fetch('/api/upload', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error('Upload failed');
      }

      const data = await response.json();
      onUpdate({ image: data.filePath });
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  }, [onUpdate]);

  // Clipboard paste handler
  const handlePaste = useCallback(async (event: ClipboardEvent) => {
    event.preventDefault();
    
    try {
      // Check if we have clipboard items
      if (navigator.clipboard?.read) {
        const clipboardItems = await navigator.clipboard.read();
        
        for (const item of clipboardItems) {
          if (item.types.some(type => type.startsWith('image/'))) {
            const imageType = item.types.find(type => type.startsWith('image/'));
            if (imageType) {
              const blob = await item.getType(imageType);
              const file = new File([blob], 'pasted-image.png', { type: imageType });
              
              if (validateFile(file)) {
                await uploadFile(file);
              }
              return;
            }
          }
        }
      }
      
      // Fallback for older browsers or when clipboard.read() isn't available
      const items = event.clipboardData?.items;
      if (items) {
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          if (item.type.startsWith('image/')) {
            const file = item.getAsFile();
            if (file && validateFile(file)) {
              await uploadFile(file);
            }
            return;
          }
        }
      }
    } catch (error) {
      console.error('Error pasting image:', error);
      alert('Failed to paste image. Please try uploading manually.');
    }
  }, [validateFile, uploadFile]);

  // Check clipboard content for image
  const checkClipboardForImage = useCallback(async () => {
    try {
      if (navigator.clipboard?.read) {
        const clipboardItems = await navigator.clipboard.read();
        const hasImage = clipboardItems.some(item => 
          item.types.some(type => type.startsWith('image/'))
        );
        setClipboardHasImage(hasImage);
      } else {
        setClipboardHasImage(false);
      }
    } catch (error) {
      // Permission denied or not supported, ignore
      setClipboardHasImage(false);
    }
  }, []);

  // Setup clipboard event listeners
  useEffect(() => {
    const handleGlobalPaste = (event: ClipboardEvent) => {
      // Only handle paste if this component is visible and the paste is not in an input
      const target = event.target as HTMLElement;
      if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') return;
      
      handlePaste(event);
    };

    // Check clipboard content when component mounts
    checkClipboardForImage();
    
    // Listen for focus to check clipboard again
    const handleFocus = () => checkClipboardForImage();
    
    document.addEventListener('paste', handleGlobalPaste);
    window.addEventListener('focus', handleFocus);
    
    return () => {
      document.removeEventListener('paste', handleGlobalPaste);
      window.removeEventListener('focus', handleFocus);
    };
  }, [handlePaste, checkClipboardForImage]);

  // Keyboard shortcut hint
  const getShortcutText = () => {
    const isMac = /(Mac|iPhone|iPod|iPad)/i.test(navigator.userAgent);
    return isMac ? 'V' : 'Ctrl+V';
  };

  return (
    <label
      ref={containerRef}
      className={`flex flex-col justify-center items-center w-full h-[200px] rounded-xl border-2 border-dashed transition-colors cursor-pointer ${isDragOver ? 'bg-opacity-10' : 'hover:bg-opacity-100'}`}
      style={{
        borderColor: isDragOver
          ? colors['button-primary-fg']
          : colors['input-border'],
        backgroundColor: isDragOver
          ? `${colors['button-primary-bg']}10`
          : colors['input-bg-hover'],
      }}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      <input
        type="file"
        onChange={handleFileChange}
        accept="image/*"
        className="hidden"
      />
      <div className="self-stretch h-[94px] flex flex-col justify-start items-center gap-3">
        <div
          className="w-10 h-10 p-2.5 rounded-lg border flex justify-center items-center"
          style={{ borderColor: colors['input-border'] }}
        >
          <div className="w-5 h-5 rounded-full flex justify-center items-center">
            <img
              src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/upload-cloud-icon.svg`}
              alt="Upload Icon"
              className="w-4 h-4"
            />
          </div>
        </div>
        <div className="self-stretch h-[42px] flex flex-col justify-start items-center gap-1">
          <div className="self-stretch flex justify-center items-center gap-1">
            <div
              className="text-sm font-semibold leading-tight"
              style={{ color: colors['button-secondary-color-fg'] }}
            >
              Click to upload
            </div>
            <div
              className="text-sm font-normal leading-tight"
              style={{ color: colors['input-hint'] }}
            >
              or drag and drop
            </div>
          </div>
          <div className="self-stretch flex flex-col items-center gap-1">
            <div
              className="text-center text-xs font-normal leading-[18px]"
              style={{ color: colors['input-hint'] }}
            >
              SVG, PNG, JPG or GIF
            </div>
            {clipboardHasImage && (
              <div
                className="text-center text-xs font-medium leading-[18px]"
                style={{ color: colors['button-primary-fg'] }}
              >
                Press {getShortcutText()} to paste image
              </div>
            )}
          </div>
        </div>
      </div>
    </label>
  );
}
</file>

<file path="app/[slug]/[flow]/read/components/ReadPageClient.tsx">
'use client';

import React, { useState, useEffect, useRef, useMemo } from 'react';
import Header from './Header';
import { useParams } from 'next/navigation';
import { User } from '@/types/user';
import { createClient } from '@/utils/supabase/client';
import UserSettings from '@/app/dashboard/components/UserSettings';
import HelpCenterModal from '@/app/dashboard/components/HelpCenterModal';
import dynamic from 'next/dynamic';
import Sidebar from './Sidebar';
import { Workspace, Folder } from '@/types/workspace';
import { useColors } from '@/app/theme/hooks';
import ProcessCard from './ProcessCard';
import ViewModeSwitch from './ViewModeSwitch';
import VerticalStep from './steps/VerticalStep';
import HorizontalLastStep from './steps/HorizontalLastStep';
import ButtonNormal from '@/app/components/ButtonNormal';
import { cn } from '@/lib/utils';
import { toast } from 'sonner';
import { usePathsStore } from '../store/pathsStore';
import ProcessCanvas from './ProcessCanvas';
import VerticalLastStep from './steps/VerticalLastStep';
import HorizontalStep from './steps/HorizontalStep';
import { Block, Path, PathParentBlock, WorkflowData } from '../../types';
import { BlockEndType } from '@/types/block';
import { cp } from 'fs';
import VerticalDelay from './steps/VerticalDelay';
import HorizontalDelay from './steps/HorizontalDelay';
import ShareModal from '@/app/components/ShareModal';
import {
  createAndCopyShareLink,
  createShareLink,
} from '../../utils/createLinks';
import { calculateTotalTime } from '../utils/timeUtils';

const HelpCenterModalDynamic = dynamic(
  () => import('@/app/dashboard/components/HelpCenterModal'),
  {
    ssr: false,
  }
);

const UserSettingsDynamic = dynamic(
  () => import('@/app/dashboard/components/UserSettings'),
  {
    ssr: false,
  }
);

interface StepOption {
  id: string;
  title: string;
  description: string;
}

interface StepData {
  number: number;
  label: string;
  description: string;
  icon: string;
  isActive?: boolean;
  isConditional?: boolean;
  options?: StepOption[];
}

interface StrokeLine {
  id: number;
  source_block_id: number;
  target_block_id: number;
  workflow_id: number;
  label: string;
}

interface BreadcrumbItem {
  label: string;
  href?: string;
}

// Modify the type for source block pairs
type SourceBlockPair = {
  originalId: number;
  copies: Block[];
};

interface ExtendedWorkspace extends Workspace {
  logo?: string;
}

interface Workflow {
  id: number;
  name: string;
  icon: string;
  description: string;
  workspace_id: number;
  public_access_id: string;
  folder_id?: number;
  last_opened?: Date;
  updated_at: string;
  created_at: string;
}

export default function ReadPageClient() {
  const params = useParams();
  const supabase = createClient();
  const colors = useColors();
  const [user, setUser] = useState<User | null>(null);
  const [userSettingsVisible, setUserSettingsVisible] =
    useState<boolean>(false);
  const [helpCenterVisible, setHelpCenterVisible] = useState<boolean>(false);
  const [passwordChanged, setPasswordChanged] = useState<boolean>(false);
  const [newPassword, setNewPassword] = useState<string>('');
  const [workspace, setWorkspace] = useState<ExtendedWorkspace | null>(null);
  const [viewMode, setViewMode] = useState<'vertical' | 'carousel'>('vertical');
  const [selectedOptions, setSelectedOptions] = useState<[number, number][]>(
    []
  );
  const [currentStep, setCurrentStep] = useState<number>(-1);
  const [expandedSteps, setExpandedSteps] = useState<number[]>([]);
  const stepRefs = useRef<(HTMLDivElement | null)[]>([]);
  const [pathsToDisplay, setPathsToDisplay] = useState<typeof paths>([]);
  const [strokeLines, setStrokeLines] = useState<StrokeLine[]>([]);
  const [workflowData, setWorkflowData] = useState<WorkflowData | null>(null);
  const [breadcrumbItems, setBreadcrumbItems] = useState<BreadcrumbItem[]>([]);
  const [mergePathsParents, setMergePathsParents] = useState<
    [number, number][]
  >([]);
  const [generatedPathIds] = useState<Set<number>>(new Set());
  const [generatedBlockIds] = useState<Set<number>>(new Set());
  const [copyPaths, setCopyPaths] = useState<Path[]>([]);
  const [shareUrl, setShareUrl] = useState<string>('');
  const [isToggling, setIsToggling] = useState(false);
  const [localIsPublic, setLocalIsPublic] = useState(
    workflowData?.is_public || false
  );

  // Add sourceBlockPairs as a component-level variable
  const sourceBlockPairs: SourceBlockPair[] = [];

  const paths = usePathsStore((state) => state.paths);
  const mainPath = useMemo(
    () => paths.find((path) => path.parent_blocks.length === 0),
    [paths]
  );

  const PathsToDisplayBlocks = useMemo(() => {
    return pathsToDisplay.flatMap((path) => {
      // Filter blocks and apply skip logic
      return path.blocks.filter(
        (block) => !['BEGIN', 'LAST', 'MERGE', 'END'].includes(block.type)
      );
    });
  }, [pathsToDisplay, selectedOptions, paths]);

  // Parse the flow parameter to get workflowId
  const flowParam = params?.flow as string;
  const lastPfIndex = flowParam.lastIndexOf('--pf-');
  const workflowName = flowParam.slice(0, lastPfIndex);
  const workflowId = flowParam.slice(lastPfIndex + 5);

  // Initialize all steps as expanded when paths are loaded
  useEffect(() => {
    if (pathsToDisplay.length > 0) {
      const allBlockIds = pathsToDisplay.flatMap((path) =>
        path.blocks
          .filter((block) => block.type !== 'BEGIN' && block.type !== 'LAST')
          .map((block) => block.id)
      );
      setExpandedSteps(allBlockIds);
    }
  }, [pathsToDisplay]);

  useEffect(() => {
    const fetchSignedUrl = async () => {
      if (process.env.NODE_ENV !== 'production') {
        console.log('user', user);
      }
      if (user && user.avatar_url && !user.avatar_signed_url) {
        user.avatar_signed_url = user.avatar_url;
      }
    };

    fetchSignedUrl();
  }, [user]);

  // Fetch user data
  useEffect(() => {
    const fetchUser = async () => {
      try {
        // Check authentication status first
        const {
          data: { user: authUser },
          error: authError,
        } = await supabase.auth.getUser();

        if (!authUser || authError) {
          window.location.href = '/login';
          return;
        }

        const res = await fetch('/api/user');
        const data = await res.json();
        if (data) {
          setUser(data);
        }
      } catch (error) {
        console.error('Error fetching user:', error);
        window.location.href = '/login';
      }
    };
    fetchUser();
  }, []);

  // Fetch workspace data
  useEffect(() => {
    const fetchWorkspace = async () => {
      try {
        const response = await fetch(
          `/api/workspace/${workflowData?.workspace_id}`
        );
        if (!response.ok) throw new Error('Failed to fetch workspace');
        const data = await response.json();
        setWorkspace(data);
      } catch (error) {
        console.error('Error fetching workspace:', error);
      }
    };

    if (workflowData?.workspace_id) {
      fetchWorkspace();
    }
  }, [workflowData?.workspace_id]);

  useEffect(() => {}, [paths]);
  // Fetch paths
  useEffect(() => {
    const fetchPathsAndStrokeLines = async () => {
      if (!workflowId || !workflowData?.workspace_id) return;

      try {
        // Fetch paths
        const response = await fetch(
          `/api/workspace/${workflowData?.workspace_id}/paths?workflow_id=${workflowId}`
        );
        const pathsData = await response.json();

        if (pathsData.paths) {
          const newPaths = [...pathsData.paths];

          // First process stroke lines
          const strokeLinesResponse = await fetch(
            `/api/stroke-lines?workflow_id=${workflowId}`
          );
          if (strokeLinesResponse.ok) {
            const strokeLinesData: StrokeLine[] =
              await strokeLinesResponse.json();
            setStrokeLines(strokeLinesData);

            strokeLinesData.forEach((strokeLine) => {
              const sourcePath = newPaths.find((p: Path) =>
                p.blocks.some((b) => b.id === strokeLine.source_block_id)
              );
              let targetPath = newPaths.find((p: Path) =>
                p.blocks.some((b) => b.id === strokeLine.target_block_id)
              );

              if (sourcePath && targetPath) {
                // Find the source block index
                const sourceBlockIndex = sourcePath.blocks.findIndex(
                  (b: Block) => b.id === strokeLine.source_block_id
                );

                if (sourceBlockIndex !== -1) {
                  // Get the next block after source
                  const nextBlock = sourcePath.blocks[sourceBlockIndex + 1];

                  let continuePath: Path | undefined;

                  // Original logic for non-PATH blocks
                  const blocksAfterSource = sourcePath.blocks.slice(
                    sourceBlockIndex + 1
                  );
                  if (blocksAfterSource.length > 0) {
                    continuePath = {
                      id: generateUniqueId(generatedPathIds, true),
                      name:
                        blocksAfterSource[0].type === 'MERGE' &&
                        blocksAfterSource[0].child_paths?.[0]
                          ? (() => {
                              const childPathId =
                                blocksAfterSource[0].child_paths[0].path_id;
                              const childPath = pathsData.paths.find(
                                (p: Path) => p.id === childPathId
                              );
                              const childBlock = childPath?.blocks[1];
                              return (
                                childBlock?.title ||
                                (childBlock?.type
                                  ? childBlock.type.charAt(0).toUpperCase() +
                                    childBlock.type.slice(1).toLowerCase() +
                                    ' Block'
                                  : 'Merge Block')
                              );
                            })()
                          : blocksAfterSource[0].title ||
                            (blocksAfterSource[0].type === 'LAST' ||
                            blocksAfterSource[0].type === 'END'
                              ? 'Complete process'
                              : blocksAfterSource[0].type
                                  .charAt(0)
                                  .toUpperCase() +
                                blocksAfterSource[0].type
                                  .slice(1)
                                  .toLowerCase() +
                                ' Block'),
                      workflow_id: parseInt(workflowId as string),
                      workflow: sourcePath.workflow,
                      blocks: blocksAfterSource,
                      parent_blocks: [
                        {
                          path_id: -1,
                          block_id: strokeLine.source_block_id,
                          created_at: new Date().toISOString(),
                          path: {} as Path,
                          block: {} as Block,
                        },
                      ],
                    };

                    const sourceBlock = newPaths
                      .flatMap((p) => p.blocks)
                      .find((b: Block) => b.id === strokeLine.source_block_id);

                    if (sourceBlock) {
                      if (
                        sourceBlock.is_endpoint &&
                        (blocksAfterSource[0].type === 'LAST' ||
                          blocksAfterSource[0].type === 'END')
                      ) {
                        sourceBlock.child_paths = sourceBlock.child_paths;
                      } else {
                        sourceBlock.child_paths = [
                          ...(sourceBlock.child_paths || []),
                          {
                            path_id: continuePath.id,
                            block_id: sourceBlock.id,
                            created_at: new Date().toISOString(),
                            path: continuePath,
                            block: sourceBlock,
                          },
                        ];
                      }
                    }

                    newPaths.push(continuePath);
                  }

                  // Remove blocks after source block
                  sourcePath.blocks = sourcePath.blocks.slice(
                    0,
                    sourceBlockIndex + 1
                  );

                  // If target path is the same as source path and we created a continue path,
                  // update targetPath to be the continue path
                  if (targetPath.id === sourcePath.id && continuePath) {
                    const targetBlockIndex = continuePath.blocks.findIndex(
                      (b: Block) => b.id === strokeLine.target_block_id
                    );
                    if (targetBlockIndex !== -1) {
                      targetPath = continuePath;
                    }
                  }

                  const targetBlockIndex = targetPath.blocks.findIndex(
                    (b: Block) => b.id === strokeLine.target_block_id
                  );

                  if (targetBlockIndex !== -1) {
                    // Rest of the existing code for creating the target path...
                    const { clonedPath: newPath, sourceBlocks } =
                      clonePathWithMergeBlocks(
                        {
                          id: generateUniqueId(generatedPathIds, true),
                          name: strokeLine.label,
                          workflow_id: parseInt(workflowId as string),
                          workflow: targetPath.workflow,
                          blocks: targetPath.blocks.slice(targetBlockIndex),
                          parent_blocks: [
                            {
                              path_id: -1,
                              block_id: strokeLine.source_block_id,
                              created_at: new Date().toISOString(),
                              path: {} as Path,
                              block: {} as Block,
                            },
                          ],
                        },
                        newPaths,
                        strokeLine.source_block_id
                      );

                    // Add the new path to all source blocks as a child path
                    const sourceBlock = newPaths
                      .flatMap((p) => p.blocks)
                      .find((b: Block) => b.id === strokeLine.source_block_id);
                    if (sourceBlock) {
                      sourceBlock.child_paths = [
                        ...(sourceBlock.child_paths || []),
                        {
                          path_id: newPath.id,
                          block_id: sourceBlock.id,
                          created_at: new Date().toISOString(),
                          path: newPath,
                          block: sourceBlock,
                        },
                      ];
                    }

                    // Add the new path to newPaths
                    newPaths.push(newPath);
                  }
                }
              }
            });

            // Apply child_paths from original blocks to their copies
            sourceBlockPairs.forEach((pair) => {
              const originalBlock = newPaths
                .flatMap((p) => p.blocks)
                .find((b) => b.id === pair.originalId);

              if (originalBlock?.child_paths) {
                if (process.env.NODE_ENV !== 'production') {
                  console.log('originalBlock', originalBlock);
                }
                pair.copies.forEach((copyBlock) => {
                  const existingPathIds = new Set(
                    copyBlock.child_paths?.map((cp) => cp.path_id) || []
                  );

                  copyBlock.child_paths = [
                    ...(copyBlock.child_paths || []),
                    ...originalBlock.child_paths
                      .filter(
                        (cp: PathParentBlock) =>
                          !existingPathIds.has(cp.path_id)
                      )
                      .map((cp: PathParentBlock) => ({
                        ...cp,
                        block_id: copyBlock.id,
                        block: copyBlock,
                      })),
                  ];
                });
              }
            });

            // Then process MERGE blocks in each path
            newPaths.forEach((path: Path) => {
              const mergeBlockIndex = path.blocks.findIndex(
                (block: Block) =>
                  block.type === 'MERGE' && block.child_paths?.[0]
              );

              if (mergeBlockIndex !== -1) {
                const mergeBlock = path.blocks[mergeBlockIndex];
                const childPath = pathsData.paths.find(
                  (p: Path) => p.id === mergeBlock.child_paths[0].path.id
                );
                if (childPath) {
                  // Deep clone the blocks from child path
                  const clonedBlocks = childPath.blocks
                    .filter((b: Block) => !['BEGIN', 'END'].includes(b.type))
                    .map((block: Block) => ({
                      ...block,
                      path_id: path.id,
                    }));

                  // Replace MERGE block with the cloned blocks
                  path.blocks = [
                    ...path.blocks.slice(0, mergeBlockIndex),
                    ...clonedBlocks,
                    ...path.blocks.slice(mergeBlockIndex + 1),
                  ];
                }
              }
            });

            // After syncing child paths for blocks with original_id
            newPaths.forEach((path) => {
              path.blocks.forEach((block: Block) => {
                if (block.original_id) {
                  // Find original block
                  const originalBlock = newPaths
                    .flatMap((p) => p.blocks)
                    .find((b) => b.id === block.original_id);

                  if (originalBlock?.child_paths) {
                    // Get existing path IDs
                    const existingPathIds = new Set(
                      block.child_paths?.map((cp) => cp.path_id) || []
                    );

                    // Add missing child paths from original block
                    block.child_paths = [
                      ...(block.child_paths || []),
                      ...originalBlock.child_paths
                        .filter(
                          (cp: PathParentBlock) =>
                            !existingPathIds.has(cp.path_id)
                        )
                        .map((cp: PathParentBlock) => ({
                          ...cp,
                          block_id: block.id,
                          block: block,
                        })),
                    ];
                  }
                }
              });
            });

            // Now remove blocks after any block with child paths
            newPaths.forEach((path) => {
              path.blocks.forEach((block: Block) => {
                if (block.child_paths?.length > 0) {
                  const blockIndex = path.blocks.findIndex(
                    (b: Block) => b.id === block.id
                  );
                  if (blockIndex !== -1) {
                    // Trim path to remove blocks after this one
                    path.blocks = path.blocks.slice(0, blockIndex + 1);
                  }
                }
              });
            });

            // Update paths store with the final processed paths
            usePathsStore.getState().setPaths(newPaths);
          }
        }
      } catch (error) {
        console.error('Error fetching paths and stroke lines:', error);
      }
    };

    fetchPathsAndStrokeLines();
  }, [workflowId, workflowData]);

  // Update this useEffect to set initial pathsToDisplay
  useEffect(() => {
    if (mainPath) {
      setPathsToDisplay([mainPath]);
    }
  }, [mainPath]);

  // Add utility function for generating unique IDs
  const generateUniqueId = (
    existingIds: Set<number>,
    isPath: boolean = false
  ): number => {
    let id: number;
    do {
      id = Math.floor(Math.random() * -1000000);
    } while (existingIds.has(id));

    existingIds.add(id);
    return id;
  };

  // Remove sourceBlockPairs parameter since we can access it from component scope
  const deepCloneBlock = (block: Block, sourceBlockId: number): Block => {
    const newBlockId = generateUniqueId(generatedBlockIds);
    const newBlock = {
      ...block,
      id: newBlockId,
      original_id: block.original_id ? block.original_id : block.id,
      path_id: block.path_id,
    };

    if (sourceBlockId < 0) {
      if (process.env.NODE_ENV !== 'production') {
        console.log('sourceBlockId', sourceBlockId);
      }
    }
    if (block.id === sourceBlockId) {
      if (process.env.NODE_ENV !== 'production') {
        console.log('pushing the copy ofsourceBlockId', sourceBlockId);
      }
      const pair = sourceBlockPairs.find((p) => p.originalId === sourceBlockId);
      if (pair) {
        pair.copies.push(newBlock);
      } else {
        sourceBlockPairs.push({
          originalId: sourceBlockId,
          copies: [newBlock],
        });
      }
    }

    return newBlock;
  };

  // Modify clonePathWithMergeBlocks function
  const clonePathWithMergeBlocks = (
    path: Path,
    allPaths: Path[],
    sourceBlockId: number
  ): { clonedPath: Path; sourceBlocks: Block[] } => {
    const newPathId = generateUniqueId(generatedPathIds, true);

    // Clone the path normally
    const clonedPath = {
      ...path,
      id: newPathId,
      blocks: path.blocks.reduce<Block[]>((acc, block, index, blocks) => {
        const clonedBlock = deepCloneBlock(block, sourceBlockId);
        clonedBlock.path_id = newPathId;

        return [...acc, clonedBlock];
      }, []),
      parent_blocks: path.parent_blocks.map((pb) => ({
        ...pb,
        path_id: newPathId,
        path: { ...pb.path },
        block: { ...pb.block },
      })),
    };

    return {
      clonedPath,
      sourceBlocks: sourceBlockPairs.flatMap((pair) => pair.copies),
    };
  };

  // Update the useEffect to only fetch workflow data
  useEffect(() => {
    const fetchData = async () => {
      try {
        if (!workflowId) {
          console.error('No workflow ID provided');
          return;
        }

        const workflowResponse = await fetch(`/api/workflow/${workflowId}`);
        const workflowData = await workflowResponse.json();
        setWorkflowData(workflowData);
        setLocalIsPublic(workflowData.is_public);
        // Create breadcrumbs from workflow data
        const items: BreadcrumbItem[] = [];

        if (workflowData.folder?.parent) {
          items.push({
            label: workflowData.folder.parent.name,
            href: `/?folder=${workflowData.folder.parent.id}`,
          });
        }

        if (workflowData.folder) {
          items.push({
            label: workflowData.folder.name,
            href: `/?folder=${workflowData.folder.id}`,
          });
        }

        items.push({ label: workflowData.name });
        setBreadcrumbItems(items);

        // Generate share URL when we have workflow data
        if (workflowData) {
          const url = createShareLink(
            workflowData.name,
            workflowData.public_access_id
          );
          if (url) {
            setShareUrl(url);
          }
        }
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    };

    fetchData();
  }, [workflowId]);

  // Update processCardData to use workflow data
  const processCardData = workflowData
    ? {
        icon:
          workflowData.icon && workflowData.icon.trim() !== ''
            ? workflowData.icon.startsWith('https://cdn.brandfetch.io/')
              ? workflowData.icon
              : workflowData.signedIconUrl
                ? workflowData.signedIconUrl
                : `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`
            : `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`,
        workflow: {
          name: workflowData.name,
          description: workflowData.description,
        },
        integrations: paths
          .flatMap((path) =>
            path.blocks
              .filter(
                (block) =>
                  block.icon &&
                  block.icon.includes('/apps/') &&
                  block.signedIconUrl
              )
              .map((block) => ({
                name: block
                  .icon!.split('/apps/')[1]
                  .split('.svg')[0]
                  .split('-')
                  .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
                  .join(' '),
                icon: `${block.signedIconUrl}`,
              }))
          )
          .filter(
            (integration, index, self) =>
              index === self.findIndex((i) => i.name === integration.name)
          ),
        ...(workflowData.process_owner &&
          workflowData.process_owner.trim() && {
            owner: {
              name: workflowData.process_owner,
              // Flow owners don't have avatars in our current system
            },
          }),
        review_date: workflowData.review_date
          ? new Date(workflowData.review_date).toLocaleDateString('en-GB')
          : 'No review date',
        additionalNotes: workflowData.additional_notes,
        lastUpdate:
          paths
            .flatMap((path) => path.blocks)
            .reduce(
              (latest, block) =>
                block.updated_at &&
                (!latest || new Date(block.updated_at) > new Date(latest))
                  ? new Date(block.updated_at).toLocaleDateString('en-GB')
                  : latest,
              ''
            ) || 'No updates',
      }
    : null;

  const openUserSettings = () => {
    setUserSettingsVisible(true);
  };

  const closeUserSettings = () => {
    setUserSettingsVisible(false);
    setPasswordChanged(false);
  };

  const openHelpCenter = () => {
    setHelpCenterVisible(true);
  };

  const closeHelpCenter = () => {
    setHelpCenterVisible(false);
  };

  // Function to update the user in state
  const updateUser = (updatedUser: User) => {
    setUser(updatedUser);
  };

  // Add this effect to handle view mode changes
  useEffect(() => {
    // Reset to main path when view mode changes
    const mainPath = paths.find((path) => path.parent_blocks.length === 0);
    if (mainPath) {
      setPathsToDisplay([mainPath]);
      setSelectedOptions([]); // Clear selected options
      setCurrentStep(-1); // Reset current step to initial state
    }
  }, [viewMode, paths]);

  // Update useEffect to initialize copyPaths when paths change
  useEffect(() => {
    setCopyPaths(paths);
  }, [paths]);

  // Modify handleOptionSelect to use copyPaths
  const handleOptionSelect = (optionId: number, blockId: number) => {
    if (
      selectedOptions.some(
        ([pathId, bId]) => pathId === optionId && bId === blockId
      )
    ) {
      return;
    }

    // Search in copyPaths instead of paths
    const pathToAdd = copyPaths.find((path) => path.id === optionId);
    if (!pathToAdd) {
      return;
    }

    // Find the index where this selection will replace an existing one
    const replaceIndex = pathsToDisplay.findIndex((path) =>
      path.blocks.some((block) =>
        selectedOptions.some(
          ([_, selectedBlockId]) =>
            selectedBlockId === block.id && block.id === blockId
        )
      )
    );

    // Remove any existing selection for this blockId
    const existingSelection = selectedOptions.find(
      ([_, bId]) => bId === blockId
    );
    if (existingSelection) {
      const [existingPathId] = existingSelection;
      setSelectedOptions((prev) => prev.filter(([_, bId]) => bId !== blockId));
      setPathsToDisplay((prev) => prev.filter((p) => p.id !== existingPathId));
    }

    // Always create a copy of the path
    const newPathId = generateUniqueId(generatedPathIds, true);
    const pathCopy = {
      ...pathToAdd,
      id: newPathId,
      blocks: pathToAdd.blocks.map((block) => ({
        ...block,
        original_id: block.original_id ? block.original_id : block.id,
        id: generateUniqueId(generatedBlockIds),
        path_id: newPathId,
      })),
      parent_blocks: [
        {
          path_id: newPathId,
          block_id: blockId,
          created_at: new Date().toISOString(),
          path: {} as Path,
          block:
            PathsToDisplayBlocks.find((b) => b.id === blockId) || ({} as Block),
        },
      ],
    };

    // Add the new path copy to copyPaths
    setCopyPaths((current) => {
      // If pathToAdd was only in copyPaths (not in original paths), remove it
      if (!paths.some((p) => p.id === pathToAdd.id)) {
        return current.filter((p) => p.id !== pathToAdd.id).concat(pathCopy);
      }
      // Otherwise just add the new copy
      return [...current, pathCopy];
    });

    // Replace in child_paths of the parent block
    const parentBlock = PathsToDisplayBlocks.find(
      (block) =>
        block.id === blockId &&
        block.child_paths?.some((cp) => cp.path.id === pathToAdd.id)
    );

    if (parentBlock) {
      parentBlock.child_paths = parentBlock.child_paths?.map((cp) =>
        cp.path.id === pathToAdd.id
          ? {
              ...cp,
              path_id: newPathId,
              block_id: blockId,
              path: pathCopy,
            }
          : cp
      );
    }

    // If we found a replace index, remove everything after it
    if (replaceIndex !== -1) {
      setPathsToDisplay((current) => [
        ...current.slice(0, replaceIndex + 1),
        pathCopy,
      ]);
      setSelectedOptions((prev) => {
        const blockIdsToKeep = new Set(
          pathsToDisplay
            .slice(0, replaceIndex + 1)
            .flatMap((p) => p.blocks)
            .map((b) => b.id)
        );
        return [
          ...prev.filter(([_, bId]) => blockIdsToKeep.has(bId)),
          [pathCopy.id, blockId],
        ];
      });
    } else {
      setPathsToDisplay((current) => [...current, pathCopy]);
      setSelectedOptions((prev) => [...prev, [pathCopy.id, blockId]]);
    }

    // Add smooth scrolling to the first block of the newly added path
    // Use setTimeout to ensure DOM has updated with new blocks
    setTimeout(() => {
      // Find the first non-system block in the newly added path
      const firstNewBlock = pathCopy.blocks.find(
        (block) => !['BEGIN', 'LAST', 'MERGE', 'END'].includes(block.type)
      );
      
      if (firstNewBlock) {
        const blockElement = document.getElementById(`block-${firstNewBlock.id}`);
        if (blockElement) {
          blockElement.scrollIntoView({
            behavior: 'smooth',
            block: 'center',
          });
          // Adjust for header height
          window.scrollBy(0, -120);
        }
      }
    }, 200); // Increased delay to ensure content has rendered
  };

  // Add this function to handle step navigation
  const handleStepNavigation = (direction: 'prev' | 'next') => {
    if (direction === 'next') {
      if (currentStep === PathsToDisplayBlocks.length - 1) {
        setCurrentStep(PathsToDisplayBlocks.length);
      } else {
        setCurrentStep((prev) =>
          Math.min(prev + 1, PathsToDisplayBlocks.length - 1)
        );
      }
    } else {
      if (currentStep === PathsToDisplayBlocks.length) {
        setCurrentStep(PathsToDisplayBlocks.length - 1);
      } else {
        setCurrentStep((prev) => Math.max(prev - 1, -1));
      }
    }
  };

  // Add this function to calculate progress
  const calculateProgress = () => {
    return ((currentStep + 1) / (PathsToDisplayBlocks.length + 1)) * 100;
  };

  const handleCopyLink = async () => {
    if (!workflowData?.id) return;

    try {
      const url = await createAndCopyShareLink(workflowData.id);
      setShareUrl(url);
      toast.success('Link Copied!', {
        description: 'Share link has been copied to your clipboard.',
        duration: 3000,
      });
    } catch (error) {
      console.error('Error copying link:', error);
      toast.error('Failed to Copy', {
        description: 'Could not copy the link to your clipboard.',
        duration: 3000,
      });
    }
  };

  // Function to handle step click from sidebar
  const handleStepClick = (blockId: number) => {
    setCurrentStep(blockId);

    // Add to expanded steps if not already expanded
    if (!expandedSteps.includes(blockId)) {
      setExpandedSteps((prev) => [...prev, blockId]);
    }

    // Find the element with the matching block ID
    const blockElement = document.getElementById(`block-${blockId.toString()}`);
    if (blockElement) {
      setTimeout(() => {
        blockElement.scrollIntoView({
          behavior: 'smooth',
          block: 'center',
        });
        // Adjust for header height
        window.scrollBy(0, -120); // Offset for header height
      }, 50);
    }
  };

  const handleStepToggle = (blockId: number, isExpanded: boolean) => {
    if (isExpanded) {
      setCurrentStep(blockId);
      // Add scrolling behavior
      const element = stepRefs.current[blockId];
      if (element) {
        setTimeout(() => {
          element.scrollIntoView({
            behavior: 'smooth',
            block: 'center',
          });
          window.scrollBy(0, -120);
        }, 50);
      }
    }
    setExpandedSteps((prev) =>
      isExpanded ? [...prev, blockId] : prev.filter((i) => i !== blockId)
    );
  };

  const handleRestart = () => {
    setCurrentStep(-1);
    setSelectedOptions([]);
    if (mainPath) {
      setPathsToDisplay([mainPath]);
    }
  };

  const toggleWorkflowAccess = async () => {
    if (isToggling || !workflowData) return;

    try {
      setIsToggling(true);

      // Optimistic update for immediate feedback
      setLocalIsPublic(!localIsPublic);

      const response = await fetch(`/api/workflow/${workflowData.id}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          is_public: !localIsPublic,
        }),
      });

      const responseData = await response.json();

      if (!response.ok) {
        // Revert the optimistic update if the server request failed
        setLocalIsPublic(workflowData.is_public);
        throw new Error(
          responseData.message || 'Failed to update workflow access'
        );
      }

      // Update workflowData with the actual server response
      setWorkflowData({
        ...workflowData,
        is_public: responseData.is_public,
      });

      // Use the actual server response to determine the new state
      const newState = responseData.is_public;
      toast.success('Access updated', {
        description: `Workflow is now ${newState ? 'public' : 'private'}`,
        duration: 3000,
      });
    } catch (error) {
      console.error('Error toggling workflow access:', error);
      toast.error('Failed to update access', {
        description: 'Could not update the workflow access settings.',
        duration: 3000,
      });
    } finally {
      setIsToggling(false);
    }
  };

  const [isShareModalOpen, setIsShareModalOpen] = useState(false);

  return (
    <div
      className="min-h-screen flex"
      style={{ backgroundColor: colors['bg-primary'] }}
    >
      {user && workspace && workflowData && (
        <>
          {viewMode === 'vertical' && (
            <Sidebar
              className="w-64"
              workspace={workspace}
              activeStepId={currentStep}
              onStepClick={handleStepClick}
              pathsToDisplay={pathsToDisplay}
            />
          )}
          <div
            className={cn(
              'flex-1',
              viewMode === 'vertical' ? 'ml-64' : 'w-full'
            )}
          >
            <div
              className={cn(
                'fixed right-0 bg-primary z-30',
                viewMode === 'vertical' ? 'left-64' : 'left-0'
              )}
            >
              <Header
                breadcrumbItems={breadcrumbItems}
                user={user}
                onOpenUserSettings={openUserSettings}
                onOpenHelpCenter={openHelpCenter}
                params={
                  params
                    ? {
                        id: workflowData.workspace_id.toString(),
                        workflowId: workflowId.toString() ?? '',
                        slug: workflowData.workspace.name ?? '',
                      }
                    : undefined
                }
                is_public={localIsPublic}
                onToggleAccess={toggleWorkflowAccess}
                shareUrl={shareUrl}
                workflowTitle={workflowName}
                workspace={workspace || undefined}
              />
              <div className="absolute right-4 top-20 flex items-center gap-2">
                <ViewModeSwitch mode={viewMode} onModeChange={setViewMode} />
              </div>
            </div>

            {/* User Settings Modal */}
            {userSettingsVisible && (
              <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
                <UserSettingsDynamic
                  user={user}
                  onClose={closeUserSettings}
                  onUserUpdate={updateUser}
                  passwordChanged={passwordChanged}
                  openDeleteAccount={() => {}}
                  updateNewPassword={setNewPassword}
                />
              </div>
            )}

            {/* Help Center Modal */}
            {helpCenterVisible && (
              <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
                <HelpCenterModalDynamic onClose={closeHelpCenter} user={user} />
              </div>
            )}

            {/* Main content */}
            <ProcessCanvas
              className={cn(
                viewMode === 'vertical'
                  ? 'overflow-y-scroll absolute inset-0 left-64 ml-0'
                  : 'w-full overflow-hidden'
              )}
            >
              {viewMode === 'vertical' ? (
                <div className="p-6">
                  <div className="ml-28 flex flex-col gap-[72px]">
                    {processCardData && (
                      <ProcessCard {...processCardData} viewMode={viewMode} />
                    )}
                    {pathsToDisplay
                      .map((path) => {
                        return (
                          <div key={path.id} className="space-y-16">
                            {path.blocks
                              .filter(
                                (block) =>
                                  block.type !== 'BEGIN' &&
                                  block.type !== 'LAST' &&
                                  block.type !== 'END'
                              )
                              .map((block, index, filteredBlocks) => {
                                return (
                                  <div
                                    key={block.id}
                                    id={`block-${block.id}`}
                                    ref={(el) => {
                                      if (el) stepRefs.current[index] = el;
                                    }}
                                  >
                                    {block.type === 'DELAY' ? (
                                      <VerticalDelay
                                        block={block}
                                        isActive={currentStep === block.id}
                                        isLastStep={
                                          index === filteredBlocks.length - 1
                                        }
                                        selectedOptionIds={selectedOptions}
                                        onOptionSelect={(optionId, blockId) =>
                                          handleOptionSelect(optionId, blockId)
                                        }
                                      />
                                    ) : (
                                      <VerticalStep
                                        variant="default"
                                        block={block}
                                        isActive={currentStep === block.id}
                                        defaultExpanded={expandedSteps.includes(
                                          block.id
                                        )}
                                        onToggle={(isExpanded) =>
                                          handleStepToggle(block.id, isExpanded)
                                        }
                                        selectedOptionIds={selectedOptions}
                                        onOptionSelect={(optionId, blockId) =>
                                          handleOptionSelect(optionId, blockId)
                                        }
                                        copyPaths={copyPaths}
                                        isLastStep={
                                          index === filteredBlocks.length - 1
                                        }
                                      />
                                    )}
                                  </div>
                                );
                              })
                              .filter(Boolean)}
                          </div>
                        );
                      })
                      .filter(Boolean)}
                    {(() => {
                      const lastPath =
                        pathsToDisplay[pathsToDisplay.length - 1];
                      if (!lastPath) return null;
                      const filteredBlocks = lastPath.blocks.filter(
                        (block) =>
                          block.type !== 'BEGIN' &&
                          block.type !== 'LAST' &&
                          block.type !== 'END'
                      );
                      const lastBlock =
                        filteredBlocks[filteredBlocks.length - 1];

                      if (
                        !lastBlock ||
                        !lastBlock.child_paths ||
                        lastBlock.child_paths.length === 0
                      ) {
                        return (
                          <VerticalLastStep
                            onCopyLink={handleCopyLink}
                            onRestart={handleRestart}
                            icon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-circle.svg`}
                          />
                        );
                      }
                      return null;
                    })()}
                  </div>
                </div>
              ) : (
                <div className="h-full flex items-center justify-center">
                  <div
                    className="rounded-lg border w-full max-w-3xl mx-6"
                    style={{
                      backgroundColor: colors['bg-primary'],
                      borderColor: colors['border-secondary'],
                    }}
                  >
                    <div className="p-8 flex flex-col">
                      {currentStep === -1 ? (
                        <>
                          <div
                            style={{
                              height: '472px',
                              backgroundColor: colors['bg-primary'],
                            }}
                            className="flex items-center justify-center"
                          >
                            {processCardData && (
                              <div className="w-full flex justify-center h-full">
                                <ProcessCard
                                  {...processCardData}
                                  viewMode={viewMode}
                                />
                              </div>
                            )}
                          </div>
                          {/* Navigation and Progress Bar */}
                          <div className="flex items-center justify-end mt-8">
                            {/* Progress Bar - hidden */}
                            <div className="items-center hidden">
                              <div className="relative flex items-center w-[400px]">
                                {/* Home Icon */}
                                <img
                                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/home-05.svg`}
                                  alt="Home icon"
                                  className="w-6 h-6"
                                />

                                {/* Line from home to first step */}
                                <div
                                  className="w-[40px] h-[1px] mx-2"
                                  style={{
                                    backgroundColor:
                                      currentStep >= 0
                                        ? colors['bg-brand-solid']
                                        : colors['border-secondary'],
                                  }}
                                />

                                {/* Step Dots - Initial View */}
                                {PathsToDisplayBlocks.map((_, index) => (
                                  <div
                                    key={index}
                                    className="flex items-center"
                                  >
                                    {/* Step Indicator */}
                                    <div className="relative z-10 flex items-center justify-center w-6 h-6">
                                      {index < currentStep ? (
                                        // Completed step - show tick icon
                                        <img
                                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/step-icon-done.svg`}
                                          alt="Completed step"
                                          className="w-6 h-6"
                                        />
                                      ) : (
                                        // Current or future step - show simple dot
                                        <div
                                          className={cn('w-2 h-2 rounded-full')}
                                          style={{
                                            backgroundColor:
                                              index === currentStep
                                                ? colors['bg-brand-solid']
                                                : colors['border-secondary'],
                                          }}
                                        />
                                      )}
                                    </div>
                                    {/* Connecting Line */}
                                    {index <
                                      PathsToDisplayBlocks.length - 1 && (
                                      <div
                                        className="w-[40px] h-[1px] mx-2"
                                        style={{
                                          backgroundColor:
                                            index < currentStep
                                              ? colors['bg-brand-solid']
                                              : colors['border-secondary'],
                                        }}
                                      />
                                    )}
                                  </div>
                                ))}
                              </div>
                            </div>

                            {/* Navigation Buttons */}
                            <div className="flex items-center gap-2">
                              {currentStep > -1 && (
                                <ButtonNormal
                                  variant="secondary"
                                  size="small"
                                  onClick={() => handleStepNavigation('prev')}
                                  disabled={currentStep === -1}
                                  leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-left.svg`}
                                >
                                  Previous step
                                </ButtonNormal>
                              )}
                              {currentStep < PathsToDisplayBlocks.length && (
                                <ButtonNormal
                                  variant="primary"
                                  size="small"
                                  onClick={() => handleStepNavigation('next')}
                                  disabled={
                                    currentStep ===
                                      PathsToDisplayBlocks.length ||
                                    (currentStep >= 0 &&
                                      currentStep <
                                        PathsToDisplayBlocks.length &&
                                      PathsToDisplayBlocks[currentStep]
                                        ?.child_paths?.length > 0 &&
                                      !selectedOptions.some(
                                        ([_, blockId]) =>
                                          blockId ===
                                          PathsToDisplayBlocks[currentStep].id
                                      ))
                                  }
                                  trailingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-right.svg`}
                                >
                                  {currentStep === -1
                                    ? 'Get Started'
                                    : currentStep ===
                                          PathsToDisplayBlocks.length - 1 &&
                                        (!PathsToDisplayBlocks[currentStep]
                                          ?.child_paths?.length ||
                                          selectedOptions.some(
                                            ([_, blockId]) =>
                                              blockId ===
                                              PathsToDisplayBlocks[currentStep]
                                                .id
                                          ))
                                      ? 'Complete'
                                      : 'Next step'}
                                </ButtonNormal>
                              )}
                            </div>
                          </div>
                        </>
                      ) : (
                        <>
                          <div className="h-[472px] flex">
                            <div
                              className={cn(
                                'w-full flex flex-col',
                                !PathsToDisplayBlocks[currentStep]?.image &&
                                  (!PathsToDisplayBlocks[currentStep]
                                    ?.child_paths ||
                                    PathsToDisplayBlocks[currentStep]
                                      ?.child_paths.length === 0) &&
                                  'justify-center'
                              )}
                            >
                              {currentStep === PathsToDisplayBlocks.length ? (
                                <HorizontalLastStep
                                  onCopyLink={handleCopyLink}
                                  onRestart={handleRestart}
                                />
                              ) : PathsToDisplayBlocks[currentStep] &&
                                PathsToDisplayBlocks[currentStep].type ===
                                  'DELAY' ? (
                                <HorizontalDelay
                                  block={PathsToDisplayBlocks[currentStep]}
                                  selectedOptionIds={selectedOptions}
                                  onOptionSelect={(optionId, blockId) =>
                                    handleOptionSelect(optionId, blockId)
                                  }
                                />
                              ) : (
                                <HorizontalStep
                                  block={PathsToDisplayBlocks[currentStep]}
                                  selectedOptionIds={selectedOptions}
                                  onOptionSelect={(optionId, blockId) =>
                                    handleOptionSelect(optionId, blockId)
                                  }
                                />
                              )}
                            </div>
                          </div>

                          {/* Navigation and Progress Bar */}
                          <div className="flex items-center justify-end mt-8">
                            {/* Progress Bar */}
                            <div className="items-center hidden">
                              <div className="relative flex items-center w-[400px]">
                                {/* Home Icon */}
                                <img
                                  src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/home-05.svg`}
                                  alt="Home icon"
                                  className="w-6 h-6"
                                />

                                {/* Line from home to first step */}
                                <div
                                  className="w-[40px] h-[1px] mx-2"
                                  style={{
                                    backgroundColor:
                                      currentStep >= 0
                                        ? colors['bg-brand-solid']
                                        : colors['border-secondary'],
                                  }}
                                />

                                {/* Step Dots - Step View */}
                                {PathsToDisplayBlocks.map((_, index) => (
                                  <div
                                    key={index}
                                    className="flex items-center"
                                  >
                                    {/* Step Indicator */}
                                    <div className="relative z-10 flex items-center justify-center w-6 h-6">
                                      {index < currentStep ? (
                                        // Completed step - show tick icon
                                        <img
                                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/step-icon-done.svg`}
                                          alt="Completed step"
                                          className="w-6 h-6"
                                        />
                                      ) : (
                                        // Current or future step - show simple dot
                                        <div
                                          className={cn('w-2 h-2 rounded-full')}
                                          style={{
                                            backgroundColor:
                                              index === currentStep
                                                ? colors['bg-brand-solid']
                                                : colors['border-secondary'],
                                          }}
                                        />
                                      )}
                                    </div>
                                    {/* Connecting Line */}
                                    {index <
                                      PathsToDisplayBlocks.length - 1 && (
                                      <div
                                        className="w-[40px] h-[1px] mx-2"
                                        style={{
                                          backgroundColor:
                                            index < currentStep
                                              ? colors['bg-brand-solid']
                                              : colors['border-secondary'],
                                        }}
                                      />
                                    )}
                                  </div>
                                ))}
                              </div>
                            </div>

                            {/* Navigation Buttons */}
                            <div className="flex items-center gap-2">
                              {currentStep > -1 && (
                                <ButtonNormal
                                  variant="secondary"
                                  size="small"
                                  onClick={() => handleStepNavigation('prev')}
                                  disabled={currentStep === -1}
                                  leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-left.svg`}
                                >
                                  Previous step
                                </ButtonNormal>
                              )}
                              {currentStep < PathsToDisplayBlocks.length && (
                                <ButtonNormal
                                  variant="primary"
                                  size="small"
                                  onClick={() => handleStepNavigation('next')}
                                  disabled={
                                    currentStep ===
                                      PathsToDisplayBlocks.length ||
                                    (currentStep >= 0 &&
                                      currentStep <
                                        PathsToDisplayBlocks.length &&
                                      PathsToDisplayBlocks[currentStep]
                                        ?.child_paths?.length > 0 &&
                                      !selectedOptions.some(
                                        ([_, blockId]) =>
                                          blockId ===
                                          PathsToDisplayBlocks[currentStep].id
                                      ))
                                  }
                                  trailingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/arrow-right.svg`}
                                >
                                  {currentStep === -1
                                    ? 'Get Started'
                                    : currentStep ===
                                          PathsToDisplayBlocks.length - 1 &&
                                        (!PathsToDisplayBlocks[currentStep]
                                          ?.child_paths?.length ||
                                          selectedOptions.some(
                                            ([_, blockId]) =>
                                              blockId ===
                                              PathsToDisplayBlocks[currentStep]
                                                .id
                                          ))
                                      ? 'Complete'
                                      : 'Next step'}
                                </ButtonNormal>
                              )}
                            </div>
                          </div>
                        </>
                      )}
                    </div>
                  </div>
                </div>
              )}
            </ProcessCanvas>
          </div>
        </>
      )}
      <ShareModal
        isOpen={isShareModalOpen}
        onClose={() => setIsShareModalOpen(false)}
        itemName={workflowData?.name}
        shareUrl={shareUrl}
        is_public={localIsPublic}
        onToggleAccess={toggleWorkflowAccess}
        workspaceLogo={
          workspace?.logo
            ? `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/${workspace.logo}`
            : undefined
        }
        workspace={workspace || undefined}
      />
    </div>
  );
}
</file>

<file path="app/api/blocks/[id]/route.ts">
// app/api/blocks/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { generatePublicUrl } from '../../utils/generatePublicUrl';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { deleteOneBlock } from '../../utils/blocks/deleteOne';
import { formatTitle } from '../../utils/formatTitle';
import { createSignedUrlForBlock } from '@/utils/createSignedUrls';
import { supabase } from '@/lib/supabaseClient';

/**
 * @swagger
 * /api/blocks/{id}:
 *   patch:
 *     summary: Update a block by ID
 *     description: Updates the properties of a block including its type, position, title, icon, and image.
 *     tags:
 *       - Blocks
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the block to update.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               type:
 *                 type: string
 *               position:
 *                 type: integer
 *               title:
 *                 type: string
 *               icon:
 *                 type: string
 *               description:
 *                 type: string
 *               path_id:
 *                 type: integer
 *               workflow_id:
 *                 type: integer
 *               image:
 *                 type: string
 *               image_description:
 *                 type: string
 *               average_time:
 *                 type: integer
 *               task_type:
 *                 type: string
 *               delay_seconds:
 *                 type: integer
 *     responses:
 *       200:
 *         description: Successfully updated block.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *       400:
 *         description: Invalid block ID.
 *       404:
 *         description: Block not found.
 *       500:
 *         description: Failed to update block.
 */
export async function PATCH(req: NextRequest) {
  const id = req.nextUrl.pathname.split('/').pop();

  if (!id) {
    return NextResponse.json(
      { error: 'Block ID is required' },
      { status: 400 }
    );
  }

  const block_id = Number(id);

  // Choose the correct Prisma client
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const {
      type,
      position,
      title,
      icon,
      description,
      path_id,
      workflow_id,
      image,
      original_image,
      image_description,
      average_time,
      task_type,
      delay_seconds,
      delay_type,
      delay_event,
    } = await req.json();

    // const formattedTitle = formatTitle(title);
    const formattedTitle = title;
    const formattedDelayEvent = delay_event ? formatTitle(delay_event) : undefined;

    const existingBlock = await prisma_client.block.findUnique({
      where: { id: block_id },
      select: { 
        image: true,
        original_image: true,
        icon: true
      },
    });

    if (!existingBlock) {
      return NextResponse.json({ error: 'Block not found' }, { status: 404 });
    }

    // Delete previous images from storage if new images are being set
    const bucketName = process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_BUCKET;
    if (bucketName && (image !== undefined || original_image !== undefined || icon !== undefined)) {
      const filesToDelete = [];
      
      // If updating image and there's an existing one, mark it for deletion only if it's different from both existingBlock.image and existingBlock.original_image
      if (
        image !== undefined &&
        existingBlock.image &&
        existingBlock.image !== image &&
        existingBlock.original_image &&
        existingBlock.original_image !== '' &&
        existingBlock.image !== existingBlock.original_image
      ) {
        filesToDelete.push(existingBlock.image);
      }
      
      // // If updating original_image and there's an existing one, mark it for deletion
      // if (original_image !== undefined && existingBlock.original_image && existingBlock.original_image !== original_image) {
      //   filesToDelete.push(existingBlock.original_image);
      // }

      // If updating icon and both new and old icons contain 'uploads/' and 'icons/', and the icon is changing, mark it for deletion
      if (
        icon !== undefined &&
        existingBlock.icon &&
        existingBlock.icon !== icon &&
        (existingBlock.icon.includes('uploads/') && existingBlock.icon.includes('icons/') || existingBlock.icon.includes('step-icons/custom'))
      ) {
        filesToDelete.push(existingBlock.icon);
      }

      // Delete the files from storage
      if (filesToDelete.length > 0) {
        const { error: storageError } = await supabase.storage
          .from(bucketName)
          .remove(filesToDelete);

        if (storageError) {
          console.error('Error deleting previous images/icons from storage:', storageError);
        }
      }
    }

    // Update block with all fields
    const updatedBlock: any = await prisma_client.block.update({
      where: { id: block_id },
      data: {
        type,
        position,
        title: formattedTitle,
        icon,
        description,
        path_id,
        workflow_id,
        image,
        original_image,
        image_description,
        updated_at: new Date(),
        average_time,
        task_type,
        delay_seconds: type === 'DELAY' ? delay_seconds : null,
        delay_type: type === 'DELAY' ? delay_type : null,
        delay_event: type === 'DELAY' ? formattedDelayEvent : null,
      },
    });

    const signedBlock = await createSignedUrlForBlock(updatedBlock);

    return NextResponse.json(signedBlock);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to update block' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

/**
 * @swagger
 * /api/blocks/{id}:
 *   delete:
 *     summary: Delete a block by ID
 *     description: Deletes a block and its related records from the database.
 *     tags:
 *       - Blocks
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the block to delete.
 *     responses:
 *       204:
 *         description: Block successfully deleted.
 *       400:
 *         description: Invalid block ID.
 *       404:
 *         description: Block not found.
 *       500:
 *         description: Failed to delete block.
 */
export async function DELETE(req: NextRequest) {
  const id = req.nextUrl.pathname.split('/').pop();

  if (!id) {
    return NextResponse.json(
      { error: 'Block ID is required' },
      { status: 400 }
    );
  }

  const block_id = Number(id);

  const { error, status } = await deleteOneBlock(block_id);

  if (error) {
    return NextResponse.json({ error }, { status });
  }

  return new NextResponse(null, { status: 204 });
}
</file>

<file path="app/api/join/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { createClient } from '@/lib/supabaseServerClient';
import { isVercel } from '../utils/isVercel';
import { PrismaClient } from '@prisma/client';

export async function POST(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) throw new Error('Prisma client not initialized');
  try {
    const { workspace, token } = await req.json();
    if (!workspace || !token) {
      return NextResponse.json({ success: false, error: 'Missing workspace or token' }, { status: 400 });
    }

    // Decode token: base64 of email:workspaceId:timestamp
    let decoded;
    try {
      decoded = Buffer.from(token, 'base64').toString('utf-8');
    } catch {
      return NextResponse.json({ success: false, error: 'Invalid token' }, { status: 400 });
    }
    const [email, workspaceId, timestamp] = decoded.split(':');
    if (!email || workspaceId !== workspace) {
      return NextResponse.json({ success: false, error: 'Token does not match workspace' }, { status: 400 });
    }

    // Get current user from Supabase session
    const supabase = createClient();
    const {
      data: { user: supaUser },
      error: supaError,
    } = await supabase.auth.getUser();
    if (supaError || !supaUser) {
      return NextResponse.json({ success: false, error: 'Not authenticated' }, { status: 401 });
    }

    // Find user in DB by email (should match supaUser.email)
    const dbUser = await prisma_client.user.findUnique({ where: { email: supaUser.email } });
    if (!dbUser) {
      return NextResponse.json({ success: false, error: 'User not found' }, { status: 404 });
    }

    // Check if user_workspace already exists
    const existing = await prisma_client.user_workspace.findFirst({
      where: { user_id: dbUser.id, workspace_id: Number(workspace) },
    });
    if (!existing) {
      await prisma_client.user_workspace.create({
        data: {
          user_id: dbUser.id,
          workspace_id: Number(workspace),
          role: 'EDITOR', // Default role, adjust as needed
        },
      });
    }

    // Set as active workspace
    await prisma_client.user.update({
      where: { id: dbUser.id },
      data: { active_workspace_id: Number(workspace) },
    });

    // Find invitation for this email and workspace
    const invitation = await prisma_client.workspace_invitation.findFirst({
      where: {
        workspace_id: Number(workspace),
        email: supaUser.email,
        status: 'PENDING',
      },
    });
    if (!invitation) {
      return NextResponse.json({ success: false, error: 'No valid invitation found.' }, { status: 404 });
    }
    const now = new Date();
    if (invitation.expired_at && now > invitation.expired_at) {
      await prisma_client.workspace_invitation.update({
        where: { id: invitation.id },
        data: { status: 'EXPIRED' },
      });
      return NextResponse.json({ success: false, error: 'Invitation expired.' }, { status: 410 });
    }
    // Mark invitation as accepted
    await prisma_client.workspace_invitation.update({
      where: { id: invitation.id },
      data: { status: 'ACCEPTED', accepted_at: now },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Join workspace error:', error);
    return NextResponse.json({ success: false, error: 'Internal server error' }, { status: 500 });
  } finally {
    if (isVercel()) {
      await prisma_client?.$disconnect();
    }
  }
}
</file>

<file path="app/api/stroke-lines/route.ts">
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { formatTitle } from '../utils/formatTitle';
import { isVercel } from '../utils/isVercel';
import { PrismaClient } from '@prisma/client';

/**
 * @swagger
 * /api/stroke-lines:
 *   post:
 *     summary: Create a new stroke line
 *     description: Creates a new connection line between two blocks in a workflow
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - source_block_id
 *               - target_block_id
 *               - workflow_id
 *               - label
 *             properties:
 *               source_block_id:
 *                 type: integer
 *                 description: ID of the source block
 *               target_block_id:
 *                 type: integer
 *                 description: ID of the target block
 *               workflow_id:
 *                 type: integer
 *                 description: ID of the workflow
 *               label:
 *                 type: string
 *                 description: Label for the stroke line
 *               control_points:
 *                 type: array
 *                 description: Control points for the stroke line
 *     responses:
 *       200:
 *         description: Stroke line created successfully
 *       400:
 *         description: Missing required fields or duplicate stroke line
 *       500:
 *         description: Server error
 */
export async function POST(request: Request) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const body = await request.json();
    const { source_block_id, target_block_id, workflow_id, label, control_points = null } = body;

    // Validate required fields
    if (!source_block_id || !target_block_id || !workflow_id || !label) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    const formattedLabel = formatTitle(label);

    // Check if a stroke line with same source and target already exists
    const existingStrokeLine = await prisma_client.stroke_line.findFirst({
      where: {
        source_block_id,
        target_block_id,
        workflow_id,
      },
    });

    if (existingStrokeLine) {
      return NextResponse.json(
        { error: 'A stroke line between these blocks already exists' },
        { status: 400 }
      );
    }

    // Create new stroke line
    const strokeLine = await prisma_client.stroke_line.create({
      data: {
        source_block_id,
        target_block_id,
        workflow_id,
        label: formattedLabel || '',
        control_points: control_points ? { set: control_points } : undefined,
      },
    });

    return NextResponse.json(strokeLine);
  } catch (error) {
    console.error('Error creating stroke line:', error);
    return NextResponse.json(
      { error: 'Failed to create stroke line' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

/**
 * @swagger
 * /api/stroke-lines:
 *   put:
 *     summary: Update an existing stroke line
 *     description: Modifies an existing stroke line's properties
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - id
 *             properties:
 *               id:
 *                 type: integer
 *                 description: ID of the stroke line to update
 *               source_block_id:
 *                 type: integer
 *                 description: New source block ID
 *               target_block_id:
 *                 type: integer
 *                 description: New target block ID
 *               workflow_id:
 *                 type: integer
 *                 description: ID of the workflow
 *               label:
 *                 type: string
 *                 description: New label for the stroke line
 *               control_points:
 *                 type: array
 *                 description: New control points for the stroke line
 *     responses:
 *       200:
 *         description: Stroke line updated successfully
 *       400:
 *         description: Missing ID or duplicate stroke line
 *       500:
 *         description: Server error
 */
export async function PUT(request: Request) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const body = await request.json();
    const { id, source_block_id, target_block_id, workflow_id, label, control_points } = body;

    if (!id) {
      return NextResponse.json(
        { error: 'Missing stroke line ID' },
        { status: 400 }
      );
    }

    // Check if the new source/target combination already exists for another stroke line
    const existingStrokeLine = await prisma_client.stroke_line.findFirst({
      where: {
        source_block_id,
        target_block_id,
        workflow_id,
        NOT: {
          id,
        },
      },
    });

    if (existingStrokeLine) {
      return NextResponse.json(
        { error: 'A stroke line between these blocks already exists' },
        { status: 400 }
      );
    }

    const formattedLabel = label ? formatTitle(label) : undefined;

    // Update stroke line
    const updatedStrokeLine = await prisma_client.stroke_line.update({
      where: { id },
      data: {
        source_block_id,
        target_block_id,
        workflow_id,
        label: formattedLabel,
        control_points: control_points ? { set: control_points } : undefined,
      },
    });

    return NextResponse.json(updatedStrokeLine);
  } catch (error) {
    console.error('Error updating stroke line:', error);
    return NextResponse.json(
      { error: 'Failed to update stroke line' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

/**
 * @swagger
 * /api/stroke-lines:
 *   delete:
 *     summary: Delete a stroke line
 *     description: Removes a stroke line from the workflow
 *     parameters:
 *       - in: query
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID of the stroke line to delete
 *     responses:
 *       200:
 *         description: Stroke line deleted successfully
 *       400:
 *         description: Missing stroke line ID
 *       500:
 *         description: Server error
 */
export async function DELETE(request: Request) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');

    if (!id) {
      return NextResponse.json(
        { error: 'Missing stroke line ID' },
        { status: 400 }
      );
    }

    // Fetch the stroke line to get source_block_id and target_block_id
    const strokeLine = await prisma_client.stroke_line.findUnique({
      where: { id: parseInt(id) },
      select: { source_block_id: true, target_block_id: true },
    });
    if (!strokeLine) {
      return NextResponse.json(
        { error: 'Stroke line not found' },
        { status: 404 }
      );
    }

    const { source_block_id } = strokeLine;

    await prisma_client.stroke_line.delete({
      where: { id: parseInt(id) },
    });

    // Count remaining stroke lines where this block is the source and NOT self-referencing
    const remainingCount = await prisma_client.stroke_line.count({
      where: {
        source_block_id,
      },
    });

    if (remainingCount === 0) {
      // Set is_endpoint to false
      await prisma_client.block.update({
        where: { id: source_block_id },
        data: { is_endpoint: false },
      });
    }

    return NextResponse.json({ message: 'Link deleted successfully' });
  } catch (error) {
    console.error('Error deleting stroke line:', error);
    return NextResponse.json(
      { error: 'Failed to delete stroke line' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

/**
 * @swagger
 * /api/stroke-lines:
 *   get:
 *     summary: Get stroke lines
 *     description: Retrieves either a single stroke line by ID or all stroke lines for a workflow
 *     parameters:
 *       - in: query
 *         name: id
 *         required: false
 *         schema:
 *           type: integer
 *         description: ID of a specific stroke line to fetch
 *       - in: query
 *         name: workflow_id
 *         required: false
 *         schema:
 *           type: integer
 *         description: ID of the workflow to get all stroke lines for
 *     responses:
 *       200:
 *         description: Single stroke line or list of stroke lines
 *       400:
 *         description: Missing required parameters
 *       404:
 *         description: Stroke line not found
 *       500:
 *         description: Server error
 */
export async function GET(request: Request) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    const workflowId = searchParams.get('workflow_id');

    // Helper function to transform control points
    const transformControlPoints = (strokeLine: any) => {
      if (strokeLine.control_points && strokeLine.control_points.set) {
        return {
          ...strokeLine,
          control_points: strokeLine.control_points.set
        };
      }
      return strokeLine;
    };

    // If ID is provided, fetch single stroke line
    if (id) {
      const strokeLine = await prisma_client.stroke_line.findUnique({
        where: {
          id: parseInt(id),
        },
        select: {
          id: true,
          source_block_id: true,
          target_block_id: true,
          workflow_id: true,
          label: true,
          control_points: true,
          created_at: true,
          updated_at: true,
        },
      });

      if (!strokeLine) {
        return NextResponse.json(
          { error: 'Stroke line not found' },
          { status: 404 }
        );
      }

      return NextResponse.json(transformControlPoints(strokeLine));
    }

    // If workflow_id is provided, fetch all stroke lines for that workflow
    if (workflowId) {
      const strokeLines = await prisma_client.stroke_line.findMany({
        where: {
          workflow_id: parseInt(workflowId),
        },
        select: {
          id: true,
          source_block_id: true,
          target_block_id: true,
          workflow_id: true,
          label: true,
          control_points: true,
          created_at: true,
          updated_at: true,
        },
      });

      return NextResponse.json(strokeLines.map(transformControlPoints));
    }

    // If neither parameter is provided
    return NextResponse.json(
      { error: 'Missing required parameter: either id or workflow_id must be provided' },
      { status: 400 }
    );
  } catch (error) {
    console.error('Error fetching stroke lines:', error);
    return NextResponse.json(
      { error: 'Failed to fetch stroke lines' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

/**
 * @swagger
 * /api/stroke-lines:
 *   patch:
 *     summary: Update control points of a stroke line
 *     description: Updates the control points of an existing stroke line
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - id
 *               - control_points
 *             properties:
 *               id:
 *                 type: integer
 *                 description: ID of the stroke line to update
 *               control_points:
 *                 type: array
 *                 description: New control points for the stroke line
 *     responses:
 *       200:
 *         description: Control points updated successfully
 *       400:
 *         description: Missing stroke line ID
 *       500:
 *         description: Server error
 */
export async function PATCH(request: Request) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    const body = await request.json();
    const { control_points } = body;

    if (!id) {
      return NextResponse.json(
        { error: 'Missing stroke line ID' },
        { status: 400 }
      );
    }

    // Validate control points structure
    if (!Array.isArray(control_points) || !control_points.every(point => 
      point !== null &&
      typeof point === 'object' &&
      typeof point.x === 'number' && !isNaN(point.x) &&
      typeof point.y === 'number' && !isNaN(point.y)
    )) {
      return NextResponse.json(
        { error: 'Invalid control points format' },
        { status: 400 }
      );
    }

    // Update only the control points using Prisma's set operator for JSON fields
    const updatedStrokeLine = await prisma_client.stroke_line.update({
      where: { 
        id: parseInt(id) 
      },
      data: {
        control_points: {
          set: control_points
        },
        updated_at: new Date()
      },
    });

    // Transform the response to remove the 'set' wrapper
    const transformedStrokeLine = {
      ...updatedStrokeLine,
      control_points: control_points
    };

    return NextResponse.json(transformedStrokeLine);
  } catch (error) {
    console.error('Error updating control points:', error);
    return NextResponse.json(
      { error: 'Failed to update control points' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/test/get-workspace-by-name/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { isVercel } from '../../utils/isVercel';

export async function GET(req: NextRequest) {

  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  const { searchParams } = new URL(req.url);
  const user_id = searchParams.get('user_id');
  const name = searchParams.get('name');

  if (!user_id || !name) {
    return NextResponse.json({ error: 'Missing user_id or name parameter' }, { status: 400 });
  }

  try {
    const workspace = await prisma_client.workspace.findFirst({
      where: {
        name,
        user_workspaces: {
          some: {
            user_id: parseInt(user_id, 10),
          },
        },
      },
      include: {
        user_workspaces: true,
      },
    });

    if (!workspace) {
      return NextResponse.json({ error: 'Workspace not found' }, { status: 404 });
    }
    return NextResponse.json(workspace, { status: 200 });
  } catch (error) {
    console.error('Error fetching workspace by name:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/upload/avatar/route.ts">
// app/api/upload/avatar/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/lib/supabaseClient'; // Shared Supabase client
import { createClient } from '@/utils/supabase/server';
import { v4 as uuidv4 } from 'uuid';

/**
 * @swagger
 * /api/upload/avatar:
 *   post:
 *     summary: Upload a file to Supabase storage
 *     description: Allows users to upload images or videos to a designated Supabase storage bucket.
 *     tags:
 *       - Upload 
*     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               file:
 *                 type: string
 *                 format: binary
 *                 description: The file to be uploaded.
 *     responses:
 *       200:
 *         description: File uploaded successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "File uploaded successfully: uploads/unique-file-name.png"
 *                 filePath:
 *                   type: string
 *                   example: "uploads/unique-file-name.png"
 *       400:
 *         description: Invalid file type or no file provided.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "No file uploaded"
 *       500:
 *         description: Internal server error, possibly due to Supabase upload failure.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "File upload failed"
 */
export async function POST(req: NextRequest) {
  // Get authenticated user
  const supabaseServer = await createClient();
  const { data: userData, error: userError } = await supabaseServer.auth.getUser();

  if (userError || !userData || !userData.user) {
    return NextResponse.json(
      { error: 'User not authenticated' },
      { status: 401 }
    );
  }

  const userUID = userData.user.id;

  const formData = await req.formData();
  const file = formData.get('file') as File | null;

  if (!file) {
    return NextResponse.json({ error: 'No file uploaded' }, { status: 400 });
  }

  // Validate file type - avatars should be images only
  const allowedMimeTypes = [
    'image/svg+xml',
    'image/png',
    'image/jpeg',
    'image/gif',
  ];
  if (!allowedMimeTypes.includes(file.type)) {
    return NextResponse.json({ error: 'Invalid file type. Only images are allowed for avatars.' }, { status: 400 });
  }

  const buffer = await file.arrayBuffer();
  const fileData = new Uint8Array(buffer); // Convert to Uint8Array

  // Generate a unique file name and specify the folder using user UID
  const sanitizedFileName = file.name.replace(/\s+/g, '_'); // Replace spaces with underscores
  const fileName = `${uuidv4()}-${sanitizedFileName}`;
  const filePath = `${userUID}/avatars/${fileName}`; // Upload inside user's avatar folder

  // Retrieve bucket name from environment variable
  const bucketName = process.env.NEXT_PUBLIC_SUPABASE_PRIVATE_BUCKET;

  if (!bucketName) {    
    return NextResponse.json(
      { error: 'Bucket name is not defined in environment variables' },
      { status: 500 }
    );
  }

  try {
    // Upload the file to the user's avatar folder in the specified bucket
    const { data, error } = await supabase.storage
      .from(bucketName)
      .upload(filePath, fileData, {
        contentType: file.type,
        upsert: false, // Avoid overwriting existing files
      });

    if (error) {
      console.error('Supabase upload error:', error);
      return NextResponse.json(
        { error: 'File upload failed' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      message: `Avatar uploaded successfully: ${filePath}`,
      filePath,
    });
  } catch (error) {
    console.error('File upload error:', error);
    return NextResponse.json({ error: 'File upload failed' }, { status: 500 });
  }
}
</file>

<file path="app/api/upload/workspace-brand-logo/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/lib/supabaseClient';
import { createClient } from '@/utils/supabase/server';
import { v4 as uuidv4 } from 'uuid';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function POST(req: NextRequest) {
  let prisma_client: PrismaClient | undefined;

  try {
    prisma_client = isVercel() ? new PrismaClient() : prisma;

    if (!prisma_client) {
      return NextResponse.json(
        { error: 'Database connection not available' },
        { status: 500 }
      );
    }

    // Get authenticated user
    const supabaseServer = await createClient();
    const { data: userData, error: userError } =
      await supabaseServer.auth.getUser();

    if (userError || !userData || !userData.user) {
      return NextResponse.json(
        { error: 'User not authenticated' },
        { status: 401 }
      );
    }

    const userUID = userData.user.id;

    // Get user's active workspace
    const user = await prisma_client.user.findUnique({
      where: { auth_id: userUID },
      include: {
        active_workspace: true,
      },
    });

    if (!user || !user.active_workspace) {
      return NextResponse.json(
        { error: 'No active workspace found' },
        { status: 400 }
      );
    }

    const workspaceSlug = user.active_workspace.slug;

    const formData = await req.formData();
    const file = formData.get('file') as File | null;
    const workspaceId = formData.get('workspaceId') as string | null;

    if (!file) {
      return NextResponse.json({ error: 'No file uploaded' }, { status: 400 });
    }

    if (!workspaceId) {
      return NextResponse.json(
        { error: 'No workspace ID provided' },
        { status: 400 }
      );
    }

    // Retrieve bucket name from environment variable
    const bucketName = process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_BUCKET;

    if (!bucketName) {
      return NextResponse.json(
        { error: 'Bucket name is not defined in environment variables' },
        { status: 500 }
      );
    }

    // Check for existing brand logo and delete it if exists
    const existingWorkspace = await prisma_client.workspace.findUnique({
      where: { id: parseInt(workspaceId) },
      select: { brand_logo_url: true },
    });

    if (existingWorkspace?.brand_logo_url) {
      // Delete existing file from storage
      const { error: deleteError } = await supabase.storage
        .from(bucketName)
        .remove([existingWorkspace.brand_logo_url]);

      if (deleteError) {
        console.error('Failed to delete existing brand logo:', deleteError);
      }
    }

    // Validate file type - only images allowed
    const allowedMimeTypes = [
      'image/svg+xml',
      'image/png',
      'image/jpeg',
      'image/gif',
    ];
    if (!allowedMimeTypes.includes(file.type)) {
      return NextResponse.json(
        { error: 'Invalid file type. Only images are allowed.' },
        { status: 400 }
      );
    }

    const buffer = await file.arrayBuffer();
    const fileData = new Uint8Array(buffer);

    // Generate a unique file name
    const sanitizedFileName = file.name.replace(/\s+/g, '_');
    const fileName = `${uuidv4()}-${sanitizedFileName}`;
    const filePath = `uploads/${workspaceSlug}/${fileName}`;

    // Upload the file
    const { data, error } = await supabase.storage
      .from(bucketName)
      .upload(filePath, fileData, {
        contentType: file.type,
        upsert: true, // Allow overwriting existing brand logo
      });

    if (error) {
      console.error('Supabase upload error:', error);
      return NextResponse.json(
        { error: 'File upload failed' },
        { status: 500 }
      );
    }

    // Update workspace with new brand logo URL
    await prisma_client.workspace.update({
      where: { id: parseInt(workspaceId) },
      data: { brand_logo_url: filePath },
    });

    return NextResponse.json({
      message: `Brand logo uploaded successfully: ${filePath}`,
      filePath,
    });
  } catch (error) {
    console.error('File upload error:', error);
    return NextResponse.json({ error: 'File upload failed' }, { status: 500 });
  } finally {
    if (isVercel() && prisma_client) await prisma_client.$disconnect();
  }
}

export async function DELETE(req: NextRequest) {
  let prisma_client: PrismaClient | undefined;
  try {
    prisma_client = isVercel() ? new PrismaClient() : prisma;

    if (!prisma_client) {
      return NextResponse.json(
        { error: 'Database connection not available' },
        { status: 500 }
      );
    }

    // Get authenticated user
    const supabaseServer = await createClient();
    const { data: userData, error: userError } =
      await supabaseServer.auth.getUser();

    if (userError || !userData || !userData.user) {
      return NextResponse.json(
        { error: 'User not authenticated' },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(req.url);
    const workspaceId = searchParams.get('workspaceId');

    if (!workspaceId) {
      return NextResponse.json(
        { error: 'No workspace ID provided' },
        { status: 400 }
      );
    }
    // Get the workspace to find the current brand logo URL
    const workspace = await prisma_client.workspace.findUnique({
      where: { id: parseInt(workspaceId) },
      select: { brand_logo_url: true },
    });

    if (!workspace?.brand_logo_url) {
      return NextResponse.json(
        { error: 'No brand logo found' },
        { status: 404 }
      );
    }

    const bucketName = process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_BUCKET;

    if (!bucketName) {
      return NextResponse.json(
        { error: 'Bucket name is not defined in environment variables' },
        { status: 500 }
      );
    }

    // Delete the file from storage
    const { error: deleteError } = await supabase.storage
      .from(bucketName)
      .remove([workspace.brand_logo_url]);

    if (deleteError) {
      console.error('Supabase delete error:', deleteError);
    }

    // Update workspace to remove the brand logo URL
    await prisma_client.workspace.update({
      where: { id: parseInt(workspaceId) },
      data: { brand_logo_url: null },
    });

    return NextResponse.json({
      message: 'Brand logo deleted successfully',
    });
  } catch (error) {
    console.error('Delete error:', error);
    return NextResponse.json(
      { error: 'Failed to delete brand logo' },
      { status: 500 }
    );
  } finally {
    if (isVercel() && prisma_client) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/upload/workspace-brand-name/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/lib/supabaseClient';
import { createClient } from '@/utils/supabase/server';
import { v4 as uuidv4 } from 'uuid';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

export async function POST(req: NextRequest) {
  let prisma_client: PrismaClient | undefined;

  try {
    prisma_client = isVercel() ? new PrismaClient() : prisma;

    if (!prisma_client) {
      return NextResponse.json(
        { error: 'Database connection not available' },
        { status: 500 }
      );
    }

    // Get authenticated user
    const supabaseServer = await createClient();
    const { data: userData, error: userError } =
      await supabaseServer.auth.getUser();

    if (userError || !userData || !userData.user) {
      return NextResponse.json(
        { error: 'User not authenticated' },
        { status: 401 }
      );
    }

    const userUID = userData.user.id;

    // Get user's active workspace
    const user = await prisma_client.user.findUnique({
      where: { auth_id: userUID },
      include: {
        active_workspace: true,
      },
    });

    if (!user || !user.active_workspace) {
      return NextResponse.json(
        { error: 'No active workspace found' },
        { status: 400 }
      );
    }

    const workspaceSlug = user.active_workspace.slug;

    const formData = await req.formData();
    const file = formData.get('file') as File | null;
    const workspaceId = formData.get('workspaceId') as string | null;

    if (!file) {
      return NextResponse.json({ error: 'No file uploaded' }, { status: 400 });
    }

    if (!workspaceId) {
      return NextResponse.json(
        { error: 'No workspace ID provided' },
        { status: 400 }
      );
    }

    // Retrieve bucket name from environment variable
    const bucketName = process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_BUCKET;

    if (!bucketName) {
      return NextResponse.json(
        { error: 'Bucket name is not defined in environment variables' },
        { status: 500 }
      );
    }

    // Check for existing brand name image and delete it if exists
    const existingWorkspace = await prisma_client.workspace.findUnique({
      where: { id: parseInt(workspaceId) },
      select: { brand_name_img_url: true },
    });

    if (existingWorkspace?.brand_name_img_url) {
      // Delete existing file from storage
      const { error: deleteError } = await supabase.storage
        .from(bucketName)
        .remove([existingWorkspace.brand_name_img_url]);

      if (deleteError) {
        console.error(
          'Failed to delete existing brand name image:',
          deleteError
        );
      }
    }

    // Validate file type - only images allowed
    const allowedMimeTypes = [
      'image/svg+xml',
      'image/png',
      'image/jpeg',
      'image/gif',
    ];
    if (!allowedMimeTypes.includes(file.type)) {
      return NextResponse.json(
        { error: 'Invalid file type. Only images are allowed.' },
        { status: 400 }
      );
    }

    const buffer = await file.arrayBuffer();
    const fileData = new Uint8Array(buffer);

    // Generate a unique file name
    const sanitizedFileName = file.name.replace(/\s+/g, '_');
    const fileName = `${uuidv4()}-${sanitizedFileName}`;
    const filePath = `uploads/${workspaceSlug}/${fileName}`;

    // Upload the file
    const { data, error } = await supabase.storage
      .from(bucketName)
      .upload(filePath, fileData, {
        contentType: file.type,
        upsert: true, // Allow overwriting existing brand name image
      });

    if (error) {
      console.error('Supabase upload error:', error);
      return NextResponse.json(
        { error: 'File upload failed' },
        { status: 500 }
      );
    }

    // Update workspace with new brand name image URL
    await prisma_client.workspace.update({
      where: { id: parseInt(workspaceId) },
      data: { brand_name_img_url: filePath },
    });

    return NextResponse.json({
      message: `Brand name image uploaded successfully: ${filePath}`,
      filePath,
    });
  } catch (error) {
    console.error('File upload error:', error);
    return NextResponse.json({ error: 'File upload failed' }, { status: 500 });
  } finally {
    if (isVercel() && prisma_client) await prisma_client.$disconnect();
  }
}

export async function DELETE(req: NextRequest) {
  let prisma_client: PrismaClient | undefined;
  try {
    prisma_client = isVercel() ? new PrismaClient() : prisma;

    if (!prisma_client) {
      return NextResponse.json(
        { error: 'Database connection not available' },
        { status: 500 }
      );
    }

    // Get authenticated user
    const supabaseServer = await createClient();
    const { data: userData, error: userError } =
      await supabaseServer.auth.getUser();

    if (userError || !userData || !userData.user) {
      return NextResponse.json(
        { error: 'User not authenticated' },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(req.url);
    const workspaceId = searchParams.get('workspaceId');

    if (!workspaceId) {
      return NextResponse.json(
        { error: 'No workspace ID provided' },
        { status: 400 }
      );
    }
    // Get the workspace to find the current brand name image URL
    const workspace = await prisma_client.workspace.findUnique({
      where: { id: parseInt(workspaceId) },
      select: { brand_name_img_url: true },
    });

    if (!workspace?.brand_name_img_url) {
      return NextResponse.json(
        { error: 'No brand name image found' },
        { status: 404 }
      );
    }

    const bucketName = process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_BUCKET;

    if (!bucketName) {
      return NextResponse.json(
        { error: 'Bucket name is not defined in environment variables' },
        { status: 500 }
      );
    }

    // Delete the file from storage
    const { error: deleteError } = await supabase.storage
      .from(bucketName)
      .remove([workspace.brand_name_img_url]);

    if (deleteError) {
      console.error('Supabase delete error:', deleteError);
    }

    // Update workspace to remove the brand name image URL
    await prisma_client.workspace.update({
      where: { id: parseInt(workspaceId) },
      data: { brand_name_img_url: null },
    });

    return NextResponse.json({
      message: 'Brand name image deleted successfully',
    });
  } catch (error) {
    console.error('Delete error:', error);
    return NextResponse.json(
      { error: 'Failed to delete brand name image' },
      { status: 500 }
    );
  } finally {
    if (isVercel() && prisma_client) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/upload-icon/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { createClient as createServerClient } from '@/utils/supabase/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';

const ALLOWED_FILE_TYPES = ['image/png', 'image/jpeg', 'image/svg+xml'];
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

/**
 * Handles icon file uploads to workspace-specific folders
 * @param {NextRequest} request - The incoming request containing the file
 * @returns {Promise<NextResponse>} JSON response with the uploaded file URL or error
 */
export async function POST(request: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }

  try {
    // Get authenticated user
    const supabaseServer = await createServerClient();
    const { data: userData, error: userError } = await supabaseServer.auth.getUser();

    if (userError || !userData || !userData.user) {
      return NextResponse.json(
        { 
          success: false,
          error: 'User not authenticated' 
        },
        { status: 401 }
      );
    }

    const userUID = userData.user.id;

    // Get user's active workspace
    const user = await prisma_client.user.findUnique({
      where: { auth_id: userUID },
      include: {
        active_workspace: true
      }
    });

    if (!user || !user.active_workspace) {
      return NextResponse.json(
        { 
          success: false,
          error: 'No active workspace found' 
        },
        { status: 400 }
      );
    }

    const workspaceSlug = user.active_workspace.slug;

    // Input validation
    const formData = await request.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return NextResponse.json(
        { 
          success: false,
          error: 'No file provided' 
        },
        { status: 400 }
      );
    }

    // Validate file type
    if (!ALLOWED_FILE_TYPES.includes(file.type)) {
      return NextResponse.json(
        { 
          success: false,
          error: 'Invalid file type. Please upload PNG, JPEG, or SVG files.' 
        },
        { status: 400 }
      );
    }

    // Validate file size
    if (file.size > MAX_FILE_SIZE) {
      return NextResponse.json(
        { 
          success: false,
          error: 'File size exceeds 5MB limit.' 
        },
        { status: 400 }
      );
    }

    // Convert File to Buffer
    const buffer = Buffer.from(await file.arrayBuffer());
    const fileExtension = file.name.split('.').pop()?.toLowerCase();
    
    // Generate a secure filename and upload to workspace-specific icons folder
    const timestamp = Date.now();
    const randomString = crypto.randomUUID();
    const fileName = `${timestamp}-${randomString}.${fileExtension}`;
    const filePath = `uploads/${workspaceSlug}/icons/${fileName}`;

    // Upload to Supabase Storage
    const { error: uploadError, data } = await supabase.storage
      .from(process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_BUCKET!)
      .upload(filePath, buffer, {
        contentType: file.type,
        cacheControl: '3600',
        upsert: false,
      });

    if (uploadError) {
      console.error('Supabase upload error:', uploadError);
      return NextResponse.json(
        { 
          success: false,
          error: 'Failed to upload file to storage' 
        },
        { status: 500 }
      );
    }

    // Get the public URL for the uploaded file
    const { data: { publicUrl } } = supabase.storage
      .from(process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_BUCKET!)
      .getPublicUrl(filePath);

    if (process.env.NODE_ENV === 'development') {
      console.log('publicUrl', publicUrl);
      console.log('filePath', filePath);
    }
    // Return success response with file information
    return NextResponse.json({
      success: true,
      data: {
        iconUrl: filePath,
        publicUrl: publicUrl
      }
    }, { 
      status: 201,
      headers: {
        'Content-Type': 'application/json'
      }
    });

  } catch (error) {
    console.error('Server error:', error);
    return NextResponse.json(
      { 
        success: false,
        error: 'Internal server error',
      },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}

// Configure request size limit
export const config = {
  api: {
    bodyParser: {
      sizeLimit: '5mb',
    },
  },
};
</file>

<file path="app/api/user/update/route.ts">
// app/api/user/update/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { generatePublicUrl } from '../../utils/generatePublicUrl';
import prisma from '@/lib/prisma'; // Import your Prisma client
import { supabase } from '@/lib/supabaseClient';
import { isVercel } from '../../utils/isVercel';
import { PrismaClient } from '@prisma/client';
import { generateUserUrl } from '../../utils/generateUserUrl';
import { deleteAvatarFromPrivateBucket } from '../../utils/deleteFile';

/**
 * @swagger
 * /api/user/update:
 *   put:
 *     summary: Update user profile
 *     description: Updates user details, including avatar management (upload/delete).
 *     tags:
 *       - User
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The user ID.
 *                 example: 1
 *               first_name:
 *                 type: string
 *                 description: User's first name.
 *                 example: "John"
 *               last_name:
 *                 type: string
 *                 description: User's last name.
 *                 example: "Doe"
 *               full_name:
 *                 type: string
 *                 description: User's full name.
 *                 example: "John Doe"
 *               email:
 *                 type: string
 *                 format: email
 *                 description: User's email address.
 *                 example: "john.doe@example.com"
 *               avatar_url:
 *                 type: string
 *                 format: uri
 *                 nullable: true
 *                 description: URL of the user's avatar.
 *                 example: "https://example.com/avatar.jpg"
 *               active_workspace:
 *                 type: integer
 *                 nullable: true
 *                 description: The ID of the active workspace.
 *                 example: 3
 *               delete_avatar:
 *                 type: boolean
 *                 description: If true, deletes the user's current avatar.
 *                 example: false
 *     responses:
 *       200:
 *         description: User updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 first_name:
 *                   type: string
 *                   example: "John"
 *                 last_name:
 *                   type: string
 *                   example: "Doe"
 *                 full_name:
 *                   type: string
 *                   example: "John Doe"
 *                 email:
 *                   type: string
 *                   example: "john.doe@example.com"
 *                 avatar_url:
 *                   type: string
 *                   nullable: true
 *                   example: "https://example.com/avatar.jpg"
 *                 active_workspace:
 *                   type: integer
 *                   nullable: true
 *                   example: 3
 *       400:
 *         description: Missing required user ID.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "User id is required"
 *       404:
 *         description: User not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "User not found"
 *       500:
 *         description: Internal server error, possibly due to database or storage issues.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Failed to update user"
 */
export async function PUT(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const body = await req.json();
    const {
      id,
      first_name,
      last_name,
      full_name,
      email,
      avatar_url,
      active_workspace_id,
      delete_avatar,
    } = body;

    if (!id) {
      return NextResponse.json(
        { error: 'User id is required' },
        { status: 400 }
      );
    }

    // Retrieve the existing user data
    const existingUser = await prisma_client.user.findUnique({
      where: { id: Number(id) },
      select: { avatar_url: true },
    });

    if (!existingUser) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Delete avatar from storage if needed
    const shouldDeleteAvatar =
      delete_avatar ||
      (existingUser.avatar_url && avatar_url !== undefined && avatar_url !== null && avatar_url !== existingUser.avatar_url);

    if (
      shouldDeleteAvatar &&
      existingUser.avatar_url &&
      typeof existingUser.avatar_url === 'string' &&
      !existingUser.avatar_url.startsWith('http')
    ) {
      await deleteAvatarFromPrivateBucket(existingUser.avatar_url);
    }

    let newAvatarUrl = avatar_url;

    // If delete_avatar is true, set avatar_url to null
    if (delete_avatar) {
      newAvatarUrl = null;
    }

    // Update user data
    const updatedUser: any = await prisma_client.user.update({
      where: { id: Number(id) },
      data: {
        first_name,
        last_name,
        full_name,
        email,
        avatar_url: newAvatarUrl,
        active_workspace_id: active_workspace_id ? Number(active_workspace_id) : null,
      },
    });

    if (updatedUser.avatar_url) {
      // If the updatedUser.avatar_url is a storage path (not an external URL), generate a public URL
      if (!updatedUser.avatar_url.startsWith('http')) {
        try {
          updatedUser.avatar_signed_url = generateUserUrl(updatedUser.avatar_url);
          if (process.env.NODE_ENV !== 'production') {
            console.log('Generating user URL for avatar:', updatedUser.avatar_signed_url);
          }
        } catch (error) {
          console.error('Error generating public URL for avatar:', error);
        }
      }
    }
    return NextResponse.json(updatedUser, { status: 200 });
  } catch (error) {
    console.error('Error updating user:', error);
    return NextResponse.json(
      { error: 'Failed to update user' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/api/utils/generatePublicUrl.ts">
import { generateWorkspaceURL } from './generateWorkspaceURL';

/**
 * Generates a public URL for a file in the Supabase storage bucket
 * @param path - The path of the file in the storage bucket
 * @returns The complete public URL for the file
 * @throws Error if required environment variables are missing
 */
export function generatePublicUrl(path: string): string {
  // Get the environment variables
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const storagePath = process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH;

  if (!supabaseUrl) {
    throw new Error('NEXT_PUBLIC_SUPABASE_URL is not defined in the environment variables');
  }

  if (!storagePath) {
    throw new Error('NEXT_PUBLIC_SUPABASE_STORAGE_PATH is not defined in the environment variables');
  }

  if (!path) {
    throw new Error('Path is required to generate public URL');
  }

  // If the path contains 'step-icons/custom', use generateWorkspaceURL instead
  if (path.includes('step-icons/custom') || (path.includes('uploads/') && path.includes('icons/'))) {
    if (process.env.NODE_ENV === 'development') {
      console.log('Using generateWorkspaceURL for path:', path);
    }
    return generateWorkspaceURL(path);
  }

  // Remove leading slash from path if present to avoid double slashes
  const cleanPath = path.startsWith('/') ? path.slice(1) : path;

  // Build and return the public URL
  return `${supabaseUrl}${storagePath}/${cleanPath}`;
}
</file>

<file path="app/api/workflow/[workflow_id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { generatePublicAccessId } from '../utils';
import { supabase } from '@/lib/supabaseClient';
import { generatePublicUrl } from '../../utils/generatePublicUrl';

export async function PATCH(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const workflow_id = req.nextUrl.pathname.split('/').pop();
    if (!workflow_id) {
      return NextResponse.json({ error: 'Workflow ID is required' }, { status: 400 });
    }

    const data = await req.json();
    
    // Ensure is_public is a boolean if it's being updated
    if ('is_public' in data && typeof data.is_public !== 'boolean') {
      return NextResponse.json({ error: 'is_public must be a boolean' }, { status: 400 });
    }

    const updatedWorkflow = await prisma_client.workflow.update({
      where: { id: parseInt(workflow_id) },
      data: {
        ...data,
        updated_at: new Date()
      },
      select: {
        id: true,
        name: true,
        icon: true,
        is_public: true,
        public_access_id: true,
        description: true,
        process_owner: true,
        review_date: true,
        additional_notes: true,
        workspace_id: true,
        folder: {
          select: {
            id: true,
            name: true,
            parent: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        },
        workspace: {
          select: {
            id: true,
            name: true,
          },
        },
        author: {
          select: {
            full_name: true,
            avatar_url: true,
          },
        },
      },
    });

    return NextResponse.json(updatedWorkflow);
  } catch (error) {
    console.error('Error updating workflow:', error);
    return NextResponse.json({ error: 'Failed to update workflow' }, { status: 500 });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}

export async function GET(
  req: NextRequest,
  props: { params: Promise<{ workflow_id: string }> }
) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const params = await props.params;

    const workflowId = parseInt(params.workflow_id);

    let workflow: any = await prisma_client.workflow.findUnique({
      where: { id: workflowId },
      select: {
        id: true,
        name: true,
        icon: true,
        is_public: true,
        public_access_id: true,
        description: true,
        process_owner: true,
        review_date: true,
        additional_notes: true,
        workspace_id: true,
        folder: {
          select: {
            id: true,
            name: true,
            parent: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        },
        workspace: {
          select: {
            id: true,
            name: true,
          },
        },
        author: {
          select: {
            full_name: true,
            avatar_url: true,
          },
        },
      },
    });
    
    if (!workflow) {
      return new NextResponse(null, { status: 404 });
    }

    if (!workflow.public_access_id) {
      const publicId = await generatePublicAccessId(
        workflow.name,
        workflow.id,
        workflow.workspace_id
      );

      workflow = await prisma_client.workflow.update({
        where: { id: workflowId },
        data: { public_access_id: publicId },
        select: {
          id: true,
          name: true,
          icon: true,
          is_public: true,
          public_access_id: true,
          description: true,
          process_owner: true,
          review_date: true,
          additional_notes: true,
          workspace_id: true,
          folder: {
            select: {
              id: true,
              name: true,
              parent: {
                select: {
                  id: true,
                  name: true,
                },
              },
            },
          },
          workspace: {
            select: {
              id: true,
              name: true,
            },
          },
          author: {
            select: {
              full_name: true,
              avatar_url: true,
            },
          },
        },
      });
    }

    // Add signedIconUrl if workflow.icon exists and is not a Brandfetch URL
    if (workflow.icon && !workflow.icon.startsWith('https://cdn.brandfetch.io/')) {
      try {
        (workflow as any).signedIconUrl = generatePublicUrl(workflow.icon);
      } catch (error) {
        console.error('Error generating public URL for workflow icon:', error);
      }
    }

    // Add signed avatar URL for author if needed
    if (
      workflow.author &&
      workflow.author.avatar_url &&
      !workflow.author.avatar_url.startsWith('http')
    ) {
      try {
        (workflow.author as any).avatar_signed_url = generatePublicUrl(workflow.author.avatar_url);
      } catch (error) {
        console.error('Error generating public URL for author avatar:', error);
      }
    }
    
    return NextResponse.json(workflow);
  } catch (error) {
    console.error('Error fetching workflow:', error);
    return new NextResponse(null, { status: 500 });
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/workspace/[id]/invite/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { sendEmail } from '@/lib/email';
import prisma from '@/lib/prisma';
import { createClient } from '@/lib/supabaseServerClient';
import { isVercel } from '@/app/api/utils/isVercel';
import { PrismaClient } from '@prisma/client';

export async function POST(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) throw new Error('Prisma client not initialized');
  try {
    const { email } = await req.json();
    // Extract workspaceId from the URL
    const url = new URL(req.url);
    const match = url.pathname.match(/\/workspace\/(\d+)\/invite/);
    const workspaceId = match ? match[1] : undefined;
    if (!email || !workspaceId) {
      return NextResponse.json({ success: false, error: 'Missing email or workspaceId' }, { status: 400 });
    }

    // Fetch workspace name
    const workspace = await prisma_client.workspace.findUnique({
      where: { id: Number(workspaceId) },
      select: { name: true },
    });
    if (!workspace) {
      return NextResponse.json({ success: false, error: 'Workspace not found' }, { status: 404 });
    }

    // Get inviter from Supabase session
    const supabase = createClient();
    const {
      data: { user: supaUser },
      error: supaError,
    } = await supabase.auth.getUser();
    if (supaError || !supaUser) {
      return NextResponse.json({ success: false, error: 'Not authenticated' }, { status: 401 });
    }
    // Find inviter in DB
    const inviter = await prisma_client.user.findUnique({ where: { email: supaUser.email } });
    if (!inviter) {
      return NextResponse.json({ success: false, error: 'Inviter not found' }, { status: 404 });
    }

    // Check if the user is already a member of the workspace
    const existingMember = await prisma_client.user_workspace.findFirst({
      where: {
        workspace_id: Number(workspaceId),
        user: { email },
      },
    });
    if (existingMember) {
      return NextResponse.json({ success: false, error: 'User is already a member of this workspace.' }, { status: 409 });
    }

    // Check for existing, non-expired invitation
    const now = new Date();
    const existingInvitation = await prisma_client.workspace_invitation.findFirst({
      where: {
        workspace_id: Number(workspaceId),
        email,
        status: 'PENDING',
        expired_at: { gt: now },
      },
    });
    if (existingInvitation) {
      return NextResponse.json({ success: false, error: 'An active invitation already exists for this email.' }, { status: 409 });
    }

    // Create new invitation (expires in 5 minutes)
    const expiredAt = new Date(now.getTime() + 5 * 60 * 1000);
    await prisma_client.workspace_invitation.create({
      data: {
        workspace_id: Number(workspaceId),
        email,
        inviter_id: inviter.id,
        status: 'PENDING',
        invited_at: now,
        expired_at: expiredAt,
      },
    });

    // Generate a simple token (base64 of email:workspaceId:timestamp)
    const tokenRaw = `${email}:${workspaceId}:${Date.now()}`;
    const token = Buffer.from(tokenRaw).toString('base64');
    const joinUrl = `${process.env.NEXT_PUBLIC_BASE_URL || 'https://app.process-flow.io'}/join?workspace=${workspaceId}&token=${token}`;

    // Email content
    const subject = `join my workspace: ${workspace.name}`;
    const emailHtml = `
      <div style="font-family: Inter, Arial, sans-serif;">
        <h2>You've been invited to join the workspace <b>${workspace.name}</b> on ProcessFlow!</h2>
        <p>Click the button below to join:</p>
        <a href="${joinUrl}" style="display:inline-block;padding:12px 24px;background:#4761C4;color:#fff;border-radius:6px;text-decoration:none;font-weight:600;">Join Workspace</a>
        <p>If the button doesn't work, copy and paste this link into your browser:</p>
        <p><a href="${joinUrl}">${joinUrl}</a></p>
      </div>
    `;

    const result = await sendEmail({
      to: email,
      subject,
      emailHtml,
      sender: 'noreply',
    });

    if (!result.success) {
      return NextResponse.json({ success: false, error: 'Failed to send email' }, { status: 500 });
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Invite error:', error);
    return NextResponse.json({ success: false, error: 'Internal server error' }, { status: 500 });
  } finally {
    if (isVercel()) {
      await prisma_client?.$disconnect();
    }
  }
}
</file>

<file path="app/api/workspace/folders/[id]/route.ts">
// app/api/workspace/folders/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { checkFolderName } from '@/app/utils/checkNames';
import { supabase } from '@/lib/supabaseClient';

/**
 * DELETE /api/workspace/folders/:id
 * Deletes a folder by ID
 */
/**
 * @swagger
 * /api/workspace/folders/{id}:
 *   delete:
 *     summary: Delete a folder by ID
 *     description: Deletes a folder with the specified ID.
 *     tags:
 *       - Workspace
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the folder to delete
 *     responses:
 *       200:
 *         description: Folder deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Folder deleted successfully"
 *       404:
 *         description: Folder not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Folder not found"
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal server error"
 *   patch:
 *     summary: Update a folder by ID
 *     description: Updates a folder's properties (e.g., name, icon_url, emote, etc.) with the specified ID.
 *     tags:
 *       - Workspace
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the folder to update
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 example: "Updated Folder"
 *               icon_url:
 *                 type: string
 *                 example: "/path/to/icon.svg"
 *               emote:
 *                 type: string
 *                 example: ":smile:"
 *               parent_id:
 *                 type: integer
 *                 example: 2
 *     responses:
 *       200:
 *         description: Folder updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 name:
 *                   type: string
 *                   example: "Updated Folder"
 *                 icon_url:
 *                   type: string
 *                   example: "/path/to/icon.svg"
 *                 emote:
 *                   type: string
 *                   example: ":smile:"
 *                 parent_id:
 *                   type: integer
 *                   example: 2
 *       404:
 *         description: Folder not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Folder not found"
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal server error"
 */
export async function DELETE(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  const params = await props.params;
  const folderId = Number(params.id);
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // Parse body for parent_id and workspace_id
    const { parent_id, workspace_id } = await req.json();

    // Check if folder exists
    const folder = await prisma_client.folder.findUnique({
      where: { id: folderId },
    });

    if (!folder) {
      return NextResponse.json({ error: 'Folder not found' }, { status: 404 });
    }

    // Delete icon from storage if it matches the pattern
    const bucketName = process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_BUCKET;
    if (
      bucketName &&
      folder.icon_url &&
      (
        (folder.icon_url.includes('uploads/') && folder.icon_url.includes('icons/')) ||
        folder.icon_url.includes('step-icons/custom')
      )
    ) {
      const { error: storageError } = await supabase.storage
        .from(bucketName)
        .remove([folder.icon_url]);
      if (storageError) {
        console.error('Error deleting folder icon from storage:', storageError);
      }
    }

    // Get all child folders and delete their icons from storage if they match the pattern
    if (bucketName) {
      const childFolders = await prisma_client.folder.findMany({
        where: { parent_id: folderId },
        select: { icon_url: true }
      });
      const childIconsToDelete = childFolders
        .map(f => f.icon_url)
        .filter((iconUrl): iconUrl is string =>
          !!iconUrl && (
            (iconUrl.includes('uploads/') && iconUrl.includes('icons/')) ||
            iconUrl.includes('step-icons/custom')
          )
        );
      if (childIconsToDelete.length > 0) {
        const { error: childStorageError } = await supabase.storage
          .from(bucketName)
          .remove(childIconsToDelete);
        if (childStorageError) {
          console.error('Error deleting child folder icons from storage:', childStorageError);
        }
      }
    }

    // Delete folder
    await prisma_client.folder.delete({
      where: { id: folderId },
    });

    // Update positions of siblings with higher position
    await prisma_client.folder.updateMany({
      where: {
        workspace_id: Number(workspace_id),
        parent_id: parent_id === null ? null : Number(parent_id),
        position: { gt: folder.position },
      },
      data: {
        position: { decrement: 1 },
      },
    });

    return NextResponse.json(
      { message: 'Folder deleted successfully' },
      { status: 200 }
    );
  } catch (error) {
    console.error('Error deleting folder:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

/**
 * PATCH /api/workspace/folders/:id
 * Updates a folder by ID
 */
/**
 * PATCH /api/workspace/folders/:id
 * Updates a folder by ID
 */
export async function PATCH(req: NextRequest, props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  const folderId = Number(params.id);

  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { name, icon_url, emote, parent_id } = await req.json();

    // Check if folder exists
    const existingFolder = await prisma_client.folder.findUnique({
      where: { id: folderId },
    });

    if (!existingFolder) {
      return NextResponse.json({ error: 'Folder not found' }, { status: 404 });
    }

    // Delete previous icon from storage if new icon_url is being set and the old one matches criteria
    const bucketName = process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_BUCKET;
    if (
      bucketName &&
      icon_url !== undefined &&
      icon_url !== null &&
      existingFolder.icon_url &&
      existingFolder.icon_url !== icon_url &&
      (
        (existingFolder.icon_url.includes('uploads/') && existingFolder.icon_url.includes('icons/')) ||
        existingFolder.icon_url.includes('step-icons/custom')
      )
    ) {
      const { error: storageError } = await supabase.storage
        .from(bucketName)
        .remove([existingFolder.icon_url]);
      if (storageError) {
        console.error('Error deleting previous folder icon from storage:', storageError);
      }
    }

    // Validate folder name if it's being updated
    if (name) {
      const nameError = checkFolderName(name);
      if (nameError) {
        return NextResponse.json({ 
          error: 'Invalid folder name',
          ...nameError 
        }, { status: 400 });
      }
    }

    // Ensure icon_url and emote are explicitly set to null if undefined
    const updateData: Record<string, any> = {
      name,
      icon_url: icon_url ?? null,
      emote: emote ?? null,
      parent_id,
    };

    // Update folder
    const updatedFolder = await prisma_client.folder.update({
      where: { id: folderId },
      data: updateData,
    });

    return NextResponse.json(updatedFolder, { status: 200 });
  } catch (error) {
    console.error('Error updating folder:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/api/workspace/workflows/route.ts">
// app/api/workspace/workflows/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import { getActiveUser } from '@/lib/auth';
import { checkAndScheduleProcessLimitEmail } from '@/lib/emails/scheduleProcessLimitEmail';
import { generatePublicAccessId } from '../../workflow/utils';
import { checkWorkflowName } from '@/app/utils/checkNames';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { deleteFile } from '@/app/api/utils/deleteFile';

/**
 * @swagger
 * /api/workspace/workflows:
 *   post:
 *     summary: Create a new workflow
 *     description: Creates a new workflow within a workspace, optionally inside a folder.
 *     tags:
 *       - Workspace
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 example: "New Workflow"
 *               description:
 *                 type: string
 *                 example: "This is a new workflow"
 *               workspace_id:
 *                 type: integer
 *                 example: 1
 *               folder_id:
 *                 type: integer
 *                 example: 2
 *     responses:
 *       201:
 *         description: Workflow created successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 name:
 *                   type: string
 *                   example: "New Workflow"
 *                 description:
 *                   type: string
 *                   example: "This is a new workflow"
 *                 workspace_id:
 *                   type: integer
 *                   example: 1
 *                 folder_id:
 *                   type: integer
 *                   example: 2
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Failed to add workflow"
 *
 *   put:
 *     summary: Update an existing workflow
 *     description: Updates an existing workflow with new values.
 *     tags:
 *       - Workspace
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 example: 1
 *               name:
 *                 type: string
 *                 example: "Updated Workflow"
 *               description:
 *                 type: string
 *                 example: "Updated description"
 *               folder_id:
 *                 type: integer
 *                 example: 2
 *               icon:
 *                 type: string
 *                 example: "https://example.com/icon.png"
 *               status:
 *                 type: string
 *                 example: "active"
 *     responses:
 *       200:
 *         description: Workflow updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 name:
 *                   type: string
 *                   example: "Updated Workflow"
 *                 description:
 *                   type: string
 *                   example: "Updated description"
 *                 folder_id:
 *                   type: integer
 *                   example: 2
 *       400:
 *         description: Workflow ID is required
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Workflow ID is required"
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Failed to update workflow"
 *
 *   delete:
 *     summary: Delete a workflow and its related data
 *     description: Deletes a workflow and all related blocks and paths.
 *     tags:
 *       - Workspace
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               workflowId:
 *                 type: integer
 *                 example: 1
 *     responses:
 *       200:
 *         description: Workflow and related data deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Workflow and related data deleted successfully"
 *       400:
 *         description: Workflow ID is required
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Workflow ID is required"
 *       404:
 *         description: Workflow not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Workflow not found"
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Failed to delete workflow and related data"
 */
export async function POST(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const {
      name,
      description,
      process_owner,
      review_date,
      additional_notes,
      workspace_id,
      folder_id = null,
      author_id,
      icon = null,
    } = await req.json();

    // Validate required fields
    if (!name || !workspace_id) {
      return NextResponse.json(
        { error: 'Name and workspace_id are required' },
        { status: 400 }
      );
    }

    // Use the checkWorkflowName utility
    const nameError = checkWorkflowName(name);
    if (nameError) {
      return NextResponse.json(
        { 
          error: 'Invalid workflow name',
          ...nameError
        },
        { status: 400 }
      );
    }

    // Clean whitespaces in name
    const cleanedName = name.trim().replace(/\s+/g, ' ');

    // Convert review_date to proper DateTime format
    let sanitizedReviewDate = null;
    if (review_date && review_date !== '') {
      try {
        // If it's just a date (YYYY-MM-DD), convert to full DateTime
        const dateObj = new Date(review_date);
        if (!isNaN(dateObj.getTime())) {
          // Convert to ISO string for Prisma
          sanitizedReviewDate = dateObj.toISOString();
        }
      } catch (error) {
        console.error('Error parsing review_date:', error);
        // Leave as null if parsing fails
      }
    }

    // Get workspace with subscription info and workflow count
    const workspace = await prisma_client.workspace.findUnique({
      where: { id: Number(workspace_id) },
      include: {
        subscription: true,
        workflows: {
          select: { id: true },
        },
      },
    });

    if (!workspace) {
      return NextResponse.json(
        { error: 'Workspace not found' },
        { status: 404 }
      );
    }

    // Log workspace details for debugging
    if (process.env.NODE_ENV !== 'production') {
      console.log('Workspace details:', {
        id: workspace.id,
        subscription: workspace.subscription,
        workflowCount: workspace.workflows.length,
        isFreePlan: !workspace.subscription || workspace.subscription.plan_type === 'FREE',
      });
    }

    // Check if workspace is on free plan and has reached the limit
    const isFreePlan = !workspace.subscription || workspace.subscription.plan_type === 'FREE';
    const hasReachedLimit = workspace.workflows.length >= 5;

    if (isFreePlan && hasReachedLimit) {
      if (process.env.NODE_ENV !== 'production') {
        console.log('Blocking workflow creation: Free plan limit reached', {
          isFreePlan,
          workflowCount: workspace.workflows.length,
        });
      }
      return NextResponse.json(
        {
          error: 'Free plan is limited to 5 workflows',
          title: 'Workflow Limit Reached',
          description: 'Your free plan is limited to 5 workflows. Upgrade to create more workflows.',
          status: 403
        },
        { status: 403 }
      );
    }

    if (process.env.NODE_ENV !== 'production') {
      console.log('Creating workflow with author_id:', author_id, typeof author_id);
    }
    // Create the workflow with cleaned name
    const workflow = await prisma_client.workflow.create({
      data: {
        name: cleanedName,
        description,
        process_owner,
        review_date: sanitizedReviewDate,
        additional_notes,
        workspace_id,
        folder_id,
        is_public: true,
        author_id: author_id ? Number(author_id) : null,
        icon,
        public_access_id: await generatePublicAccessId(cleanedName, 0, workspace_id),
      },
      include: {
        workspace: {
          select: {
            id: true,
            name: true,
          },
        },
        folder: {
          select: {
            id: true,
            name: true,
            parent: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        },
      },
    });

    // --- NEW LOGIC: Create a path and default blocks for the new workflow ---
    // Create a new path affiliated with this workflow
    const newPath = await prisma_client.path.create({
      data: {
        name: 'First Path',
        workflow_id: workflow.id,
      }
    });

    // Create BEGIN block
    await prisma_client.block.create({
      data: {
        type: 'BEGIN',
        position: 0,
        icon: '/step-icons/default-icons/begin.svg',
        description: '',
        workflow: { connect: { id: workflow.id } },
        path: { connect: { id: newPath.id } },
      }
    });

    // Create default STEP block
    await prisma_client.block.create({
      data: {
        type: 'STEP',
        position: 1,
        icon: '/step-icons/default-icons/container.svg',
        description: '',
        workflow: { connect: { id: workflow.id } },
        path: { connect: { id: newPath.id } },
      }
    });

    // Create END block
    await prisma_client.block.create({
      data: {
        type: 'LAST',
        position: 2,
        icon: '/step-icons/default-icons/end.svg',
        description: '',
        workflow: { connect: { id: workflow.id } },
        path: { connect: { id: newPath.id } },
      }
    });
    // --- END NEW LOGIC ---

    // If we need to update the public_access_id with the actual workflow ID
    const updatedPublicId = await generatePublicAccessId(
      workflow.name,
      workflow.id,
      workflow.workspace_id
    );

    // Update the workflow with the final public_access_id
    const updatedWorkflow = await prisma_client.workflow.update({
      where: { id: workflow.id },
      data: { public_access_id: updatedPublicId },
      include: {
        workspace: {
          select: {
            id: true,
            name: true,
          },
        },
        folder: {
          select: {
            id: true,
            name: true,
            parent: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        },
      },
    });

    // Check if we should send a process limit reached email
    // We only want to send this when they've EXACTLY reached the limit (5 workflows)
    try {
      // After creating the workflow, get the current count
      const currentCount = await prisma_client.workflow.count({
        where: { workspace_id: Number(workspace_id) }
      });
      
      // Get the user ID from the workspace members
      const workspaceUsers = await prisma_client.user_workspace.findMany({
        where: { workspace_id: Number(workspace_id) },
        select: {
          user_id: true,
          role: true,
        },
        orderBy: { role: 'asc' }, // This should put admins first
      });
      
      if (workspaceUsers.length > 0) {
        const userId = workspaceUsers[0].user_id;
        
        // Only send the email if they've exactly reached the limit (5) and are on the free plan
        if (isFreePlan && currentCount === 5) {
          await checkAndScheduleProcessLimitEmail(userId);
        }
      }
    } catch (emailError) {
      // Just log the error, but don't block the workflow creation
      console.error('Error checking workflow limit for email:', emailError);
    }

    return NextResponse.json(updatedWorkflow, { status: 201 });
  } catch (error: any) {
    console.error('Error adding workflow:', error);
    return NextResponse.json(
      { error: 'Failed to add workflow' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}

export async function PUT(req: NextRequest) {

  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const {
      id,
      name,
      description,
      process_owner,
      review_date,
      additional_notes,
      folder_id = null,
      icon = null,
      status = null,
    } = await req.json();

    if (!id) {
      return NextResponse.json(
        { error: 'Workflow ID is required' },
        { status: 400 }
      );
    }

    // Fetch the existing workflow to check the previous icon
    let previousIcon: string | null = null;
    if (icon !== undefined) {
      const existingWorkflow = await prisma_client.workflow.findUnique({
        where: { id: Number(id) },
        select: { icon: true },
      });
      previousIcon = existingWorkflow?.icon || null;
      // If previous icon exists, is different, and matches the pattern, delete it
      if (
        previousIcon &&
        previousIcon !== icon &&
        ((previousIcon.includes('uploads/') && previousIcon.includes('icons/')) || previousIcon.includes('step-icons/custom'))
      ) {
        await deleteFile(previousIcon);
      }
    }

    // Add name validation if name is being updated
    if (name) {
      const nameError = checkWorkflowName(name);
      if (nameError) {
        return NextResponse.json(
          { 
            error: 'Invalid workflow name',
            ...nameError
          },
          { status: 400 }
        );
      }
    }

    // Convert review_date to proper DateTime format if provided
    let sanitizedReviewDate = undefined;
    if (review_date !== undefined) {
      if (review_date === '' || review_date === null) {
        sanitizedReviewDate = null;
      } else {
        try {
          const dateObj = new Date(review_date);
          if (!isNaN(dateObj.getTime())) {
            sanitizedReviewDate = dateObj.toISOString();
          }
        } catch (error) {
          console.error('Error parsing review_date:', error);
        }
      }
    }

    const updatedWorkflow = await prisma_client.workflow.update({
      where: {
        id: Number(id),
      },
      data: {
        ...(name && { name: name.trim().replace(/\s+/g, ' ') }),
        ...(description !== undefined && { description }),
        ...(process_owner !== undefined && { process_owner }),
        ...(sanitizedReviewDate !== undefined && { review_date: sanitizedReviewDate }),
        ...(additional_notes !== undefined && { additional_notes }),
        ...(folder_id !== null && {
          folder_id: folder_id ? Number(folder_id) : null,
        }),
        ...(icon !== undefined && { icon }),
        ...(status && { status }),
      },
    });

    return NextResponse.json(updatedWorkflow, { status: 200 });
  } catch (error: any) {
    console.error('Error updating workflow:', error);
    return NextResponse.json(
      { error: 'Failed to update workflow' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

export async function DELETE(req: NextRequest) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const { workflowId } = await req.json(); // Expecting the workflow ID in the request body

    // Ensure workflowId is provided
    if (!workflowId) {
      return NextResponse.json(
        { error: 'Workflow ID is required' },
        { status: 400 }
      );
    }

    // --- Delete all block files from storage before deleting blocks ---
    // Fetch all blocks for the workflow
    const blocks = await prisma_client.block.findMany({
      where: { workflow_id: Number(workflowId) },
      select: { image: true, original_image: true, icon: true },
    });
    for (const block of blocks) {
      // Delete image if exists
      if (block.image) {
        await deleteFile(block.image);
      }
      // Delete original_image if exists
      if (block.original_image) {
        await deleteFile(block.original_image);
      }
      // Delete icon if matches the pattern
      if (
        block.icon &&
        ((block.icon.includes('uploads/') && block.icon.includes('icons/')) || block.icon.includes('step-icons/custom'))
      ) {
        await deleteFile(block.icon);
      }
    }

    // --- Delete workflow icon from storage if it matches the pattern ---
    const workflow = await prisma_client.workflow.findUnique({
      where: { id: Number(workflowId) },
      select: { icon: true },
    });
    if (
      workflow?.icon &&
      ((workflow.icon.includes('uploads/') && workflow.icon.includes('icons/')) || workflow.icon.includes('step-icons/custom'))
    ) {
      await deleteFile(workflow.icon);
    }

    // Start a transaction to ensure all related deletions occur together
    await prisma_client.$transaction(async (prisma) => {
      // Delete all blocks related to the workflow
      await prisma.block.deleteMany({
        where: { workflow_id: Number(workflowId) },
      });

      // Delete all paths related to the workflow
      await prisma.path.deleteMany({
        where: { workflow_id: Number(workflowId) },
      });

      // Finally, delete the workflow itself
      await prisma.workflow.delete({
        where: {
          id: Number(workflowId),
        },
      });
    });

    return NextResponse.json(
      { message: 'Workflow and related data deleted successfully' },
      { status: 200 }
    );
  } catch (error: any) {
    console.error('Error deleting workflow:', error);

    // Handle specific Prisma errors (e.g., if the workflow doesn't exist)
    if (error.code === 'P2025') {
      return NextResponse.json(
        { error: 'Workflow not found' },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { error: 'Failed to delete workflow and related data' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/dashboard/components/ConfirmDeleteModal.tsx">
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { supabasePublicClient } from '@/lib/supabasePublicClient';
import { User } from '@/types/user';
import Modal from '@/app/components/Modal';
import ButtonNormal from '@/app/components/ButtonNormal';
import ButtonDestructive from '@/app/components/ButtonDestructive';
import { useColors } from '@/app/theme/hooks';

interface ConfirmDeleteModalProps {
  onClose: () => void;
  user: User;
}

export default function ConfirmDeleteModal({
  onClose,
  user,
}: ConfirmDeleteModalProps) {
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const router = useRouter();
  const colors = useColors();

  const handleDeleteAccount = async () => {
    if (!password) {
      setError('Please enter your password.');
      return;
    }

    setLoading(true);
    setError(null);

    try {
      // Re-authenticate the user before deletion
      const { data, error: authError } =
        await supabasePublicClient.auth.signInWithPassword({
          email: user.email,
          password,
        });

      if (authError) {
        setError('Incorrect password. Please try again.');
        setLoading(false);
        return;
      }

      // Call API route to delete the user
      const response = await fetch('/api/deleteUser', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId: user.auth_id }),
      });

      if (response.ok) {
        localStorage.removeItem('theme-mode');
        alert('Your account has been deleted.');
        router.push('/login'); // Redirect to home page
      } else {
        setError('Failed to delete account. Please try again.');
      }
    } catch (err) {
      console.error(err);
      setError('An error occurred. Please try again.');
    }

    setLoading(false);
  };

  // Define modal actions
  const modalActions = (
    <>
      <ButtonNormal
        variant="secondary"
        size="small"
        onClick={onClose}
        className="flex-1"
        disabled={loading}
      >
        Cancel
      </ButtonNormal>
      <ButtonDestructive
        variant="primary"
        size="small"
        onClick={handleDeleteAccount}
        disabled={loading}
        className="flex-1"
      >
        {loading ? 'Deleting...' : 'Delete account'}
      </ButtonDestructive>
    </>
  );

  return (
    <Modal
      onClose={onClose}
      title="Confirm delete"
      icon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/trash-delete.svg`}
      iconBackgroundColor="#fee3e1"
      actions={modalActions}
      showActionsSeparator={true}
    >
      <div className="flex flex-col gap-4">
        <p style={{ color: colors['text-secondary'] }} className="text-sm">
          Please enter your password to delete your account.
        </p>

        {/* Password Input Field */}
        <div className="mt-3">
          <input
            type="password"
            placeholder="Enter your password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            className="w-full px-3 py-2 rounded-lg shadow-sm border text-sm"
            style={{
              borderColor: colors['border-secondary'],
              backgroundColor: colors['bg-primary'],
              color: colors['text-primary'],
            }}
          />
        </div>

        {/* Error Message */}
        {error && (
          <div
            className="mt-2 text-sm font-medium"
            style={{
              color:
                colors['text-error'] || colors['text-destructive'] || '#ef4444',
            }}
          >
            {error}
          </div>
        )}
      </div>
    </Modal>
  );
}
</file>

<file path="app/dashboard/components/WorkflowCard.tsx">
'use client';

import { Workflow, WorkflowStatus } from '@/types/workflow';
import { useState, useRef, useEffect } from 'react';
import { useRouter } from 'next/navigation'; // Import the useRouter hook
import { Workspace } from '@/types/workspace';
import DynamicIcon from '../../../utils/DynamicIcon';
import { useColors } from '@/app/theme/hooks';
import {
  createEditLink,
  createReadLink,
  createShareLink,
} from '@/app/[slug]/[flow]/utils/createLinks';
import { toast } from 'sonner';
import ShareModal from '@/app/components/ShareModal';
import { motion } from 'framer-motion';

interface StatusStyle {
  bg: string;
  border: string;
  text: string;
  label: string;
}

type MenuItem = { label: string; icon: string; disabled?: boolean; tooltip?: string } | 'separator';

const menuItems: MenuItem[] = [
  { label: 'Open in read mode', icon: 'play.svg' },
  { label: 'Share', icon: 'share-01.svg' },
  'separator',
  { label: 'Edit Flow info', icon: 'edit-05.svg' },
  { label: 'Duplicate', icon: 'duplicate-icon.svg', disabled: true, tooltip: 'Not available for the moment' },
  { label: 'Move', icon: 'folder-download.svg' },
  'separator',
  { label: 'Delete Flow', icon: 'trash-01.svg' },
];

interface WorkflowCardProps {
  workflow: Workflow;
  workspace: Workspace;
  onSelectWorkflow: (workflow: Workflow) => void;
  onDeleteWorkflow: (workflow: Workflow) => void;
  onEditWorkflow: (workflow: Workflow) => void;
  onDuplicateWorkflow: (workflow: Workflow) => void;
  onMoveWorkflow: (workflow: Workflow) => void;
  onStatusChange: (workflow: Workflow, newStatus: WorkflowStatus) => void;
}

export default function WorkflowCard({
  workflow,
  workspace,
  onSelectWorkflow,
  onDeleteWorkflow,
  onEditWorkflow,
  onDuplicateWorkflow,
  onMoveWorkflow,
  onStatusChange,
}: WorkflowCardProps) {
  const colors = useColors();

  const [isHovered, setIsHovered] = useState(false);
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const [isStatusMenuOpen, setIsStatusMenuOpen] = useState(false);
  const [isStarFilled, setIsStarFilled] = useState(false);
  const [isShareModalOpen, setIsShareModalOpen] = useState(false);
  const menuRef = useRef<HTMLDivElement | null>(null);
  const statusMenuRef = useRef<HTMLDivElement | null>(null);
  const statusButtonRef = useRef<HTMLDivElement | null>(null);
  const actionsButtonRef = useRef<HTMLDivElement | null>(null);
  const cardRef = useRef<HTMLDivElement | null>(null);
  const [statusMenuPosition, setStatusMenuPosition] = useState<
    'top' | 'bottom'
  >('bottom');
  const [actionsMenuPosition, setActionsMenuPosition] = useState<
    'top' | 'bottom'
  >('bottom');
  const router = useRouter();
  const [isToggling, setIsToggling] = useState(false);
  const [localIsPublic, setLocalIsPublic] = useState(workflow.is_public);
  const [hoveredItem, setHoveredItem] = useState<number | null>(null);

  const formatLastEdited = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };

  const STATUS_STYLES: Record<WorkflowStatus, StatusStyle> = {
    ACTIVE: {
      bg: colors['utility-success-100'],
      border: colors['utility-success-200'],
      text: colors['utility-success-700'],
      label: 'Active',
    },
    DRAFT: {
      bg: colors['utility-gray-50'],
      border: colors['utility-gray-200'],
      text: colors['utility-gray-700'],
      label: 'Draft',
    },
    IN_REVIEW: {
      bg: colors['utility-purple-100'],
      border: colors['utility-purple-200'],
      text: colors['utility-purple-700'],
      label: 'In review',
    },
    NEEDS_UPDATE: {
      bg: colors['utility-warning-100'],
      border: colors['utility-warning-200'],
      text: colors['utility-warning-700'],
      label: 'Needs update',
    },
    ARCHIVED: {
      bg: colors['utility-error-50'],
      border: colors['utility-error-200'],
      text: colors['utility-error-700'],
      label: 'Archived',
    },
  };

  const handleWorkflowClick = (workflowId: number) => {
    const editLink = createEditLink(
      workflow.name,
      workflow.id.toString(),
      workspace.name
    );
    router.push(editLink);
  };

  const navigateToEditMode = (workflowId: number) => {
    const readLink = createReadLink(
      workflow.name,
      workflow.id.toString(),
      workspace.name
    );
    router.push(readLink);
  };

  const handleCopyLink = async () => {
    if (!workflow) return;

    try {
      const url = createShareLink(workflow.name, workflow.public_access_id);
      if (!url) throw new Error('Could not create share link');

      try {
        // Try the modern clipboard API first
        await navigator.clipboard.writeText(url);
        toast.success('Link Copied!', {
          description: 'Share link has been copied to your clipboard.',
          duration: 3000,
        });
      } catch (err) {
        try {
          // Fallback: Create a temporary textarea element
          const textArea = document.createElement('textarea');
          textArea.value = url;
          textArea.style.position = 'fixed';
          textArea.style.left = '-999999px';
          textArea.style.top = '-999999px';
          document.body.appendChild(textArea);
          textArea.focus();
          textArea.select();

          // Try the execCommand approach as fallback
          const successful = document.execCommand('copy');
          textArea.remove();

          if (successful) {
            toast.success('Link Copied!', {
              description: 'Share link has been copied to your clipboard.',
              duration: 3000,
            });
          } else {
            throw new Error('Fallback copy failed');
          }
        } catch (fallbackErr) {
          // If both methods fail, show error with the URL
          toast.error('Failed to Copy', {
            description: 'Please copy this URL manually: ' + url,
            duration: 5000,
          });
        }
      }
    } catch (error) {
      console.error('Error creating share link:', error);
      toast.error('Failed to Copy', {
        description: 'Could not create the share link.',
        duration: 3000,
      });
    }
  };

  const handleMenuClick = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (isStatusMenuOpen) {
      setIsStatusMenuOpen(false);
    }
    if (actionsButtonRef.current) {
      const buttonRect = actionsButtonRef.current.getBoundingClientRect();
      const spaceBelow = window.innerHeight - buttonRect.bottom;
      const menuHeight = 240; // Increased to account for all menu items + padding
      setActionsMenuPosition(spaceBelow < menuHeight ? 'top' : 'bottom');
    }
    setIsMenuOpen(!isMenuOpen);
  };

  const handleStatusClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (isMenuOpen) {
      setIsMenuOpen(false);
    }
    if (statusButtonRef.current) {
      const buttonRect = statusButtonRef.current.getBoundingClientRect();
      const spaceBelow = window.innerHeight - buttonRect.bottom;
      const menuHeight = 180; // Approximate height of status menu
      setStatusMenuPosition(spaceBelow < menuHeight ? 'top' : 'bottom');
    }
    setIsStatusMenuOpen(!isStatusMenuOpen);
  };

  // Close menus when clicking outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (cardRef.current && !cardRef.current.contains(event.target as Node)) {
        setIsMenuOpen(false);
        setIsStatusMenuOpen(false);
      }
    }

    if (isMenuOpen || isStatusMenuOpen) {
      document.addEventListener('mousedown', handleClickOutside);
      // Also handle escape key
      const handleEscape = (e: KeyboardEvent) => {
        if (e.key === 'Escape') {
          setIsMenuOpen(false);
          setIsStatusMenuOpen(false);
        }
      };
      document.addEventListener('keydown', handleEscape);

      return () => {
        document.removeEventListener('mousedown', handleClickOutside);
        document.removeEventListener('keydown', handleEscape);
      };
    }
  }, [isMenuOpen, isStatusMenuOpen]);

  const currentStatus = STATUS_STYLES[workflow.status as WorkflowStatus];

  const handleToggleAccess = async () => {
    if (isToggling) return;

    try {
      setIsToggling(true);

      // Optimistic update for immediate feedback
      setLocalIsPublic(!localIsPublic);

      const response = await fetch(`/api/workflow/${workflow.id}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          is_public: !localIsPublic,
        }),
      });

      const responseData = await response.json();

      if (!response.ok) {
        // Revert the optimistic update if the server request failed
        setLocalIsPublic(workflow.is_public);
        throw new Error(
          responseData.message || 'Failed to update workflow access'
        );
      }

      // Update with the actual server response data
      const updatedWorkflow = {
        ...workflow,
        is_public: responseData.is_public,
      };
      onSelectWorkflow(updatedWorkflow);

      // Use the actual server response to determine the new state
      const newState = responseData.is_public;
      toast.success('Access updated', {
        description: `Workflow is now ${newState ? 'public' : 'private'}`,
        duration: 3000,
      });
    } catch (error) {
      console.error('Error toggling workflow access:', error);
      toast.error('Failed to update access', {
        description: 'Could not update the workflow access settings.',
        duration: 3000,
      });
    } finally {
      setIsToggling(false);
    }
  };

  // Update localIsPublic when workflow.is_public changes
  useEffect(() => {
    setLocalIsPublic(workflow.is_public);
  }, [workflow.is_public]);

  // Call onSelectWorkflow when either menu is open
  useEffect(() => {
    if (isStatusMenuOpen || isMenuOpen) {
      onSelectWorkflow(workflow);
    }
  }, [isStatusMenuOpen, isMenuOpen, onSelectWorkflow, workflow]);

  return (
    <>
      <div
        ref={cardRef}
        onClick={() => handleWorkflowClick(workflow.id)}
        style={
          {
            backgroundColor: colors['bg-primary'],
            borderColor:
              isHovered || isMenuOpen
                ? colors['border-primary']
                : colors['border-secondary'],
            '--hover-bg': colors['bg-quaternary'],
          } as React.CSSProperties
        }
        className={`rounded-lg border hover:cursor-pointer relative transition-all duration-300 ease-in-out hover:bg-[var(--hover-bg)] hover:scale-[1.02] hover:shadow-lg h-[200px] flex flex-col ${
          isMenuOpen || isStatusMenuOpen ? 'z-50' : 'z-10'
        }`}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
      >
        {/* Menu Icons */}
        <div className="absolute top-3 right-3 z-2">
          <div className="flex items-center gap-2">
            {/* Star Button */}
            <div
              style={
                {
                  '--hover-bg': colors['bg-quaternary'],
                } as React.CSSProperties
              }
              className="w-6 h-6 rounded hidden items-center justify-center cursor-pointer hover:bg-[var(--hover-bg)] transition-colors"
              onClick={(e) => {
                e.stopPropagation();
                setIsStarFilled(!isStarFilled);
              }}
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${isStarFilled ? 'star-filled.svg' : 'star-01.svg'}`}
                alt="Star Icon"
                className="w-4 h-4 opacity-70 hover:opacity-100 transition-opacity select-none"
                draggable="false"
              />
            </div>

            {/* Menu Button */}
            <div
              ref={actionsButtonRef}
              data-menu-button
              style={
                {
                  '--hover-bg': colors['bg-quaternary'],
                } as React.CSSProperties
              }
              className="w-7 h-7 rounded flex items-center justify-center cursor-pointer hover:bg-[var(--hover-bg)] transition-colors"
              onClick={handleMenuClick}
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/dots-horizontal-quinary.svg`}
                alt="Menu"
                className="w-5 h-5 opacity-70 hover:opacity-100 transition-opacity select-none"
                draggable="false"
              />
            </div>
          </div>
        </div>

        {/* Main Content */}
        <div className="flex flex-col h-full">
          {/* Top Section */}
          <div className="p-4">
            {/* Icon */}
            <div className="mb-3">
              <div className="flex items-center justify-center w-8 h-8">
                {workflow.signedIconUrl ? (
                  <img
                    src={workflow.signedIconUrl}
                    alt={workflow.name}
                    className="w-6 h-auto object-contain"
                    referrerPolicy="strict-origin-when-cross-origin"
                  />
                ) : workflow.icon &&
                  workflow.icon.startsWith('https://cdn.brandfetch.io/') ? (
                  <img
                    src={workflow.icon}
                    alt={workflow.name}
                    className="w-6 h-auto object-contain"
                    referrerPolicy="strict-origin-when-cross-origin"
                  />
                ) : workspace.brand_logo_url ? (
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_STORAGE_PATH}/${workspace.brand_logo_url}`}
                    alt="Workspace Brand Logo"
                    className="w-8 h-8 object-contain select-none"
                    draggable="false"
                  />
                ) : (
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`}
                    alt="Default Icon"
                    className="w-8 h-8 select-none"
                    draggable="false"
                  />
                )}
              </div>
            </div>

            {/* Title */}
            <div className="space-y-1">
              <h3
                style={{ color: colors['text-primary'] }}
                className="font-medium text-md line-clamp-2 break-words overflow-hidden"
                title={workflow.name}
              >
                {workflow.name}
              </h3>
            </div>
          </div>

          {/* Middle Section - Process Owner and Review Date */}
          {((workflow.process_owner && workflow.process_owner.trim()) ||
            (workflow.review_date && workflow.review_date.trim())) && (
            <div className="px-4 pb-3">
              <div className="space-y-1">
                {workflow.process_owner && workflow.process_owner.trim() && (
                  <div className="flex items-center gap-2">
                    <div className="w-4 h-4 relative overflow-hidden flex-shrink-0">
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/user-profile.svg`}
                        alt="Owner"
                        className="w-4 h-4 opacity-50"
                      />
                    </div>
                    <span
                      style={{ color: colors['text-tertiary'] }}
                      className="text-xs truncate"
                      title={workflow.process_owner}
                    >
                      {workflow.process_owner}
                    </span>
                  </div>
                )}
                {workflow.review_date && workflow.review_date.trim() && (
                  <div className="flex items-center gap-2">
                    <div className="w-4 h-4 relative overflow-hidden flex-shrink-0">
                      <img
                        src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/calendar-clock-1.svg`}
                        alt="Review Date"
                        className="w-4 h-4 opacity-50"
                      />
                    </div>
                    <span
                      style={{ color: colors['text-tertiary'] }}
                      className="text-xs"
                    >
                      Review due:{' '}
                      {new Date(workflow.review_date).toLocaleDateString(
                        'en-US',
                        {
                          month: 'short',
                          day: 'numeric',
                          year: 'numeric',
                        }
                      )}
                    </span>
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Bottom Section */}
          <div className="mt-auto">
            <div
              style={{ borderColor: colors['border-secondary'] }}
              className="border-t w-full"
            />
            <div className="px-4 py-3 flex items-center justify-between">
              <div
                className="relative"
                ref={statusButtonRef}
                onClick={handleStatusClick}
              >
                <div
                  style={{
                    backgroundColor: currentStatus.bg,
                    borderColor: currentStatus.border,
                    color: currentStatus.text,
                  }}
                  className="px-2 py-0.5 text-xs rounded-full border cursor-pointer transition-colors duration-150"
                >
                  {currentStatus.label}
                </div>

                {/* Status Dropdown Menu */}
                {isStatusMenuOpen && (
                  <motion.div
                    ref={statusMenuRef}
                    initial={{ opacity: 0, scale: 0.95, y: -10 }}
                    animate={{ opacity: 1, scale: 1, y: 0 }}
                    exit={{ opacity: 0, scale: 0.95, y: -10 }}
                    transition={{
                      duration: 0.15,
                      ease: [0.16, 1, 0.3, 1], // Custom easing for smooth feel
                    }}
                    style={{
                      backgroundColor: colors['bg-secondary'],
                      borderColor: colors['border-primary'],
                      ...(statusMenuPosition === 'top'
                        ? { bottom: 'calc(100% + 4px)' }
                        : { top: 'calc(100% + 4px)' }),
                    }}
                    className="absolute left-0 z-[60] rounded-lg border shadow-[0px_4px_6px_-2px_rgba(16,24,40,0.03)] py-1 min-w-[200px]"
                  >
                    <div className="flex flex-col">
                      {Object.entries(STATUS_STYLES).map(([key, style]) => (
                        <div
                          key={key}
                          className="self-stretch px-1.5 py-px flex items-center gap-3"
                          onClick={(e) => {
                            e.preventDefault();
                            onStatusChange(workflow, key as WorkflowStatus);
                            setIsStatusMenuOpen(false);
                          }}
                        >
                          <div
                            style={
                              {
                                '--hover-bg': colors['bg-quaternary'],
                              } as React.CSSProperties
                            }
                            className="grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center flex hover:bg-[var(--hover-bg)] transition-all duration-300 overflow-hidden"
                          >
                            <div
                              style={{ color: colors['text-primary'] }}
                              className="text-sm font-normal font-['Inter'] leading-tight flex items-center gap-2"
                            >
                              <div
                                style={{
                                  backgroundColor: style.bg,
                                  borderColor: style.border,
                                }}
                                className="w-2 h-2 rounded-full border"
                              ></div>
                              {style.label}
                            </div>
                            {key === workflow.status && (
                              <img
                                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/check-icon2.svg`}
                                alt="Selected"
                                className="w-4 h-4 opacity-70 ml-auto select-none"
                                draggable="false"
                              />
                            )}
                          </div>
                        </div>
                      ))}
                    </div>
                  </motion.div>
                )}
              </div>

              <span
                style={{ color: colors['text-tertiary'] }}
                className="text-xs truncate ml-4"
              >
                Last update: {formatLastEdited(workflow.updated_at)}
              </span>
            </div>
          </div>
        </div>

        {/* Menu Dropdown */}
        {isMenuOpen && (
          <motion.div
            ref={menuRef}
            initial={{ opacity: 0, scale: 0.95, y: -10 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            exit={{ opacity: 0, scale: 0.95, y: -10 }}
            transition={{
              duration: 0.15,
              ease: [0.16, 1, 0.3, 1], // Custom easing for smooth feel
            }}
            style={{
              backgroundColor: colors['bg-secondary'],
              borderColor: colors['border-primary'],
              ...(actionsMenuPosition === 'top'
                ? { bottom: 'calc(100%)' }
                : { top: '40px' }),
              right: '4px',
            }}
            className="absolute w-48 py-1 rounded-lg shadow-md z-[60] overflow-hidden border"
            onClick={(e) => e.stopPropagation()}
          >
            {menuItems.map((item, index) =>
              item === 'separator' ? (
                <div
                  key={`sep-${index}`}
                  style={{ borderColor: colors['border-secondary'] }}
                  className="w-full border-b my-1"
                />
              ) : (
                <div
                  key={index}
                  className={`self-stretch px-1.5 py-px flex items-center gap-3 relative ${
                    item.disabled ? 'cursor-not-allowed' : 'cursor-pointer'
                  }`}
                  onMouseEnter={() => item.disabled && setHoveredItem(index)}
                  onMouseLeave={() => setHoveredItem(null)}
                  onClick={(e) => {
                    e.stopPropagation();
                    if (item.disabled) return;
                    
                    onSelectWorkflow(workflow);
                    if (item.label === 'Delete Flow') {
                      onDeleteWorkflow(workflow);
                    } else if (item.label === 'Move') {
                      onMoveWorkflow(workflow);
                    } else if (item.label === 'Edit Flow info') {
                      onEditWorkflow(workflow);
                    } else if (item.label === 'Open in read mode') {
                      navigateToEditMode(workflow.id);
                    } else if (item.label === 'Duplicate') {
                      onDuplicateWorkflow(workflow);
                    } else if (item.label === 'Share') {
                      setIsShareModalOpen(true);
                    }
                    setIsMenuOpen(false);
                  }}
                >
                  <div
                    style={
                      {
                        '--hover-bg': item.disabled ? 'transparent' : colors['bg-quaternary'],
                      } as React.CSSProperties
                    }
                    className={`grow shrink basis-0 px-2.5 py-[9px] rounded-md justify-start items-center gap-3 flex transition-all duration-300 overflow-hidden ${
                      item.disabled ? 'opacity-50' : 'hover:bg-[var(--hover-bg)]'
                    }`}
                  >
                    <div className="grow shrink basis-0 h-5 justify-start items-center gap-2 flex">
                      <div className="w-4 h-4 relative overflow-hidden">
                        <img
                          src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${item.icon}`}
                          alt={`${item.label} Icon`}
                          className={`w-4 h-4 select-none ${item.disabled ? 'opacity-50' : ''}`}
                          draggable="false"
                        />
                      </div>
                      <div
                        style={{ color: item.disabled ? colors['text-tertiary'] : colors['text-primary'] }}
                        className="grow shrink basis-0 text-sm font-normal font-['Inter'] leading-tight"
                      >
                        {item.label}
                      </div>
                    </div>
                  </div>
                  {/* Tooltip for disabled items */}
                  {item.disabled && item.tooltip && hoveredItem === index && (
                    <div className="absolute right-2 top-1/2 transform -translate-y-1/2 z-[70]">
                      <div
                        className="px-2 py-1 text-xs rounded shadow-lg whitespace-nowrap"
                        style={{
                          backgroundColor: colors['bg-primary'],
                          color: colors['text-secondary'],
                          border: `1px solid ${colors['border-primary']}`,
                          fontSize: '11px',
                        }}
                      >
                        {item.tooltip}
                      </div>
                    </div>
                  )}
                </div>
              )
            )}
          </motion.div>
        )}
      </div>

      {/* Share Modal */}
      <ShareModal
        shareUrl={createShareLink(workflow.name, workflow.public_access_id)}
        isOpen={isShareModalOpen}
        onClose={() => setIsShareModalOpen(false)}
        itemName={workflow.name}
        shareableLink={createShareLink(
          workflow.name,
          workflow.public_access_id
        )}
        is_public={localIsPublic}
        onToggleAccess={handleToggleAccess}
        workspace={workspace}
      />
    </>
  );
}
</file>

<file path="app/join/page.tsx">
'use client';
import { useEffect, useState } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { createBrowserClient } from '@supabase/ssr';

export default function JoinWorkspacePage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [status, setStatus] = useState<'loading' | 'error' | 'success'>(
    'loading'
  );
  const [error, setError] = useState('');

  useEffect(() => {
    const checkAuthAndJoin = async () => {
      const workspace = searchParams.get('workspace');
      const token = searchParams.get('token');

      if (!workspace || !token) {
        setStatus('error');
        setError('Missing workspace or token.');
        return;
      }

      // Decode token to get email
      let email;
      try {
        const decoded = Buffer.from(token, 'base64').toString('utf-8');
        [email] = decoded.split(':');
      } catch {
        setStatus('error');
        setError('Invalid invitation token.');
        return;
      }

      const supabase = createBrowserClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL as string,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY as string
      );
      const {
        data: { user },
      } = await supabase.auth.getUser();

      if (!user) {
        // Check if account exists
        const response = await fetch(
          `/api/check-email?email=${encodeURIComponent(email)}`
        );
        const { exists } = await response.json();

        const params = new URLSearchParams();
        if (workspace) params.set('workspace', workspace);
        if (token) params.set('token', token);
        params.set('redirect', '/join');

        if (exists) {
          router.replace(`/login?${params.toString()}`);
        } else {
          params.set('autoConfirm', 'true');
          params.set('email', email);
          router.replace(`/signup?${params.toString()}`);
        }
        return;
      }

      // Always check onboarding after join attempt
      let joinError = null;
      try {
        const res = await fetch('/api/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ workspace, token }),
        });
        if (!res.ok) {
          const data = await res.json();
          joinError = data.error || 'Failed to join workspace.';
        }
      } catch (err) {
        joinError = 'An unexpected error occurred.';
      }

      // Check onboarding status
      const {
        data: { user: refreshedUser },
      } = await supabase.auth.getUser();

      const onboardingStatus =
        refreshedUser?.user_metadata?.onboarding_status || {};
      const isOnboardingComplete = onboardingStatus.completed_at;

      if (!isOnboardingComplete) {
        router.replace(`/onboarding?join=${encodeURIComponent(workspace)}`);
      } else {
        setStatus(joinError ? 'error' : 'success');
        if (joinError) setError(joinError);
        router.replace('/');
      }
    };

    checkAuthAndJoin();
  }, [searchParams, router]);

  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      {status === 'loading' && (
        <>
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900 mb-4" />
          <p>Joining workspace...</p>
        </>
      )}
      {status === 'error' && (
        <>
          <div className="text-red-500 font-bold text-lg mb-2">Error</div>
          <p>{error}</p>
        </>
      )}
    </div>
  );
}
</file>

<file path="app/onboarding/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { AnimatePresence } from 'framer-motion';
import { useColors, useTheme } from '@/app/theme/hooks';
import LoadingSpinner from '@/app/components/LoadingSpinner';
import { OnboardingProvider, useOnboarding } from './context/OnboardingContext';
import MotionStep from './components/MotionStep';
import ProgressIndicator from './components/ProgressIndicator';
import PersonalInfoStep from './components/PersonalInfoStep';
import ProfessionalInfoStep from './components/ProfessionalInfoStep';
import WorkspaceSetupStep from './components/WorkspaceSetupStep';
import CompletedStep from './components/CompletedStep';
import { useRouter, useSearchParams } from 'next/navigation';
import { createClient } from '@/utils/supabase/client';

// Main onboarding component wrapped with provider
export default function Onboarding() {
  return (
    <OnboardingProvider>
      <OnboardingContent />
    </OnboardingProvider>
  );
}

// Inner component that uses the onboarding context
function OnboardingContent() {
  const { currentStep, isLoadingInitialState, workspaceCreationStarted } =
    useOnboarding();
  const router = useRouter();
  const searchParams = useSearchParams();
  const joinWorkspace = searchParams.get('join');
  const [userHasWorkspace, setUserHasWorkspace] = useState(false);

  // Use the colors hook which returns CSS variables
  const colors = useColors();
  const { currentTheme, setTheme } = useTheme();

  // Add effect to ensure page is scrollable and uses light mode
  useEffect(() => {
    // Ensure the body has proper overflow behavior
    document.body.style.overflow = 'auto';
    document.body.style.height = '100%';

    // Force light theme styles for onboarding
    document.documentElement.classList.add('force-light-theme');
    document.documentElement.classList.remove('dark');

    if (currentTheme !== 'light') {
      setTheme('light');
    }

    return () => {
      // Reset on unmount
      document.body.style.overflow = '';
      document.body.style.height = '';
      document.documentElement.classList.remove('force-light-theme');
    };
  }, [currentTheme, setTheme]);

  // Add effect to handle browser back button
  useEffect(() => {
    // Listen for popstate events (browser back/forward buttons)
    const handlePopState = (event: PopStateEvent) => {
      // If workspace creation has started, prevent going back to onboarding steps
      if (workspaceCreationStarted) {
        // Prevent the default back behavior
        window.history.pushState(null, '', window.location.pathname);
      }
    };

    window.addEventListener('popstate', handlePopState);

    // Add a history entry to capture back button
    window.history.pushState(null, '', window.location.pathname);

    // Clean up the event listener
    return () => {
      window.removeEventListener('popstate', handlePopState);
    };
  }, [workspaceCreationStarted]);

  useEffect(() => {
    const checkUserAndWorkspace = async () => {
      if (!joinWorkspace) return;

      // 1. Get the authenticated user
      const userRes = await fetch('/api/user');
      if (!userRes.ok) return;
      const user = await userRes.json();
      if (!user?.id || !user?.auth_id) return;

      // 2. Get the user's workspaces
      const wsRes = await fetch(`/api/user_workspace/${user.id}`);
      if (!wsRes.ok) return;
      const workspaces = (await wsRes.json()) as any[];

      // 3. Check if user is part of the workspace (by id or slug)
      const found = workspaces.some(
        (ws) => ws.id === parseInt(joinWorkspace) // or ws.slug === joinWorkspace
      );
      setUserHasWorkspace(found);
    };

    checkUserAndWorkspace();
  }, [joinWorkspace]);

  // Render loading state during initial check to prevent flashing of onboarding UI
  if (isLoadingInitialState) {
    return (
      <div className="flex h-screen w-full items-center justify-center">
        <LoadingSpinner size="large" />
      </div>
    );
  }

  // Render the actual onboarding content
  return (
    <div
      className="w-full min-h-screen flex flex-col overflow-auto"
      style={{ backgroundColor: colors['bg-primary'] }}
    >
      <div className="w-full flex-1 flex flex-col items-center gap-8 py-6 px-4">
        {/* Fixed position logo */}
        <div className="w-[140px] sm:w-[180px] md:w-[240px] flex items-center">
          <img
            src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logo-pf-in-app.png`}
            alt="Logo ProcessFlow"
            className="w-full"
          />
        </div>

        {/* Fixed position progress indicator */}
        <div className="w-full">
          <ProgressIndicator />
        </div>

        {/* Content container */}
        <div className="w-full flex items-start justify-center pb-16">
          {/* Content for current step */}
          <AnimatePresence mode="wait">
            {currentStep === 'PERSONAL_INFO' && (
              <MotionStep key="personal-info-step">
                <PersonalInfoStep />
              </MotionStep>
            )}

            {currentStep === 'PROFESSIONAL_INFO' && (
              <MotionStep key="professional-info-step">
                <ProfessionalInfoStep userHasWorkspace={userHasWorkspace} />
              </MotionStep>
            )}

            {currentStep === 'WORKSPACE_SETUP' && (
              <MotionStep key="workspace-setup-step">
                <WorkspaceSetupStep />
              </MotionStep>
            )}

            {currentStep === 'COMPLETED' && (
              <MotionStep key="completed-step">
                <CompletedStep />
              </MotionStep>
            )}
          </AnimatePresence>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/signup/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import Link from 'next/link';
import posthog from 'posthog-js';
import { signup, checkEmailExists } from '../login/actions';
import * as Sentry from '@sentry/nextjs';
import { createBrowserClient } from '@supabase/ssr';
import { sanitizeInput } from '../utils/sanitize';

export default function SignupPage() {
  const [showPassword, setShowPassword] = useState(false);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [showEmailNotification, setShowEmailNotification] = useState(false);
  const [emailError, setEmailError] = useState('');
  const [passwordError, setPasswordError] = useState('');
  const [globalError, setGlobalError] = useState('');
  const [isCheckingEmail, setIsCheckingEmail] = useState(false);
  const router = useRouter();
  const searchParams = useSearchParams();
  const workspace = searchParams.get('workspace');
  const token = searchParams.get('token');
  const autoConfirm = searchParams.get('autoConfirm');

  // Email validation
  const validateEmail = (email: string): boolean => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  };

  // Password validation
  const validatePassword = (password: string): boolean => {
    // At least 8 characters, one uppercase, one lowercase, one number, one special character
    const strongPasswordRegex =
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_\-+=\[\]{};':"\\|,.<>/?]).{8,}$/;
    return strongPasswordRegex.test(password);
  };

  // Handle email validation and check if it exists
  const handleEmailChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setEmail(e.target.value);
    if (emailError) setEmailError('');
    if (globalError) setGlobalError('');
  };

  const handlePasswordChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setPassword(e.target.value);
    if (passwordError) setPasswordError('');
  };

  // Add a function to check email existence
  const checkEmailAvailability = async (email: string) => {
    if (!validateEmail(email)) return; // Don't check invalid emails

    setIsCheckingEmail(true);
    try {
      const result = await checkEmailExists(email);

      // Optionally, you can show a generic message if you want, but don't reveal existence
    } catch (error) {
      console.error('Failed to check email:', error);
    } finally {
      setIsCheckingEmail(false);
    }
  };

  // Add a debounce effect for email checks
  useEffect(() => {
    if (!email || !validateEmail(email)) return;

    const timer = setTimeout(() => {
      checkEmailAvailability(email);
    }, 600); // 600ms debounce

    return () => clearTimeout(timer);
  }, [email]);

  // Autofill email from token if present and valid
  useEffect(() => {
    if (token && !email) {
      try {
        // Robust base64 decode for UTF-8
        function b64DecodeUnicode(str: string) {
          return decodeURIComponent(
            atob(str)
              .split('')
              .map(function (c) {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
              })
              .join('')
          );
        }
        const decoded = b64DecodeUnicode(token);
        const [decodedEmail] = decoded.split(':');
        if (decodedEmail && validateEmail(decodedEmail)) {
          setEmail(decodedEmail);
        }
      } catch (e) {
        // Optionally handle invalid token
        console.error('Invalid invitation token:', e);
      }
    }
    // Only run when token changes or email is empty
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [token]);

  async function handleSignUp(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();

    if (process.env.NODE_ENV !== 'production') {
      console.log('Starting signup process');
    }

    // Clear any existing notifications first
    setShowEmailNotification(false);
    setGlobalError('');
    setEmailError('');
    setPasswordError('');

    // Validate inputs before submission
    let hasErrors = false;

    if (!validateEmail(email)) {
      setEmailError('Please enter a valid email address.');
      hasErrors = true;
    }

    if (!validatePassword(password)) {
      setPasswordError(
        'Password must be at least 8 characters and include uppercase, lowercase, number, and special character.'
      );
      hasErrors = true;
    }

    if (hasErrors) return;

    // Validate password
    if (password.length < 8) {
      setPasswordError('Password must be at least 8 characters');
      if (process.env.NODE_ENV !== 'production') {
        console.log('Password too short, signup blocked');
      }
      return;
    }

    // Final check for email existence before signup
    if (process.env.NODE_ENV !== 'production') {
      console.log('Performing final email check before signup');
    }
    setIsLoading(true);
    try {
      const emailCheck = await checkEmailExists(email);

      // Continue with signup process if email doesn't exist
      if (email && password) {
        const formData = new FormData();
        formData.append('email', email);
        formData.append('password', password);
        if (workspace) formData.append('workspace', workspace);
        if (token) formData.append('token', token);
        if (autoConfirm) formData.append('autoConfirm', autoConfirm);

        if (process.env.NODE_ENV !== 'production') {
          console.log('Submitting signup request with email:', email);
        }
        const newUser = await signup(formData);
        if (process.env.NODE_ENV !== 'production') {
          console.log('Signup response:', newUser);
        }
        setIsLoading(false);

        // Explicit check to ensure we don't proceed if there was an error
        if (globalError || emailError) {
          if (process.env.NODE_ENV !== 'production') {
            console.log('Preventing notification due to errors:', {
              globalError,
              emailError,
            });
          }
          return;
        }

        // Store email in sessionStorage for the confirmation page
        if (newUser?.email) {
          try {
            // Track analytics
            Sentry.setUser({
              id: newUser.id,
              email: newUser.email,
            });

            posthog.identify(newUser.id);
            posthog.people.set({
              email: newUser.email,
            });
            posthog.capture('signup', {
              email: newUser.email,
            });
          } catch (error) {
            if (process.env.NODE_ENV !== 'production') {
              console.error('Error during analytics tracking:', error);
            }
            // Continue with redirect even if analytics fails
          }
        }
        // Single redirect after analytics (success or fail)
        if (newUser?.redirectTo) {
          router.push(newUser.redirectTo);
        } else {
          router.push(
            `/login?email=${encodeURIComponent(newUser.email || (formData.get('email') as string))}&signup=success`
          );
        }
      }
    } catch (error) {
      console.error('Unexpected error during signup:', error);
      // Report to PostHog
      posthog.capture('signup_failed', {
        email,
        error: error instanceof Error ? error.message : String(error),
      });
      setIsLoading(false);
      setGlobalError('An unexpected error occurred. Please try again later.');
    }
  }

  const handleGoogleAuth = async () => {
    try {
      const supabase = createBrowserClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL as string,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY as string,
        {
          cookies: {
            get(name: string) {
              return document.cookie
                .split('; ')
                .find((row) => row.startsWith(`${name}=`))
                ?.split('=')[1];
            },
            set(name: string, value: string, options: any) {
              let cookie = `${name}=${value}; path=/`;
              if (options.maxAge) {
                cookie += `; max-age=${options.maxAge}`;
              }
              if (options.domain) {
                cookie += `; domain=.process-flow.io`;
              }
              document.cookie = cookie;
            },
            remove(name: string) {
              document.cookie = `${name}=; path=/; expires=Thu, 01 Jan 1970 00:00:01 GMT`;
            },
          },
        }
      );

      // Get workspace and token from URL params
      const workspace = searchParams?.get('workspace');
      const token = searchParams?.get('token');

      // Build the callback URL with additional parameters if they exist
      let callbackUrl = `${window.location.origin}/auth/callback`;
      if (workspace && token) {
        callbackUrl += `?workspace_id=${encodeURIComponent(workspace)}&invite_token=${encodeURIComponent(token)}`;
      }

      const { data, error } = await supabase.auth.signInWithOAuth({
        provider: 'google',
        options: {
          redirectTo: callbackUrl,
          queryParams: {
            access_type: 'offline',
            prompt: 'consent',
          },
        },
      });

      if (error) {
        if (process.env.NODE_ENV !== 'production') {
          console.error('Erreur authentification Google:', error.message);
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          console.log('Redirection OAuth initie:', data);
        }
      }
    } catch (error) {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Erreur inattendue:', error);
      }
    }
  };

  return (
    <div className="relative w-full min-h-screen bg-white overflow-hidden flex flex-col items-center justify-center py-6 px-4 sm:px-6">
      {/* Error notification */}
      {globalError && (
        <div className="fixed top-4 right-4 left-4 sm:left-auto bg-red-500 text-white px-4 sm:px-6 py-3 rounded-lg shadow-lg z-50">
          <p>{globalError}</p>
        </div>
      )}

      <div className="w-full max-w-[420px] p-3 bg-gray-50 rounded-3xl border border-[#e4e7ec] flex flex-col justify-center items-center gap-2">
        <div className="relative w-full h-fit px-4 sm:px-6 py-8 sm:py-10 bg-white rounded-2xl border border-[#e4e7ec] flex flex-col justify-start items-center gap-6 sm:gap-8 overflow-hidden">
          {/* Corner dots */}
          <div className="pointer-events-none absolute inset-0">
            <div
              className="w-1.5 h-1.5 bg-white rounded-full shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)] border border-[#e4e7ec] absolute"
              style={{ top: 16, left: 16 }}
            />
            <div
              className="w-1.5 h-1.5 bg-white rounded-full shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)] border border-[#e4e7ec] absolute"
              style={{ bottom: 16, left: 16 }}
            />
            <div
              className="w-1.5 h-1.5 bg-white rounded-full shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)] border border-[#e4e7ec] absolute"
              style={{ top: 16, right: 16 }}
            />
            <div
              className="w-1.5 h-1.5 bg-white rounded-full shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)] border border-[#e4e7ec] absolute"
              style={{ bottom: 16, right: 16 }}
            />
          </div>

          {/* App icon */}
          <div className="z-10 flex justify-start items-start">
            <div className="w-10 h-10 relative overflow-hidden bg-white rounded-[10px] flex items-center justify-center">
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`}
                alt="App Icon"
                className="w-full h-full object-cover"
              />
            </div>
          </div>

          {/* Heading section */}
          <div className="z-10 flex flex-col items-center gap-3 w-full">
            <div className="flex flex-col items-start gap-1 w-full">
              <div className="w-full text-center text-[#101828] text-lg font-semibold font-['Inter'] leading-7">
                Create your account
              </div>
              <div className="w-full text-center text-[#475467] text-sm font-normal font-['Inter'] leading-tight">
                Start managing your processes efficiently
              </div>
            </div>
          </div>

          {/* Signup form */}
          <form
            onSubmit={handleSignUp}
            className="z-10 flex flex-col items-center gap-6 w-full rounded-xl"
          >
            <div className="flex flex-col items-start gap-5 w-full">
              {/* Email field */}
              <div className="flex flex-col items-start gap-1.5 w-full">
                <label className="flex items-start gap-0.5 text-[#344054] text-sm font-medium font-['Inter'] leading-tight">
                  Email
                </label>
                <div
                  className={`px-3.5 py-1.5 bg-white rounded-lg shadow-[0px_1px_2px_0px_rgba(16,24,40,0.05)] border ${emailError ? 'border-red-500' : 'border-[#d0d5dd]'} flex items-center gap-2 w-full focus-within:border-[#4e6bd7] focus-within:shadow-[0px_0px_0px_4px_rgba(78,107,215,0.2)] transition-colors duration-200`}
                >
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/mail-01.svg`}
                    alt="Mail Icon"
                    className="w-4 h-4"
                  />
                  <input
                    type="email"
                    placeholder="Email address"
                    className="grow text-[#667085] text-base font-normal font-['Inter'] leading-normal outline-none bg-transparent"
                    value={email}
                    onChange={handleEmailChange}
                  />
                  {isCheckingEmail && (
                    <div className="w-4 h-4 animate-spin rounded-full border-2 border-[#4e6bd7] border-t-transparent" />
                  )}
                </div>
                {emailError && (
                  <span className="text-red-500 text-sm mt-1">
                    {emailError}
                  </span>
                )}
              </div>

              {/* Password field */}
              <div className="flex flex-col items-start gap-1.5 w-full">
                <label className="flex items-start gap-0.5 text-[#344054] text-sm font-medium font-['Inter'] leading-tight">
                  Password
                </label>
                <div
                  className={`px-3.5 py-1.5 bg-white rounded-lg shadow-[0px_1px_2px_0px_rgba(16,24,40,0.05)] border ${passwordError ? 'border-red-500' : 'border-[#d0d5dd]'} flex items-center gap-2 w-full focus-within:border-[#4e6bd7] focus-within:shadow-[0px_0px_0px_4px_rgba(78,107,215,0.2)] transition-colors duration-200`}
                >
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/lock-01.svg`}
                    alt="Lock Icon"
                    className="w-4 h-4"
                  />
                  <input
                    type={showPassword ? 'text' : 'password'}
                    placeholder=""
                    className="grow text-[#667085] text-base font-normal font-['Inter'] leading-normal outline-none bg-transparent"
                    value={password}
                    onChange={handlePasswordChange}
                  />
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${showPassword ? 'eye-off' : 'eye'}.svg`}
                    alt={showPassword ? 'Hide Password' : 'Show Password'}
                    className="w-4 h-4 cursor-pointer"
                    onClick={() => setShowPassword(!showPassword)}
                  />
                </div>
                {passwordError && (
                  <span className="text-red-500 text-sm mt-1">
                    {passwordError}
                  </span>
                )}
              </div>
            </div>

            {/* Sign up button */}
            <div className="flex flex-col items-start gap-4 w-full">
              <button
                type="submit"
                disabled={isLoading || !email || !password}
                className={`w-full px-3 py-2 rounded-lg border-2 border-white flex items-center justify-center gap-1 overflow-hidden transition-colors duration-300 ${
                  isLoading ? 'bg-[#F9FAFB]' : 'bg-[#4e6bd7] hover:bg-[#374c99]'
                }`}
              >
                {isLoading ? (
                  <div
                    className="w-5 h-5 animate-spin"
                    style={{
                      borderRadius: '50%',
                      background: 'conic-gradient(#4761C4 0%, #F9FAFB 100%)',
                      maskImage:
                        'radial-gradient(closest-side, transparent 83%, black 84%)',
                    }}
                  />
                ) : (
                  <div className="text-white text-sm font-semibold font-['Inter'] leading-tight">
                    Sign up
                  </div>
                )}
              </button>
            </div>
          </form>

          {/* Divider */}
          <div className="z-10 flex items-center gap-4 w-full mt-2">
            <div className="grow h-px border border-[#e4e7ec]" />
            <div className="text-center text-[#475467] text-sm font-normal font-['Inter'] leading-tight">
              or
            </div>
            <div className="grow h-px border border-[#e4e7ec]" />
          </div>

          {/* Google signup */}
          <div className="z-10 flex flex-col items-center w-full mb-2">
            <button
              onClick={handleGoogleAuth}
              className="w-full px-4 py-2 bg-white rounded-lg shadow-[0px_1px_2px_0px_rgba(0,0,0,0.07)] border border-[#d0d5dd] flex items-center justify-center gap-3 overflow-hidden transition-colors duration-300 hover:bg-[#F9FAFB]"
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/google.svg`}
                alt="Google Icon"
                className="w-4 h-4"
              />
              <div className="text-[#344054] text-sm font-semibold font-['Inter'] leading-tight">
                Sign up with Google
              </div>
            </button>
          </div>

          {/* Terms and Privacy */}
          <div className="z-10 text-center flex flex-wrap justify-center items-center gap-1">
            <div className="text-[#667085] text-sm font-normal font-['Inter'] leading-tight">
              By continuing you agree to
            </div>
            <Link
              href="https://www.process-flow.io/terms"
              className="text-[#374c99] text-sm font-semibold font-['Inter'] leading-tight"
            >
              Terms of Service
            </Link>
            <div className="text-[#667085] text-sm font-normal font-['Inter'] leading-tight">
              and
            </div>
            <Link
              href="https://www.process-flow.io/privacy"
              className="text-[#374c99] text-sm font-semibold font-['Inter'] leading-tight"
            >
              Privacy Policy.
            </Link>
          </div>
        </div>

        {/* Login link */}
        <div className="py-3 flex justify-center items-baseline gap-1">
          <div className="text-[#667085] text-sm font-normal font-['Inter'] leading-tight">
            Already have an account?
          </div>
          <Link
            href="/login"
            className="text-[#374c99] text-sm font-semibold font-['Inter'] leading-tight"
          >
            Log in
          </Link>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="e2e/step-definitions/login.steps.ts">
// @ts-nocheck
const { Given, When, Then } = require('@cucumber/cucumber');
const { expect } = require('@playwright/test');
// const { TEST_USER } = require('./authentication.steps'); // If you want to reuse constants

Given('I am on the login page', async function () {
  await this.page.goto('http://localhost:3000/login');
  await this.page.waitForSelector('text="Log in to Processflow"', { timeout: 10000 });
});

When('I enter a valid email and password', async function () {
  await this.page.fill('input[name="email"]', 'tomaxime0@gmail.com');
  await this.page.fill('input[name="password"]', 'abcd1234');
});

When('I enter a valid email and an incorrect password', async function () {
  await this.page.fill('input[name="email"]', 'tomaxime0@gmail.com');
  await this.page.fill('input[name="password"]', 'wrongpassword123');
});

When('I click the "Log in" button', async function () {
  await this.page.click('button[type="submit"]:has-text("Log in")');
});

When('I click the "Log in" button without entering credentials', async function () {
  await this.page.click('button[type="submit"]:has-text("Log in")');
});

Then('I should be redirected to the dashboard', async function () {
  await this.page.waitForURL('http://localhost:3000/', { timeout: 10000 });
  expect(this.page.url()).toBe('http://localhost:3000/');
});

Then('I should see a welcome message', async function () {
  await this.page.waitForSelector('text="Welcome"', { timeout: 5000 });
});

Then('I should see an error message', async function () {
  await this.page.waitForSelector('[role="alert"], .error, .toast, text*="error"', { timeout: 5000 });
});

Then('I should see validation errors for both email and password', async function () {
  await this.page.waitForSelector('text*="email"', { timeout: 5000 });
  await this.page.waitForSelector('text*="password"', { timeout: 5000 });
});
</file>

<file path="prisma/dbml/schema.dbml">
//// ------------------------------------------------------
//// THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
//// ------------------------------------------------------

Table user {
  id Int [pk, increment]
  created_at DateTime [default: `now()`, not null]
  updated_at DateTime [default: `now()`, not null]
  archived_at DateTime
  auth_id String [unique, not null]
  first_name String [not null]
  last_name String [not null]
  full_name String [not null]
  email String [unique, not null]
  avatar_url String
  active_workspace_id Int
  hubspot_contact_id String
  sentry_id String
  post_hog_id String
  last_login_at DateTime
  onboarding_completed_at DateTime
  onboarding_step onboarding_step [default: 'PERSONAL_INFO']
  professional_role String
  source String
  temp_company_size String
  temp_industry String
  tutorial_completed Boolean [not null, default: false]
  active_workspace workspace
  workspaces user_workspace [not null]
  scheduled_emails scheduled_emails [not null]
  workflows workflow [not null]
  sent_invitations workspace_invitation [not null]
}

Table workspace {
  id Int [pk, increment]
  created_at DateTime [default: `now()`, not null]
  updated_at DateTime [default: `now()`, not null]
  archived_at DateTime
  name String [not null]
  slug String [unique]
  icon_url String
  brand_logo_url String
  brand_name_img_url String
  background_colour String
  linear_customer_id String
  stripe_customer_id String [unique]
  hubspot_company_id String
  company_size String
  industry String
  branding_enabled Boolean [not null, default: false]
  subscription_id Int [unique]
  subscription subscription
  billing_infos workspace_billing_infos
  billings billing [not null]
  folders folder [not null]
  active_users user [not null]
  user_workspaces user_workspace [not null]
  workflows workflow [not null]
  invitations workspace_invitation [not null]
}

Table workspace_billing_infos {
  id Int [pk, increment]
  created_at DateTime [default: `now()`, not null]
  updated_at DateTime [default: `now()`, not null]
  billing_email String [not null]
  billing_address String [not null]
  tax_rate Decimal [not null]
  vat_number String
  workspace_id Int [unique, not null]
  workspace workspace [not null]
}

Table subscription {
  id Int [pk, increment]
  created_at DateTime [default: `now()`, not null]
  updated_at DateTime [default: `now()`, not null]
  canceled_at DateTime
  workspace_id Int [unique, not null]
  stripe_subscription_id String [unique, not null]
  trial_end_date DateTime
  plan_type plan_type [not null]
  quantity_seats Int [not null]
  current_period_start DateTime [not null]
  current_period_end DateTime [not null]
  status subscription_status [not null]
  workspace workspace
  billings billing [not null]
}

Table billing {
  id Int [pk, increment]
  created_at DateTime [default: `now()`, not null]
  updated_at DateTime [default: `now()`, not null]
  paid_at DateTime
  subscription_id Int [not null]
  stripe_invoice_id String [unique, not null]
  amount_net Int [not null]
  tax_amount Int [not null]
  amount_gross Int [not null]
  currency String [not null]
  invoice_date DateTime [not null]
  due_date DateTime [not null]
  workspace_id Int [not null]
  subscription subscription [not null]
  workspace workspace [not null]
}

Table user_workspace {
  id Int [pk, increment]
  user_id Int [not null]
  workspace_id Int [not null]
  role user_role [not null, default: 'ADMIN']
  user user [not null]
  workspace workspace [not null]

  indexes {
    (user_id, workspace_id) [unique]
  }
}

Table folder {
  id Int [pk, increment]
  name String [not null]
  workspace_id Int [not null]
  parent_id Int
  icon_url String
  emote String
  path String
  position Int [not null, default: 0]
  parent folder
  subfolders folder [not null]
  workspace workspace [not null]
  workflows workflow [not null]
}

Table workflow {
  id Int [pk, increment]
  created_at DateTime [default: `now()`, not null]
  updated_at DateTime [default: `now()`, not null]
  last_opened DateTime
  name String [not null]
  icon String
  description String [not null]
  additional_notes String
  process_owner String
  review_date DateTime
  workspace_id Int [not null]
  folder_id Int
  is_public Boolean [not null, default: true]
  public_access_id String [unique]
  status workflow_status [not null, default: 'DRAFT']
  blocks block [not null]
  paths path [not null]
  stroke_lines stroke_line [not null]
  folder folder
  workspace workspace [not null]
  author user
  author_id Int

  indexes {
    (name, workspace_id) [unique]
  }
}

Table path {
  id Int [pk, increment]
  name String [not null]
  workflow_id Int [not null]
  blocks block [not null]
  workflow workflow [not null]
  parent_blocks path_parent_block [not null]

  Note: 'Collection of connected blocks forming a workflow path'
}

Table path_parent_block {
  path_id Int [not null]
  block_id Int [not null]
  created_at DateTime [default: `now()`, not null]
  block block [not null]
  path path [not null]

  indexes {
    (path_id, block_id) [pk]
  }

  Note: 'Junction table that allows paths to be triggered from multiple parent blocks'
}

Table block {
  id Int [pk, increment]
  created_at DateTime [default: `now()`, not null]
  updated_at DateTime [default: `now()`, not null]
  type block_type [not null]
  position Int [not null]
  title String
  icon String
  description String
  image String
  original_image String
  image_description String
  average_time String
  task_type task_type
  workflow_id Int [not null]
  path_id Int [not null]
  is_endpoint Boolean [default: false]
  delay_seconds Int
  delay_event String
  delay_type delay_type
  path path [not null]
  workflow workflow [not null]
  child_paths path_parent_block [not null]
  source_stroke_lines stroke_line [not null]
  target_stroke_lines stroke_line [not null]
}

Table stroke_line {
  id Int [pk, increment]
  source_block_id Int [not null]
  target_block_id Int [not null]
  workflow_id Int [not null]
  label String [not null]
  created_at DateTime [default: `now()`, not null]
  updated_at DateTime [default: `now()`, not null]
  control_points Json
  source_block block [not null]
  target_block block [not null]
  workflow workflow [not null]
}

Table scheduled_emails {
  id Int [pk, increment]
  created_at DateTime [default: `now()`, not null]
  updated_at DateTime [default: `now()`, not null]
  user_id Int [not null]
  email_type String [not null]
  scheduled_for DateTime [not null]
  status email_status [not null, default: 'PENDING']
  sent Boolean [not null, default: false]
  sent_at DateTime
  metadata Json
  error String
  retry_count Int [not null, default: 0]
  user user [not null]

  indexes {
    (user_id, email_type) [unique]
  }
}

Table workspace_invitation {
  id Int [pk, increment]
  workspace_id Int [not null]
  email String [not null]
  inviter_id Int [not null]
  status invitation_status [not null, default: 'PENDING']
  invited_at DateTime [default: `now()`, not null]
  accepted_at DateTime
  expired_at DateTime
  workspace workspace [not null]
  inviter user [not null]
}

Enum onboarding_step {
  PERSONAL_INFO
  PROFESSIONAL_INFO
  WORKSPACE_SETUP
  COMPLETED
  INVITED_USER
}

Enum user_role {
  ADMIN
  EDITOR
  READER
}

Enum block_type {
  DELAY
  STEP
  PATH
  BEGIN
  END
  LAST
  MERGE
}

Enum subscription_status {
  ACTIVE
  TRIALING
  CANCELED
}

Enum plan_type {
  FREE
  EARLY_ADOPTER
}

Enum task_type {
  MANUAL
  AUTOMATIC
}

Enum delay_type {
  FIXED_DURATION
  WAIT_FOR_EVENT
}

Enum workflow_status {
  DRAFT
  ACTIVE
  IN_REVIEW
  NEEDS_UPDATE
  ARCHIVED
}

Enum email_status {
  PENDING
  CANCELLED
  PAUSED
  SENT
  FAILED
}

Enum invitation_status {
  PENDING
  ACCEPTED
  EXPIRED
  REVOKED
}

Ref: user.active_workspace_id > workspace.id

Ref: workspace.subscription_id - subscription.id

Ref: workspace_billing_infos.workspace_id - workspace.id [delete: Cascade]

Ref: billing.subscription_id > subscription.id

Ref: billing.workspace_id > workspace.id [delete: Cascade]

Ref: user_workspace.user_id > user.id [delete: Cascade]

Ref: user_workspace.workspace_id > workspace.id [delete: Cascade]

Ref: folder.parent_id - folder.id

Ref: folder.workspace_id > workspace.id [delete: Cascade]

Ref: workflow.folder_id > folder.id

Ref: workflow.workspace_id > workspace.id [delete: Cascade]

Ref: workflow.author_id > user.id

Ref: path.workflow_id > workflow.id

Ref: path_parent_block.block_id > block.id [delete: Cascade]

Ref: path_parent_block.path_id > path.id [delete: Cascade]

Ref: block.path_id > path.id [delete: Cascade]

Ref: block.workflow_id > workflow.id [delete: Cascade]

Ref: stroke_line.source_block_id > block.id [delete: Cascade]

Ref: stroke_line.target_block_id > block.id [delete: Cascade]

Ref: stroke_line.workflow_id > workflow.id [delete: Cascade]

Ref: scheduled_emails.user_id > user.id [delete: Cascade]

Ref: workspace_invitation.workspace_id > workspace.id [delete: Cascade]

Ref: workspace_invitation.inviter_id > user.id [delete: Cascade]
</file>

<file path="prisma/schema.prisma">
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x", "rhel-openssl-3.0.x"]
}

generator dbml {
  provider = "prisma-dbml-generator"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}
  
model user {
  id                      Int                @id @default(autoincrement())
  created_at              DateTime           @default(now())
  updated_at              DateTime           @default(now()) @updatedAt
  archived_at             DateTime?
  auth_id                 String             @unique
  first_name              String
  last_name               String
  full_name               String
  email                   String             @unique
  avatar_url              String?
  active_workspace_id     Int?
  hubspot_contact_id      String?
  sentry_id               String?
  post_hog_id             String?
  last_login_at           DateTime?
  onboarding_completed_at DateTime?
  onboarding_step         onboarding_step?   @default(PERSONAL_INFO)
  professional_role       String?
  source                  String?
  temp_company_size       String?
  temp_industry           String?
  tutorial_completed      Boolean            @default(false)
  active_workspace        workspace?         @relation("active_workspace", fields: [active_workspace_id], references: [id])
  workspaces              user_workspace[]
  scheduled_emails        scheduled_email[]
  workflows        workflow[]           @relation("author")
  sent_invitations      workspace_invitation[] @relation("UserInvitations")
  @@index([active_workspace_id])
  @@index([email])
  @@index([auth_id])
  @@index([auth_id], map: "auth_id_cover_idx")
  @@map("user")
}

model workspace {
  id                 Int                       @id @default(autoincrement())
  created_at         DateTime                  @default(now())
  updated_at         DateTime                  @default(now()) @updatedAt
  archived_at        DateTime?
  name               String
  slug               String?                   @unique
  icon_url           String?
  brand_logo_url     String?
  brand_name_img_url String?
  background_colour  String?
  linear_customer_id String?
  stripe_customer_id String?                   @unique
  hubspot_company_id String?
  company_size       String?
  industry           String?
  branding_enabled   Boolean                   @default(false)
  subscription_id    Int?                      @unique
  subscription       subscription?             @relation(fields: [subscription_id], references: [id])
  billing_infos      workspace_billing_infos?
  billings           billing[]
  folders            folder[]
  active_users       user[]                    @relation("active_workspace")
  user_workspaces    user_workspace[]
  workflows          workflow[]
  invitations        workspace_invitation[]

  @@index([stripe_customer_id])
  @@index([subscription_id])
  @@map("workspace")
}

model workspace_billing_infos {
  id              Int       @id @default(autoincrement())
  created_at      DateTime  @default(now())
  updated_at      DateTime  @default(now()) @updatedAt
  billing_email   String
  billing_address String
  tax_rate        Decimal   @db.Decimal(5, 2)
  vat_number      String?
  workspace_id    Int       @unique
  workspace       workspace @relation(fields: [workspace_id], references: [id], onDelete: Cascade)

  @@index([workspace_id])
  @@map("workspace_billing_infos")
}

model subscription {
  id                     Int                 @id @default(autoincrement())
  created_at             DateTime            @default(now())
  updated_at             DateTime            @default(now()) @updatedAt
  canceled_at            DateTime?
  workspace_id           Int                 @unique
  stripe_subscription_id String              @unique
  trial_end_date         DateTime?
  plan_type              plan_type
  quantity_seats         Int
  current_period_start   DateTime
  current_period_end     DateTime
  status                 subscription_status
  workspace              workspace?
  billings               billing[]

  @@map("subscription")
}

model billing {
  id                Int          @id @default(autoincrement())
  created_at        DateTime     @default(now())
  updated_at        DateTime     @default(now()) @updatedAt
  paid_at           DateTime?
  subscription_id   Int
  stripe_invoice_id String       @unique
  amount_net        Int
  tax_amount        Int
  amount_gross      Int
  currency          String       @db.VarChar(3)
  invoice_date      DateTime
  due_date          DateTime
  workspace_id      Int
  subscription      subscription @relation(fields: [subscription_id], references: [id])
  workspace         workspace    @relation(fields: [workspace_id], references: [id], onDelete: Cascade)

  @@index([subscription_id])
  @@index([workspace_id])
  @@index([stripe_invoice_id])
  @@map("billing")
}

model user_workspace {
  id           Int       @id @default(autoincrement())
  user_id      Int
  workspace_id Int
  role         user_role @default(ADMIN)
  user         user      @relation(fields: [user_id], references: [id], onDelete: Cascade)
  workspace    workspace @relation(fields: [workspace_id], references: [id], onDelete: Cascade)

  @@unique([user_id, workspace_id], name: "unique_user_workspace")
  @@index([user_id, workspace_id], map: "user_workspace_composite_idx")
  @@index([user_id])
  @@index([workspace_id])
  @@map("user_workspace")
}

model folder {
  id           Int        @id @default(autoincrement())
  name         String
  workspace_id Int
  parent_id    Int?
  icon_url     String?
  emote        String?
  path         String?
  position     Int        @default(0)
  parent       folder?    @relation("folder_hierarchy", fields: [parent_id], references: [id])
  subfolders   folder[]   @relation("folder_hierarchy")
  workspace    workspace  @relation(fields: [workspace_id], references: [id], onDelete: Cascade)
  workflows    workflow[]

  @@index([workspace_id])
  @@index([parent_id])
  @@index([path])
  @@map("folder")
}

model workflow {
  id               Int                @id @default(autoincrement())
  created_at       DateTime           @default(now())
  updated_at       DateTime           @default(now()) @updatedAt
  last_opened      DateTime?
  name             String
  icon             String?
  description      String
  additional_notes String?
  process_owner    String?
  review_date      DateTime?
  workspace_id     Int
  folder_id        Int?
  is_public        Boolean            @default(true)
  public_access_id String?            @unique
  status           workflow_status    @default(DRAFT)
  blocks           block[]
  paths            path[]
  stroke_lines     stroke_line[]
  folder           folder?            @relation(fields: [folder_id], references: [id])
  workspace        workspace          @relation(fields: [workspace_id], references: [id], onDelete: Cascade)
  author           user?              @relation("author", fields: [author_id], references: [id])
  author_id        Int?

  @@unique([name, workspace_id])
  @@index([workspace_id])
  @@index([folder_id])
  @@map("workflow")
}

/// Collection of connected blocks forming a workflow path
model path {
  id            Int                 @id @default(autoincrement())
  name          String
  workflow_id   Int
  blocks        block[]
  workflow      workflow            @relation(fields: [workflow_id], references: [id])
  parent_blocks path_parent_block[]

  @@index([workflow_id])
  @@map("path")
}

/// Junction table that allows paths to be triggered from multiple parent blocks
model path_parent_block {
  path_id    Int
  block_id   Int
  created_at DateTime @default(now())
  block      block    @relation("path_parent", fields: [block_id], references: [id], onDelete: Cascade)
  path       path     @relation(fields: [path_id], references: [id], onDelete: Cascade)

  @@id([path_id, block_id])
  @@index([path_id])
  @@index([block_id])
  @@map("path_parent_block")
}

model block {
  id                  Int                 @id @default(autoincrement())
  created_at          DateTime            @default(now())
  updated_at          DateTime            @default(now()) @updatedAt
  type                block_type
  position            Int
  title               String?
  icon                String?
  description         String?
  image               String?
  original_image      String?
  image_description   String?
  average_time        String?
  task_type           task_type?
  workflow_id         Int
  path_id             Int
  is_endpoint         Boolean?            @default(false)
  delay_seconds       Int?
  delay_event         String?
  delay_type          delay_type?
  path                path                @relation(fields: [path_id], references: [id], onDelete: Cascade)
  workflow            workflow            @relation(fields: [workflow_id], references: [id], onDelete: Cascade)
  child_paths         path_parent_block[] @relation("path_parent")
  source_stroke_lines stroke_line[]       @relation("stroke_source")
  target_stroke_lines stroke_line[]       @relation("stroke_target")

  @@index([workflow_id])
  @@index([path_id])
  @@index([type])
  @@map("block")
}

model stroke_line {
  id              Int      @id @default(autoincrement())
  source_block_id Int
  target_block_id Int
  workflow_id     Int
  label           String
  created_at      DateTime @default(now())
  updated_at      DateTime @default(now()) @updatedAt
  control_points  Json?    // Array of {x: number, y: number}
  source_block    block    @relation("stroke_source", fields: [source_block_id], references: [id], onDelete: Cascade)
  target_block    block    @relation("stroke_target", fields: [target_block_id], references: [id], onDelete: Cascade)
  workflow        workflow @relation(fields: [workflow_id], references: [id], onDelete: Cascade)

  @@index([source_block_id])
  @@index([target_block_id])
  @@index([workflow_id])
  @@map("stroke_line")
}

model scheduled_email {
  id            Int                @id @default(autoincrement())
  created_at    DateTime           @default(now())
  updated_at    DateTime           @default(now()) @updatedAt
  user_id       Int
  email_type    String
  scheduled_for DateTime
  status        email_status       @default(PENDING)
  sent          Boolean            @default(false)
  sent_at       DateTime?
  metadata      Json?
  error         String?
  retry_count   Int                @default(0)
  user          user               @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, email_type], name: "unique_pending_email_per_user_type", map: "unique_pending_email_per_user_type_where")
  @@index([user_id])
  @@index([scheduled_for])
  @@index([status])
  @@index([sent])
  @@map("scheduled_emails")
}

model workspace_invitation {
  id             Int        @id @default(autoincrement())
  workspace_id   Int
  email          String
  inviter_id     Int
  status         invitation_status @default(PENDING)
  invited_at     DateTime   @default(now())
  accepted_at    DateTime?
  expired_at     DateTime?
  workspace      workspace  @relation(fields: [workspace_id], references: [id], onDelete: Cascade)
  inviter        user       @relation("UserInvitations", fields: [inviter_id], references: [id], onDelete: Cascade)

  @@index([workspace_id])
  @@index([email])
  @@index([status])
}

enum onboarding_step {
  PERSONAL_INFO
  PROFESSIONAL_INFO
  WORKSPACE_SETUP
  COMPLETED
  INVITED_USER
}

enum user_role {
  ADMIN
  EDITOR
  READER
}

enum block_type {
  DELAY
  STEP
  PATH
  BEGIN
  END
  LAST
  MERGE
}

enum subscription_status {
  ACTIVE
  TRIALING
  CANCELED
}

enum plan_type {
  FREE
  EARLY_ADOPTER
}

enum task_type {
  MANUAL
  AUTOMATIC
}

enum delay_type {
  FIXED_DURATION
  WAIT_FOR_EVENT
}

enum workflow_status {
  DRAFT
  ACTIVE
  IN_REVIEW
  NEEDS_UPDATE
  ARCHIVED
}

enum email_status {
  PENDING
  CANCELLED
  PAUSED
  SENT
  FAILED
}

enum invitation_status {
  PENDING
  ACCEPTED
  EXPIRED
  REVOKED
}
</file>

<file path="app/api/utils/generateWorkspaceURL.ts">
import { generateUserUrl } from "./generateUserUrl";

/**
 * Generates a public URL for a file in the Supabase storage bucket
 * @param path - The path of the file in the storage bucket
 * @returns The complete public URL for the file
 * @throws Error if required environment variables are missing
 */
export function generateWorkspaceURL(path: string): string {
    // Get the environment variables
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const storagePath = process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_STORAGE_PATH;
    const userStoragePath = process.env.NEXT_PUBLIC_SUPABASE_USER_STORAGE_PATH;
    
    if (!supabaseUrl) {
      throw new Error('NEXT_PUBLIC_SUPABASE_URL is not defined in the environment variables');
    }
  
    if (!storagePath) {
      throw new Error('NEXT_PUBLIC_SUPABASE_WORKSPACE_STORAGE_PATH is not defined in the environment variables');
    }
  
    if (!path) {
      throw new Error('Path is required to generate public URL');
    }
  
    // Remove leading slash from path if present to avoid double slashes
    const cleanPath = path.startsWith('/') ? path.slice(1) : path;
  
    // Build and return the public URL
    return `${supabaseUrl}${storagePath}/${cleanPath}`;
  }
</file>

<file path="app/api/workspace/[id]/paths/route.ts">
// app/api/workspace/[id]/paths/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { PrismaClient, Prisma } from '@prisma/client';
import { BlockEndType } from '@/types/block';
import { createSignedUrls } from '@/utils/createSignedUrls';
import { isVercel } from '@/app/api/utils/isVercel';

/**
 * @swagger
 * /api/workspace/{id}/paths:
 *   get:
 *     summary: Retrieve all paths for a workspace based on workflow_id
 *     description: Fetches paths associated with a given `workflow_id` for the specified workspace, creating a default path and block if none exist.
 *     tags:
 *       - Workspace
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the workspace
 *       - in: query
 *         name: workflow_id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the workflow to filter the paths
 *     responses:
 *       200:
 *         description: Successfully retrieved paths
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 paths:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         example: 1
 *                       name:
 *                         type: string
 *                         example: "First Path"
 *                       blocks:
 *                         type: array
 *                         items:
 *                           type: object
 *                           properties:
 *                             id:
 *                               type: integer
 *                               example: 10
 *                             position:
 *                               type: integer
 *                               example: 0
 *                             path_block:
 *                               type: object
 *                               nullable: true
 *                               properties:
 *                                 id:
 *                                   type: integer
 *                                   example: 5
 *                             step_block:
 *                               type: object
 *                               nullable: true
 *                               properties:
 *                                 id:
 *                                   type: integer
 *                                   example: 15
 *       400:
 *         description: Missing workflow_id or invalid workspaceId
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "workflow_id and valid workspaceId are required"
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Failed to fetch or create paths"
 */
export async function GET(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  const params = await props.params;
  const url = new URL(req.url);
  const workflow_id = url.searchParams.get('workflow_id');
  const workspaceId = parseInt(params.id);

  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  if (!workflow_id || isNaN(workspaceId)) {
    return NextResponse.json(
      { error: 'workflow_id and valid workspaceId are required' },
      { status: 400 }
    );
  }

  try {
    const result = await prisma_client.$transaction(async (prisma: Prisma.TransactionClient) => {
      const parsedworkflow_id = parseInt(workflow_id, 10);

      // Fetch paths for the given workflow_id
      let existingPaths = await prisma.path.findMany({
        where: {
          workflow_id: parsedworkflow_id,
        },
        include: {
          blocks: {
            orderBy: {
              position: 'asc',
            },
            include: {
              child_paths: {
                include: {
                  path: true
                }
              }
            }
          },
          parent_blocks: true,
        }
      });

      // Function to fix block positions in a path
      const fixPathBlockPositions = async (path: any) => {
        const blocks = [...path.blocks];
        let needsUpdate = false;

        // Find BEGIN and end-type blocks
        const beginBlock = blocks.find(b => b.type === 'BEGIN');
        const endTypeBlock = blocks.find(b => Object.values(BlockEndType).includes(b.type as BlockEndType));

        // Create BEGIN block if it doesn't exist
        if (!beginBlock) {
          needsUpdate = true;
          const newBeginBlock = await prisma.block.create({
            data: {
              type: 'BEGIN',
              position: 0,
              icon: '/step-icons/default-icons/begin.svg',
              description: '',
              workflow: { connect: { id: path.workflow_id } },
              path: { connect: { id: path.id } },
            }
          });
          blocks.unshift({ ...newBeginBlock, child_paths: [] });
        } else if (beginBlock.position !== 0) {
          needsUpdate = true;
          // Remove BEGIN block from current position
          const beginIndex = blocks.findIndex(b => b.type === 'BEGIN');
          blocks.splice(beginIndex, 1);
          // Insert BEGIN block at position 0
          blocks.unshift(beginBlock);
        }

        // Check if end-type block exists and has child paths
        if (endTypeBlock) {
          if (endTypeBlock.child_paths?.length > 1) {
            needsUpdate = true;
            await prisma.block.update({
              where: { id: endTypeBlock.id },
              data: { type: BlockEndType.PATH }
            });
            endTypeBlock.type = BlockEndType.PATH;
          } else if (endTypeBlock.child_paths?.length === 1) {
            needsUpdate = true;
            await prisma.block.update({
              where: { id: endTypeBlock.id },
              data: { type: BlockEndType.MERGE }
            });
            endTypeBlock.type = BlockEndType.MERGE;
          } else if (endTypeBlock.child_paths?.length === 0 && 
                    endTypeBlock.type !== BlockEndType.LAST && 
                    endTypeBlock.type !== BlockEndType.END) {
            needsUpdate = true;
            await prisma.block.update({
              where: { id: endTypeBlock.id },
              data: { type: BlockEndType.LAST }
            });
            endTypeBlock.type = BlockEndType.LAST;
          }
        } else {
          // Create default end-type block if none exists
          needsUpdate = true;
          const newEndBlock = await prisma.block.create({
            data: {
              type: BlockEndType.LAST,
              position: blocks.length,
              icon: '/step-icons/default-icons/end.svg',
              description: '',
              workflow: { connect: { id: path.workflow_id } },
              path: { connect: { id: path.id } },
            }
          });
          blocks.push({ ...newEndBlock, child_paths: [] });
        }

        // Create default STEP block if there are no blocks between BEGIN and end-type block
        // if (blocks.length === 2) { // Only BEGIN and end-type blocks exist
        //   needsUpdate = true;
        //   const newStepBlock = await prisma.block.create({
        //     data: {
        //       type: 'STEP',
        //       position: 1,
        //       icon: '/step-icons/default-icons/container.svg',
        //       description: '',
        //       workflow: { connect: { id: path.workflow_id } },
        //       path: { connect: { id: path.id } },
        //     }
        //   });
        //   blocks.splice(1, 0, { ...newStepBlock, child_paths: [] });
        // }

        if (needsUpdate) {
          // Update positions for all blocks
          const updates = blocks.map((block, index) => 
            prisma.block.update({
              where: { id: block.id },
              data: { position: index }
            })
          );

          await Promise.all(updates);

          // Return updated path with correct block positions
          return {
            ...path,
            blocks: blocks.map((block, index) => ({
              ...block,
              position: index
            }))
          };
        }

        return path;
      };

      if (existingPaths.length > 1) {
        // 1. Find all paths with no parent_blocks
        const rootPaths = existingPaths.filter(path => !path.parent_blocks || path.parent_blocks.length === 0);

        // Only delete if there are more than one rootPaths
        if (rootPaths.length > 1) {
          // Find the rootPath with the oldest created_at BEGIN block among all rootPaths
          let oldestPathId: number | null = null;
          let oldestCreatedAt: Date | null = null;
          rootPaths.forEach(path => {
            const beginBlock = path.blocks.find(b => b.type === 'BEGIN');
            if (beginBlock && beginBlock.created_at) {
              const createdAt = new Date(beginBlock.created_at);
              if (!oldestCreatedAt || createdAt < oldestCreatedAt) {
                oldestCreatedAt = createdAt;
                oldestPathId = path.id;
              }
            }
          });


          // Delete all rootPaths except the one with the oldest BEGIN block
          for (const path of rootPaths) {
            if (path.id !== oldestPathId) {
              // Delete blocks first due to foreign key constraints
              await prisma.block.deleteMany({ where: { path_id: path.id } });
              await prisma.path.delete({ where: { id: path.id } });
            }
          }
        }
      }

      // Fetch again to log root paths after deletion
      existingPaths = await prisma.path.findMany({
        where: {
          workflow_id: parsedworkflow_id,
        },
        include: {
          blocks: {
            orderBy: {
              position: 'asc',
            },
            include: {
              child_paths: {
                include: {
                  path: true
                }
              }
            }
          },
          parent_blocks: true,
        }
      });

      // Process existing paths or create new one
      if (existingPaths.length === 0) {
        // Create new path if none exists
        const newPath = await prisma.path.create({
          data: {
            name: 'First Path',
            workflow_id: parsedworkflow_id,
          },
          include: {
            blocks: {
              include: {
                child_paths: {
                  include: {
                    path: true
                  }
                }
              }
            }
          }
        });

        // Create BEGIN block
        await prisma.block.create({
          data: {
            type: 'BEGIN',
            position: 0,
            icon: '/step-icons/default-icons/begin.svg',
            description: '',
            workflow: { connect: { id: parsedworkflow_id } },
            path: { connect: { id: newPath.id } },
          }
        });

        // Create END block
        await prisma.block.create({
          data: {
            type: 'LAST',
            position: 2,
            icon: '/step-icons/default-icons/end.svg',
            description: '',
            workflow: { connect: { id: parsedworkflow_id } },
            path: { connect: { id: newPath.id } },
          }
        });

        return { paths: [newPath] };
      } else {
        // Fix positions in all existing paths
        const updatedPaths = await Promise.all(
          existingPaths.map(path => fixPathBlockPositions(path))
        );

        // Add signed URLs to each path's blocks
        const signedPaths = await Promise.all(
          updatedPaths.map(path => createSignedUrls(path))
        );

        return { paths: signedPaths };
      }
    });

    return NextResponse.json(result);
  } catch (error) {
    console.error('Error fetching or creating paths:', error instanceof Error ? error.message : 'Unknown error');
    
    return NextResponse.json(
      { error: 'Failed to fetch or create paths' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/login/actions.ts">
'use server';

import { revalidatePath } from 'next/cache';
import { createClient } from '@/utils/supabase/server';
import { supabaseAdmin } from '@/utils/supabase/admin';
import prisma from '@/lib/prisma';
import { sendEmail } from '../utils/mail';
import { render } from '@react-email/render';
import { WelcomeEmail } from '@/emails/templates/WelcomeEmail';
import { Prisma, PrismaClient } from '@prisma/client';
import { redirect } from 'next/navigation';
import posthog from 'posthog-js';
import React from 'react';
import { cookies } from 'next/headers';
import { isPreview } from '@/app/utils/isPreview';
import { isVercel } from '../api/utils/isVercel';

const isDevelopmentOrStaging = isPreview();

export async function login(formData: FormData) {
  if (isDevelopmentOrStaging) {
    console.log('[DEBUG] SUPABASE_URL:', process.env.NEXT_PUBLIC_SUPABASE_URL);
    console.log('[DEBUG] SUPABASE_ANON_KEY:', process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ? 'present' : 'missing');
  }
  try {
    const supabase = await createClient();
    if (isDevelopmentOrStaging) {
      console.log('[DEBUG] Supabase client created');
    }

    await supabase.auth.signOut();
    if (isDevelopmentOrStaging) {
      console.log('[DEBUG] Signed out previous session');
    }

    const credentials = {
      email: formData.get('email') as string,
      password: formData.get('password') as string,
    };

    const { data, error } = await supabase.auth.signInWithPassword(credentials);

    if (error) {
      if (isDevelopmentOrStaging) {
        console.error('Login error:', error);
      }
      return { error: error.message };
    }

    const user = data?.user;
    if (!user) {
      return { error: 'No user returned from signInWithPassword' };
    }

    // Check if email is confirmed
    if (!user.email_confirmed_at) {
      return { 
        needsEmailConfirmation: true,
        email: user.email,
        message: 'Please confirm your email before logging in. Check your inbox for the confirmation link.'
      };
    }

    // Set the auth cookie
    const cookieStore = await cookies();
    const session = data.session;
    if (session) {
      cookieStore.set('session', session.access_token, {
        path: '/',
        maxAge: 60 * 60 * 24 * 7, // 1 week
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax'
      });
    }

    return { id: user.id, email: user.email };
  } catch (err) {
    if (isDevelopmentOrStaging) {
      console.error('Unexpected error during login:', err);
    }
    return { error: 'An unexpected error occurred during login' };
  }
}

export async function signup(formData: FormData) {
  const supabase = await createClient();
  const email = formData.get('email') as string;
  const password = formData.get('password') as string;
  const autoConfirm = formData.get('autoConfirm') === 'true';
  // Get the workspace and token from the form data for the redirect
  const workspace = formData.get('workspace') as string;
  const token = formData.get('token') as string;

  // Password strength validation (same as frontend)
  const strongPasswordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_\-+=\[\]{};':"\\|,.<>/?]).{8,}$/;
  if (!strongPasswordRegex.test(password)) {
    // Always return success to prevent enumeration, but do not proceed
    return { success: true, message: "If your signup was successful, check your email." };
  }

  // 1. Check if email already exists in Prisma
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }

  const existingUser = await prisma_client.user.findUnique({
    where: { email },
  });
  if (existingUser) {
    if (isVercel()) await prisma_client.$disconnect();
    // Always return success, do not reveal existence
    return { success: true, message: "If your signup was successful, check your email." };
  }

  // 2. Check if email already exists in Supabase Auth
  try {
    const { data, error } = await supabaseAdmin.auth.admin.listUsers();
    if (!error && data?.users) {
      const userExists = data.users.some(user => user.email === email);
      if (userExists) {
        // Always return success, do not reveal existence
        return { success: true, message: "If your signup was successful, check your email." };
      }
    }
  } catch (e) {
    // Optionally log error, but do not block signup on admin API failure
  }

  let user;
  let authError;

  if (autoConfirm) {
    // 3a. Auto-confirmed signup (admin createUser)
    const { data, error } = await supabaseAdmin.auth.admin.createUser({
      email,
      password,
      email_confirm: true,
    });
    user = data?.user;
    authError = error;

    // Log the user in immediately using the existing login function
    if (user) {
      const loginFormData = new FormData();
      loginFormData.append('email', email);
      loginFormData.append('password', password);
      // Optionally, add any other required fields
      const loginResult = await login(loginFormData);
      if (loginResult?.error) {
        // Optionally handle login error (should not happen)
        console.error('Auto-login after signup failed:', loginResult.error);
      }
    }
  } else {
    // 3b. Regular signup (user signUp)
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        emailRedirectTo: `${process.env.NEXT_PUBLIC_BASE_URL}/auth/confirm`,
        data: {
          onboarding_status: {
            completed_at: undefined // Not completed yet
          }
        }
      }
    });
    user = data?.user;
    authError = error;
  }

  if (authError) {
    // Always return success, do not reveal error details
    return { success: true, message: "If your signup was successful, check your email." };
  }

  if (!user) return { success: true, message: "If your signup was successful, check your email." };

  try {
    await prisma_client.user.create({
      data: {
        auth_id: user.id,
        email: user.email!,
        first_name: '',
        last_name: '',
        full_name: '',
        onboarding_step: 'PERSONAL_INFO'
      }
    });

    await posthog.capture('signup_google', {
      distinctId: String(user.id),
      event: 'signup_google',
      properties: {
        email: user.email,
      }
    });

    if (autoConfirm) {
      // If autoConfirm, redirect to join page with params
      const joinParams = new URLSearchParams();
      if (workspace) joinParams.set('workspace', workspace);
      if (token) joinParams.set('token', token);
      const redirectUrl = `/join${joinParams.toString() ? `?${joinParams.toString()}` : ''}`;
      return {
        success: true,
        message: "Account created successfully.",
        id: user.id,
        email: user.email,
        redirectTo: redirectUrl
      };
    }

    // If not autoConfirm, redirect to check-email page
    return {
      success: true,
      message: "If your signup was successful, check your email.",
      id: user.id,
      email: user.email,
    };
  } catch (error) {
    // Clean up Supabase user if needed
    return { success: true, message: "If your signup was successful, check your email." };
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}

export async function checkEmailExists(email: string) {
  // ... perform your checks as before

  // Always return the same response, regardless of whether the email exists
  return { success: true, message: "If this email can be used, you will receive an email." };
}

export async function debugCheckEmail(email: string) {
  const results = {
    prismaCheck: false as boolean,
    supabaseAdminCheck: null as boolean | null,
    finalResult: false as boolean,
    explanation: ""
  };
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    // 1. Check Prisma
    try {
      const existingUser = await prisma_client.user.findUnique({
        where: { email: email },
      });
      
      results.prismaCheck = !!existingUser;
      
      // If found in Prisma, get more details
      if (existingUser) {
        results.explanation += `User found in Prisma database with ID: ${existingUser.id}. `;
      } else {
        results.explanation += "No user found in Prisma database. ";
      }
    } catch (error) {
      results.explanation += "Prisma check failed. ";
    } finally {
      if (isVercel()) await prisma_client.$disconnect();
    }
    
    // 2. Check Supabase directly using admin API
    try {
      const supabase = await createClient();
      try {
        const { data, error } = await supabase.auth.admin.listUsers();
        
        if (!error && data?.users) {
          const userExists = data.users.some(user => user.email === email);
          results.supabaseAdminCheck = userExists;
          
          if (userExists) {
            const matchingUser = data.users.find(user => user.email === email);
            results.explanation += `User found in Supabase with ID: ${matchingUser?.id}. `;
          } else {
            results.explanation += "No user found in Supabase admin check. ";
          }
        } else {
          results.explanation += `Supabase admin check failed: ${error?.message || "Unknown error"}. `;
          results.supabaseAdminCheck = null; // Couldn't check
        }
      } catch (adminError: any) {
        results.explanation += `Supabase admin check not available: ${adminError?.message || "Unknown error"}. `;
        results.supabaseAdminCheck = null; // Couldn't check
      }
    } catch (error) {
      results.explanation += "Supabase check failed with error. ";
      results.supabaseAdminCheck = null; // Couldn't check
    }
    
    // 3. Determine final result
    if (results.prismaCheck === true && results.supabaseAdminCheck === false) {
      results.finalResult = false;
      results.explanation += "INCONSISTENCY DETECTED: Account exists in Prisma but confirmed not in Supabase. ";
    } 
    else if (results.supabaseAdminCheck === true) {
      results.finalResult = true;
      results.explanation += "Account confirmed to exist in Supabase. ";
    }
    else if (results.prismaCheck === true) {
      results.finalResult = true;
      results.explanation += "Account confirmed to exist in Prisma. Supabase status unknown. ";
    }
    else if (results.prismaCheck === false) {
      results.finalResult = false;
      results.explanation += "Account confirmed not to exist in Prisma. ";
    }
    else {
      results.finalResult = false;
      results.explanation += "Could not determine email existence with confidence. ";
    }
    
    if (isDevelopmentOrStaging) {
      console.log(`[DEBUG] Final result: ${results.finalResult ? "Email exists" : "Email doesn't exist"}`);
    }
    return results;
    
  } catch (error) {
    if (isDevelopmentOrStaging) {
      console.error('[DEBUG] Unexpected error:', error);
    }
    results.explanation += "Debug check failed with unexpected error. ";
    return results;
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/login/page.tsx">
'use client';

import { useState, useEffect, Suspense, useRef } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import Link from 'next/link';
import posthog from 'posthog-js';
import { login } from './actions';
import * as Sentry from '@sentry/nextjs';
import { createBrowserClient } from '@supabase/ssr';
import LoadingSpinner from '../components/LoadingSpinner';
import { toast } from 'sonner';

// Add these constants at the top (after imports)
const LOGIN_ATTEMPT_KEY = 'login_attempts';
const LOGIN_BLOCK_KEY = 'login_block_until';
const MAX_ATTEMPTS = 30;
const WINDOW_MINUTES = 10;
const BLOCK_MINUTES = 10;

function getLoginAttempts(): number[] {
  try {
    const raw = localStorage.getItem(LOGIN_ATTEMPT_KEY);
    if (!raw) return [];
    return JSON.parse(raw) as number[];
  } catch {
    return [];
  }
}

function setLoginAttempts(attempts: number[]) {
  localStorage.setItem(LOGIN_ATTEMPT_KEY, JSON.stringify(attempts));
}

function addLoginAttempt() {
  const now = Date.now();
  const attempts = getLoginAttempts().filter(
    (ts) => now - ts < WINDOW_MINUTES * 60 * 1000
  );
  attempts.push(now);
  setLoginAttempts(attempts);
  return attempts.length;
}

function clearLoginAttempts() {
  localStorage.removeItem(LOGIN_ATTEMPT_KEY);
}

function setBlockUntil(timestamp: number) {
  localStorage.setItem(LOGIN_BLOCK_KEY, timestamp.toString());
}

function getBlockUntil(): number | null {
  const raw = localStorage.getItem(LOGIN_BLOCK_KEY);
  if (!raw) return null;
  return parseInt(raw, 10);
}

function clearBlock() {
  localStorage.removeItem(LOGIN_BLOCK_KEY);
}

function LoginContent() {
  const [showPassword, setShowPassword] = useState(false);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isBlocked, setIsBlocked] = useState(false);
  const [blockTimeLeft, setBlockTimeLeft] = useState<number | null>(null);
  const router = useRouter();
  const searchParams = useSearchParams();
  const notificationShown = useRef(false);

  // Check block status on mount and every second if blocked
  useEffect(() => {
    const checkBlock = () => {
      const blockUntil = getBlockUntil();
      if (blockUntil && Date.now() < blockUntil) {
        setIsBlocked(true);
        setBlockTimeLeft(Math.ceil((blockUntil - Date.now()) / 1000));
      } else {
        setIsBlocked(false);
        setBlockTimeLeft(null);
        clearBlock();
      }
    };
    checkBlock();
    let interval: NodeJS.Timeout | undefined;
    if (isBlocked) {
      interval = setInterval(checkBlock, 1000);
    }
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [isBlocked]);

  // Get URL parameters for signup confirmation
  useEffect(() => {
    const signupEmail = searchParams?.get('email');
    const isSignupSuccess = searchParams?.get('signup') === 'success';

    if (signupEmail && isSignupSuccess && !notificationShown.current) {
      setEmail(signupEmail); // Pre-fill the email field
      toast.success('Confirm your email', {
        description:
          'A confirmation email has been sent. Please check your inbox.',
        duration: 7000,
      });
      notificationShown.current = true;
    }
  }, [searchParams]);

  // Validate email format
  const validateEmail = (email: string) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  };

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();

    // Blocked: prevent login
    if (isBlocked) {
      toast.error('Too many failed attempts', {
        description: 'Please wait before trying again.',
        duration: 5000,
      });
      return;
    }

    const cleanEmail = email;
    const cleanPassword = password;

    if (!validateEmail(cleanEmail)) {
      toast.error('Invalid Email', {
        description: 'Please enter a valid email address',
        duration: 5000,
      });
      return;
    }

    if (cleanEmail && cleanPassword) {
      setIsLoading(true);

      try {
        const formData = new FormData();
        formData.append('email', cleanEmail);
        formData.append('password', cleanPassword);

        const response = await login(formData);

        if (response?.error) {
          // Add failed attempt
          const attempts = addLoginAttempt();
          // Log error to console
          console.error('Login failed:', response.error, { email: cleanEmail });

          // Report to PostHog
          posthog.capture('login_failed', {
            email: cleanEmail,
            error: response.error,
            attempts,
          });

          if (attempts >= MAX_ATTEMPTS) {
            const blockUntil = Date.now() + BLOCK_MINUTES * 60 * 1000;
            setBlockUntil(blockUntil);
            setIsBlocked(true);
            setBlockTimeLeft(BLOCK_MINUTES * 60);
            toast.error('Too many failed attempts', {
              description:
                'You have been blocked for 10 minutes. Please wait before trying again.',
              duration: 7000,
            });
            return;
          }
          toast.error('Login Failed', {
            description: response.error,
            duration: 5000,
          });
          return;
        }

        // On successful login, clear attempts and block
        clearLoginAttempts();
        clearBlock();

        if (response?.needsEmailConfirmation) {
          if (process.env.NODE_ENV !== 'production') {
            console.log('Email needs confirmation:', response.email);
          }
          toast.info('Email Confirmation Required', {
            description: response.message,
            duration: 7000,
          });
          return;
        }

        if (response?.id && response?.email) {
          Sentry.setUser({
            id: response.id,
            email: response.email,
          });

          posthog.identify(response.id);
          posthog.people.set({ email: response.email });
          posthog.capture('login', { email: response.email });

          // Check for redirect params
          const redirect = searchParams?.get('redirect');
          const workspace = searchParams?.get('workspace');
          const token = searchParams?.get('token');
          if (redirect === '/join' && workspace && token) {
            router.push(
              `/join?workspace=${encodeURIComponent(workspace)}&token=${encodeURIComponent(token)}`
            );
          } else {
            router.push('/');
          }
        }
      } catch (err) {
        // Add failed attempt on unexpected error
        const attempts = addLoginAttempt();
        // Log error to console
        console.error('Unexpected error during login:', err, {
          email: cleanEmail,
        });

        // Report to PostHog
        posthog.capture('login_failed_unexpected', {
          email: cleanEmail,
          error: err instanceof Error ? err.message : String(err),
          attempts,
        });

        if (attempts >= MAX_ATTEMPTS) {
          const blockUntil = Date.now() + BLOCK_MINUTES * 60 * 1000;
          setBlockUntil(blockUntil);
          setIsBlocked(true);
          setBlockTimeLeft(BLOCK_MINUTES * 60);
          toast.error('Too many failed attempts', {
            description:
              'You have been blocked for 10 minutes. Please wait before trying again.',
            duration: 7000,
          });
          return;
        }
        toast.error('Login Failed', {
          description: 'An unexpected error occurred. Please try again.',
          duration: 5000,
        });
      } finally {
        setIsLoading(false);
      }
    }
  }

  const handleGoogleAuth = async () => {
    try {
      const supabase = createBrowserClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL as string,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY as string,
        {
          cookies: {
            get(name: string) {
              return document.cookie
                .split('; ')
                .find((row) => row.startsWith(`${name}=`))
                ?.split('=')[1];
            },
            set(name: string, value: string, options: any) {
              let cookie = `${name}=${value}; path=/`;
              if (options.maxAge) {
                cookie += `; max-age=${options.maxAge}`;
              }
              if (options.domain) {
                cookie += `; domain=.process-flow.io`;
              }
              document.cookie = cookie;
            },
            remove(name: string) {
              document.cookie = `${name}=; path=/; expires=Thu, 01 Jan 1970 00:00:01 GMT`;
            },
          },
        }
      );

      // Get workspace and token from URL params
      const workspace = searchParams?.get('workspace');
      const token = searchParams?.get('token');

      // Build the callback URL with additional parameters if they exist
      let callbackUrl = `${window.location.origin}/auth/callback`;
      if (workspace && token) {
        callbackUrl += `?workspace_id=${encodeURIComponent(workspace)}&invite_token=${encodeURIComponent(token)}`;
      }

      const { data, error } = await supabase.auth.signInWithOAuth({
        provider: 'google',
        options: {
          redirectTo: callbackUrl,
          queryParams: {
            access_type: 'offline',
            prompt: 'consent',
          },
        },
      });

      if (error) {
        if (process.env.NEXT_PUBLIC_APP_ENV !== 'production') {
          console.error('Erreur authentification Google:', error.message);
        }
      } else {
        if (process.env.NEXT_PUBLIC_APP_ENV !== 'production') {
          console.log('Redirection OAuth initie:', data);
        }
      }
    } catch (error) {
      if (process.env.NEXT_PUBLIC_APP_ENV !== 'production') {
        console.error('Erreur inattendue:', error);
      }
    }
  };

  return (
    <div className="relative w-full min-h-screen bg-white overflow-hidden flex flex-col items-center justify-center py-6 px-4 sm:px-6">
      <div className="w-full max-w-[420px] p-3 bg-gray-50 rounded-3xl border border-[#e4e7ec] flex flex-col justify-center items-center gap-2">
        <div className="relative w-full h-fit px-4 sm:px-6 py-8 sm:py-10 bg-white rounded-2xl border border-[#e4e7ec] flex flex-col justify-start items-center gap-6 sm:gap-8 overflow-hidden">
          {/* Corner dots */}
          <div className="pointer-events-none absolute inset-0">
            <div
              className="w-1.5 h-1.5 bg-white rounded-full shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)] border border-[#e4e7ec] absolute"
              style={{ top: 16, left: 16 }}
            />
            <div
              className="w-1.5 h-1.5 bg-white rounded-full shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)] border border-[#e4e7ec] absolute"
              style={{ bottom: 16, left: 16 }}
            />
            <div
              className="w-1.5 h-1.5 bg-white rounded-full shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)] border border-[#e4e7ec] absolute"
              style={{ top: 16, right: 16 }}
            />
            <div
              className="w-1.5 h-1.5 bg-white rounded-full shadow-[0px_1px_2px_0px_rgba(0,0,0,0.10)] border border-[#e4e7ec] absolute"
              style={{ bottom: 16, right: 16 }}
            />
          </div>

          {/* App icon */}
          <div className="z-10 flex justify-start items-start">
            <div className="w-10 h-10 relative overflow-hidden bg-white rounded-[10px] flex items-center justify-center">
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/logomark-pf.png`}
                alt="App Icon"
                className="w-full h-full object-cover"
              />
            </div>
          </div>

          {/* Heading section */}
          <div className="z-10 flex flex-col items-center gap-3 w-full">
            <div className="flex flex-col items-start gap-1 w-full">
              <div className="w-full text-center text-[#101828] text-lg font-semibold font-['Inter'] leading-7">
                Log in to Processflow
              </div>
              <div className="w-full text-center text-[#475467] text-sm font-normal font-['Inter'] leading-tight">
                Stay on top of your processes
              </div>
            </div>
          </div>

          {/* Blocked message */}
          {isBlocked ? (
            <div className="w-full text-center text-red-600 text-base font-semibold font-['Inter'] leading-tight mb-4">
              Too many failed attempts, please wait{' '}
              {blockTimeLeft ? Math.ceil(blockTimeLeft / 60) : ''} minute(s).
            </div>
          ) : null}

          {/* Login form */}
          <form
            onSubmit={handleSubmit}
            className="z-10 flex flex-col items-center gap-6 w-full rounded-xl"
          >
            <div className="flex flex-col items-start gap-5 w-full">
              {/* Email field */}
              <div className="flex flex-col items-start gap-1.5 w-full">
                <label className="flex items-start gap-0.5 text-[#344054] text-sm font-medium font-['Inter'] leading-tight">
                  Email
                </label>
                <div
                  className={`px-3.5 py-1.5 bg-white rounded-lg shadow-[0px_1px_2px_0px_rgba(16,24,40,0.05)] border border-[#d0d5dd] flex items-center gap-2 w-full focus-within:border-[#4e6bd7] focus-within:shadow-[0px_0px_0px_4px_rgba(78,107,215,0.2)] transition-colors duration-200`}
                >
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/mail-01.svg`}
                    alt="Mail Icon"
                    className="w-4 h-4"
                  />
                  <input
                    type="email"
                    name="email"
                    placeholder="Email address"
                    className="grow text-[#667085] text-base font-normal font-['Inter'] leading-normal outline-none bg-transparent"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                  />
                </div>
              </div>

              {/* Password field */}
              <div className="flex flex-col items-start gap-1.5 w-full">
                <label className="flex items-start gap-0.5 text-[#344054] text-sm font-medium font-['Inter'] leading-tight">
                  Password
                </label>
                <div className="px-3.5 py-1.5 bg-white rounded-lg shadow-[0px_1px_2px_0px_rgba(16,24,40,0.05)] border border-[#d0d5dd] flex items-center gap-2 w-full focus-within:border-[#4e6bd7] focus-within:shadow-[0px_0px_0px_4px_rgba(78,107,215,0.2)] transition-colors duration-200">
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/lock-01.svg`}
                    alt="Lock Icon"
                    className="w-4 h-4"
                  />
                  <input
                    type={showPassword ? 'text' : 'password'}
                    name="password"
                    placeholder=""
                    className="grow text-[#667085] text-base font-normal font-['Inter'] leading-normal outline-none bg-transparent"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                  />
                  <img
                    src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/${showPassword ? 'eye-off' : 'eye'}.svg`}
                    alt={showPassword ? 'Hide Password' : 'Show Password'}
                    className="w-4 h-4 cursor-pointer"
                    onClick={() => setShowPassword(!showPassword)}
                  />
                </div>
              </div>
            </div>

            {/* Forgot password link */}
            <Link
              href="/reset-password-request"
              className="flex items-center gap-1 w-full text-[#667085] text-sm font-normal font-['Inter'] leading-tight"
            >
              <span>Forgot password?</span>
              <span className="text-[#374c99] font-semibold">Reset</span>
            </Link>

            {/* Login button */}
            <div className="flex flex-col items-start gap-4 w-full">
              <button
                type="submit"
                disabled={isLoading || !email || !password || isBlocked}
                className={`w-full px-3 py-2 rounded-lg border-2 border-white flex items-center justify-center gap-1 overflow-hidden transition-colors duration-300 ${
                  isLoading ? 'bg-[#F9FAFB]' : 'bg-[#4e6bd7] hover:bg-[#374c99]'
                } ${isBlocked ? 'opacity-60 cursor-not-allowed' : ''}`}
              >
                {isLoading ? (
                  <div
                    className="w-5 h-5 animate-spin"
                    style={{
                      borderRadius: '50%',
                      background: 'conic-gradient(#4761C4 0%, #F9FAFB 100%)',
                      maskImage:
                        'radial-gradient(closest-side, transparent 83%, black 84%)',
                    }}
                  />
                ) : (
                  <div className="text-white text-sm font-semibold font-['Inter'] leading-tight">
                    Log in
                  </div>
                )}
              </button>
            </div>
          </form>

          {/* Divider */}
          <div className="z-10 flex items-center gap-4 w-full mt-2">
            <div className="grow h-px border border-[#e4e7ec]" />
            <div className="text-center text-[#475467] text-sm font-normal font-['Inter'] leading-tight">
              or
            </div>
            <div className="grow h-px border border-[#e4e7ec]" />
          </div>

          {/* Google login */}
          <div className="z-10 flex flex-col items-center w-full mb-2">
            <button
              onClick={handleGoogleAuth}
              className="w-full px-4 py-2 bg-white rounded-lg shadow-[0px_1px_2px_0px_rgba(0,0,0,0.07)] border border-[#d0d5dd] flex items-center justify-center gap-3 overflow-hidden transition-colors duration-300 hover:bg-[#F9FAFB]"
            >
              <img
                src={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/logo/google.svg`}
                alt="Google Icon"
                className="w-4 h-4"
              />
              <div className="text-[#344054] text-sm font-semibold font-['Inter'] leading-tight">
                Log in with Google
              </div>
            </button>
          </div>
        </div>

        {/* Sign up link */}
        <div className="py-3 flex justify-center items-baseline gap-1">
          <div className="text-[#667085] text-sm font-normal font-['Inter'] leading-tight">
            Don't have an account?
          </div>
          <Link
            href="/signup"
            className="text-[#374c99] text-sm font-semibold font-['Inter'] leading-tight"
          >
            Sign up
          </Link>
        </div>
      </div>
    </div>
  );
}

export default function LoginPage() {
  return (
    <Suspense fallback={<LoadingSpinner fullScreen size="large" />}>
      <LoginContent />
    </Suspense>
  );
}
</file>

<file path="app/onboarding/components/ProfessionalInfoStep.tsx">
'use client';

import React from 'react';
import ButtonNormal from '@/app/components/ButtonNormal';
import { useOnboarding } from '../context/OnboardingContext';

interface ProfessionalInfoStepProps {
  userHasWorkspace?: boolean;
}

const ProfessionalInfoStep: React.FC<ProfessionalInfoStepProps> = ({
  userHasWorkspace,
}) => {
  const {
    professionalInfo: {
      industry,
      role,
      companySize,
      source,
      setIndustry,
      setRole,
      setCompanySize,
      setSource,
    },
    isLoading,
    error,
    submitProfessionalInfo,
    goToPreviousStep,
  } = useOnboarding();

  // Dropdown options
  const dropdownOptions = {
    industry: ['IT', 'Healthcare', 'Finance', 'Education', 'Retail', 'Other'],
    role: [
      'CEO/Founder',
      'Operations Manager',
      'Process Manager',
      'Quality Assurance Manager',
      'Project Manager',
      'Team Lead/Supervisor',
      'HR Manager',
      'Customer Success Manager',
      'Business Analyst',
      'Product Manager',
      'Consultant',
      'Training & Development',
      'Compliance Manager',
      'Office Manager',
      'Other'
    ],
    companySize: ['1', '2-9', '10-49', '50-199', '200-499', '500+'],
    source: ['LinkedIn', 'Google Search', 'ProductHunt', 'Colleague/Friend', 'Business Blog/Article', 'Software Review Site', 'AI Search', 'Other'],
  };

  return (
    <div
      data-testid="professional-info-step"
      className="w-full max-w-[500px] flex flex-col gap-4 sm:gap-6 mb-8 mx-auto"
    >
      <div className="self-stretch text-center text-xl md:text-2xl font-semibold font-['Inter'] leading-loose text-gray-900 dark:text-white">
        Tell us about yourself
      </div>
      <div className="self-stretch text-center text-sm md:text-base font-normal font-['Inter'] leading-normal text-gray-600 dark:text-gray-300">
        This information will be used to improve your experience.
      </div>
      {error && (
        <div className="self-stretch text-center text-red-600 text-sm font-normal">
          {error}
        </div>
      )}
      <div className="w-full flex flex-col md:flex-row pt-4 md:pt-6 justify-start items-start md:items-center gap-4 md:gap-2">
        <div className="flex flex-col md:flex-row items-start md:items-center gap-2 w-full">
          <div className="whitespace-nowrap text-base font-normal leading-normal text-gray-900 dark:text-white">
            I work in
          </div>
          <div className="w-full relative">
            <select
              data-testid="industry-select"
              name="industry"
              className="w-full px-3.5 py-2.5 pr-10 rounded-lg border text-base cursor-pointer shadow-sm transition-all appearance-none bg-white dark:bg-gray-900 border-gray-300 dark:border-gray-700 text-gray-900 dark:text-white"
              value={industry}
              onChange={(e) => setIndustry(e.target.value)}
            >
              <option value="">Select industry</option>
              {dropdownOptions.industry.map((option) => (
                <option key={option} value={option}>
                  {option}
                </option>
              ))}
            </select>
            <div className="absolute inset-y-0 right-2 flex items-center pointer-events-none z-10">
              <svg
                className="w-5 h-5 text-gray-600 dark:text-gray-300"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
                strokeWidth="2"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M19 9l-7 7-7-7"
                />
              </svg>
            </div>
          </div>
        </div>
        <div className="flex flex-col md:flex-row items-start md:items-center gap-2 w-full">
          <div className="whitespace-nowrap text-base font-normal leading-normal text-gray-900 dark:text-white">
            as a
          </div>
          <div className="w-full relative">
            <select
              data-testid="role-select"
              name="role"
              className="w-full px-3.5 py-2.5 pr-10 rounded-lg border text-base cursor-pointer shadow-sm transition-all appearance-none bg-white dark:bg-gray-900 border-gray-300 dark:border-gray-700 text-gray-900 dark:text-white"
              value={role}
              onChange={(e) => setRole(e.target.value)}
            >
              <option value="">Select role</option>
              {dropdownOptions.role.map((option) => (
                <option key={option} value={option}>
                  {option}
                </option>
              ))}
            </select>
            <div className="absolute inset-y-0 right-2 flex items-center pointer-events-none z-10">
              <svg
                className="w-5 h-5 text-gray-600 dark:text-gray-300"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
                strokeWidth="2"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M19 9l-7 7-7-7"
                />
              </svg>
            </div>
          </div>
        </div>
      </div>
      <div className="flex flex-col md:flex-row justify-start items-start md:items-center gap-2 w-full">
        <div className="whitespace-nowrap text-base font-normal leading-normal text-gray-900 dark:text-white">
          for a company of
        </div>
        <div className="w-full relative">
          <select
            data-testid="company-size-select"
            name="companySize"
            className="w-full px-3.5 py-2.5 pr-10 rounded-lg border text-base cursor-pointer shadow-sm transition-all appearance-none bg-white dark:bg-gray-900 border-gray-300 dark:border-gray-700 text-gray-900 dark:text-white"
            value={companySize}
            onChange={(e) => setCompanySize(e.target.value)}
          >
            <option value="">Select company size</option>
            {dropdownOptions.companySize.map((option) => (
              <option key={option} value={option}>
                {option}
              </option>
            ))}
          </select>
          <div className="absolute inset-y-0 right-2 flex items-center pointer-events-none z-10">
            <svg
              className="w-5 h-5 text-gray-600 dark:text-gray-300"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              strokeWidth="2"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M19 9l-7 7-7-7"
              />
            </svg>
          </div>
        </div>
      </div>
      <div className="flex flex-col md:flex-row justify-start items-start md:items-center gap-2 w-full">
        <div className="whitespace-nowrap text-base font-normal leading-normal text-gray-900 dark:text-white">
          I learned about ProcessFlow from
        </div>
        <div className="w-full relative">
          <select
            data-testid="source-select"
            name="source"
            className="w-full px-3.5 py-2.5 pr-10 rounded-lg border text-base cursor-pointer shadow-sm transition-all appearance-none bg-white dark:bg-gray-900 border-gray-300 dark:border-gray-700 text-gray-900 dark:text-white"
            value={source}
            onChange={(e) => setSource(e.target.value)}
          >
            <option value="">Select source</option>
            {dropdownOptions.source.map((option) => (
              <option key={option} value={option}>
                {option}
              </option>
            ))}
          </select>
          <div className="absolute inset-y-0 right-2 flex items-center pointer-events-none z-10">
            <svg
              className="w-5 h-5 text-gray-600 dark:text-gray-300"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              strokeWidth="2"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M19 9l-7 7-7-7"
              />
            </svg>
          </div>
        </div>
      </div>
      <div className="flex flex-row justify-between items-center w-full mt-4 sm:mt-6 gap-4">
        <ButtonNormal
          variant="secondary"
          size="small"
          onClick={goToPreviousStep}
          className="w-1/3"
        >
          Back
        </ButtonNormal>
        <ButtonNormal
          variant="primary"
          size="small"
          onClick={() => submitProfessionalInfo(userHasWorkspace)}
          disabled={isLoading}
          className="w-2/3"
        >
          {isLoading ? 'Loading...' : 'Continue'}
        </ButtonNormal>
      </div>
    </div>
  );
};

export default ProfessionalInfoStep;
</file>

<file path="app/api/blocks/[id]/duplicate/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { supabase } from '@/lib/supabaseClient';
import { Prisma } from '@prisma/client';
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { generatePublicUrl } from '@/app/api/utils/generatePublicUrl';

/**
 * @swagger
 * /api/blocks/{id}/duplicate:
 *   post:
 *     summary: Duplicate a block
 *     description: Duplicates a block by its ID, optionally at a new position or under a different path. Handles image duplication if the block has an image.
 *     tags:
 *       - Blocks
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the block to duplicate.
 *     requestBody:
 *       required: false
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               position:
 *                 type: integer
 *                 description: The position to insert the duplicated block.
 *               path_id:
 *                 type: integer
 *                 description: The path ID to assign the duplicated block to.
 *     responses:
 *       200:
 *         description: Block duplicated successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 block:
 *                   $ref: '#/components/schemas/Block'
 *                 paths:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Path'
 *       404:
 *         description: Original block not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Original block not found
 *       500:
 *         description: Failed to duplicate block
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Failed to duplicate block
 */

export async function POST(req: NextRequest, props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  const blockId = Number(params.id);

  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }

  try {
    // Get position and path_id from request body if provided
    const body = await req.json().catch(() => ({}));
    
    // Get the original block
    const originalBlock = await prisma_client.block.findUnique({
      where: { id: blockId },
      select: {
        id: true,
        type: true,
        position: true,
        icon: true,
        description: true,
        image: true,
        workflow_id: true,
        path_id: true,
        delay_seconds: true,
        delay_event: true,
        delay_type: true,
        title: true,
      }
    });

    if (!originalBlock) {
      return NextResponse.json(
        { error: 'Original block not found' },
        { status: 404 }
      );
    }

    // Use provided position and path_id or defaults
    const targetPosition = body.position ?? originalBlock.position + 1;
    const targetPathId = body.path_id ?? originalBlock.path_id;

    // Handle image duplication if exists
    let newImagePath = null;
    if (originalBlock.image) {
      const bucketName = process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_BUCKET;
      if (bucketName) {
        // Generate new unique filename
        const timestamp = Date.now();
        const originalFileName = originalBlock.image.split('/').pop();
        const newFileName = `${timestamp}-${originalFileName}`;
        const newPath = originalBlock.image.replace(originalFileName!, newFileName);

        // Copy file in Supabase storage
        const { data: copyData, error: copyError } = await supabase
          .storage
          .from(bucketName)
          .copy(originalBlock.image, newPath);

        if (copyError) {
          console.error('Error copying file:', copyError);
        } else {
          newImagePath = newPath;
        }
      }
    }

    // Handle icon duplication if it matches certain paths

    let newIconPath = originalBlock.icon;
    if (originalBlock.icon && (
      (originalBlock.icon.includes('/uploads') && originalBlock.icon.includes('/icons')) ||
      originalBlock.icon.includes('/step-icons/custom')
    )) {
        const bucketName = process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_BUCKET;
        if (bucketName) {
          const timestamp = Date.now();
          const originalIconFileName = originalBlock.icon.split('/').pop();
          const newIconFileName = `${timestamp}-${originalIconFileName}`;
          const newIconPathCandidate = originalBlock.icon.replace(originalIconFileName!, newIconFileName);
          
          const { data: iconCopyData, error: iconCopyError } = await supabase
          .storage
          .from(bucketName)
          .copy(originalBlock.icon, newIconPathCandidate);
          
          if (iconCopyError) {
            console.error('Error copying icon:', iconCopyError);
        } else {
          newIconPath = newIconPathCandidate;
        }
      }
    }  
    
    // Update positions of blocks after the target position
    await prisma_client.block.updateMany({
      where: {
        path_id: targetPathId,
        position: {
          gte: targetPosition
        }
      },
      data: {
        position: {
          increment: 1
        }
      }
    });

    // Create the duplicate block
    const duplicatedBlock = await prisma_client.block.create({
      data: {
        type: originalBlock.type,
        position: targetPosition,
        icon: newIconPath,
        description: originalBlock.description,
        image: newImagePath,
        workflow: { connect: { id: originalBlock.workflow_id } },
        path: { connect: { id: targetPathId } },
        delay_seconds: originalBlock.type === 'DELAY' ? originalBlock.delay_seconds : null,
        delay_event: originalBlock.type === 'DELAY' ? originalBlock.delay_event : null,
        delay_type: originalBlock.type === 'DELAY' ? originalBlock.delay_type : null,
        title: `${originalBlock.title || ''} (copy)`,
        created_at: new Date(),
        updated_at: new Date(),
      },
    });

    const shouldGenerateIconUrl = duplicatedBlock.icon && !duplicatedBlock.icon.startsWith('https://cdn.brandfetch.io/');

    // Fetch all paths to return updated data
    // const paths = await prisma.path.findMany({
    //   where: {
    //     workflow_id: originalBlock.workflow_id,
    //   },
    //   include: {
    //     blocks: {
    //       orderBy: {
    //         position: 'asc',
    //       },
    //       include: {
    //         child_paths: {
    //           include: {
    //             path: true,
    //           },
    //         },
    //       },
    //     },
    //     parent_blocks: true,
    //   },
    // });

    return NextResponse.json({
      block: {
        ...duplicatedBlock,
        signedIconUrl: shouldGenerateIconUrl && typeof duplicatedBlock.icon === 'string'
          ? await generatePublicUrl(duplicatedBlock.icon)
          : duplicatedBlock.icon
      },
      // paths: paths,
    });

  } catch (error) {
    console.error('Error duplicating block:', error);
    return NextResponse.json(
      { error: 'Failed to duplicate block' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}
</file>

<file path="app/page.tsx">
'use client';

import {
  useEffect,
  useState,
  useRef,
  Suspense,
  useCallback,
  useMemo,
} from 'react';
import UserInfo from './dashboard/components/UserInfo';
import SearchBar from './dashboard/components/SearchBar';
import UserDropdown from './dashboard/components/UserDropdown';
import { AnimatePresence } from 'framer-motion';
import Sidebar from './dashboard/components/Sidebar';
import { Folder, Workspace } from '@/types/workspace';
import { User } from '@/types/user';
import ConfirmChangePasswordModal from './dashboard/components/ConfirmChangePasswordModal';
import dynamic from 'next/dynamic';
import { cache } from 'react';
import { getIcons } from '@/app/utils/icons';
import { useTheme, useColors } from '@/app/theme/hooks';
import Modal from '@/app/components/Modal';
import ButtonNormal from '@/app/components/ButtonNormal';
import SettingsPage from '@/app/dashboard/components/SettingsPage';
import CreateFolderModal from './dashboard/components/CreateFolderModal';
import CreateSubfolderModal from './dashboard/components/CreateSubfolderModal';
import EditFolderModal from './dashboard/components/EditFolderModal';
import Canvas from './dashboard/components/Canvas';
import UploadImageModal from './dashboard/components/UploadImageModal';
import ConfirmDeleteModal from './dashboard/components/ConfirmDeleteModal';
import CreateFlowModal from './dashboard/components/CreateFlowModal';
import { Workflow, WorkflowStatus } from '@/types/workflow';
import { createWorkflow } from './utils/createWorkflow';
import ConfirmDeleteFolderModal from './dashboard/components/ConfirmDeleteFolderModal';
import { deleteWorkflow } from './utils/deleteWorkflow';
import ConfirmDeleteFlowModal from './dashboard/components/ConfirmDeleteFlowModal';
import EditFlowModal from './dashboard/components/EditFlowModal';
import { updateWorkflow } from '@/app/utils/updateWorkflow';
import MoveWorkflowModal from './dashboard/components/MoveWorkflowModal';
import InputField from '@/app/components/InputFields';
import IconModifier from './dashboard/components/IconModifier';
import { createClient } from '@/utils/supabase/client';
import TutorialOverlay from './dashboard/components/TutorialOverlay';
import { toast } from 'sonner';
import { useSearchParams, useRouter, usePathname } from 'next/navigation';
import { debounce } from 'lodash';
import LoadingSpinner from '@/app/components/LoadingSpinner';
import { checkFolderName, checkWorkspaceName } from './utils/checkNames';

import HelpCenterModal from './dashboard/components/HelpCenterModal';
import UserSettings from './dashboard/components/UserSettings';

export default function Page() {
  const { currentTheme } = useTheme();
  const colors = useColors();
  const [workspaces, setWorkspaces] = useState<Workspace[]>([]);
  const [user, setUser] = useState<User | null>(null);
  const [searchTerm, setSearchTerm] = useState<string>('');
  const [dropdownVisible, setDropdownVisible] = useState<boolean>(false);
  const [userSettingsVisible, setUserSettingsVisible] =
    useState<boolean>(false);
  const [helpCenterVisible, setHelpCenterVisible] = useState<boolean>(false);
  const [createFolderVisible, setCreateFolderVisible] =
    useState<boolean>(false);
  const [createSubfolderVisible, setCreateSubfolderVisible] =
    useState<boolean>(false);
  const [editFolderVisible, setEditFolderVisible] = useState<boolean>(false);
  const [uploadImageVisible, setUploadImageVisible] = useState<boolean>(false);
  const [deleteAccountVisible, setDeleteAccountVisible] =
    useState<boolean>(false);
  const [deleteFolderVisible, setDeleteFolderVisible] =
    useState<boolean>(false);
  const [createFlowVisible, setCreateFlowVisible] = useState<boolean>(false);
  const [deleteFlowVisible, setDeleteFlowVisible] = useState<boolean>(false);
  const [editFlowVisible, setEditFlowVisible] = useState<boolean>(false);
  const [moveFlowVisible, setMoveFlowVisible] = useState<boolean>(false);
  const [activeWorkspace, setActiveWorkspace] = useState<Workspace | null>(
    null
  );
  // const [fileToUpload, setFileToUpload] = useState<File | null>(null);
  const [passwordChanged, setPasswordChanged] = useState<boolean>(false);
  const [selectedWorkflow, setSelectedWorkflow] = useState<Workflow | null>(
    null
  );
  const [selectedFolder, setSelectedFolder] = useState<Folder | undefined>(
    undefined
  );
  const [sidebarSelectedFolder, setSidebarSelectedFolder] = useState<
    Folder | undefined
  >(undefined);
  const [folderParent, setFolderParent] = useState<Folder | null>(null);
  const [folderParentId, setFolderParentId] = useState<number | null>(null);
  const supabase = createClient();

  // States for password change
  const [newPassword, setNewPassword] = useState<string>('');

  // Ref used as a flag so that the active_workspace update is performed only once
  const activeWorkspaceUpdatedRef = useRef(false);

  // Add this near the top of the component with other state declarations
  const [deleteHandler, setDeleteHandler] = useState<() => Promise<void>>(
    () => async () => {}
  );

  // Add or modify these state declarations
  const [editingFolder, setEditingFolder] = useState<Folder | undefined>();

  // Add this to the Canvas props
  const [currentView, setCurrentView] = useState<'grid' | 'table'>('grid');

  // Add new state near other states
  const [isSettingsView, setIsSettingsView] = useState(false);

  // Add new state near other states
  const [folderName, setFolderName] = useState('');
  const [iconUrl, setIconUrl] = useState<string | undefined>(undefined);
  const [previewIcon, setPreviewIcon] = useState<string | undefined>(undefined);
  const [emote, setEmote] = useState<string | undefined>(undefined);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Add this state near other state declarations
  const [showTutorial, setShowTutorial] = useState(false);

  // Add this state near other state declarations
  const [activeTab, setActiveTab] = useState<string>('Workspace');

  // Add near the top of the component
  const searchParams = useSearchParams();
  const router = useRouter();

  // // Memoize the filtered workspaces based on search term
  // const filteredWorkspaces = useMemo(() => {
  //   if (!activeWorkspace?.workflows) return [];
  //   return activeWorkspace.workflows.filter((workflow) =>
  //     workflow.name.toLowerCase().includes(searchTerm.toLowerCase())
  //   );
  // }, [activeWorkspace?.workflows, searchTerm]);

  // Debounced search handler
  const debouncedSearchHandler = useCallback(
    debounce((value: string) => {
      setSearchTerm(value);
    }, 10),
    []
  );

  // Memoize handlers that are passed to child components
  const handleSearchChange = useCallback(
    (event: React.ChangeEvent<HTMLInputElement>) => {
      debouncedSearchHandler(event.target.value);
    },
    [debouncedSearchHandler]
  );

  const onSelectFolderSidebar = useCallback((folder?: Folder) => {
    setSidebarSelectedFolder(folder);
  }, []);

  const onSelectFolderView = useCallback((folder?: Folder) => {
    setSelectedFolder(folder);
  }, []);

  // Optimize fetchWorkspaces with caching
  const fetchWorkspaces = useCallback(async () => {
    try {
      // const cacheKey = `workspaces-${user?.id}`;
      // const cachedData = sessionStorage.getItem(cacheKey);

      // if (cachedData) {
      //   const { data, timestamp } = JSON.parse(cachedData);
      //   const isCacheValid = Date.now() - timestamp < 5 * 60 * 1000; // 5 minutes cache

      //   if (isCacheValid) {
      //     setWorkspaces(data);
      //     return;
      //   }
      // }

      const response = await fetch(`/api/user_workspace/${user?.id}`);
      const data = await response.json();

      if (!response.ok) {
        console.error('Error fetching workspaces:', data.error);
        return;
      }

      if (Array.isArray(data)) {
        setWorkspaces(data);
        // sessionStorage.setItem(
        //   cacheKey,
        //   JSON.stringify({
        //     data,
        //     timestamp: Date.now(),
        //   })
        // );
      } else {
        console.error('Unexpected data format:', data);
      }
    } catch (error) {
      console.error('Error fetching workspaces:', error);
    }
  }, [user?.id]);

  // Optimize user data fetching
  const fetchUser = useCallback(async () => {
    try {
      const {
        data: { user: authUser },
        error: authError,
      } = await supabase.auth.getUser();

      if (!authUser || authError) {
        window.location.href = '/login';
        return;
      }

      const res = await fetch('/api/user');
      const data = await res.json();
      if (data) {
        setUser(data);
      }
    } catch (error) {
      console.error('Error fetching user:', error);
      window.location.href = '/login';
    }
  }, []);

  // Update useEffect dependencies
  useEffect(() => {
    fetchUser();
  }, [fetchUser]);

  useEffect(() => {
    if (user) {
      fetchWorkspaces();
    }
  }, [user, fetchWorkspaces]);

  // Optimize workspace update handler
  const updateActiveWorkspace = useCallback(
    async (workspace: Workspace) => {
      if (!user) return;

      try {
        setActiveWorkspace(workspace);

        const updateRes = await fetch('/api/user/update', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            id: user.id,
            active_workspace_id: workspace.id,
          }),
        });

        if (!updateRes.ok) {
          throw new Error('Failed to update active workspace');
        }

        const updatedUser = await updateRes.json();
        setUser(updatedUser);

        // Update cache
        // const cacheKey = `workspaces-${user.id}`;
        // const cachedData = sessionStorage.getItem(cacheKey);
        // if (cachedData) {
        //   const { data } = JSON.parse(cachedData);
        //   const updatedWorkspaces = data.map((ws: Workspace) =>
        //     ws.id === workspace.id ? workspace : ws
        //   );
        //   sessionStorage.setItem(
        //     cacheKey,
        //     JSON.stringify({
        //       data: updatedWorkspaces,
        //       timestamp: Date.now(),
        //     })
        //   );
        // }
      } catch (error) {
        console.error('Error updating active workspace:', error);
        toast.error('Failed to update workspace');
      }
    },
    [user]
  );

  const addWorkspace = async (workspaceName: string) => {
    if (!user) return;
    const response = await fetch('/api/user_workspace', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        name: workspaceName,
        user_id: user.id,
      }),
    });
    // Refresh workspaces if needed.
  };

  const handleDuplicateWorkflow = async () => {
    if (!selectedWorkflow || !activeWorkspace) return;

    const baseName = selectedWorkflow.name;
    let duplicateName = baseName;
    let counter = 1;

    // Get all workflow names in the current workspace
    const existingNames = new Set(activeWorkspace.workflows.map((w) => w.name));

    // Ensure the name is unique by appending a counter if needed
    while (existingNames.has(duplicateName)) {
      duplicateName = `${baseName} (${counter})`;
      counter++;
    }

    await handleCreateWorkflow(
      duplicateName,
      selectedWorkflow.description || selectedWorkflow.description || '',
      selectedWorkflow.process_owner || '',
      selectedWorkflow.review_date || '',
      selectedWorkflow.additional_notes || '',
      selectedWorkflow.icon,
      selectedWorkflow.signedIconUrl
    );
  };

  const handleCreateWorkflow = async (
    name: string,
    description: string,
    process_owner: string,
    review_date: string,
    additional_notes: string,
    icon: string | null,
    signedIcon: string | null | undefined
  ) => {
    if (!activeWorkspace) {
      console.error('No active workspace selected');
      return;
    }
    if (!user) {
      console.error('No user found');
      return;
    }
    try {
      const result = await createWorkflow({
        name,
        description,
        process_owner,
        review_date,
        additional_notes,
        workspaceId: activeWorkspace.id,
        folderId: selectedFolder?.id,
        icon,
        authorId: user.id,
      });

      if (result.error) {
        toast.error(result.error.title, {
          description: result.error.description,
        });
        return;
      }

      if (result.workflow) {
        const workflow = result.workflow;
        if (signedIcon) {
          workflow.signedIconUrl = signedIcon;
        }
        // Update the list of workspaces
        setWorkspaces((prevWorkspaces) =>
          prevWorkspaces.map((workspace) =>
            workspace.id === workflow.workspaceId
              ? {
                  ...workspace,
                  workflows: [...workspace.workflows, workflow],
                }
              : workspace
          )
        );

        // Update the active workspace
        setActiveWorkspace((prev) =>
          prev
            ? {
                ...prev,
                workflows: [...prev.workflows, workflow],
              }
            : prev
        );

        toast.success('Workflow Created', {
          description: 'Your new workflow has been created successfully.',
        });

        // Navigate to the edit mode of the newly created workflow
        if (activeWorkspace.slug) {
          // Sanitize the workflow name for URL
          const sanitizedName = name.replace(/\s+/g, '-');
          const editUrl = `/${activeWorkspace.slug}/${sanitizedName}--pf-${workflow.id}/edit`;
          router.push(editUrl);
        }
      }
    } catch (error) {
      console.error('Error creating workflow:', error);
    }
  };

  const handleEditWorkflow = async (
    id: number,
    name: string,
    description: string,
    process_owner: string,
    review_date: string,
    additional_notes: string,
    folder?: Folder | null,
    icon?: string | null,
    signedIcon?: string | null
  ): Promise<{
    workflow: Workflow | null;
    error?: { title: string; description: string };
  }> => {
    try {
      const result = await updateWorkflow(id, {
        name,
        description,
        process_owner,
        review_date,
        additional_notes,
        folder_id: folder?.id,
        icon: icon ?? undefined,
        signedIconUrl: signedIcon ?? undefined,
      });

      if (result.error) {
        return result;
      }

      if (result.workflow) {
        // Update the activeWorkspace state
        if (activeWorkspace) {
          const updatedWorkflows = activeWorkspace.workflows.map((workflow) =>
            workflow.id === result.workflow?.id ? result.workflow : workflow
          );

          setActiveWorkspace({
            ...activeWorkspace,
            workflows: updatedWorkflows,
          });
        }
      }

      return result;
    } catch (error) {
      console.error('Error updating workflow:', error);
      return {
        workflow: null,
        error: {
          title: 'Error Updating Workflow',
          description: 'An unexpected error occurred',
        },
      };
    }
  };

  const handleDeleteWorkflow = async (workflowId: number) => {
    const wasDeleted = await deleteWorkflow(workflowId);

    if (wasDeleted && activeWorkspace) {
      // Update the state to remove the deleted workflow
      setActiveWorkspace({
        ...activeWorkspace,
        workflows: activeWorkspace.workflows.filter(
          (workflow) => workflow.id !== workflowId
        ),
      });
    }
  };

  // Toggle the dropdown
  const toggleDropdown = (e: React.MouseEvent) => {
    e.stopPropagation();
    setDropdownVisible(!dropdownVisible);
  };

  const openUserSettings = () => {
    setUserSettingsVisible(true);
    setDropdownVisible(false);
  };

  const closeUserSettings = () => {
    // setFileToUpload(null);
    setUserSettingsVisible(false);
    setPasswordChanged(false);
  };

  // Simple open handler
  const openHelpCenter = (): void => {
    setHelpCenterVisible(true);
  };

  // Simple close handler
  const closeHelpCenter = () => {
    setHelpCenterVisible(false);
  };

  const openCreateFolder = (parentId?: number) => {
    if (parentId) {
      setFolderParentId(parentId);
    } else {
      setCreateFolderVisible(true);
      // setOnCreateFolderAction(() => fn);
    }
  };

  const openCreateSubFolder = (parentFolder: Folder) => {
    setCreateSubfolderVisible(true);
    // setOnCreateSubfolderAction(() => fn);
    setFolderParent(parentFolder);
  };

  const openEditFolder = (folder: Folder) => {
    setEditingFolder(folder);
    setEditFolderVisible(true);
  };

  const openUploadImage = () => {
    setUploadImageVisible(true);
  };

  const openDeleteAccount = () => {
    setDeleteAccountVisible(true);
  };

  const closeDeleteAccount = () => {
    setDeleteAccountVisible(false);
  };

  const openCreateFlow = () => {
    setCreateFlowVisible(true);
  };

  // Simple close handler
  const closeDeleteFolder = () => {
    setDeleteFolderVisible(false);
    setSelectedFolder(undefined);
  };

  // Simple delete handler
  const handleDeleteFolder = async () => {
    if (!selectedFolder || !activeWorkspace) return;

    try {
      const response = await fetch(
        `/api/workspace/folders/${selectedFolder.id}`,
        {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            parent_id: selectedFolder.parent_id,
            workspace_id: selectedFolder.workspace_id,
          }),
        }
      );

      if (!response.ok) {
        throw new Error('Failed to delete folder');
      }

      setActiveWorkspace((prevWorkspace) =>
        prevWorkspace
          ? {
              ...prevWorkspace,
              folders: prevWorkspace.folders.filter(
                (f) => f.id !== selectedFolder.id
              ),
            }
          : null
      );
      closeDeleteFolder();
    } catch (error) {
      console.error('Error deleting folder:', error);
    }
  };

  // Simple open handler
  const openDeleteFolder = async (folder: Folder): Promise<void> => {
    setSelectedFolder(folder);
    setDeleteFolderVisible(true);
  };

  const openDeleteFlow = () => {
    setDeleteFlowVisible(true);
  };

  const openEditFlow = () => {
    setEditFlowVisible(true);
  };

  const openMoveFlow = () => {
    setMoveFlowVisible(true);
  };

  const closeMoveFlow = () => {
    setMoveFlowVisible(false);
  };

  const closeEditFlow = () => {
    setEditFlowVisible(false);
  };

  const closeDeleteFlow = () => {
    setSelectedWorkflow(null);
    setDeleteFlowVisible(false);
  };

  const closeCreateFlow = () => {
    setCreateFlowVisible(false);
  };

  const closeUploadImage = () => {
    setUploadImageVisible(false);
  };

  const closeCreateSubfolder = () => {
    setFolderParent(null);
    setCreateSubfolderVisible(false);
  };

  const closeEditFolder = () => {
    setFolderParent(null);
    setEditFolderVisible(false);
  };

  const handleSelectWorkflow = (workflow: Workflow | null) => {
    setSelectedWorkflow(workflow);
  };

  // Function to update the user in state
  const updateUser = (updatedUser: User) => {
    setUser(updatedUser);
  };

  const handleLogout = async () => {
    const { error } = await supabase.auth.signOut();
    if (error) {
      console.error('Error logging out:', error.message);
    } else {
      window.location.href = '/login';
    }
  };

  // Add this useEffect to preload the component
  useEffect(() => {
    // Preload the HelpCenterModal component
    import('./dashboard/components/HelpCenterModal');
  }, []);

  useEffect(() => {
    // Preload images
    const imageUrls = [
      `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/x-close-icon.svg`,
      `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/support-icon.svg`,
      `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/certificate.svg`,
      `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/compass-icon.svg`,
      `${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/slack.svg`,
    ];

    imageUrls.forEach((url) => {
      const img = new Image();
      img.src = url;
    });
  }, []);

  const onWorkspaceUpdate = async (
    updates: Partial<Workspace>
  ): Promise<boolean> => {
    if (!activeWorkspace) return false;

    console.log('updates', updates);
    if (updates.name) {
      const nameError = checkWorkspaceName(updates.name || '');
      if (nameError) {
        toast.error(nameError.title + ' ' + nameError.description);
        return false;
      }
    }
    try {
      console.log('try to update activeWorkspace', activeWorkspace);
      const response = await fetch(`/api/workspace/${activeWorkspace.id}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(updates),
      });

      console.log('response', response);
      if (!response.ok) {
        throw new Error('Failed to update workspace');
      }

      const updatedWorkspace = await response.json();

      console.log('updatedWorkspace', updatedWorkspace);
      // Update both activeWorkspace and the workspace in the workspaces array
      setActiveWorkspace((prev) =>
        prev ? { ...prev, ...updatedWorkspace } : updatedWorkspace
      );
      setWorkspaces((prevWorkspaces) =>
        prevWorkspaces.map((w) =>
          w.id === updatedWorkspace.id ? { ...w, ...updatedWorkspace } : w
        )
      );

      // Refresh the page after successful workspace update
      if (updates.name) {
        window.location.reload();
      }

      return true;
    } catch (error) {
      console.error('Error updating workspace:', error);
      return false;
    }
  };

  const onWorkspaceDelete = async (workspaceId: number) => {
    try {
      const response = await fetch(`/api/workspace/${workspaceId}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error('Failed to delete workspace');
      }

      // Remove the deleted workspace from the workspaces array
      setWorkspaces((prevWorkspaces) =>
        prevWorkspaces.filter((w) => w.id !== workspaceId)
      );

      // If the deleted workspace was the active one, set a new active workspace
      if (activeWorkspace && activeWorkspace.id === workspaceId) {
        // Find another workspace to set as active, or null if none exist
        const nextWorkspace =
          workspaces.find((w) => w.id !== workspaceId) || null;

        if (nextWorkspace) {
          // Update the user's active workspace in the database
          await updateActiveWorkspace(nextWorkspace);
        } else {
          // If no workspaces left, set active workspace to null
          setActiveWorkspace(null);

          // Update the user in the database
          if (user) {
            await fetch('/api/user/update', {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                id: user.id,
                active_workspace_id: null,
              }),
            });
          }
        }
      }

      // Close the settings view
      setIsSettingsView(false);

      // Redirect to the onboarding page with workspace_setup step if no workspaces left
      if (workspaces.length <= 1) {
        // If this was the last workspace, redirect to onboarding with workspace_setup step
        // Include from=workspace_deletion to signal this is a fresh workspace setup
        window.location.href =
          '/onboarding?step=WORKSPACE_SETUP&from=workspace_deletion';
      }
    } catch (error) {
      console.error('Error deleting workspace:', error);
      throw error;
    }
  };

  const handleCreateFolder = async () => {
    if (!folderName.trim()) return;

    setIsSubmitting(true);
    let uploadedIconUrl = iconUrl;
    let uploadedSignedIcon = previewIcon;
    if (previewFile) {
      try {
        const formData = new FormData();
        formData.append('file', previewFile);
        const response = await fetch('/api/upload-icon', {
          method: 'POST',
          body: formData,
        });
        const data = await response.json();
        if (!response.ok || !data.success)
          throw new Error(data.error || 'Upload failed');
        uploadedIconUrl = data.data.iconUrl;
        uploadedSignedIcon = data.data.publicUrl || uploadedIconUrl;
      } catch (error) {
        console.error('Error uploading icon:', error);
        setIsSubmitting(false);
        return;
      }
    }
    try {
      if (uploadedIconUrl)
        await handleAddFolder(
          folderName,
          uploadedIconUrl,
          undefined,
          uploadedSignedIcon
        );
      else if (emote) await handleAddFolder(folderName, undefined, emote);
      else await handleAddFolder(folderName);
      closeCreateFolder();
    } catch (error) {
      console.error('Error creating folder:', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const updateIcon = (icon?: string, emote?: string, signedIcon?: string) => {
    if (icon) {
      setIconUrl(icon);
      setEmote(undefined);
      setPreviewIcon(signedIcon ? signedIcon : icon || undefined);
    } else if (emote) {
      setIconUrl(undefined);
      setEmote(emote);
    } else {
      setIconUrl(undefined);
      setEmote(undefined);
      setPreviewIcon(undefined);
    }
  };

  const closeCreateFolder = () => {
    setCreateFolderVisible(false);
    setFolderName('');
    setIconUrl(undefined);
    setEmote(undefined);
    setPreviewIcon(undefined);
  };

  // Add this near your other useEffect hooks
  useEffect(() => {
    // Only redirect if we have a workspace with a slug and we're on the dashboard page
    if (activeWorkspace?.slug && window.location.pathname === '/') {
      // Get current URL search params
      const currentSearchParams = new URLSearchParams(window.location.search);

      // Create new URL with workspace slug and preserve existing search params
      const newUrl = `/${activeWorkspace.slug}${currentSearchParams.toString() ? '?' + currentSearchParams.toString() : ''}`;

      // Update URL to the workspace slug without refreshing the page
      window.history.replaceState({}, '', newUrl);
    }
  }, [activeWorkspace]);

  // Add this near the beginning of your component
  useEffect(() => {
    if (workspaces.length > 0) {
      // Get slug from URL if available
      const pathSegments = window.location.pathname.split('/').filter(Boolean);
      const slugFromUrl = pathSegments.length > 0 ? pathSegments[0] : null;

      if (slugFromUrl) {
        // Find workspace with matching slug
        const workspaceFromSlug = workspaces.find(
          (w) => w.slug === slugFromUrl
        );

        if (
          workspaceFromSlug &&
          (!activeWorkspace || activeWorkspace.id !== workspaceFromSlug.id)
        ) {
          // Set this workspace as active
          updateActiveWorkspace(workspaceFromSlug);
          return;
        }
      }

      // If no matching workspace found from URL or no slug in URL, and we have an active workspace
      // Redirect to the active workspace slug URL
      if (activeWorkspace?.slug && !slugFromUrl) {
        window.history.replaceState({}, '', `/${activeWorkspace.slug}`);
      }
    }
  }, [workspaces, activeWorkspace]);

  // Add this near your other useEffect hooks
  useEffect(() => {
    // Handle click events on workspace links
    const handleNavigation = (e: MouseEvent) => {
      // Check if the clicked element is a workspace link
      const target = e.target as HTMLElement;
      const link = target.closest('a');

      if (link && link.pathname.split('/').filter(Boolean).length === 1) {
        // This looks like a workspace slug link
        const slug = link.pathname.split('/').filter(Boolean)[0];

        // Find the workspace with this slug
        const workspace = workspaces.find((w) => w.slug === slug);

        if (workspace) {
          // Prevent the default navigation
          e.preventDefault();

          // Update the active workspace directly
          updateActiveWorkspace(workspace);
        }
      }
    };

    // Add event listener
    document.addEventListener('click', handleNavigation);

    // Cleanup
    return () => {
      document.removeEventListener('click', handleNavigation);
    };
  }, [workspaces, updateActiveWorkspace]);

  // Effect to check tutorial status
  useEffect(() => {
    const checkTutorialStatus = async () => {
      if (!user) return;

      try {
        const response = await fetch(`/api/user/tutorial-status/${user.id}`);
        const data = await response.json();

        if (!data.hasCompletedTutorial) {
          // Add a short delay to ensure DOM elements are fully loaded
          setTimeout(() => {
            setShowTutorial(true);
          }, 500);
        }
      } catch (error) {
        console.error('Error checking tutorial status:', error);
      }
    };

    checkTutorialStatus();
  }, [user]);

  // Handler for tutorial completion
  const handleTutorialComplete = async () => {
    if (!user) return;

    try {
      await fetch(`/api/user/tutorial-status/${user.id}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ hasCompletedTutorial: true }),
      });

      setShowTutorial(false);
    } catch (error) {
      console.error('Error updating tutorial status:', error);
    }
  };

  // Check URL parameters for subscription events
  useEffect(() => {
    if (typeof window !== 'undefined') {
      const url = new URL(window.location.href);
      const checkoutStatus = url.searchParams.get('checkout');
      const action = url.searchParams.get('action');
      const error = url.searchParams.get('error');

      // Only show notifications if we have checkout status
      if (checkoutStatus) {
        // Success notifications
        if (checkoutStatus === 'success') {
          if (action === 'upgrade') {
            toast.success('Successfully Upgraded! ', {
              description:
                'Your subscription has been upgraded to the Early Adopter plan. Enjoy all the premium features!',
              duration: 7000,
            });
          } else {
            toast.success('Subscription Activated', {
              description:
                'Your Early Adopter subscription has been successfully activated.',
              duration: 5000,
            });
          }
        }
        // Error notifications
        else if (checkoutStatus === 'failed') {
          const errorMessage =
            error ||
            'There was an issue processing your payment. Please try again or contact support.';
          toast.error('Checkout Failed', {
            description: errorMessage,
            duration: 10000, // Longer duration for error messages
          });
        }
        // Pending notifications
        else if (checkoutStatus === 'pending') {
          toast.info('Processing Your Subscription', {
            description:
              'Your payment was successful. We are setting up your subscription. This may take a few moments.',
            duration: 5000,
          });
        }

        // Clean up URL parameters after showing toast
        url.searchParams.delete('checkout');
        url.searchParams.delete('action');
        url.searchParams.delete('error');
        url.searchParams.delete('message');
        window.history.replaceState({}, '', url.toString());
      }
    }
  }, []); // Empty dependency array means this runs once on mount

  // Add after your state declarations
  useEffect(() => {
    const folderParam = searchParams?.get('folder');
    if (folderParam) {
      const folderId = parseInt(folderParam);
      // Find the folder in the active workspace's folders
      const folder = activeWorkspace?.folders?.find((f) => f.id === folderId);
      if (folder) {
        setSelectedFolder(folder);
      }
    }
  }, [searchParams, activeWorkspace]); // Change dependency to activeWorkspace

  const handleStatusChange = async (
    workflow: Workflow,
    newStatus: WorkflowStatus
  ) => {
    try {
      await updateWorkflow(workflow.id, {
        ...workflow,
        status: newStatus,
      });

      // Update the workflow in the active workspace
      if (activeWorkspace) {
        const updatedWorkflows = activeWorkspace.workflows.map((w) =>
          w.id === workflow.id ? { ...w, status: newStatus } : w
        );
        setActiveWorkspace({
          ...activeWorkspace,
          workflows: updatedWorkflows,
        });
      }
    } catch (error) {
      console.error('Error updating workflow status:', error);
      toast.error('Failed to update workflow status', {
        description:
          'Please try again or contact support if the issue persists.',
      });
    }
  };

  // FOLDER MANAGEMENT
  // Handler to add a top-level folder (parent_id will be null)
  const handleAddFolder = async (
    name: string,
    icon_url?: string,
    emote?: string,
    signedIconUrl?: string
  ) => {
    if (!activeWorkspace) return;

    const nameError = checkFolderName(name);
    if (nameError) {
      toast.error(nameError.title, {
        description: nameError.description,
      });
      return;
    }
    try {
      const res = await fetch('/api/workspace/folders', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name,
          workspace_id: activeWorkspace.id,
          icon_url,
          emote,
          position: activeWorkspace.folders.length,
        }),
      });

      if (!res.ok) {
        throw new Error('Failed to add folder');
      }

      const newFolder: Folder = await res.json();
      if (signedIconUrl) {
        newFolder.signedIconUrl = signedIconUrl;
      }
      setPreviewIcon(undefined);
      setIconUrl(undefined);
      setEmote(undefined);
      setActiveWorkspace((prevWorkspace) =>
        prevWorkspace
          ? {
              ...prevWorkspace,
              folders: [...prevWorkspace.folders, newFolder],
            }
          : null
      );
    } catch (error) {
      console.error('Error adding folder:', error);
    }
  };

  // Handler to add a subfolder with a given parent folder id
  const handleAddSubfolder = async (
    name: string,
    parentId: number,
    icon_url?: string,
    emote?: string,
    signedIconUrl?: string
  ) => {
    if (!activeWorkspace) return;

    try {
      const res = await fetch('/api/workspace/subfolders', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name,
          workspace_id: activeWorkspace.id,
          parent_id: parentId,
          icon_url,
          emote,
          position: activeWorkspace.folders.length,
        }),
      });

      if (!res.ok) {
        throw new Error('Failed to add subfolder');
      }

      const newSubfolder: Folder = await res.json();
      if (signedIconUrl) {
        newSubfolder.signedIconUrl = signedIconUrl;
      }
      setActiveWorkspace((prevWorkspace) =>
        prevWorkspace
          ? {
              ...prevWorkspace,
              folders: [...prevWorkspace.folders, newSubfolder],
            }
          : null
      );

      setSidebarSelectedFolder(undefined);
    } catch (error) {
      console.error('Error adding subfolder:', error);
    }
  };

  //Handler to edit a specific folder
  const handleEditFolder = async (
    folderName: string,
    icon_url?: string | null,
    emote?: string | null,
    signedIconUrl?: string | null
  ) => {
    if (!activeWorkspace || !editingFolder) return;

    const nameError = checkFolderName(folderName);
    if (nameError) {
      toast.error(nameError.title, {
        description: nameError.description,
      });
      return;
    }
    try {
      const response = await fetch(
        `/api/workspace/folders/${editingFolder.id}`,
        {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ name: folderName, icon_url, emote }),
        }
      );

      if (!response.ok) {
        throw new Error('Failed to update folder');
      }

      const updatedFolder: Folder = await response.json();

      if (signedIconUrl) {
        updatedFolder.signedIconUrl = signedIconUrl;
      } else if (!icon_url) {
        updatedFolder.signedIconUrl = undefined;
      }
      setActiveWorkspace((prevWorkspace) =>
        prevWorkspace
          ? {
              ...prevWorkspace,
              folders: prevWorkspace.folders.map((f) =>
                f.id === editingFolder.id ? { ...f, ...updatedFolder } : f
              ),
            }
          : null
      );

      // Update selected states if needed
      if (sidebarSelectedFolder?.id === updatedFolder.id) {
        setSidebarSelectedFolder(updatedFolder);
      }
      if (selectedFolder?.id === updatedFolder.id) {
        setSelectedFolder(updatedFolder);
      }

      setEditingFolder(undefined);
    } catch (error) {
      console.error('Error updating folder:', error);
    }
  };

  const handleUserInfoClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    setDropdownVisible(!dropdownVisible);
  };

  // Loading state
  const [isLoading, setIsLoading] = useState(true);

  // Restore fetchSignedUrl effect
  useEffect(() => {
    const fetchSignedUrl = async () => {
      if (user && user.avatar_url && !user.avatar_signed_url) {
        user.avatar_signed_url = user.avatar_url;
        if (process.env.NODE_ENV !== 'production') {
          console.log('user.avatar_signed_url', user.avatar_signed_url);
        }
      }
    };
    console.log('user', user);
    fetchSignedUrl();
  }, [user]);

  // Restore workspace effect
  useEffect(() => {
    if (user && workspaces.length > 0) {
      if (!user.active_workspace_id) {
        if (!activeWorkspaceUpdatedRef.current) {
          if (!activeWorkspace || activeWorkspace.id !== workspaces[0].id) {
            setActiveWorkspace(workspaces[0]);
          }
          activeWorkspaceUpdatedRef.current = true;
          const updateActiveWorkspace = async () => {
            const updateRes = await fetch('/api/user/update', {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                id: user.id,
                active_workspace_id: workspaces[0].id,
              }),
            });
            if (updateRes.ok) {
              const updatedUser = await updateRes.json();
              if (
                updatedUser.active_workspace_id !== user.active_workspace_id
              ) {
                setUser(updatedUser);
              }
            } else {
              console.error('Error updating user active_workspace_id');
            }
          };
          updateActiveWorkspace();
        }
      } else {
        const foundWorkspace = workspaces.find(
          (ws) => ws.id === user.active_workspace_id
        );
        if (foundWorkspace) {
          if (!activeWorkspace || activeWorkspace.id !== foundWorkspace.id) {
            setActiveWorkspace(foundWorkspace);
          }
        } else {
          if (!activeWorkspaceUpdatedRef.current) {
            if (!activeWorkspace || activeWorkspace.id !== workspaces[0].id) {
              setActiveWorkspace(workspaces[0]);
            }
            activeWorkspaceUpdatedRef.current = true;
            const updateActiveWorkspace = async () => {
              const updateRes = await fetch('/api/user/update', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  id: user.id,
                  active_workspace_id: workspaces[0].id,
                }),
              });
              if (updateRes.ok) {
                const updatedUser = await updateRes.json();
                if (
                  updatedUser.active_workspace_id !== user.active_workspace_id
                ) {
                  setUser(updatedUser);
                }
              } else {
                console.error('Error updating user active_workspace_id');
              }
            };
            updateActiveWorkspace();
          }
        }
      }
      setIsLoading(false);
    }
  }, [user, workspaces]);

  // Restore password update handlers
  const handleUpdatePassword = async () => {
    const { error } = await supabase.auth.updateUser({ password: newPassword });
    if (error) {
      console.error(
        'Erreur lors de la mise  jour du mot de passe:',
        error.message
      );
      alert('Erreur lors de la mise  jour du mot de passe : ' + error.message);
      return;
    }

    setPasswordChanged(true);
    handleCancelPasswordChange();
  };

  const handleCancelPasswordChange = () => {
    setNewPassword('');
  };

  // Add this effect to ensure activeTab is set correctly when settings view opens
  useEffect(() => {
    // When settings view is opened, ensure activeTab is set to a valid value
    if (isSettingsView) {
      // Check if activeTab is a valid tab name
      const validTabs = ['Workspace', 'Plan', 'Billing', 'Appearance'];
      if (!validTabs.includes(activeTab)) {
        setActiveTab('Workspace');
      }
    }
  }, [isSettingsView, activeTab]);

  const [previewFile, setPreviewFile] = useState<File | null>(null);

  const [inviteModalVisible, setInviteModalVisible] = useState(false);
  const [inviteEmail, setInviteEmail] = useState('');
  const [inviteLoading, setInviteLoading] = useState(false);
  const [inviteError, setInviteError] = useState('');

  const handleOpenInviteModal = () => {
    setInviteModalVisible(true);
    setInviteEmail('');
    setInviteError('');
  };
  const handleCloseInviteModal = () => {
    setInviteModalVisible(false);
    setInviteEmail('');
    setInviteError('');
  };

  const validateEmail = (email: string) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  };

  const handleSendInvite = async () => {
    setInviteError('');
    if (!inviteEmail) {
      setInviteError('Please enter an email address.');
      return;
    }
    if (!validateEmail(inviteEmail)) {
      setInviteError('Please enter a valid email address.');
      return;
    }
    setInviteLoading(true);
    try {
      const res = await fetch(`/api/workspace/${activeWorkspace?.id}/invite`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: inviteEmail }),
      });
      if (!res.ok) throw new Error('Failed to send invite');
      toast.success('Invitation Sent', {
        description: 'The invitation has been sent successfully.',
        duration: 3000,
      });
      handleCloseInviteModal();
    } catch (err) {
      setInviteError('Failed to send invitation. Please try again.');
    } finally {
      setInviteLoading(false);
    }
  };

  return (
    <div className="flex h-screen w-screen overflow-hidden">
      <Suspense
        fallback={
          <div
            className="flex-1 flex items-center justify-center"
            style={{ backgroundColor: colors['bg-primary'] }}
          >
            <LoadingSpinner size="large" />
          </div>
        }
      >
        {isLoading ? (
          <div
            className="flex-1 flex items-center justify-center"
            style={{ backgroundColor: colors['bg-primary'] }}
          >
            <LoadingSpinner size="large" />
          </div>
        ) : (
          <>
            {/* Sidebar with header and list of workspaces */}
            {user && user.email && activeWorkspace && (
              <Sidebar
                workspaces={workspaces}
                userEmail={user.email}
                activeWorkspace={activeWorkspace}
                setActiveWorkspace={updateActiveWorkspace}
                onCreateFolder={openCreateFolder}
                onEditFolder={openEditFolder}
                onCreateSubfolder={openCreateSubFolder}
                onDeleteFolder={openDeleteFolder}
                onSelectFolder={onSelectFolderSidebar}
                onSelectFolderView={onSelectFolderView}
                onOpenUserSettings={openUserSettings}
                user={user}
                onOpenHelpCenter={openHelpCenter}
                selectedFolder={selectedFolder}
                onLogout={handleLogout}
                isSettingsView={isSettingsView}
                setIsSettingsView={setIsSettingsView}
                setWorkspaces={setWorkspaces}
                setActiveTab={setActiveTab}
              />
            )}

            <div className="flex-1 flex flex-col overflow-hidden">
              {/* Page header */}
              <header
                style={{
                  backgroundColor: colors['bg-primary'],
                  borderColor: colors['border-secondary'],
                }}
                className="min-h-[73px] flex justify-between items-center px-4 relative border-b"
              >
                <SearchBar
                  searchTerm={searchTerm}
                  onSearchChange={handleSearchChange}
                />
                <div className="flex items-center gap-4">
                  {/* Invite Collaborators Button */}
                  <ButtonNormal
                    variant="secondary"
                    size="small"
                    leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/user-plus-01.svg`}
                    onClick={handleOpenInviteModal}
                    data-testid="invite-collaborators-button"
                  >
                    Invite Collaborators
                  </ButtonNormal>
                  <ButtonNormal
                    variant="primary"
                    size="small"
                    leadingIcon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/white-plus.svg`}
                    onClick={openCreateFlow}
                    data-testid="new-flow-button"
                  >
                    New Flow
                  </ButtonNormal>
                  {/* Divider */}
                  <div
                    style={{ borderColor: colors['border-secondary'] }}
                    className="h-[25px] border-r justify-center items-center"
                  />
                  <div className="relative">
                    <div
                      className="relative cursor-pointer"
                      onClick={handleUserInfoClick}
                    >
                      <UserInfo user={user} isActive={dropdownVisible} />
                      <AnimatePresence>
                        {dropdownVisible && (
                          <div
                            className="fixed inset-0 z-[80]"
                            onClick={() => setDropdownVisible(false)}
                          >
                            <div
                              className="absolute top-[68px] right-3.5"
                              onClick={(e) => e.stopPropagation()}
                            >
                              <UserDropdown
                                user={user}
                                onOpenUserSettings={openUserSettings}
                                onOpenHelpCenter={openHelpCenter}
                                onClose={() => setDropdownVisible(false)}
                              />
                            </div>
                          </div>
                        )}
                      </AnimatePresence>
                    </div>
                  </div>
                </div>
              </header>

              {/* Main content */}
              <main
                style={{ backgroundColor: colors['bg-secondary'] }}
                className="flex-1 w-full h-[100%]"
              >
                {isSettingsView ? (
                  <div className="h-full">
                    <SettingsPage
                      user={user}
                      onClose={() => setIsSettingsView(false)}
                      workspace={activeWorkspace || undefined}
                      onWorkspaceUpdate={onWorkspaceUpdate}
                      onWorkspaceDelete={onWorkspaceDelete}
                      initialTab={activeTab}
                    />
                  </div>
                ) : (
                  activeWorkspace && (
                    <Canvas
                      workspace={activeWorkspace}
                      selectedFolder={selectedFolder}
                      searchTerm={searchTerm}
                      onSelectWorkflow={handleSelectWorkflow}
                      openCreateFlow={openCreateFlow}
                      onDeleteWorkflow={openDeleteFlow}
                      onEditWorkflow={openEditFlow}
                      onDuplicateWorkflow={handleDuplicateWorkflow}
                      onMoveWorkflow={openMoveFlow}
                      currentView={currentView}
                      isLoading={isLoading}
                      onViewChange={setCurrentView}
                      onStatusChange={handleStatusChange}
                    />
                  )
                )}
              </main>
            </div>
          </>
        )}
      </Suspense>

      {/* Modals */}
      {user && userSettingsVisible && (
        <div className="fixed inset-0 z-20 flex items-center justify-center">
          <UserSettings
            user={user}
            updateNewPassword={setNewPassword}
            passwordChanged={passwordChanged}
            openDeleteAccount={openDeleteAccount}
            onClose={closeUserSettings}
            onUserUpdate={updateUser}
            // selectedFile={fileToUpload}
          />
        </div>
      )}

      {/* Password Change Modal: Displayed only if newPassword is not empty */}
      {newPassword !== '' && (
        <ConfirmChangePasswordModal
          onCancel={handleCancelPasswordChange}
          onChangePassword={handleUpdatePassword}
        />
      )}

      {createFolderVisible && (
        <Modal
          onClose={closeCreateFolder}
          title="Create a folder"
          icon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/folder-icon.svg`}
          actions={
            <>
              <ButtonNormal
                variant="secondary"
                size="small"
                onClick={closeCreateFolder}
                className="flex-1"
                disabled={isSubmitting}
              >
                Cancel
              </ButtonNormal>
              <ButtonNormal
                variant="primary"
                size="small"
                onClick={handleCreateFolder}
                disabled={!folderName.trim() || isSubmitting}
                className="flex-1"
              >
                {isSubmitting ? 'Creating...' : 'Create'}
              </ButtonNormal>
            </>
          }
          showActionsSeparator={true}
        >
          <div className="flex flex-col gap-4">
            <div>
              <label
                className="block text-sm font-semibold mb-2"
                style={{ color: colors['text-primary'] }}
              >
                Folder name{' '}
                <span style={{ color: colors['text-accent'] }}>*</span>
              </label>
              <div className="flex items-center gap-2">
                <IconModifier
                  initialIcon={previewIcon || undefined}
                  onUpdate={(icon, emote, signedIcon, file) => {
                    setIconUrl(icon);
                    setEmote(emote);
                    setPreviewIcon(signedIcon ? signedIcon : icon || undefined);
                    setPreviewFile(file || null);
                  }}
                  emote={emote}
                />
                <InputField
                  type="default"
                  value={folderName}
                  onChange={setFolderName}
                  placeholder="Enter folder name"
                />
              </div>
            </div>
          </div>
        </Modal>
      )}

      {createSubfolderVisible && folderParent && (
        <CreateSubfolderModal
          onClose={closeCreateSubfolder}
          onCreate={handleAddSubfolder}
          parentId={folderParent?.id}
          parent={folderParent}
        ></CreateSubfolderModal>
      )}

      {editFolderVisible && editingFolder && (
        <EditFolderModal
          onClose={closeEditFolder}
          onEdit={handleEditFolder}
          folder={editingFolder}
        ></EditFolderModal>
      )}

      {/* Modal for Help Center */}
      {helpCenterVisible && user && (
        <Suspense
          fallback={
            <div className="fixed inset-0 flex items-center justify-center p-8 bg-[#0c111d] bg-opacity-40 z-50">
              <div className="bg-white rounded-xl p-4 shadow-lg">
                <p>Loading...</p>
              </div>
            </div>
          }
        >
          <HelpCenterModal
            onClose={closeHelpCenter}
            user={user}
            setShowTutorial={setShowTutorial}
          />
        </Suspense>
      )}

      {uploadImageVisible && (
        <UploadImageModal
          onClose={closeUploadImage}
          onSave={(file: File) => {
            // setFileToUpload(file);
          }}
        />
      )}

      {deleteAccountVisible && user && (
        <ConfirmDeleteModal user={user} onClose={closeDeleteAccount} />
      )}

      {createFlowVisible && (
        <CreateFlowModal
          onClose={closeCreateFlow}
          onCreateFlow={handleCreateWorkflow}
        />
      )}

      {deleteFolderVisible && (
        <ConfirmDeleteFolderModal
          onClose={closeDeleteFolder}
          onDelete={handleDeleteFolder}
        />
      )}

      {editFlowVisible && selectedWorkflow && (
        <EditFlowModal
          onClose={closeEditFlow}
          onConfirm={handleEditWorkflow}
          selectedWorkflow={selectedWorkflow}
        />
      )}

      {moveFlowVisible && selectedWorkflow && activeWorkspace && (
        <MoveWorkflowModal
          onClose={closeMoveFlow}
          onConfirm={async (folder) =>
            handleEditWorkflow(
              selectedWorkflow.id,
              selectedWorkflow.name,
              selectedWorkflow.description ||
                selectedWorkflow.description ||
                '',
              selectedWorkflow.process_owner || '',
              selectedWorkflow.review_date || '',
              selectedWorkflow.additional_notes || '',
              folder,
              selectedWorkflow.icon
            )
          }
          selectedWorkflow={selectedWorkflow}
          activeWorkspace={activeWorkspace}
        />
      )}

      {deleteFlowVisible && selectedWorkflow && (
        <ConfirmDeleteFlowModal
          onClose={closeDeleteFlow}
          onDelete={handleDeleteWorkflow}
          selectedWorkflow={selectedWorkflow}
        />
      )}

      {/* Add the tutorial overlay */}
      {showTutorial && <TutorialOverlay onComplete={handleTutorialComplete} />}

      {inviteModalVisible && (
        <Modal
          onClose={handleCloseInviteModal}
          title="Invite Collaborators"
          icon={`${process.env.NEXT_PUBLIC_SUPABASE_URL}${process.env.NEXT_PUBLIC_SUPABASE_STORAGE_PATH}/assets/shared_components/user-plus-01.svg`}
          actions={
            <>
              <ButtonNormal
                variant="secondary"
                size="small"
                onClick={handleCloseInviteModal}
                className="flex-1"
                disabled={inviteLoading}
              >
                Cancel
              </ButtonNormal>
              <ButtonNormal
                variant="primary"
                size="small"
                onClick={handleSendInvite}
                className="flex-1"
                isLoading={inviteLoading}
                disabled={!inviteEmail.trim() || inviteLoading}
              >
                Send Invite
              </ButtonNormal>
            </>
          }
          showActionsSeparator={true}
        >
          <div className="flex flex-col gap-4">
            <InputField
              type="default"
              value={inviteEmail}
              onChange={setInviteEmail}
              placeholder="Enter collaborator's email"
              label="Email Address"
              required
              errorMessage={inviteError}
              dataTestId="invite-email-input"
            />
          </div>
        </Modal>
      )}
    </div>
  );
}
</file>

<file path="middleware.ts">
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { createClient } from '@/utils/supabase/server';
import { workspaceProtection } from './app/middlewares/workspaceProtection';
import { isVercel } from './app/api/utils/isVercel';

// Define auth routes that should redirect to dashboard when authenticated
const authRoutes = [
  '/login',
  '/signup',
  '/auth',
  '/reset-password',
  '/reset-password-request',
  '/set-new-password'
];

const shareRoutes = [
  '/shared',
  '/step-icons',
  '/apps',
  '/assets',
  '.png',
  '.svg',
  '/unauthorized',
  '/monitoring',
];

// Add onboarding routes to skip middleware redirects
const onboardingRoutes = [
  '/onboarding'
];

// Add join routes to skip middleware redirects
const joinRoutes = [
  '/join'
];

// Simple in-memory store (not for production)
const rateLimitStore = new Map<string, { count: number; lastRequest: number }>();
const RATE_LIMIT_WINDOW = 60 * 1000; // 1 minute
const RATE_LIMIT_AUTH_SHARE = isVercel() ? 20 : 1000; // 20 if Vercel, 1000 otherwise
const RATE_LIMIT_GENERAL = 1000;      // 1000 requests per window for other routes

function isRateLimited(ip: string, maxRequests: number): boolean {
  const now = Date.now();
  const entry = rateLimitStore.get(ip);

  if (!entry || now - entry.lastRequest > RATE_LIMIT_WINDOW) {
    rateLimitStore.set(ip, { count: 1, lastRequest: now });
    return false;
  }

  if (entry.count >= maxRequests) {
    return true;
  }

  entry.count += 1;
  entry.lastRequest = now;
  rateLimitStore.set(ip, entry);
  return false;
}

/**
 * Format a string for use in URLs by replacing spaces and special characters with hyphens
 */
function formatSlug(value: string): string {
  return value
    .replace(/\s+/g, '-')       // Replace spaces with hyphens
    .replace(/[^a-zA-Z0-9-]/g, '-') // Remove any non-alphanumeric characters
    .replace(/-+/g, '-')        // Replace multiple hyphens with a single one
    .replace(/^-|-$/g, '');     // Remove leading/trailing hyphens
}

export async function middleware(request: NextRequest) {
  // Add this at the top of your middleware function
  const ip = request.headers.get('x-forwarded-for') ?? 'unknown';

  // Check if this is a join route with autoConfirm
  const pathname = request.nextUrl.pathname;
  const searchParams = request.nextUrl.searchParams;
  const isJoinRoute = joinRoutes.some(route => pathname.startsWith(route));
  const isAutoConfirm = searchParams.get('autoConfirm') === 'true';

  // Determine route type for rate limiting
  const isAuthRoute = authRoutes.some(route => pathname.startsWith(route));
  const isShareRoute = shareRoutes.some(route => pathname.includes(route));
  const isSensitiveRoute = isAuthRoute || isShareRoute;

  // Check if this is an onboarding route (to avoid redirect loops)
  const isOnboardingRoute = onboardingRoutes.some(route => pathname === route);

  // Apply rate limiting based on route type
  const maxRequests = isSensitiveRoute ? RATE_LIMIT_AUTH_SHARE : RATE_LIMIT_GENERAL;
  if (isRateLimited(ip, maxRequests)) {
    return new NextResponse('Too many requests', { status: 429 });
  }

  // Handle URLs with encoded spaces in the workspace slug
  // Match pattern like /workspace%20name/flow/edit
  if (pathname.match(/^\/[^/]*%20[^/]*/)) {
    try {
      // Split the path into segments
      const segments = pathname.split('/').filter(Boolean);
      
      if (segments.length >= 1) {
        // Clean the slug (first segment) by replacing encoded spaces with hyphens
        const originalSlug = segments[0];
        const decodedSlug = decodeURIComponent(originalSlug);
        const cleanSlug = formatSlug(decodedSlug);
        
        // Only redirect if the slug actually changed
        if (cleanSlug !== originalSlug) {
          // Reconstruct the URL with the clean slug
          const cleanUrl = new URL(request.url);
          
          // Replace only the first segment
          const restOfPath = pathname.substring(originalSlug.length + 1);
          cleanUrl.pathname = `/${cleanSlug}${restOfPath ? `/${restOfPath}` : ''}`;
          
          return NextResponse.redirect(cleanUrl);
        }
      }
    } catch (error) {
      console.error('Error cleaning URL:', error);
      // Continue with normal middleware if URL cleaning fails
    }
  }

  // Add embed headers if needed
  if (request.nextUrl.pathname.startsWith('/shared/') && request.nextUrl.pathname.endsWith('/embed')) {
    const response = NextResponse.next();
    response.headers.set('X-Frame-Options', 'ALLOWALL');
    response.headers.set('Content-Security-Policy', 'frame-ancestors *');
    return response;
  }

  try {
    const supabase = await createClient();
    const { data: { user }, error } = await supabase.auth.getUser();

    // Skip middleware for static and API routes
    if (
      pathname.startsWith('/_next') ||
      pathname.startsWith('/api') ||
      pathname.startsWith('/static') ||
      pathname === '/' ||
      (isJoinRoute && isAutoConfirm) // Allow direct access to join route when auto-confirming
    ) {
      return NextResponse.next();
    }

    // If user is authenticated
    if (user) {
      // If trying to access onboarding route directly while already completed
      if (isOnboardingRoute) {
        const onboardingStatus = user.user_metadata?.onboarding_status || {};
        const isOnboardingComplete = onboardingStatus.completed_at;
        
        if (isOnboardingComplete) {
          // Redirect completed users to dashboard when they try to access onboarding
          return NextResponse.redirect(new URL('/', request.url));
        }
      }
      
      // If trying to access auth routes while authenticated
      if (isAuthRoute) {
        // Check onboarding status
        const onboardingStatus = user.user_metadata?.onboarding_status || {};
        const isOnboardingComplete = onboardingStatus.completed_at;
        
        if (!isOnboardingComplete) {
          // Only redirect if not already on an onboarding route
          if (!isOnboardingRoute) {
            console.log('Redirecting to onboarding:', request.url);
            return NextResponse.redirect(new URL('/onboarding', request.url));
          }
        }
        
        // Redirect to dashboard if trying to access auth routes while authenticated
        return NextResponse.redirect(new URL('/', request.url));
      }
      
      // Add user info to headers for all other protected routes
      const requestHeaders = new Headers(request.headers);
      requestHeaders.set('x-user-id', user.id);
      if (user.user_metadata?.role) {
        requestHeaders.set('x-user-role', user.user_metadata.role);
      }

      // Check if this is a workspace or workflow route
      if (request.url.includes('/edit') || request.url.includes('/read')) {
        return workspaceProtection(request, user);
      }

      return NextResponse.next({
        request: { headers: requestHeaders }
      });
    }

    // If not authenticated and trying to access protected routes
    if (!isAuthRoute && !isShareRoute && !isJoinRoute) {
      const redirectUrl = new URL('/login', request.url);
      redirectUrl.searchParams.set('redirect', pathname);
      // Copy all original search params
      request.nextUrl.searchParams.forEach((value, key) => {
        redirectUrl.searchParams.set(key, value);
      });
      console.log('Redirecting to login:', redirectUrl);
      return NextResponse.redirect(redirectUrl);
    }

    // Allow access to auth routes for non-authenticated users
    return NextResponse.next();
  } catch (error) {
    console.error('Middleware error:', error);
    // In case of error, allow the request to continue to be handled by the application
    return NextResponse.next();
  }
}

// Configure which paths the middleware will run on
export const config = {
  matcher: [
    '/((?!_next/|api/|static/|favicon.ico).*)',
    '/workspace/:path*'
  ],
};
</file>

<file path="package.json">
{
  "name": "processflow",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "dependencies": {
    "@contentsquare/tag-sdk": "^1.1.0",
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/modifiers": "^9.0.0",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@emotion/css": "^11.13.5",
    "@huggingface/inference": "^4.0.6",
    "@langchain/community": "^0.3.38",
    "@langchain/core": "^0.3.43",
    "@langchain/langgraph": "^0.2.62",
    "@langchain/langgraph-sdk": "^0.0.62",
    "@langchain/openai": "^0.5.2",
    "@motionone/dom": "^10.18.0",
    "@n8n/chat": "^0.27.1",
    "@pinecone-database/pinecone": "^5.1.1",
    "@prisma/client": "^5.16.2",
    "@react-email/components": "^0.0.33",
    "@react-email/render": "^1.0.5",
    "@sentry/nextjs": "^8.54.0",
    "@stripe/stripe-js": "^5.10.0",
    "@supabase/auth-helpers-nextjs": "^0.10.0",
    "@supabase/ssr": "^0.5.2",
    "@supabase/supabase-js": "^2.49.1",
    "@toast-ui/react-image-editor": "^3.15.2",
    "@vercel/speed-insights": "^1.2.0",
    "@xyflow/react": "12.4.3",
    "clsx": "^2.1.1",
    "dompurify": "^3.2.3",
    "elkjs": "^0.9.3",
    "framer-motion": "^12.9.4",
    "js-cookie": "^3.0.5",
    "libphonenumber-js": "^1.12.5",
    "lodash": "^4.17.21",
    "lottie-react": "^2.4.1",
    "lucide-react": "^0.503.0",
    "motion": "^12.5.0",
    "next": "^15.2.0",
    "nodemailer": "^6.10.0",
    "posthog-js": "^1.215.1",
    "posthog-node": "^4.5.0",
    "react": "^18.3.1",
    "react-beautiful-dnd": "^13.1.1",
    "react-dom": "^18.3.1",
    "react-hot-toast": "^2.5.2",
    "react-quill": "^2.0.0",
    "react-zoom-pan-pinch": "^3.6.1",
    "sonner": "^2.0.1",
    "stripe": "^17.7.0",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-dist": "^5.18.3",
    "swagger-ui-express": "^5.0.1",
    "swagger-ui-react": "^5.18.3",
    "swr": "^2.3.3",
    "tailwind-merge": "^3.0.1",
    "tui-color-picker": "^2.2.8",
    "tui-image-editor": "^3.15.3",
    "uuid": "^11.0.2"
  },
  "devDependencies": {
    "@babel/preset-typescript": "^7.26.0",
    "@cucumber/cucumber": "^11.3.0",
    "@playwright/test": "^1.52.0",
    "@sentry/cli": "^2.42.2",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/jest": "^29.5.14",
    "@types/js-cookie": "^3.0.6",
    "@types/lodash": "^4.17.9",
    "@types/mjml": "^4.7.4",
    "@types/node": "^20.17.24",
    "@types/nodemailer": "^6.4.17",
    "@types/react": "^18",
    "@types/react-beautiful-dnd": "^13.1.8",
    "@types/react-dom": "^18.3.5",
    "@types/stripe": "^8.0.417",
    "@types/supertest": "^6.0.3",
    "@types/swagger-jsdoc": "^6.0.4",
    "@types/swagger-ui-express": "^4.1.7",
    "@types/uuid": "^10.0.0",
    "babel-jest": "^29.7.0",
    "cross-env": "^7.0.3",
    "dotenv-cli": "^8.0.0",
    "eslint": "^9.22.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "next-test-api-route-handler": "^4.0.16",
    "postcss": "^8",
    "prisma": "^5.16.2",
    "prisma-dbml-generator": "^0.12.0",
    "react-email": "3.0.7",
    "supabase": "^2.12.1",
    "supertest": "^7.1.1",
    "tailwindcss": "^3.4.1",
    "ts-jest": "^29.3.4",
    "ts-node": "^10.9.2",
    "tsx": "^4.19.2",
    "typescript": "^5.8.2",
    "uglify-js": "^3.19.3"
  }
}
</file>

<file path="app/api/workspace/[id]/route.ts">
// app/api/workspace/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma'; // Adjust the path to your Prisma client
import { PrismaClient } from '@prisma/client';
import { isVercel } from '@/app/api/utils/isVercel';
import { checkWorkspaceName } from '@/app/utils/checkNames';
import { supabase } from '@/lib/supabaseClient';

/**
 * @swagger
 * /api/workspace/{id}:
 *   get:
 *     summary: Retrieve a workspace by its ID
 *     description: Fetches the details of a workspace, including related user information, workflows, blocks, and paths.
 *     tags:
 *       - Workspace
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the workspace
 *     responses:
 *       200:
 *         description: Successfully retrieved the workspace
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 name:
 *                   type: string
 *                   example: "Workspace Name"
 *                 user_workspaces:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       user:
 *                         type: object
 *                         properties:
 *                           id:
 *                             type: integer
 *                             example: 1
 *                           name:
 *                             type: string
 *                             example: "John Doe"
 *                 workflows:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         example: 1
 *                       name:
 *                         type: string
 *                         example: "Workflow Name"
 *                       blocks:
 *                         type: array
 *                         items:
 *                           type: object
 *                           properties:
 *                             id:
 *                               type: integer
 *                               example: 1
 *                             position:
 *                               type: integer
 *                               example: 1
 *                       paths:
 *                         type: array
 *                         items:
 *                           type: object
 *                           properties:
 *                             id:
 *                               type: integer
 *                               example: 1
 *                             name:
 *                               type: string
 *                               example: "Path Name"
 *       400:
 *         description: Workspace ID is required
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Workspace ID is required"
 *       404:
 *         description: Workspace not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Workspace not found"
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal server error"
 *   patch:
 *     summary: Update a workspace
 *     description: Updates a workspace's properties (e.g., name, icon_url, etc.).
 *     tags:
 *       - Workspace
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the workspace to update
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 example: "Updated Workspace"
 *               icon_url:
 *                 type: string
 *                 example: "/path/to/icon.svg"
 *               background_colour:
 *                 type: string
 *                 example: "#4299E1"
 *     responses:
 *       200:
 *         description: Workspace updated successfully
 *       404:
 *         description: Workspace not found
 *       500:
 *         description: Internal server error
 *   delete:
 *     summary: Delete a workspace
 *     description: Deletes a workspace and all associated data (folders, workflows, etc.)
 *     tags:
 *       - Workspace
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the workspace to delete
 *     responses:
 *       200:
 *         description: Workspace deleted successfully
 *       404:
 *         description: Workspace not found
 *       500:
 *         description: Internal server error
 */
export async function GET(req: NextRequest, props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  const { id } = params;
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  if (!id) {
    return NextResponse.json(
      { error: 'Workspace ID is required' },
      { status: 400 }
    );
  }

  try {
    const workspace = await prisma_client.workspace.findUnique({
      where: { id: parseInt(id) },
      include: {
        user_workspaces: {
          include: {
            user: true, // Include the user related to the workspace
          },
        },
        workflows: {
          include: {
            blocks: true,
            paths: true,
          },
        },
      },
    });

    if (!workspace) {
      return NextResponse.json(
        { error: 'Workspace not found' },
        { status: 404 }
      );
    }

    return NextResponse.json(workspace, { status: 200 });
  } catch (error) {
    console.error('Error fetching workspace:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

export async function PATCH(req: NextRequest, props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  const workspaceId = parseInt(params.id);
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const updates = await req.json();

    // Check if workspace exists
    const existingWorkspace = await prisma_client.workspace.findUnique({
      where: { id: workspaceId },
    });

    if (!existingWorkspace) {
      return NextResponse.json({ error: 'Workspace not found' }, { status: 404 });
    }

    if (updates.name) {
      const nameError = checkWorkspaceName(updates.name);
      if (nameError) {
        return NextResponse.json({ 
            error: 'Invalid workspace name',
            ...nameError 
          }, { status: 400 });
      }

      // Only perform file moving logic if name is being updated
      // Fetch all workflows, folders, and blocks for this workspace
      const workflows = await prisma_client.workflow.findMany({
        where: { workspace_id: workspaceId },
      });
      const folders = await prisma_client.folder.findMany({
        where: { workspace_id: workspaceId },
      });
      const blocks = await prisma_client.block.findMany({
        where: { workflow_id: { in: workflows.map(w => w.id) } },
      });

      // Collect all icon URLs from folders and workflows that match the pattern
      const iconUrls = [
        ...folders.map(f => f.icon_url),
        ...workflows.map(w => w.icon)
      ].filter(
        (iconUrl): iconUrl is string =>
          !!iconUrl && (
            (iconUrl.includes('uploads/') && iconUrl.includes('icons/')) ||
            iconUrl.includes('step-icons/custom')
          )
      );

      // Collect all block images (non-null)
      const blockImages = blocks
        .map(b => b.image)
        .filter((img): img is string => !!img);

      // Move assets in storage and update URLs if workspace name changes
      const oldWorkspaceName = existingWorkspace.slug;
      const newWorkspaceName = updates.name.toLowerCase().replace(/\s+/g, '-');
      const bucketName = process.env.NEXT_PUBLIC_SUPABASE_WORKSPACE_BUCKET;
      const urlMappings: { oldUrl: string, newUrl: string }[] = [];

      // Helper to update a url if it starts with uploads/oldWorkspaceName
      function updateUrl(url: string | null): string | null {
        if (!url) return url;
        const oldPrefix = `uploads/${oldWorkspaceName}/`;
        if (url.startsWith(oldPrefix)) {
          const newUrl = `uploads/${newWorkspaceName}/` + url.slice(oldPrefix.length);
          urlMappings.push({ oldUrl: url, newUrl });
          return newUrl;
        }
        return url;
      }

      // Update folders' icon_url
      for (const folder of folders) {
        const newIconUrl = updateUrl(folder.icon_url);
        if (newIconUrl && newIconUrl !== folder.icon_url) {
          await prisma_client.folder.update({
            where: { id: folder.id },
            data: { icon_url: newIconUrl },
          });
        }
      }
      // Update workflows' icon
      for (const workflow of workflows) {
        const newIcon = updateUrl(workflow.icon);
        if (newIcon && newIcon !== workflow.icon) {
          await prisma_client.workflow.update({
            where: { id: workflow.id },
            data: { icon: newIcon },
          });
        }
      }
      // Update blocks' image
      for (const block of blocks) {
        const newImage = updateUrl(block.image);
        if (newImage && newImage !== block.image) {
          await prisma_client.block.update({
            where: { id: block.id },
            data: { image: newImage },
          });
        }
      }
      // Update blocks' icon
      for (const block of blocks) {
        const newIcon = updateUrl(block.icon);
        if (newIcon && newIcon !== block.icon) {
          await prisma_client.block.update({
            where: { id: block.id },
            data: { icon: newIcon },
          });
        }
      }

      // Move files in storage
      if (bucketName) {
        for (const { oldUrl, newUrl } of urlMappings) {
          // Copy file to new location
          const { error: copyError } = await supabase.storage.from(bucketName).copy(oldUrl, newUrl);
          if (copyError) {
            console.error(`Error copying ${oldUrl} to ${newUrl}:`, copyError);
          } else {
            // Remove old file
            const { error: removeError } = await supabase.storage.from(bucketName).remove([oldUrl]);
            if (removeError) {
              console.error(`Error removing old file ${oldUrl}:`, removeError);
            }
          }
        }
      }
    }

    // Update workspace and include all related data in the response
    const updatedWorkspace = await prisma_client.workspace.update({
      where: { id: workspaceId },
      data: updates,
      include: {
        user_workspaces: {
          include: {
            user: true,
          },
        },
        workflows: {
          include: {
            blocks: true,
            paths: true,
          },
        },
        subscription: true,
      },
    });

    return NextResponse.json(updatedWorkspace, { status: 200 });
  } catch (error) {
    console.error('Error updating workspace:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) {
      await prisma_client.$disconnect();
    }
  }
}

export async function DELETE(req: NextRequest, props: { params: Promise<{ id: string }> }) {
  const prisma_client = isVercel() ? new PrismaClient() : prisma;
  if (!prisma_client) {
    throw new Error('Prisma client not initialized');
  }
  try {
    const params = await props.params;
    const workspaceId = parseInt(params.id);

    // Check if workspace exists
    const existingWorkspace = await prisma_client.workspace.findUnique({
      where: { id: workspaceId },
    });

    if (!existingWorkspace) {
      return NextResponse.json({ error: 'Workspace not found' }, { status: 404 });
    }

    // First, update any users who have this as their active workspace
    await prisma_client.user.updateMany({
      where: { active_workspace_id: workspaceId },
      data: { active_workspace_id: null },
    });

    // Delete all user_workspace associations
    await prisma_client.user_workspace.deleteMany({
      where: { workspace_id: workspaceId },
    });

    // Delete all workflows in this workspace
    // First, delete all blocks and paths associated with workflows
    const workflowsInWorkspace = await prisma_client.workflow.findMany({
      where: { workspace_id: workspaceId },
      select: { id: true },
    });

    const workflowIds = workflowsInWorkspace.map(w => w.id);

    // Delete blocks
    await prisma_client.block.deleteMany({
      where: { workflow_id: { in: workflowIds } },
    });

    // Delete paths
    await prisma_client.path.deleteMany({
      where: { workflow_id: { in: workflowIds } },
    });

    // Delete workflows
    await prisma_client.workflow.deleteMany({
      where: { workspace_id: workspaceId },
    });

    // Delete all folders in this workspace
    await prisma_client.folder.deleteMany({
      where: { workspace_id: workspaceId },
    });

    // Finally, delete the workspace itself
    await prisma_client.workspace.delete({
      where: { id: workspaceId },
    });

    return NextResponse.json({ success: true }, { status: 200 });
  } catch (error) {
    console.error('Error deleting workspace:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  } finally {
    if (isVercel()) await prisma_client.$disconnect();
  }
}
</file>

<file path="app/middlewares/workspaceProtection.ts">
import { NextResponse } from "next/server";
import { NextRequest } from 'next/server';
import getBaseUrl from '../utils/getBaseUrl';

interface User {
  id: string;
}

const isDevelopment = process.env.NEXT_PUBLIC_VERCEL_ENV === 'preview';

export async function workspaceProtection(request: NextRequest, user: User) {
  if (isDevelopment) {
    console.log('workspace protection middleware');
  }

  // Handle new workflow routes: [slug]/[workflow name]--pf-[workflowId]/edit or /read
  try {
    const urlObj = new URL(request.url);
    const pathParts = urlObj.pathname.split('/').filter(Boolean);

    // Look for a segment that contains '--pf-'
    const workflowSegment = pathParts.find(part => part.includes('--pf-'));
    const isEditOrRead = pathParts.some(part => part === 'edit' || part === 'read');

    if (workflowSegment && isEditOrRead) {
      // Extract workflowId from the segment
      const match = workflowSegment.match(/--pf-(.+)$/);
      const workflowId = match ? match[1] : null;

      if (!workflowId) {
        return NextResponse.next();
      }

      try {
        const headers: HeadersInit = {};
        
        if (process.env.VERCEL_AUTOMATION_BYPASS_SECRET) {
          headers['x-vercel-protection-bypass'] = process.env.VERCEL_AUTOMATION_BYPASS_SECRET;
        }

        // Check if workflow exists and get its workspace
        const workflowRes = await fetch(
          `${getBaseUrl()}/api/workflow/${workflowId}`,
          { headers }
        );

        if (!workflowRes.ok) {
          return NextResponse.rewrite(new URL('/not-found', request.url));
        }

        const workflow = await workflowRes.json();

        // Check if user has access to the workflow's workspace
        const userWorkspaceRes = await fetch(
          `${getBaseUrl()}/api/workspace/${workflow.workspace_id}/access?userId=${user.id}`,
          { headers }
        );

        if (!userWorkspaceRes.ok) {
          return NextResponse.redirect(new URL('/unauthorized', request.url));
        }

        const userWorkspace = await userWorkspaceRes.json();
        if (isDevelopment) {
          console.log('userWorkspace query result:', userWorkspace);
        }
      } catch (error) {
        if (isDevelopment) {
          console.error('Error in workflow protection:', error);
        }
        return NextResponse.redirect(new URL('/error', request.url));
      }
    }
  } catch (parseError) {
    if (isDevelopment) {
      console.error('Error parsing URL in workflow protection:', parseError);
    }
    return NextResponse.redirect(new URL('/error', request.url));
  }

  return NextResponse.next();
}
</file>

<file path="e2e/step-definitions/utils.steps.ts">
// @ts-nocheck
const { createClient } = require('@supabase/supabase-js');
const { PrismaClient } = require('@prisma/client');

const BASE_URL = process.env.TEST_BASE_URL || 'http://localhost:3000';
const prisma = new PrismaClient();

const BYPASS = process.env.VERCEL_AUTOMATION_BYPASS_SECRET;

const headers = {
  'Content-Type': 'application/json',
  ...(BYPASS && { 'x-vercel-protection-bypass': BYPASS }),
};

/** @type {string[]} */
let createdTestUsers = [];

/**
 * @param {string} email
 * @returns {Promise<string|null>}
 */
async function getUserIdByEmail(email) {
  try {
    const res = await fetch(`${BASE_URL}/api/test/get-user-by-email`, {
      method: 'POST',
      headers,
      body: JSON.stringify({ email }),
    });
    if (!res.ok) return null;
    const data = await res.json();
    return data.auth_id;
  } catch (err) {
    console.error(`Error fetching userId for email ${email}:`, err);
    return null;
  }
}

/**
 * @param {string} email
 * @returns {Promise<void>}
 */
async function cleanupTestUser(email) {
  if (!email) return;
  try {
    const res = await fetch(`${BASE_URL}/api/test/cleanup-user`, {
      method: 'POST',
      headers,
      body: JSON.stringify({ email }),
    });
    if (!res.ok) {
      const error = await res.json();
      console.error(`Failed to delete user: ${error.error}`);
    } else {
      console.log(` Deleted user: ${email}`);
    }
    createdTestUsers = createdTestUsers.filter(e => e !== email);
  } catch (err) {
    console.error(`Error cleaning up user ${email}:`, err);
  }
}

/**
 * @param {object} userData
 * @this {any}
 */
async function seedTestUser(userData) {
  if (!createdTestUsers.includes(userData.email)) {
    createdTestUsers.push(userData.email);
  }
  const res = await fetch(`${BASE_URL}/api/test/seed-user`, {
    method: 'POST',
    headers,
    body: JSON.stringify(userData),
  });
  if (!res.ok) {
    const error = await res.json();
    throw new Error(`Failed to seed user: ${error.error}`);
  }
  const { user } = await res.json();
  if (this) this.prismaUser = user;
  return user;
}

/**
 * @param {{name: string}} param0
 * @this {any}
 */
async function seedWorkspace({ name }) {
  if (!this.prismaUser || !this.prismaUser.id) {
    console.error(' Cannot seed workspace: this.prismaUser is not defined. Seed a Prisma user first.');
    return null;
  }
  const res = await fetch(`${BASE_URL}/api/test/seed-workspace`, {
    method: 'POST',
    headers,
    body: JSON.stringify({ name, user_id: this.prismaUser.id }),
  });
  if (!res.ok) {
    const error = await res.json();
    throw new Error(`Failed to seed workspace: ${error.error}`);
  }
  const { workspace } = await res.json();
  if (this) this.workspace = workspace;
  return workspace;
}

/**
 * @param {{name: string, user_id: number}} param0
 * @returns {Promise<void>}
 */
async function cleanupWorkspace({ name, user_id }) {
  if (!name || !user_id) {
    console.warn('Workspace name and user_id are required for workspace cleanup.');
    return;
  }
  try {
    const res = await fetch(`${BASE_URL}/api/test/cleanup-workspace`, {
      method: 'POST',
      headers,
      body: JSON.stringify({ name, user_id }),
    });
    if (!res.ok) {
      const error = await res.json();
      console.error(`Failed to delete workspace: ${error.error}`);
    } else {
      console.log(` Deleted workspace "${name}" for user_id: ${user_id}`);
    }
  } catch (err) {
    console.error(`Error cleaning up workspace "${name}" for user_id ${user_id}:`, err);
  }
}

/**
 * @param {object} params
 * @param {number|string} params.user_id
 * @param {string} params.name
 * @returns {Promise<boolean>} true if workspace exists, false if not
 */
async function checkWorkspace({ user_id, name }) {
  if (!user_id || !name) throw new Error('user_id and name are required');
  console.log('Checking workspace', user_id, name);
  const url = `${BASE_URL}/api/test/get-workspace-by-name?user_id=${encodeURIComponent(user_id)}&name=${encodeURIComponent(name)}`;
  const res = await fetch(url, { headers });
  if (res.status === 200) return true;
  if (res.status === 404) return false;
  const data = await res.json().catch(() => ({}));
  throw new Error(`Unexpected response: ${res.status} ${data.error || ''}`);
}

module.exports = {
  seedTestUser,
  seedWorkspace,
  cleanupWorkspace,
  getUserIdByEmail,
  cleanupTestUser,
  createdTestUsers,
  checkWorkspace,
};
</file>

<file path="e2e/features/authentication/authentication_navigation.feature">
Feature: Navigation Control
  As the application
  I want to control user navigation based on authentication state
  So that users see appropriate content

  Scenario: Authenticated user accessing auth routes
    Given I am logged in
    When I try to access "/login"
    Then I should be redirected to dashboard "/"
    When I try to access "/signup"
    Then I should be redirected to dashboard "/"
    When I try to access "/reset-password"
    Then I should be redirected to dashboard "/"

   Scenario: Unauthenticated user accessing protected routes
     Given I am not authenticated
     When I try to access "/dashboard"
     Then I should be redirected to "/login"
     And the redirect parameter should include original path
     When I try to access "/workspace/123"
     Then I should be redirected to "/login"

   Scenario: Onboarding flow for new users
     Given I am a newly registered user
     And my onboarding is not complete
     When I log in successfully
     Then I should be redirected to "/onboarding"
     Given my onboarding is complete
     When I try to access "/onboarding"
     Then I should be redirected to dashboard "/"

   Scenario: Complete onboarding flow for new user
     Given I am a newly registered user
     And my onboarding is not complete
     When I log in successfully
     Then I should be redirected to "/onboarding"
     And I should see the onboarding progress indicator
     When I complete the personal information step
     Then I should proceed to the professional information step
     When I complete the professional information step
     Then I should proceed to the workspace setup step
     When I complete the workspace setup step
     Then I should proceed to the completion step
     And the system should create my workspace 
     And the system should create default workflows
     When I click "Continue to Dashboard"
     Then I should be redirected to dashboard "/"
     And An email should be sent to the user with the subject "Welcome to ProcessFlow - Here's how to start decently"
     And my onboarding should be marked as complete
     And I should not be able to access "/onboarding" anymore

   Scenario: URL sanitization
     Given I am logged in
     And I access a URL with encoded spaces "/workspace%20name/flow"
     Then I should be redirected to "/workspace-name/flow"
     And the URL should be properly formatted

  # Scenario: Embed route protection
  #   Given I access an embed route "/shared/flow/123/embed"
  #   Then the response should include headers:
  #     | X-Frame-Options         | ALLOWALL          |
  #     | Content-Security-Policy | frame-ancestors * |
</file>

<file path=".github/workflows/test.yml">
name: Run Jest Tests on PR

on:
  pull_request:
    branches: ['main']

permissions:
  contents: read
  pull-requests: write

jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name:  Checkout code
        uses: actions/checkout@v3
        with:
          ref: ${{ github.head_ref || github.ref_name }}
          fetch-depth: 0

      - name:  Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18

      - name:  Install dependencies
        run: npm ci --legacy-peer-deps

      # --- Vercel CLI Deployment Steps ---
      - name:  Install Vercel CLI
        run: npm install --global vercel@latest

      - name:  Pull Vercel environment variables
        run: vercel pull --yes --environment=${{ github.head_ref == 'main' && 'production' || 'preview' }} --token=${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}

      - name:  Build project using Vercel CLI
        run: vercel build --token=${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}

      - name:  Deploy to Vercel with prebuilt output
        id: vercel_deploy
        run: |
          if [ "${{ github.head_ref }}" = "main" ]; then
            vercel_url=$(vercel deploy --prebuilt --prod --token=${{ secrets.VERCEL_TOKEN }} | tail -1)
          else
            vercel_url=$(vercel deploy --prebuilt --token=${{ secrets.VERCEL_TOKEN }} | tail -1)
          fi
          echo "VERCEL_DEPLOYMENT_URL=$vercel_url" >> $GITHUB_ENV
          echo "Deployed to: $vercel_url"
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}

      - name:  Log Preview URL
        run: echo "Preview URL is $VERCEL_DEPLOYMENT_URL"

      - name:  Install Playwright Browsers
        run: npx playwright install --with-deps

      - name:  Run Playwright E2E tests
        run: npx playwright test
        env:
          TEST_BASE_URL: ${{ env.VERCEL_DEPLOYMENT_URL }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name:  Run Cucumber E2E tests
        run: npx cucumber-js "e2e/features/**/*.feature" --require-module ts-node/register --require "e2e/step-definitions/**/*.steps.ts"
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          DIRECT_URL: ${{ secrets.DIRECT_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          TEST_BASE_URL: ${{ env.VERCEL_DEPLOYMENT_URL }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: Upload Playwright screenshots
        uses: actions/upload-artifact@v4
        with:
          name: playwright-screenshots
          path: '*.png'
</file>

<file path="e2e/step-definitions/authentication.steps.ts">
// @ts-nocheck
const { Given, When, Then, After, Before, setWorldConstructor, setDefaultTimeout } = require('@cucumber/cucumber');
const { expect, chromium } = require('@playwright/test');
const { IWorldOptions, World } = require('@cucumber/cucumber');
const {
  seedTestUser,
  seedWorkspace,
  cleanupWorkspace,
  getUserIdByEmail,
  cleanupTestUser,
  checkWorkspace,
} = require('./utils.steps');

setDefaultTimeout(100000);

/**
 * @typedef {Object} CustomWorld
 * @property {any} browser
 * @property {any} page
 */

/** @type {CustomWorld} */

/**
 * @this {any}
 * @param {any} options
 */
function CustomWorld(options) {
  // You can attach properties to `this` here
  this.browser = null;
  this.page = null;
}
setWorldConstructor(CustomWorld);

const BASE_URL = process.env.TEST_BASE_URL || 'http://localhost:3000';
const BYPASS = process.env.VERCEL_AUTOMATION_BYPASS_SECRET;

// Test user credentials
const TEST_USER = {
  email: 'tomaxime0@gmail.com',
  password: 'abcd1234'
};

// Test emails for different scenarios
const TEST_EMAILS = {
  NEW_USER: 'newuser-test@example.com',
  EXISTING_USER: 'existing-test@example.com', 
  UNCONFIRMED_USER: 'unconfirmed-test@example.com',
  GOOGLE_USER: 'googleuser-test@example.com'
};



function getPageOptions() {
  return BYPASS
    ? { extraHTTPHeaders: { 'x-vercel-protection-bypass': BYPASS } }
    : {};
}

/**
 * @param {any} page
 * @param {string} [email]
 * @param {string} [password]
 */
async function login(page, email = TEST_USER.email, password = TEST_USER.password) {
  console.log('Navigating to login page:', `${BASE_URL}/login`);
  await page.goto(`${BASE_URL}/login`);

  // Log the current URL after navigation
  const currentUrl = await page.url();
  console.log('Current page URL after navigation:', currentUrl);

  // Wait for the email input to be visible
  console.log('Waiting for email input to be visible');
  await page.waitForSelector('input[name="email"]', { timeout: 300000 });
  console.log('Filling email:', email);
  await page.fill('input[name="email"]', email);

  // Wait for the password input to be visible
  console.log('Waiting for password input to be visible');
  await page.waitForSelector('input[name="password"]', { timeout: 300000 });
  console.log('Filling password');
  await page.fill('input[name="password"]', password);

  // Wait for the submit button to be visible
  await page.waitForSelector('button[type="submit"]', { timeout: 300000 });
  console.log('Clicking submit button');
  await page.click('button[type="submit"]');

  console.log('Waiting for dashboard redirect:', `${BASE_URL}/`);
  await page.waitForURL(`${BASE_URL}/`, { timeout: 300000 });
  console.log('Login function finished');
}

/**
 * @param {string} path
 * @returns {string}
 */
function normalize_path(path) {
  return path.startsWith('/') ? path : `/${path}`;
}

Before(async function () {
  this.browser = await chromium.launch();
  this.page = await this.browser.newPage(getPageOptions());
});

/** @this {any} */
After(async function (scenario) {
  if (scenario.result?.status === 'failed' && this.page) {
    const fileName = `failed-step-${Date.now()}.png`;
    await this.page.screenshot({ path: fileName, fullPage: true });
    console.log(`Screenshot taken: ${fileName}`);
  }
  // Cleanup workspace if it exists (using a default workspace name if needed)
  if (this.prismaUser && this.prismaUser.id && (this.workspaceName || this.workspace?.name)) {
    const workspaceName = this.workspaceName || this.workspace?.name;
    await cleanupWorkspace({ name: workspaceName, user_id: this.prismaUser.id });
  }
  
  if (this.newUserEmail) {
    await cleanupTestUser(this.newUserEmail);
  }
  
  await this.page?.close();
  await this.browser?.close();
});

// --- Given Steps ---
Given('I am on the signup page', async function () {
  console.log('Navigating to signup page');
  await this.page.goto(`${BASE_URL}/signup`);
  await this.page.waitForSelector('h1, [data-testid="signup-title"], text="Create your account"', { timeout: 10000 });
  console.log('Given: I am on the signup page \x1b[32m`\x1b[0m');
});

Given('I am not authenticated', async function () {
  console.log('Clearing authentication cookies');
  await this.page.context().clearCookies();
  // Ensure the page is on a valid origin before accessing localStorage/sessionStorage
  await this.page.goto(BASE_URL);
  await this.page.evaluate(() => {
    localStorage.clear();
    sessionStorage.clear();
  });
  console.log('Given: I am not authenticated \x1b[32m`\x1b[0m');
});

/** @param {string} email */
Given('a user already exists with email {string}', async function (email) {
  console.log(`Ensuring user ${email} exists in test database`);
  // Use the existing test user or seed new data
  if (email === TEST_USER.email) {
    // tomaxime0@gmail.com already exists, no seeding needed
    console.log('Using existing test user');
  } else {
    // Seed new user data
    await seedTestUser.call(this, {
      email,
      password: 'abcd1234',
      email_confirmed: true,
      onboarding_step: 'COMPLETED'
    });
  }
  console.log(`Given: a user already exists with email ${email} `);
});

Given('I am on the login page', async function () {
  console.log('Navigating to login page');
  await this.page.goto(`${BASE_URL}/login`);
  await this.page.waitForSelector('text="Log in to Processflow"', { timeout: 10000 });
  console.log('Given: I am on the login page \x1b[32m`\x1b[0m');
});

/** @param {string} email */
Given('a new user exists with email {string} and confirmed email', async function (email) {
  // Use predefined test email if placeholder is provided
  const actualEmail = email.includes('example.com') ? TEST_EMAILS.NEW_USER : email;
  console.log(`Creating new user ${actualEmail} with confirmed email`);
  
  await seedTestUser.call(this, {
    email: actualEmail,
    password: 'abcd1234',
    email_confirmed: true,
    onboarding_step: 'PERSONAL_INFO'
  });
  console.log(`Given: a new user exists with email ${email} and confirmed email `);
});

Given('the user has not completed onboarding', async function () {
  console.log('User onboarding status: incomplete');
  // This would be handled by test data seeding
  console.log('Given: the user has not completed onboarding ');
});

/** @param {string} email */
Given('an existing user with email {string} and confirmed email', async function (email) {
  console.log(`Ensuring existing user ${email} exists with confirmed email`);
  
  // Use existing test user or seed data
  if (email === TEST_USER.email) {
    console.log('Using existing test user (no seeding needed)');
  } else {
    const actualEmail = email.includes('example.com') ? TEST_EMAILS.EXISTING_USER : email;
    await seedTestUser.call(this, {
      email: actualEmail,
      password: 'abcd1234',
      email_confirmed: true,
      onboarding_step: 'COMPLETED'
    });
  }
  console.log(`Given: an existing user with email ${email} and confirmed email `);
});

Given('the user has completed onboarding', async function () {
  console.log('User onboarding status: complete');
  // This would be handled by test data seeding
  console.log('Given: the user has completed onboarding ');
});

/** @param {string} email */
Given('a user exists with email {string} and unconfirmed email', async function (email) {
  const actualEmail = email.includes('example.com') ? TEST_EMAILS.UNCONFIRMED_USER : email;
  console.log(`Creating user ${actualEmail} with unconfirmed email`);
  
  await seedTestUser.call(this, {
    email: actualEmail,
    password: 'abcd1234',
    email_confirmed: false,
    onboarding_complete: false
  });
  console.log(`Given: a user exists with email ${email} and unconfirmed email `);
});

Given('an existing user with Google account', async function () {
  console.log('Creating Google OAuth user');
  
  await seedTestUser.call(this, {
    email: TEST_EMAILS.GOOGLE_USER,
    password: null, // Google OAuth users don't have passwords
    email_confirmed: true,
    onboarding_step: 'COMPLETED',
    provider: 'google'
  });
  console.log('Given: an existing user with Google account ');
});

Given('I am accessing authentication routes', async function () {});
/** @this {any} */
Given('I am logged in', { timeout: 20000 }, async function () {
  console.log('Starting login...');
  await login(this.page);
  console.log('Login finished.');
});
Given('I am a newly registered user', async function () {
  // Seed a new user with onboarding not complete and confirmed email
  const email = TEST_EMAILS.NEW_USER;
  const password = 'abcd1234';
  await seedTestUser.call(this, {
    email,
    password,
    email_confirmed: true,
    onboarding_step: 'PERSONAL_INFO'
  });
  // Store for later steps
  this.newUserEmail = email;
  this.userEmail = email;
  this.password = password;
  console.log('Given: I am a newly registered user ');
});
Given('my onboarding is not complete', async function () {
  // Set onboarding status to false for the current test user
  const email = this.newUserEmail || TEST_USER.email;
  const password = 'abcd1234';
  await seedTestUser.call(this, {
    email,
    password,
    email_confirmed: true,
    onboarding_step: 'PERSONAL_INFO'
  });
  this.userEmail = email;
  this.password = password;
  console.log('Given: my onboarding is not complete ');
});
Given('my onboarding is complete', async function () {
  // Set onboarding status to true for the current test user
  const email = this.newUserEmail || TEST_USER.email;
  await seedTestUser.call(this, {
    email,
    password: 'abcd1234',
    email_confirmed: true,
    onboarding_step: 'COMPLETED'
  });
  const uniqueWorkspaceName = `My Test Workspace ${Date.now()}`;
  await seedWorkspace.call(this, { name: uniqueWorkspaceName });
  this.workspaceName = uniqueWorkspaceName;
  console.log('Given: my onboarding is complete ');
});
/** @param {string} url */
Given('I access a URL with encoded spaces {string}', async function (url) {
  console.log(`Navigating to URL with encoded spaces: ${url}`);
  await this.page.goto(`${BASE_URL}${url}`);
  console.log(`Given: I access a URL with encoded spaces ${url} `);
});
/** @param {string} route */
Given('I access an embed route {string}', async function (route) {
  console.log(`Navigating to embed route: ${route}`);
  // Use Playwright's APIRequestContext to fetch the response and store it for header checks
  const requestContext = await chromium.request.newContext();
  const url = `${BASE_URL}${route}`;
  const response = await requestContext.get(url);
  this.embedResponse = response;
  this.embedRouteUrl = url;
  // Optionally, also open the page in the browser for visual checks
  await this.page.goto(url);
  console.log(`Given: I access an embed route ${route} `);
});
/** @param {string} email */
Given('I have registered with email {string}', async function (email) {});
Given('I received a confirmation email', async function () {});
Given('I have registered but not confirmed my email', async function () {});

// --- When Steps ---
/** @param {string} email */
When('I enter a valid email {string}', async function (email) {
  console.log(`Entering valid email: ${email}`);
  await this.page.fill('input[name="email"], input[type="email"]', email);
  console.log(`When: I enter a valid email ${email} `);
});

/** @param {string} password */
When('I enter a strong password {string}', async function (password) {
  console.log('Entering strong password');
  await this.page.fill('input[name="password"], input[type="password"]', password);
  console.log(`When: I enter a strong password ${password} `);
});

/** @param {string} button */
When('I click the {string} button', async function (button) {
  console.log(`Clicking button: ${button}`);
  const buttonSelector = button.toLowerCase().includes('log in') 
    ? 'button[type="submit"]:has-text("Log in")'
    : button.toLowerCase().includes('sign up')
    ? 'button[type="submit"]:has-text("Sign up")'
    : `button:has-text("${button}"), input[type="submit"][value="${button}"]`;
  await this.page.click(buttonSelector);
  console.log(`When: I click the ${button} button `);
});

/** @param {string} password */
When('I enter a weak password {string}', async function (password) {
  console.log('Entering weak password');
  await this.page.fill('input[name="password"], input[type="password"]', password);
  console.log(`When: I enter a weak password ${password} `);
});

/** @param {string} email */
When('I enter an invalid email {string}', async function (email) {
  console.log(`Entering invalid email: ${email}`);
  await this.page.fill('input[name="email"], input[type="email"]', email);
  console.log(`When: I enter an invalid email ${email} `);
});

/** @param {string} email */
When('I enter email {string}', async function (email) {
  console.log(`Entering email: ${email}`);
  // Use actual test user email if it's a placeholder
  const actualEmail = email === 'user@example.com' ? TEST_USER.email : email;
  await this.page.fill('input[name="email"], input[type="email"]', actualEmail);
  console.log(`When: I enter email ${email} `);
});

/** @param {string} button */
When('I click {string}', async function (button) {
  console.log(`Clicking: ${button}`);
  if (button.toLowerCase().includes('google')) {
    await this.page.click('button:has-text("Google"), button:has-text("Log in with Google"), button:has-text("Sign up with Google")');
  } else {
    await this.page.click(`button:has-text("${button}"), [role="button"]:has-text("${button}"), a:has-text("${button}")`);
  }
  console.log(`When: I click ${button} `);
});

/** @param {string} action */
When('I click {string} with Google', async function (action) {
  console.log(`Clicking ${action} with Google`);
  const googleButtonText = action.toLowerCase().includes('log in') ? 'Log in with Google' : 'Sign up with Google';
  await this.page.click(`button:has-text("${googleButtonText}")`);
  console.log(`When: I click ${action} with Google `);
});

When('I enter the correct password', async function () {
  console.log('Entering correct password');
  await this.page.fill('input[name="password"], input[type="password"]', TEST_USER.password);
  console.log('When: I enter the correct password ');
});

When('I enter an incorrect password', async function () {
  console.log('Entering incorrect password');
  await this.page.fill('input[name="password"], input[type="password"]', 'wrongpassword123');
  console.log('When: I enter an incorrect password ');
});

When('I enter any password', async function () {
  console.log('Entering any password');
  await this.page.fill('input[name="password"], input[type="password"]', 'anypassword123');
  console.log('When: I enter any password ');
});

When('I make 30 failed login attempts within 10 minutes', async function () {
  console.log('Making 30 failed login attempts');
  for (let i = 0; i < 30; i++) {
    await this.page.fill('input[name="email"]', TEST_USER.email);
    await this.page.fill('input[name="password"]', 'wrongpassword');
    await this.page.click('button[type="submit"]');
    await this.page.waitForTimeout(100); // Small delay between attempts
  }
  console.log('When: I make 30 failed login attempts within 10 minutes ');
});

When('I make more than 20 requests per minute', async function () {
  console.log('Making more than 20 requests per minute');
  for (let i = 0; i < 25; i++) {
    await this.page.goto(`${BASE_URL}/login`);
    await this.page.waitForTimeout(50); // Very short delay to exceed rate limit
  }
  console.log('When: I make more than 20 requests per minute ');
});

When('I enter a password without uppercase letters', async function () {
  console.log('Entering password without uppercase letters');
  await this.page.fill('input[name="password"], input[type="password"]', 'lowercase123!');
  console.log('When: I enter a password without uppercase letters ');
});

When('I enter a password without lowercase letters', async function () {
  console.log('Entering password without lowercase letters');
  await this.page.fill('input[name="password"], input[type="password"]', 'UPPERCASE123!');
  console.log('When: I enter a password without lowercase letters ');
});

When('I enter a password without numbers', async function () {
  console.log('Entering password without numbers');
  await this.page.fill('input[name="password"], input[type="password"]', 'NoNumbers!');
  console.log('When: I enter a password without numbers ');
});

When('I enter a password without special characters', async function () {
  console.log('Entering password without special characters');
  await this.page.fill('input[name="password"], input[type="password"]', 'NoSpecial123');
  console.log('When: I enter a password without special characters ');
});

When('I enter a password shorter than 8 characters', async function () {
  console.log('Entering password shorter than 8 characters');
  await this.page.fill('input[name="password"], input[type="password"]', 'Short1!');
  console.log('When: I enter a password shorter than 8 characters ');
});

When('my session is valid', async function () {
  console.log('Session is valid');
  // This would involve setting up a valid session cookie or token
  console.log('When: my session is valid ');
});

When('my session expires', async function () {
  console.log('Session expires');
  await this.page.context().clearCookies();
  console.log('When: my session expires ');
});

When('I log out', async function () {
  console.log('Logging out');
  await this.page.click('[data-testid="user-dropdown"], [data-testid="logout-button"], button:has-text("Logout")');
  console.log('When: I log out ');
});

/**
 * @this {any}
 * @param {string} path
 */
When('I try to access {string}', async function (path) {
  const normalizedPath = normalize_path(path);
  console.log(`Trying to access: ${normalizedPath}`);
  await this.page.goto(`${BASE_URL}${normalizedPath}`);
  console.log(`When: I try to access ${normalizedPath} `);
});

When('I log in successfully', { timeout: 300000 }, async function () {
  await login(this.page, this.userEmail, this.password);
  console.log('When: I log in successfully ');
});

When('I complete the personal information step', async function () {
  console.log('Completing personal information step');
  // Wait for the personal info step to be visible
  console.log('Waiting for personal info step to be visible');
  await this.page.waitForSelector('[data-testid="personal-info-step"]', { timeout: 10000 });
  console.log('Filling last name');
  await this.page.fill('[data-testid="last-name-input"]', 'Doe');
  console.log('Filling first name');
  await this.page.fill('[data-testid="first-name-input"]', 'John');
  console.log('Clicking continue button');
  await this.page.click('button:has-text("Continue"), button:has-text("Next")');
  console.log('When: I complete the personal information step ');
});

When('I complete the professional information step', async function () {
  console.log('Completing professional information step');
  // Wait for the professional info step to be visible
  await this.page.waitForSelector('[data-testid="professional-info-step"]', { timeout: 10000 });
  // Select values in dropdowns
  console.log('Selecting industry');
  await this.page.selectOption('[data-testid="industry-select"]', { label: 'IT' });
  console.log('Selecting role');
  await this.page.selectOption('[data-testid="role-select"]', { label: 'Founder' });
  console.log('Selecting company size');
  await this.page.selectOption('[data-testid="company-size-select"]', { label: '10-49' });
  console.log('Selecting source');
  await this.page.selectOption('[data-testid="source-select"]', { label: 'Google' });
  console.log('Clicking continue button');
  await this.page.click('button:has-text("Continue"), button:has-text("Next")');
  console.log('When: I complete the professional information step ');
});

When('I complete the workspace setup step', async function () {
  console.log('Completing workspace setup step');
  // Wait for the workspace setup step to be visible
  console.log('Waiting for workspace setup step to be visible');
  await this.page.waitForSelector('[data-testid="workspace-setup-step"]', { timeout: 10000 });
  console.log('Workspace setup step is visible');
  // Fill in the workspace name (adjust selector as needed)
  console.log('Filling workspace name');
  const uniqueWorkspaceName = `My Test Workspace ${Date.now()}`;
  await this.page.fill('[data-testid="workspace-name-input"]', uniqueWorkspaceName);
  this.workspaceName = uniqueWorkspaceName;
  // If you have other required fields, fill/select them here
  // Click the continue/create workspace button
  console.log('Clicking continue button');
  await this.page.click('button:has-text("Continue"), button:has-text("Create Workspace")');
  console.log('When: I complete the workspace setup step ');
});

When('I click the confirmation link in the email', async function () {
  console.log('Clicking confirmation link (simulated)');
  // In a real test, this would involve checking email or using a test email service
  // For now, we simulate by navigating to a confirmation URL
  await this.page.goto(`${BASE_URL}/auth/confirm?token=test-token`);
  console.log('When: I click the confirmation link in the email ');
});

When('I access "/auth/confirm" with an invalid token', async function () {
  console.log('Accessing /auth/confirm with invalid token');
  await this.page.goto(`${BASE_URL}/auth/confirm?token=invalid-token`);
  console.log('When: I access "/auth/confirm" with an invalid token ');
});

When('I try to log in', async function () {
  console.log('Trying to log in');
  await this.page.click('button[type="submit"]:has-text("Log in")');
  console.log('When: I try to log in ');
});

When('I click "resend confirmation"', async function () {
  console.log('Clicking resend confirmation');
  await this.page.click('button:has-text("resend confirmation"), a:has-text("resend confirmation")');
  console.log('When: I click "resend confirmation" ');
});

// --- Then Steps ---
Then('I should see a success message', async function () {
  console.log('Checking for success message');
  await this.page.waitForSelector('text*="success", [role="alert"]:has-text("success"), .toast:has-text("success")', { timeout: 5000 });
  console.log('Then: I should see a success message ');
});

Then('I should be redirected to login page with pre-filled email', async function () {
  console.log('Checking redirect to login with pre-filled email');
  await this.page.waitForURL(/.*\/login.*/, { timeout: 10000 });
  const emailValue = await this.page.inputValue('input[name="email"]');
  expect(emailValue).toBeTruthy();
  console.log('Then: I should be redirected to login page with pre-filled email ');
});

/** @param {string} email */
Then('a confirmation email should be sent to {string}', async function (email) {
  console.log(`Checking confirmation email sent to ${email}`);
  // In a real test, this would check an email service or test email inbox
  // For now, we assume the email was sent based on the success flow
  console.log(`Then: a confirmation email should be sent to ${email} `);
});

/** @param {string} error */
Then('I should see error {string}', async function (error) {
  console.log(`Checking for error: ${error}`);
  await this.page.waitForSelector(`text*="${error}", [role="alert"]:has-text("${error}"), .toast:has-text("${error}"), .error:has-text("${error}")`, { timeout: 5000 });
  console.log(`Then: I should see error ${error} `);
});

Then('the signup should not proceed', async function () {
  console.log('Checking that signup did not proceed');
  // Check that we're still on the signup page
  expect(this.page.url()).toContain('/signup');
  console.log('Then: the signup should not proceed ');
});

Then('the system should perform an immediate email availability check', async function () {
  console.log('Checking immediate email availability check');
  // This would involve checking for loading indicators or network requests
  await this.page.waitForSelector('.spinner, [data-testid="email-check-spinner"]', { timeout: 3000 }).catch(() => {});
  console.log('Then: the system should perform an immediate email availability check ');
});

Then('no visual feedback should be shown about email existence', async function () {
  console.log('Checking no visual feedback about email existence');
  // Ensure no error messages about email existence are shown
  const errorElements = await this.page.locator('text*="already exists", text*="taken"').count();
  expect(errorElements).toBe(0);
  console.log('Then: no visual feedback should be shown about email existence ');
});

Then('the system should perform a final email existence check', async function () {
  console.log('Checking final email existence check');
  // This would involve checking network requests or loading states
  console.log('Then: the system should perform a final email existence check ');
});

/** @param {string} message */
Then('I should see message {string}', async function (message) {
  console.log(`Checking for message: ${message}`);
  await this.page.waitForSelector(`text*="${message}", [role="alert"]:has-text("${message}"), .toast:has-text("${message}")`, { timeout: 5000 });
  console.log(`Then: I should see message ${message} `);
});

Then('no new account should be created', async function () {
  console.log('Checking no new account was created');
  // This would involve checking the database or API responses
  // For now, we assume based on staying on the same page
  console.log('Then: no new account should be created ');
});

Then('no confirmation email should be sent', async function () {
  console.log('Checking no confirmation email was sent');
  // This would involve checking email service logs
  console.log('Then: no confirmation email should be sent ');
});

Then('I should be redirected to Google OAuth', async function () {
  console.log('Checking redirect to Google OAuth');
  await this.page.waitForURL(/.*accounts\.google\.com.*/, { timeout: 10000 });
  console.log('Then: I should be redirected to Google OAuth ');
});

Then('after successful Google authentication', async function () {
  console.log('After successful Google authentication');
  // This would involve mocking or handling the OAuth flow
  console.log('Then: after successful Google authentication ');
});

/** @param {string} path */
Then('I should be redirected to {string}', { timeout: 15000 }, async function (path) {
  const normalizedPath = normalize_path(path);
  console.log(`Checking redirect to path: ${normalizedPath}`);
  await this.page.waitForURL((url) => {
    const u = typeof url === 'string' ? new URL(url) : url;
    return u.pathname === normalizedPath;
  }, { timeout: 10000 });
  expect(new URL(this.page.url()).pathname).toBe(normalizedPath);
  console.log(`Then: I should be redirected to ${normalizedPath} `);
});

Then('a new user account should be created', async function () {
  console.log('Checking new user account was created');
  // This would involve checking database or API responses
  console.log('Then: a new user account should be created ');
});

Then('I should be redirected to the onboarding page', async function () {
  console.log('Checking redirect to onboarding page');
  await this.page.waitForURL(/.*\/onboarding.*/, { timeout: 10000 });
  console.log('Then: I should be redirected to the onboarding page ');
});

Then('I should be logged in successfully', async function () {
  console.log('Checking successful login');
  // Check for authenticated state indicators
  await this.page.waitForSelector('[data-testid="user-dropdown"], [data-testid="workspace-switcher"], text="My Flows"', { timeout: 10000 });
  console.log('Then: I should be logged in successfully ');
});

/** @this {any} */
Then('I should be redirected to the dashboard "/"', async function () {
  console.log('The Page URL before wait:', this.page.url());
  console.log('Checking redirect to dashboard');
  await this.page.waitForURL(`${BASE_URL}/`, { timeout: 10000 });
  expect(this.page.url()).toBe(`${BASE_URL}/`);
  console.log('Then: I should be redirected to the dashboard "/" ');
});

Then('a session cookie should be set', async function () {
  console.log('Checking session cookie is set');
  const cookies = await this.page.context().cookies();
  const sessionCookie = cookies.find(cookie => 
    cookie.name.includes('session') || 
    cookie.name.includes('auth') || 
    cookie.name.includes('supabase')
  );
  expect(sessionCookie).toBeTruthy();
  console.log('Then: a session cookie should be set ');
});

Then('I should see message "Please confirm your email before logging in"', async function () {
  console.log('Checking for email confirmation message');
  await this.page.waitForSelector('text*="Please confirm your email before logging in"', { timeout: 5000 });
  console.log('Then: I should see message "Please confirm your email before logging in" ');
});

Then('I should not be logged in', async function () {
  console.log('Checking user is not logged in');
  // Check that we don't see authenticated user elements
  const authElements = await this.page.locator('[data-testid="user-dropdown"], [data-testid="workspace-switcher"]').count();
  expect(authElements).toBe(0);
  console.log('Then: I should not be logged in ');
});

Then('I should see error "Login Failed"', async function () {
  console.log('Checking for Login Failed error');
  await this.page.waitForSelector('text*="Login Failed"', { timeout: 5000 });
  console.log('Then: I should see error "Login Failed" ');
});

Then('the failed attempt should be tracked', async function () {
  console.log('Checking failed attempt is tracked');
  // This would involve checking localStorage or API calls
  const attempts = await this.page.evaluate(() => {
    return localStorage.getItem('login_attempts');
  });
  expect(attempts).toBeTruthy();
  console.log('Then: the failed attempt should be tracked ');
});

Then('I should see error "Invalid Email"', async function () {
  console.log('Checking for Invalid Email error');
  await this.page.waitForSelector('text*="Invalid Email"', { timeout: 5000 });
  console.log('Then: I should see error "Invalid Email" ');
});

Then('the login should not proceed', async function () {
  console.log('Checking login did not proceed');
  expect(this.page.url()).toContain('/login');
  console.log('Then: the login should not proceed ');
});

Then('I should be logged in automatically', async function () {
  console.log('Checking automatic login');
  await this.page.waitForSelector('[data-testid="user-dropdown"], [data-testid="workspace-switcher"]', { timeout: 10000 });
  console.log('Then: I should be logged in automatically ');
});

Then('I should be blocked from further attempts', async function () {
  console.log('Checking user is blocked from further attempts');
  await this.page.waitForSelector('text*="Too many failed attempts"', { timeout: 5000 });
  console.log('Then: I should be blocked from further attempts ');
});

Then('I should see message "Too many failed attempts"', async function () {
  console.log('Checking for too many failed attempts message');
  await this.page.waitForSelector('text*="Too many failed attempts"', { timeout: 5000 });
  console.log('Then: I should see message "Too many failed attempts" ');
});

Then('I should be blocked for 10 minutes', async function () {
  console.log('Checking 10 minute block');
  const blockUntil = await this.page.evaluate(() => {
    return localStorage.getItem('login_block_until');
  });
  expect(blockUntil).toBeTruthy();
  console.log('Then: I should be blocked for 10 minutes ');
});

Then('the block timer should count down', async function () {
  console.log('Checking block timer countdown');
  await this.page.waitForSelector('text*="minute"', { timeout: 5000 });
  console.log('Then: the block timer should count down ');
});

Then('I should receive a "429 Too many requests" response', async function () {
  console.log('Checking for 429 response');
  // This would involve checking network responses
  console.log('Then: I should receive a "429 Too many requests" response ');
});

Then('further requests should be blocked', async function () {
  console.log('Checking further requests are blocked');
  // This would involve making additional requests and checking responses
  console.log('Then: further requests should be blocked ');
});

Then('I should see password strength error', async function () {
  console.log('Checking for password strength error');
  await this.page.waitForSelector('text*="Password must be at least 8 characters", text*="password strength", .error:has-text("password")', { timeout: 5000 });
  console.log('Then: I should see password strength error ');
});

Then('I should have access to protected routes', async function () {
  console.log('Checking access to protected routes');
  await this.page.goto(`${BASE_URL}/workspace/2`);
  await this.page.waitForSelector('[data-testid="workspace-switcher"]', { timeout: 10000 });
  console.log('Then: I should have access to protected routes ');
});

Then('I should be redirected to login page', async function () {
  console.log('Checking redirect to login page');
  await this.page.waitForURL(/.*\/login.*/, { timeout: 10000 });
  console.log('Then: I should be redirected to login page ');
});

Then('my session should be invalidated', async function () {
  console.log('Checking session is invalidated');
  const cookies = await this.page.context().cookies();
  const sessionCookies = cookies.filter(cookie => 
    cookie.name.includes('session') || 
    cookie.name.includes('auth')
  );
  expect(sessionCookies.length).toBe(0);
  console.log('Then: my session should be invalidated ');
});

/** @this {any} */
Then('I should be redirected to dashboard "/"', async function () {
  console.log('Checking redirect to dashboard');
  console.log('Page URL before wait:', this.page.url());
  await this.page.waitForURL(`${BASE_URL}/`, { timeout: 10000 });
  console.log('Page URL after wait:', this.page.url());
  expect(this.page.url()).toBe(`${BASE_URL}/`);
  console.log('Then: I should be redirected to dashboard "/" ');
});

Then('the redirect parameter should include original path', async function () {
  console.log('Checking redirect parameter includes original path');
  const url = new URL(this.page.url());
  const redirectParam = url.searchParams.get('redirect') || url.searchParams.get('return');
  console.log('Redirect parameter:', redirectParam);
  expect(redirectParam).toBeTruthy();
  console.log('Then: the redirect parameter should include original path ');
});

Then('I should see the onboarding progress indicator', async function () {
  console.log('Checking for onboarding progress indicator');
  await this.page.waitForSelector('[data-testid="progress-indicator"]', { timeout: 10000 });
  console.log('Then: I should see the onboarding progress indicator ');
});

Then('I should proceed to the professional information step', async function () {
  console.log('Waiting for professional info step to be visible');
  await this.page.waitForSelector('[data-testid="professional-info-step"]', { timeout: 10000 });
  console.log('professional info step is visible');
  console.log('Then: I should proceed to the professional information step ');
});

Then('I should proceed to the workspace setup step', async function () {
  console.log('Waiting for workspace setup step to be visible');
  await this.page.waitForSelector('[data-testid="workspace-setup-step"]', { timeout: 10000 });
  console.log('workspace setup step is visible');
  console.log('Then: I should proceed to the workspace setup step ');
});

Then('I should proceed to the completion step', async function () {
  console.log('Waiting for completion step to be visible');
  await this.page.waitForSelector('[data-testid="completed-step"]', { timeout: 10000 });
  console.log('completion step is visible');
  console.log('Then: I should proceed to the completion step ');
});

Then('the system should create my workspace', async function () {
  console.log('Checking workspace creation');
  if ((this.workspace && !this.workspace.name) && !this.workspaceName) {
    throw new Error('No workspace found in test context (this.workspace)');
  }
  const exists = await checkWorkspace({ user_id: this.prismaUser.id, name: this.workspaceName || this.workspace.name });
  expect(exists).toBe(true);
  if (exists) {
    console.log('Workspace exists');
  }
  console.log('Then: the system should create my workspace ');
});

Then('the system should create default workflows', async function () {
  console.log('Checking default workflows creation');
  await this.page.waitForSelector('[data-testid="workspace-ready-message"]', { timeout: 10000 });
  console.log('Then: the system should create default workflows ');
});

Then('An email should be sent to the user with the subject "Welcome to ProcessFlow - Here\'s how to start decently"', async function () {
  // console.log('Checking welcome email was sent via Mailhog');
  // const response = await fetch('http://localhost:8025/api/v2/messages');
  // if (!response.ok) {
  //   throw new Error(`Failed to fetch Mailhog messages: ${response.status} ${response.statusText}`);
  // }
  // const data = await response.json();
  const expectedSubject = "Welcome to ProcessFlow - Here's how to start decently";
  // const found = data.items.some(msg => {
  //   const subject = msg.Content.Headers.Subject && msg.Content.Headers.Subject[0];
  //   return subject === expectedSubject;
  // });
  // if (!found) {
  //   throw new Error(`No email with subject "${expectedSubject}" found in Mailhog`);
  // }
  console.log(`Then: An email should be sent to the user with the subject "${expectedSubject}" `);
});

Then('my onboarding should be marked as complete', async function () {
  console.log('Checking onboarding marked as complete');
  // This would involve checking user state in database
  console.log('Then: my onboarding should be marked as complete ');
});

Then('I should not be able to access {string} anymore', async function (path) {
  console.log(`Checking ${path} page is not accessible`);
  const normalizedPath = normalize_path(path);
  await this.page.goto(`${BASE_URL}${normalizedPath}`);
  // Wait for the URL to change to something other than the forbidden path
  await this.page.waitForURL((url) => {
    const u = typeof url === 'string' ? new URL(url) : url;
    return u.pathname !== normalizedPath;
  }, { timeout: 10000 });
  console.log(`Then: I should not be able to access ${path} anymore `);
});

Then('the URL should be properly formatted', async function () {
  console.log('Checking URL is properly formatted');
  const url = this.page.url();
  expect(url).toMatch(/^https?:\/\/.+/);
  console.log('Then: the URL should be properly formatted ');
});

Then('my email should be marked as confirmed', async function () {
  console.log('Checking email is marked as confirmed');
  // This would involve checking user state in database
  console.log('Then: my email should be marked as confirmed ');
});

Then('I should be automatically logged in', async function () {
  console.log('Checking automatic login');
  await this.page.waitForSelector('[data-testid="user-dropdown"], [data-testid="workspace-switcher"]', { timeout: 10000 });
  console.log('Then: I should be automatically logged in ');
});

Then('I should see an error message', async function () {
  console.log('Checking for error message');
  await this.page.waitForSelector('[role="alert"], .error, .toast, text*="error"', { timeout: 5000 });
  console.log('Then: I should see an error message ');
});

Then('my email should remain unconfirmed', async function () {
  console.log('Checking email remains unconfirmed');
  // This would involve checking user state in database
  console.log('Then: my email should remain unconfirmed ');
});

Then('I should see option to resend confirmation email', async function () {
  console.log('Checking for resend confirmation option');
  await this.page.waitForSelector('text*="resend", button:has-text("resend")', { timeout: 5000 });
  console.log('Then: I should see option to resend confirmation email ');
});

Then('a new confirmation email should be sent', async function () {
  console.log('Checking new confirmation email was sent');
  // This would involve checking email service logs
  console.log('Then: a new confirmation email should be sent ');
});

/**
 * @param {string} dashboardPath
 * @this {any}
 */
Then('I should be redirected to dashboard {string}', async function (dashboardPath) {
  const expectedUrl = `${BASE_URL}${normalize_path(dashboardPath)}`;
  console.log(`Checking redirect to dashboard: ${expectedUrl}`);
  console.log('The Page URL before wait:', this.page.url());
  await this.page.waitForURL(expectedUrl, { timeout: 10000 });
  expect(this.page.url()).toBe(expectedUrl);
  console.log(`Then: I should be redirected to dashboard ${dashboardPath} `);
});

Then('the URL should have spaces replaced by dashes', async function () {
  console.log('Checking that %20 has been replaced by a dash in the URL');
  const currentUrl = this.page.url();
  const hasEncodedSpace = currentUrl.includes('%20');
  const hasDash = currentUrl.includes('-');
  expect(hasEncodedSpace).toBe(false);
  expect(hasDash).toBe(true);
  console.log('Then: the URL should have spaces replaced by dashes ');
});

Then('the response should include headers:', async function (dataTable) {
  if (!this.embedResponse) {
    throw new Error('No embed response found. Did you call the embed route step?');
  }
  const expectedHeaders = dataTable.rowsHash();
  for (const [header, expectedValue] of Object.entries(expectedHeaders)) {
    const actualValue = this.embedResponse.headers()[header.toLowerCase()];
    if (!actualValue) {
      throw new Error(`Header '${header}' not found in response`);
    }
    if (actualValue !== expectedValue) {
      throw new Error(`Header '${header}' value '${actualValue}' does not match expected '${expectedValue}'`);
    }
    console.log(`Header '${header}' correctly set to '${expectedValue}'`);
  }
  console.log('Then: the response should include required embed headers ');
});
</file>

</files>
